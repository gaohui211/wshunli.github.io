<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2018-06-19T12:01:39.077Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>沉迷学术，不可自拔（九）</title>
    <link href="https://www.wshunli.com/posts/c3a39066.html"/>
    <id>https://www.wshunli.com/posts/c3a39066.html</id>
    <published>2018-06-09T08:48:00.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】都6月份了，一直拖到现在，也是6得不行
    
    </summary>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="https://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>那些年，我们用过的地图下载器</title>
    <link href="https://www.wshunli.com/posts/73256148.html"/>
    <id>https://www.wshunli.com/posts/73256148.html</id>
    <published>2018-06-09T01:46:27.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>作为地信、遥感等专业的同学，下载线划图、遥感影像应该都接触过，以前很多群发广告都看不惯，借这次下载高程数据的机会，总结下地图下载器，收费部分的搜索下就懂了。。</p><p><strong>本文仅介绍平常接触到的地图下载器，用作学习和研究目的，不提供收费软件破解文件下载</strong>。</p><p><strong>本文标题来源</strong>：那些年，我们用过的地图下载器 - 我也是个傻瓜 - 博客园<br><a href="https://www.cnblogs.com/liweis/p/4575656.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/liweis/p/4575656.html</a></p><p>1、晟兴地球 SXEarth 是一款永久免费的 3DGIS 平台软件。</p><p>支持在线 Google Earth 卫星影像（无水印无偏移）下载，支持拼接为tif，支持模拟飞行，支持场景编辑。</p><p><img src="https://img.wshunli.com/瞎推荐/地图下载器/SXEarth.png" alt="SXEarth"></p><p>下载地址：<a href="http://www.sxsim.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.sxsim.com/</a></p><p>支持的在线地图特别多，平常基本上用这个就够了。</p><p>2、LocaSpace Viewer 免费、开放的三维数字地球</p><p>多种互联网地图集成、影像、地形数据下载、倾斜数据极速浏览、二三维地理、模型数据、量测和空间分析、软件特色应用。</p><p><img src="https://img.wshunli.com/瞎推荐/地图下载器/LocaSpaceViewer.png" alt="LocaSpaceViewer"></p><p>下载地址：<a href="http://www.locaspace.cn/LSV.jsp" rel="external nofollow noopener noreferrer" target="_blank">http://www.locaspace.cn/LSV.jsp</a></p><p>支持的在线底图不是很多，但是在三维场景尤其是倾斜摄影方面很有优势。</p><p>其他收费的在参考资料，这里就先不介绍了。</p><blockquote><p>参考资料<br>1、那些年，我们用过的地图下载器 - 我也是个傻瓜 - 博客园<br><a href="https://www.cnblogs.com/liweis/p/4575656.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/liweis/p/4575656.html</a><br>2、奉上我收藏的地图下载器（低调使用，你懂的），还各个群一个良好的群环境（别再因为苦于找不到下载器而转发广告了） - ThinkGIS<br><a href="http://www.thinkgis.cn/topic/555ac3911cf2f372004ef9ac" rel="external nofollow noopener noreferrer" target="_blank">http://www.thinkgis.cn/topic/555ac3911cf2f372004ef9ac</a><br>3、SXEarth-超强的GIS数据下载利器 | 麻辣GIS<br><a href="https://malagis.com/sxearth-super-gis-data-downloader.html" rel="external nofollow noopener noreferrer" target="_blank">https://malagis.com/sxearth-super-gis-data-downloader.html</a><br>4、只要三步下载GIS数据（亲测可用/免费/无需转发5个群） | 麻辣GIS<br><a href="https://malagis.com/downlod-gis-data-by-3-steps.html" rel="external nofollow noopener noreferrer" target="_blank">https://malagis.com/downlod-gis-data-by-3-steps.html</a><br>5、北京晟兴科技有限公司 官网首页<br><a href="http://www.sxsim.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.sxsim.com/</a><br>6、LocaSpace Viewer 三维数字地球<br><a href="http://www.locaspace.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.locaspace.cn/</a><br>7、太乐地图官网 - 让地理信息应用更简单<br><a href="http://www.arctiler.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.arctiler.com/</a><br>8、谷歌卫星地图下载器-谷歌地图高清卫星地图2018-北斗卫星地图-水经注万能地图下载器-水经注软件<br><a href="http://www.rivermap.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.rivermap.cn/</a><br>9、91卫图助手，Google Earth影像高程历史影像下载专家<br><a href="http://www.91weitu.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.91weitu.com/</a><br>10、谷歌地图高清卫星地图2018_北斗卫星地图_3d地形图-BIGEMAP<br><a href="http://www.bigemap.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.bigemap.com/</a><br>11、谷歌卫星地图下载器<br><a href="http://www.wolfmap.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.wolfmap.cn/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为地信、遥感等专业的同学，下载线划图、遥感影像应该都接触过，以前很多群发广告都看不惯，借这次下载高程数据的机会，总结下地图下载器，收费部分的搜索下就懂了。。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本文仅介绍平常接触到的地图下载器，用作学习和研究目的，不提供收费软件破解文件下载&lt;/s
      
    
    </summary>
    
      <category term="瞎推荐" scheme="https://www.wshunli.com/categories/%E7%9E%8E%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="GIS" scheme="https://www.wshunli.com/tags/GIS/"/>
    
      <category term="地图下载器" scheme="https://www.wshunli.com/tags/%E5%9C%B0%E5%9B%BE%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（八）使用 Socket 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/c9a2416c.html"/>
    <id>https://www.wshunli.com/posts/c9a2416c.html</id>
    <published>2018-06-08T12:46:26.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>Socket 也称为 “嵌套字”，是计算机网络中的概念，分为流式嵌套字（TCP）和用户数据报嵌套字（UDP）。</p><p>不同用户进程通过 Socket 进行通信也是一种 IPC 方式。</p><p>在使用 Socket 通信前应在 AndroidManifest 中声明权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</code></pre><p>1、服务端</p><p>我们需要一个 Service 作为服务端，声明如下：</p><pre><code class="XML">&lt;service    android:name=&quot;.socket.SocketService&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p>Socket 服务端在 Service 启动时，会建立 TCP 连接并监听 8688 端口。</p><pre><code class="Java">public class SocketService extends Service {    private static final String TAG = &quot;SocketService&quot;;    private boolean isDestroyed = false;    private String[] messages = new String[]{            &quot;你好啊，哈哈&quot;,            &quot;请问你叫什么名字呀？&quot;,            &quot;今天北京天气不错啊&quot;,            &quot;你知道吗？我可是可以和多个人同时聊天的哦&quot;,            &quot;给你讲个笑话吧：据说爱笑的人运气不会太差，不知道真假。&quot;    };    public SocketService() {    }    @Override    public void onCreate() {        super.onCreate();        new Thread(new TCPServer()).start();    }    @Override    public IBinder onBind(Intent intent) {        return null;    }    @Override    public void onDestroy() {        isDestroyed = true;        super.onDestroy();    }    private class TCPServer implements Runnable {        @Override        public void run() {            ServerSocket serverSocket = null;            try {                serverSocket = new ServerSocket(8688);            } catch (IOException e) {                e.printStackTrace();            }            while (!isDestroyed) {                try {                    final Socket client = serverSocket.accept();                    Log.d(TAG, &quot;accept&quot;);                    new Thread() {                        @Override                        public void run() {                            responseClient(client);                        }                    }.start();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        private void responseClient(Socket client) {            try {                // 接收客户端消息                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));                // 响应客户端消息                PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())), true);                Log.d(TAG, &quot;欢迎来到聊天室！&quot;);                out.println(&quot;欢迎来到聊天室！&quot;);                while (!isDestroyed) {                    String line = in.readLine();                    Log.d(TAG, &quot;message from Client: &quot; + line);                    if (line == null) break;                    int i = new Random().nextInt(messages.length);                    String message = messages[i];                    out.println(message);                    Log.d(TAG, &quot;response to Client: &quot; + message);                }                out.close();                in.close();                client.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>当与客户端建立连接后，新建 Socket 客户端，接收消息并作出响应。</p><p>2、客户端</p><p>客户端部分首先启动 Socket 服务，并且在连接失败后会不断重新尝试连接。</p><pre><code class="Java">public class SocketActivity extends AppCompatActivity {    private static final String TAG = &quot;SocketActivity&quot;;    private Button bt_send;    private EditText et_receive;    private TextView tv_message;    private PrintWriter mPrintWriter;    private Socket mClientSocket;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_socket);        initView();        Intent service = new Intent(this, SocketService.class);        startService(service);        new Thread() {            @Override            public void run() {                connectSocketServer();            }        }.start();    }    private void initView() {        et_receive = findViewById(R.id.et_receive);        bt_send = findViewById(R.id.bt_send);        tv_message = findViewById(R.id.tv_message);        bt_send.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                final String msg = et_receive.getText().toString();                //向服务器发送信息                if (!TextUtils.isEmpty(msg) &amp;&amp; mPrintWriter != null) {                    Log.d(TAG, &quot;onClick: &quot; + msg);                    new Thread(new Runnable() {                        @Override                        public void run() {                            mPrintWriter.println(msg);                        }                    }).start();                    tv_message.setText(tv_message.getText() + &quot;\n&quot; + &quot;客户端：&quot; + msg);                    et_receive.setText(&quot;&quot;);                }            }        });    }    private void connectSocketServer() {        Socket socket = null;        while (socket == null) {            try {                //选择和服务器相同的端口8688                socket = new Socket(&quot;localhost&quot;, 8688);                mClientSocket = socket;                mPrintWriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);            } catch (IOException e) {                SystemClock.sleep(1000);            }        }        try {            // 接收服务器端的消息            BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));            while (!isFinishing()) {                final String msg = br.readLine();                if (msg != null) {                    runOnUiThread(                            new Runnable() {                                @Override                                public void run() {                                    tv_message.setText(tv_message.getText() + &quot;\n&quot; + &quot;服务端：&quot; + msg);                                }                            }                    );                }            }            mPrintWriter.close();            br.close();            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }    @Override    protected void onDestroy() {        if (mClientSocket != null) {            try {                mClientSocket.shutdownInput();                mClientSocket.close();            } catch (IOException e) {                e.printStackTrace();            }        }        super.onDestroy();    }}</code></pre><p>主要使用 socket.getOutputStream() 和 socket.getInputStream() 方法分别发送、接收服务端消息。</p><p>打印日志如下：</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/8.Socket日志.png" alt="8.Socket日志"></p><p>最终效果如下：</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/8.Socket进程间通信.png" alt="8.Socket进程间通信"></p><p>到这里把 Android IPC 通信的几种实现方式基本看了一遍，但是在 Binder 机制原理方面还有欠缺，后面再深入学习。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.6 使用 Socket<br>2、Android IPC机制（五）用Socket实现跨进程聊天程序 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/5-socket.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/5-socket.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Socket 也称为 “嵌套字”，是计算机网络中的概念，分为流式嵌套字（TCP）和用户数据报嵌套字（UDP）。&lt;/p&gt;&lt;p&gt;不同用户进程通过 Socket 进行通信也是一种 IPC 方式。&lt;/p&gt;&lt;p&gt;在使用 Socket 通信前应在 AndroidManifest 中声明
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（七）使用 ContentProvider 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/b68f7dd9.html"/>
    <id>https://www.wshunli.com/posts/b68f7dd9.html</id>
    <published>2018-06-08T11:32:34.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>ContentProvider 是 Andorid 中专门用于不同应用间进行数据共享的方式，底层实现也是 Binder 。</p><p>前面在 <a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider</a> 介绍过，这里就不再详细记录了。</p><p>首先继承 ContentProvider 类实现自己的 Provider ：</p><pre><code class="Java">public class BookProvider extends ContentProvider {    private static final String TAG = &quot;BookProvider&quot;;    public static final String AUTHORITY = &quot;com.wshunli.ipc.demo.book.provider&quot;;    public static final Uri BOOK_CONTENT_URI = Uri.parse(&quot;content://&quot;            + AUTHORITY + &quot;/book&quot;);    public static final Uri USER_CONTENT_URI = Uri.parse(&quot;content://&quot;            + AUTHORITY + &quot;/user&quot;);    public static final int BOOK_URI_CODE = 0;    public static final int USER_URI_CODE = 1;    private static final UriMatcher sUriMatcher = new UriMatcher(            UriMatcher.NO_MATCH);    static {        sUriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_URI_CODE);        sUriMatcher.addURI(AUTHORITY, &quot;user&quot;, USER_URI_CODE);    }    private Context context;    private SQLiteDatabase db;    public BookProvider() {    }    @Override    public boolean onCreate() {        context = getContext();        initProviderData();        return true;    }    private void initProviderData() {        db = new DBHelper(context).getWritableDatabase();        db.execSQL(&quot;delete from &quot; + DBHelper.BOOK_TABLE_NAME);        db.execSQL(&quot;delete from &quot; + DBHelper.USER_TALBE_NAME);        db.execSQL(&quot;insert into book values(3,&#39;Android&#39;);&quot;);        db.execSQL(&quot;insert into book values(4,&#39;Ios&#39;);&quot;);        db.execSQL(&quot;insert into book values(5,&#39;Html5&#39;);&quot;);        db.execSQL(&quot;insert into user values(1,&#39;jake&#39;,1);&quot;);        db.execSQL(&quot;insert into user values(2,&#39;jasmine&#39;,0);&quot;);    }    @Override    public String getType(Uri uri) {        Log.d(TAG, &quot;getType: &quot;);        return null;    }    @Override    public Uri insert(Uri uri, ContentValues values) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        db.insert(table, null, values);        context.getContentResolver().notifyChange(uri, null);        return uri;    }    @Override    public Cursor query(Uri uri, String[] projection, String selection,                        String[] selectionArgs, String sortOrder) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        return db.query(table, projection, selection, selectionArgs, null, null, sortOrder, null);    }    @Override    public int update(Uri uri, ContentValues values, String selection,                      String[] selectionArgs) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        int row = db.update(table, values, selection, selectionArgs);        if (row &gt; 0) {            context.getContentResolver().notifyChange(uri, null);        }        return row;    }    @Override    public int delete(Uri uri, String selection, String[] selectionArgs) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        int count = db.delete(table, selection, selectionArgs);        if (count &gt; 0) {            context.getContentResolver().notifyChange(uri, null);        }        return count;    }    private String getTableName(Uri uri) {        String tableName = null;        switch (sUriMatcher.match(uri)) {            case BOOK_URI_CODE:                tableName = DBHelper.BOOK_TABLE_NAME;                break;            case USER_URI_CODE:                tableName = DBHelper.USER_TALBE_NAME;                break;            default:                break;        }        return tableName;    }}</code></pre><p>记得在 AndroidManifest 中声明：</p><pre><code class="XML">&lt;provider    android:name=&quot;.content.BookProvider&quot;    android:authorities=&quot;com.wshunli.ipc.demo.book.provider&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;    android:permission=&quot;com.wshunli.ipc.demo.PROVIDER&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p>其中 DBHelper 为数据库帮助类，代码如下：</p><pre><code class="Java">public class DBHelper extends SQLiteOpenHelper {    private static final String DB_NAME = &quot;book_provider.db&quot;;    public static final String BOOK_TABLE_NAME = &quot;book&quot;;    public static final String USER_TALBE_NAME = &quot;user&quot;;    private static final int DB_VERSION = 3;    private String CREATE_BOOK_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot;            + BOOK_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT)&quot;;    private String CREATE_USER_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot;            + USER_TALBE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT,&quot;            + &quot;sex INT)&quot;;    public DBHelper(Context context) {        super(context, DB_NAME, null, DB_VERSION);    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK_TABLE);        db.execSQL(CREATE_USER_TABLE);    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}</code></pre><p>然后就是使用了，新建 Activity ：</p><pre><code class="Java">public class ProviderActivity extends AppCompatActivity {    private static final String TAG = &quot;ProviderActivity&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_provider);//        Uri uri = Uri.parse(&quot;content://com.wshunli.ipc.demo.book.provider&quot;);//        getContentResolver().query(uri, null, null, null, null);        Uri bookUri = Uri.parse(&quot;content://com.wshunli.ipc.demo.book.provider/book&quot;);        ContentValues values = new ContentValues();        values.put(&quot;_id&quot;, 6);        values.put(&quot;name&quot;, &quot;程序设计的艺术&quot;);        getContentResolver().insert(bookUri, values);        Cursor bookCursor = getContentResolver().query(bookUri, new String[]{&quot;_id&quot;, &quot;name&quot;}, null, null, null);        while (bookCursor.moveToNext()) {            Book book = new Book();            book.bookId = bookCursor.getInt(0);            book.bookName = bookCursor.getString(1);            Log.d(TAG, &quot;query book:&quot; + book.toString());        }        bookCursor.close();        Uri userUri = Uri.parse(&quot;content://com.wshunli.ipc.demo.book.provider/user&quot;);        Cursor userCursor = getContentResolver().query(userUri, new String[]{&quot;_id&quot;, &quot;name&quot;, &quot;sex&quot;}, null, null, null);        while (userCursor.moveToNext()) {            User user = new User();            user.userId = userCursor.getInt(0);            user.userName = userCursor.getString(1);            user.isMale = userCursor.getInt(2) == 1;            Log.d(TAG, &quot;query user:&quot; + user.toString());        }        userCursor.close();    }}</code></pre><p>日志结果如下：</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/7.ContentProvider进程间通信.png" alt="7.ContentProvider进程间通信"></p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.5 使用 ContentProvider</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ContentProvider 是 Andorid 中专门用于不同应用间进行数据共享的方式，底层实现也是 Binder 。&lt;/p&gt;&lt;p&gt;前面在 &lt;a href=&quot;https://www.wshunli.com/posts/2311b8ab.html&quot;&gt;《第一行代码》读书笔记
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（六）使用 AIDL 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/75f6d3a2.html"/>
    <id>https://www.wshunli.com/posts/75f6d3a2.html</id>
    <published>2018-06-08T06:43:53.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL（Android Interface Definition Language ，Android 接口定义语言），定义客户端与服务使用进程间通信 (IPC) 进行相互通信时都认可的编程接口。</p><p>只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。</p><p>如果不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。</p><p>1、创建 AIDL 文件</p><p>首先在 java 同级目录 aidl 文件夹，然后创建 .aidl 文件。</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/6.AIDL文件.png" alt="6.AIDL文件"></p><pre><code class="Java">// IBookManager.aidlpackage com.wshunli.ipc.demo;// Declare any non-default types here with import statementsimport com.wshunli.ipc.demo.Book;interface IBookManager {    List&lt;Book&gt; getBookList();    void addBook(in Book book);    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);}</code></pre><p>在 <code>.aidl</code> 文件中支持的数据类型包括：</p><ul><li>基本数据类型</li><li>String 和 CharSequence</li><li>List:只支持 ArrayList , 里面的元素都必须被 AIDL 支持</li><li>Map:只支持 HashMap , 里面的元素必须被 AIDL 支持</li><li>实现 Parcelable 接口的对象</li><li>所有 AIDL 接口</li></ul><p>然后创建实现了 Parcelable 的类：</p><pre><code class="Java">public class Book implements Parcelable {    public String name;    public Book(String name) {        this.name = name;    }    @Override    public int describeContents() {        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeString(name);    }    public static Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() {        @Override        public Book createFromParcel(Parcel source) {            return new Book(source);        }        @Override        public Book[] newArray(int size) {            return new Book[size];        }    };    private Book(Parcel source) {        name = source.readString();    }    @Override    public String toString() {        return &quot;Book{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>创建 Book.aidl 文件：</p><pre><code class="Java">// Book.aidlpackage com.wshunli.ipc.demo;// Declare any non-default types here with import statementsparcelable Book;</code></pre><p>这时候重新编译程序，工程就会自动生成 <code>BookManager.aidl</code> 接口对应的文件。</p><p>app\build\generated\source\aidl\debug\com\wshunli\ipc\demoIBookManager.java</p><p>2、创建服务端</p><p>服务端使用 IBookManager.Stub() 方法创建 Binder 实例并在 onBind() 方法中返回。</p><pre><code class="Java">public class BookManagerService extends Service {    private static final String TAG = &quot;BookManagerService&quot;;    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();    private Binder mBinder = new IBookManager.Stub(){        @Override        public List&lt;Book&gt; getBookList() throws RemoteException {            return mBookList;        }        @Override        public void addBook(Book book) throws RemoteException {            mBookList.add(book);        }        @Override        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {        }    };    public BookManagerService() {    }    @Override    public void onCreate() {        super.onCreate();        mBookList.add(new Book(&quot;android&quot;));        mBookList.add(new Book(&quot;ios&quot;));    }    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }}</code></pre><p>其中 onCreate() 方法中填充了数据。</p><p>当然在 AndroidManife 文件中要配置 Service</p><pre><code class="XML">&lt;service    android:name=&quot;com.wshunli.ipc.demo.BookManagerService&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p>3、客户端</p><p>客户端还是使用 bindService() 方法绑定服务。</p><pre><code class="Java">public class BookManagerActivity extends AppCompatActivity {    private static final String TAG = &quot;BookManagerActivity&quot;;    private ServiceConnection connection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            IBookManager bookManager = IBookManager.Stub.asInterface(service);            try {                List&lt;Book&gt; bookList = bookManager.getBookList();                Log.d(TAG, &quot;onServiceConnected: &quot; + bookList.toString());            } catch (RemoteException e) {                e.printStackTrace();            }        }        @Override        public void onServiceDisconnected(ComponentName name) {        }    };    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_book_manager);        Intent intent = new Intent(BookManagerActivity.this, BookManagerService.class);        bindService(intent, connection, BIND_AUTO_CREATE);    }    @Override    protected void onDestroy() {        unbindService(connection);        super.onDestroy();    }}</code></pre><p>其中 IBookManager 对象来调用具体服务器方法，获取数据。</p><p>AIDL 的功能远不止这些，后面再深入研究。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.4 使用 AIDL<br>2、Android 接口定义语言 (AIDL) | Android Developers<br><a href="https://developer.android.com/guide/components/aidl" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/aidl</a><br>3、Android IPC机制（三）在Android Studio中使用AIDL实现跨进程方法调用 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/3-aidl.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/3-aidl.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AIDL（Android Interface Definition Language ，Android 接口定义语言），定义客户端与服务使用进程间通信 (IPC) 进行相互通信时都认可的编程接口。&lt;/p&gt;&lt;p&gt;只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（五）使用 Messenger 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/9da3d2db.html"/>
    <id>https://www.wshunli.com/posts/9da3d2db.html</id>
    <published>2018-06-07T11:05:00.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>通过 Messenger 可以在不同进程之间传递 Message 对象，是一种轻量级的 IPC 方案。</p><p>首先看 Messenger 的构造方法：</p><pre><code class="Java">public Messenger(Handler target) {    mTarget = target.getIMessenger();}public Messenger(IBinder target) {    mTarget = IMessenger.Stub.asInterface(target);}</code></pre><p>实质上还是底层还是基于 AIDL 的。</p><p>对于 Message 对象可以存储传递的数据：</p><pre><code class="Java">public int what; // 消息标识public int arg1; // 整型数据public int arg2; // 整型数据public Object obj;public Messenger replyTo;/*package*/ Bundle data;public void setData(Bundle data) {    this.data = data;}</code></pre><p>其中 obj 只能传输系统中实现了 Parcelable 接口的对象。</p><p>对于 <strong>客户端</strong> 发送消息主要使用 bindService 方法绑定另一个进程的 Service 。</p><pre><code class="Java">public class MessengerActivity extends AppCompatActivity {    private static final String TAG = &quot;MessengerActivity&quot;;    private Messenger messenger;    private ServiceConnection connection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            // 请求服务端            messenger = new Messenger(service);            Message message = Message.obtain(null, MConstants.MSG_FROM_CLIENT);            Bundle bundle = new Bundle();            Log.d(TAG, &quot;这里是客户端，向服务端发送消息&quot;);            bundle.putString(&quot;msg&quot;, &quot;客户端发送内容&quot;);            message.setData(bundle);            // 注意设置 replyTo            message.replyTo = getReplyMessenger;            try {                messenger.send(message);            } catch (RemoteException e) {                e.printStackTrace();            }        }        @Override        public void onServiceDisconnected(ComponentName name) {        }    };    private static class MessageHandler extends Handler {        @Override        public void handleMessage(Message msg) {            Log.d(TAG, &quot;这里是客户端，接收服务端响应&quot;);            switch (msg.what) {                case MConstants.MSG_FROM_SERVICE:                    // 接收服务端响应                    Log.d(TAG, &quot;客户端接收到: &quot; + msg.getData().get(&quot;reply&quot;));                    break;                default:                    super.handleMessage(msg);            }        }    }    private Messenger getReplyMessenger = new Messenger(new MessageHandler());    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_messenger);        Intent intent = new Intent(this, MessengerService.class);        bindService(intent, connection, Context.BIND_AUTO_CREATE);    }    @Override    protected void onDestroy() {        unbindService(connection);        super.onDestroy();    }}</code></pre><p>如果需要接收服务端返回的消息，注意在发送 Message 字段 replyTo 关联处理消息的 Messenger 对象。</p><p>对于 <strong>服务端</strong> ，首先 Messenger 对象关联接收消息的 Handler ，然后在服务端 onBind 中调用 getBinder() 方法得到 Binder 对象。</p><p>其中 MessageHandler 继承 Handler 并重写 handleMessage 方法。</p><pre><code class="Java">public class MessengerService extends Service {    private static final String TAG = &quot;MessengerService&quot;;    private static class MessageHandler extends Handler {        @Override        public void handleMessage(Message msg) {            Log.d(TAG, &quot;这里是服务端，响应客户端消息&quot;);            switch (msg.what) {                case MConstants.MSG_FROM_CLIENT:                    Log.d(TAG, &quot;服务端接收到: &quot; + msg.getData().get(&quot;msg&quot;));                    // 响应客户端请求                    Messenger replyTo = msg.replyTo;                    Message replyMessage = Message.obtain(null, MConstants.MSG_FROM_SERVICE);                    Bundle bundle = new Bundle();                    bundle.putString(&quot;reply&quot;,&quot;服务端响应内容&quot;);                    replyMessage.setData(bundle);                    try {                        replyTo.send(replyMessage);                    } catch (RemoteException e) {                        e.printStackTrace();                    }                    break;                default:                    super.handleMessage(msg);            }        }    }    private final Messenger messenger = new Messenger(new MessageHandler());    @Nullable    @Override    public IBinder onBind(Intent intent) {        return messenger.getBinder();    }}</code></pre><p>如果需要响应客户端请求，使用 replyTo 字段获取 Messenger 实例再发送消息即可。</p><p>最后注意在 Manifest 中注册 Service 组件。</p><pre><code class="XML">&lt;service    android:name=&quot;com.wshunli.ipc.demo.message.MessengerService&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/5.Messenger进程间通信.png" alt="Messenger进程间通信"></p><p>Messenger 进程间通信在服务端是以串行的方式逐个处理的，所以有大量并发请求时使用 Messenger 不太合适。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.3 使用 Messenger<br>2、Android IPC机制（二）用Messenger进行进程间通信 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/2-messenger.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/2-messenger.html</a><br>3、Android 基于Message的进程间通信 Messenger完全解析 - CSDN博客<br><a href="https://blog.csdn.net/lmj623565791/article/details/47017485" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lmj623565791/article/details/47017485</a><br>4、Handler之Message详解 - 简书<br><a href="https://www.jianshu.com/p/a6c01dd2efdc" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/a6c01dd2efdc</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过 Messenger 可以在不同进程之间传递 Message 对象，是一种轻量级的 IPC 方案。&lt;/p&gt;&lt;p&gt;首先看 Messenger 的构造方法：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;Java&quot;&gt;public Messenger(Handler target
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（四）使用文件共享实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/60bbb7ec.html"/>
    <id>https://www.wshunli.com/posts/60bbb7ec.html</id>
    <published>2018-06-07T09:09:28.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>使用文件共享也是不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据。</p><p>在 Windows 系统，文件会被加排斥锁导致其他线程无法对其访问，而 Android 是基于 Linux 系统，所以并发读写文件没有限制。</p><pre><code class="Java">// 序列化private void persistToFile() {    new Thread(new Runnable() {        @Override        public void run() {            User user = new User(1, &quot;wshunli&quot;, true);            File dir = new File(getApplicationContext().getCacheDir().getPath() + &quot;/user/&quot;);            if (!dir.exists()) {                dir.mkdirs();            }            File cachedFile = new File(dir.getPath() + &quot;/usercache&quot;);            ObjectOutputStream objectOutputStream = null;            try {                objectOutputStream = new ObjectOutputStream(                        new FileOutputStream(cachedFile));                objectOutputStream.writeObject(user);                Log.d(TAG, &quot;persist user:&quot; + user);            } catch (IOException e) {                e.printStackTrace();            } finally {                try {                    if (objectOutputStream != null) {                        objectOutputStream.close();                    }                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }).start();}// 反序列化private void recoverFromFile() {    new Thread(new Runnable() {        @Override        public void run() {            User user = null;            File dir = new File(getApplicationContext().getCacheDir().getPath() + &quot;/user/&quot;);            File cachedFile = new File(dir.getPath() + &quot;/usercache&quot;);            if (cachedFile.exists()) {                ObjectInputStream objectInputStream = null;                try {                    objectInputStream = new ObjectInputStream(                            new FileInputStream(cachedFile));                    user = (User) objectInputStream.readObject();                    Log.d(TAG, &quot;recover user:&quot; + user);                } catch (IOException e) {                    e.printStackTrace();                } catch (ClassNotFoundException e) {                    e.printStackTrace();                } finally {                    try {                        if (objectInputStream != null) {                            objectInputStream.close();                        }                    } catch (IOException e) {                        e.printStackTrace();                    }                }            }        }    }).start();}</code></pre><p>这样对共享文件格式没有要求，但是在多线程情况下可能导致读出的内容不是最新的。<br>所以文件共享适合对数据同步要求不高的进程间进行通信，并妥善地处理好并发读/写问题。</p><p>而对于 SharedPreferences 有一定的读/写缓存策略，在内存中会有一份缓存，因此在多进程情况下，系统对其的读/写就变得不可靠，所以在进程间通信时，一般不用 SharedPreferences 。</p><blockquote><p>参考资料<br>《Android开发艺术探索》 – 2.4.2 使用文件共享</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用文件共享也是不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据。&lt;/p&gt;&lt;p&gt;在 Windows 系统，文件会被加排斥锁导致其他线程无法对其访问，而 Android 是基于 Linux 系统，所以并发读写文件没有限制。&lt;/p&gt;&lt;pre&gt;&lt;code class=
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（三）使用 Bundle 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/f0f2eaec.html"/>
    <id>https://www.wshunli.com/posts/f0f2eaec.html</id>
    <published>2018-06-07T07:40:59.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 四大组件中 Activity、Service、Receiver 都支持在 Intent 中附加传递 Bundle 数据。</p><p>Bundle 是以键值对的形式存储数据，支持基本数据类型、数组、实现 Serializable 或 Parcelable 接口的对象以及一些 Android 支持的特殊对象。</p><pre><code class="Java">// 发送数据Intent intent = new Intent(MainActivity.this, SecondActivity.class);Bundle bundle = new Bundle();bundle.putString(&quot;userName&quot;, &quot;wshunli&quot;);intent.putExtras(bundle);startActivity(intent);// 接收数据Bundle bundle = getIntent().getExtras();String userName = null;if (bundle != null) {    userName = bundle.getString(&quot;userName&quot;);}Log.d(TAG, &quot;userName: &quot; + userName);</code></pre><p>使用 Bundle 的 put 与 get 方法族将数据保存至 bundle 对象，调用 Intent 的 putExtras 方法即可。</p><p>Bundle 源码分析，Bundle 继承自 BaseBundle 并实现了 Cloneable 和 Parcelable 接口。</p><p>以 Boolean 类型数据存取为例：</p><pre><code class="Java">ArrayMap&lt;String, Object&gt; mMap = null;public void putBoolean(@Nullable String key, boolean value) {    unparcel();    mMap.put(key, value);}public boolean getBoolean(String key, boolean defaultValue) {    unparcel();    Object o = mMap.get(key);    if (o == null) {        return defaultValue;    }    try {        return (Boolean) o;    } catch (ClassCastException e) {        typeWarning(key, o, &quot;Boolean&quot;, defaultValue, e);        return defaultValue;    }}</code></pre><p>根据源码可知数据存取都是在 ArrayMap 对象中。</p><p>其中 unparcel() 方法源码如下：</p><pre><code class="Java">/** If mParcelledData is non-null, then mMap will be null and the* data are stored as a Parcel containing a Bundle.  When the data* are unparcelled, mParcelledData willbe set to null.*/Parcel mParcelledData = null;/* package */ void unparcel() {    synchronized (this) {        final Parcel source = mParcelledData;        if (source != null) {            initializeFromParcelLocked(source, /*recycleParcel=*/ true);        } else {            if (DEBUG) {                Log.d(TAG, &quot;unparcel &quot;                        + Integer.toHexString(System.identityHashCode(this))                        + &quot;: no parcelled data&quot;);            }        }    }}private void initializeFromParcelLocked(@NonNull Parcel parcelledData, boolean recycleParcel) {    if (LOG_DEFUSABLE &amp;&amp; sShouldDefuse &amp;&amp; (mFlags &amp; FLAG_DEFUSABLE) == 0) {        Slog.wtf(TAG, &quot;Attempting to unparcel a Bundle while in transit; this may &quot;                + &quot;clobber all data inside!&quot;, new Throwable());    }    if (isEmptyParcel(parcelledData)) {        if (DEBUG) {            Log.d(TAG, &quot;unparcel &quot;                    + Integer.toHexString(System.identityHashCode(this)) + &quot;: empty&quot;);        }        if (mMap == null) {            mMap = new ArrayMap&lt;&gt;(1);        } else {            mMap.erase();        }        mParcelledData = null;        return;    }    final int count = parcelledData.readInt();    if (DEBUG) {        Log.d(TAG, &quot;unparcel &quot; + Integer.toHexString(System.identityHashCode(this))                + &quot;: reading &quot; + count + &quot; maps&quot;);    }    if (count &lt; 0) {        return;    }    ArrayMap&lt;String, Object&gt; map = mMap;    if (map == null) {        map = new ArrayMap&lt;&gt;(count);    } else {        map.erase();        map.ensureCapacity(count);    }    try {        parcelledData.readArrayMapInternal(map, count, mClassLoader);    } catch (BadParcelableException e) {        if (sShouldDefuse) {            Log.w(TAG, &quot;Failed to parse Bundle, but defusing quietly&quot;, e);            map.erase();        } else {            throw e;        }    } finally {        mMap = map;        if (recycleParcel) {            recycleParcel(parcelledData);        }        mParcelledData = null;    }    if (DEBUG) {        Log.d(TAG, &quot;unparcel &quot; + Integer.toHexString(System.identityHashCode(this))                + &quot; final map: &quot; + mMap);    }}</code></pre><p>只有使用 Bundle 构造函数实例化 Bundle 对象时，才会给 mParcelledData 赋值，其他大部分情况下 mParcelledData 都是 null 。</p><pre><code class="Java">BaseBundle(Parcel parcelledData) {    readFromParcelInner(parcelledData);}void readFromParcelInner(Parcel parcel) {    // Keep implementation in sync with readFromParcel() in    // frameworks/native/libs/binder/PersistableBundle.cpp.    int length = parcel.readInt();    readFromParcelInner(parcel, length);}private void readFromParcelInner(Parcel parcel, int length) {    if (length &lt; 0) {        throw new RuntimeException(&quot;Bad length in parcel: &quot; + length);    } else if (length == 0) {        // Empty Bundle or end of data.        mParcelledData = NoImagePreloadHolder.EMPTY_PARCEL;        return;    }    final int magic = parcel.readInt();    if (magic != BUNDLE_MAGIC) {        throw new IllegalStateException(&quot;Bad magic number for Bundle: 0x&quot;                + Integer.toHexString(magic));    }    if (parcel.hasReadWriteHelper()) {        // If the parcel has a read-write helper, then we can&#39;t lazily-unparcel it, so just        // unparcel right away.        synchronized (this) {            initializeFromParcelLocked(parcel, /*recycleParcel=*/ false);        }        return;    }    // Advance within this Parcel    int offset = parcel.dataPosition();    parcel.setDataPosition(MathUtils.addOrThrow(offset, length));    Parcel p = Parcel.obtain();    p.setDataPosition(0);    p.appendFrom(parcel, offset, length);    p.adoptClassCookies(parcel);    if (DEBUG) Log.d(TAG, &quot;Retrieving &quot;  + Integer.toHexString(System.identityHashCode(this))            + &quot;: &quot; + length + &quot; bundle bytes starting at &quot; + offset);    p.setDataPosition(0);    mParcelledData = p;}</code></pre><p>从上述代码片段可以知道 mParcelledData 的取值有3种情况：</p><pre><code class="Java">mParcelledData = nullmParcelledData = NoImagePreloadHolder.EMPTY_PARCELmParcelledData = Parcel.obtain()</code></pre><p>在 unparcel() 方法中分别对这三种情况进行了处理，如果为 null 不进行任何操作返回；如果为 EMPTY_PARCEL 则使用 <code>mMap = new ArrayMap&lt;&gt;(1)</code> 创建长度为 1 的 ArrayMap 对象；如果为 Parcel.obtain() 则实例化 ArrayMap 对象并存储数据。</p><blockquote><p>参考资料<br>1、Android Bundle详解 - CSDN博客<br><a href="https://blog.csdn.net/cswhale/article/details/39053411" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/cswhale/article/details/39053411</a><br>2、Android Bundle总结 - CSDN博客<br><a href="https://blog.csdn.net/ylyg050518/article/details/72638852" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/ylyg050518/article/details/72638852</a><br>3、Android细节问题 —— 有了Intent，为什么还要有Bundle？ - 简书<br><a href="https://www.jianshu.com/p/e9db0797293b" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/e9db0797293b</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Android 四大组件中 Activity、Service、Receiver 都支持在 Intent 中附加传递 Bundle 数据。&lt;/p&gt;&lt;p&gt;Bundle 是以键值对的形式存储数据，支持基本数据类型、数组、实现 Serializable 或 Parcelable
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（二）Android 中的多进程模式</title>
    <link href="https://www.wshunli.com/posts/4662fa2f.html"/>
    <id>https://www.wshunli.com/posts/4662fa2f.html</id>
    <published>2018-06-05T14:09:30.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 中多进程指单个应用存在多个进程的情况。</p><h1 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h1><p>在 Android 中开启多线程只有一种方法，即在 AndroidManifest.xml 中指定 <code>android:process</code> 属性。</p><pre><code class="XML">&lt;activity android:name=&quot;.MainActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity    android:name=&quot;.SecondActivity&quot;    android:process=&quot;:remote&quot; /&gt;&lt;activity    android:name=&quot;.ThirdActivity&quot;    android:process=&quot;com.wshunli.ipc.demo.remote&quot; /&gt;</code></pre><p>MainActivity 没有指定 process 属性，则运行在默认进程中，进程名为包名。</p><p>当启动 SecondActivity 或者 ThirdActivity 时，系统会为他们单独创建进程，<br>进程名分别为 <code>com.wshunli.ipc.demo:remote</code> 和 <code>com.wshunli.ipc.demo.remote</code> .</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/2.开启多进程模式.png" alt="开启多进程模式"></p><p>对于二者的区别，<br>前者 <code>com.wshunli.ipc.demo:remote</code> 代表应用私有进程，其他应用的组件不可与其在同一进程中。<br>后者 <code>com.wshunli.ipc.demo.remote</code> 代表全局进程，其他应用可通过 ShareUID 方式与其在统一进程中。</p><p>Android 系统会为每个应用分配一个唯一的 UID ，具有相同的 UID 应用才能共享数据。</p><p>两个应用通过 ShareUID 跑在同一进程中也是有要求的，需要两个应用有相同的 ShareUID 并且签名相同。<br>在这种情况下，可以互相访问对方的私有数据，看起来像一个应用的两部分。</p><h1 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h1><p>Android 系统为每个应用（或者说每个进程）分配一个独立虚拟机，在内存分配上也有不同的地址空间。</p><p>我们新建一个 UserManager 类，然后写一个静态变量。</p><pre><code class="Java">public class UserManager {    public static int wshunli = 1;}</code></pre><p>在 MainActivity 中将静态变量赋值为 2 ，然后在 SecondActivity 和 ThirdActivity 中打印出来，发现其值仍然是 1 。</p><p>所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。</p><p>一般来说，使用多进程会造成如下几方面的问题：</p><p>(1) 静态成员和单例模式完全失效（不同的虚拟机）。<br>(2) 线程同步机制完全失效（不是同一块内存空间）。<br>(3) SharePreferences 的可靠性下降（底层通过 XML 执行操作，并发读/写都有可能出问题）。<br>(4) Application 会多次创建（启动新进程其实就是启动一个应用的过程，自然会创建新的 Application ）。</p><pre><code class="Java">public class MApplication extends Application {    private static final String TAG = &quot;MApplication&quot;;    @Override    public void onCreate() {        super.onCreate();        int pid = Process.myPid();        Log.d(TAG, &quot;pid: &quot; + pid);    }}</code></pre><p>同一个应用的多线程相当于不同应用采用 ShareUID 模式。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.2 Android 中的多进程模式<br>2、Android 接口定义语言 (AIDL) | Android Developers<br><a href="https://developer.android.com/guide/components/aidl" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/aidl</a><br>3、Android IPC机制（一）开启多进程 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/1-process-start.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/1-process-start.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Android 中多进程指单个应用存在多个进程的情况。&lt;/p&gt;&lt;h1 id=&quot;开启多进程模式&quot;&gt;&lt;a href=&quot;#开启多进程模式&quot; class=&quot;headerlink&quot; title=&quot;开启多进程模式&quot;&gt;&lt;/a&gt;开启多进程模式&lt;/h1&gt;&lt;p&gt;在 Android 中开启多
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（一）Android IPC 简介</title>
    <link href="https://www.wshunli.com/posts/4ff64590.html"/>
    <id>https://www.wshunli.com/posts/4ff64590.html</id>
    <published>2018-06-05T11:58:49.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>IPC（Inter-Process Communication，进程间通信）指两进程间进行数据交换的过程。</p><p>IPC 并不是 Android 独有的，Windows 上可通过剪切板、管道和油槽等来进行进程间通信；Linux 可通过命名管道、共享内存和信号量等实现进程间通信。</p><p>虽然 Android 是基于 Linux 内核的操作系统，但是它有自己的进程间通信方式。</p><p>在 Android 中，通过 Binder 可以实现进程间通信，还有 Socket 、ContentProvider 等等。</p><p>IPC 使用场景，一是应用的自身原因需要使用多进程实现；另一个是通过多进程获得更多内存空间。</p><p>我们需要通过 Intent 和 Binder 传输数据时，需要用到 <strong>Serializable</strong> 或者 <strong>Parcelable</strong> 接口完成对象的序列化。</p><p>1、Serializable 接口</p><p>Serializable 是 Java 提供的一个序列化接口，是一个空接口。</p><pre><code class="Java">public class User implements Serializable {    private static final long serialVersionUID = 8929979969779835719L;    public int userId;    public String userName;    public boolean isMale;    ···}</code></pre><p>只需实现 Serializable 接口，一般应该手动指定 serialVersionUID ，当版本升级时能最大限度恢复数据。</p><pre><code class="Java">// 序列化User user = new User(0, &quot;wshunli&quot;, true);try {    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;cache.text&quot;));    out.writeObject(user);    out.close();} catch (IOException e) {    e.printStackTrace();}// 反序列化try {    ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;cache.text&quot;));    User newUser = (User) in.readObject();    Log.d(TAG, &quot;onCreate: &quot; + newUser.toString());    in.close();} catch (IOException e) {    e.printStackTrace();} catch (ClassNotFoundException e) {    e.printStackTrace();}</code></pre><p>序列化：把对象转换为字节序列的过程称为对象的序列化。<br>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</p><p>2、Parcelable 接口</p><p>Parcelable 接口是 Android 系统提供的序列化接口。</p><pre><code class="Java">public class User implements Parcelable {    public int userId;    public String userName;    public boolean isMale;    public Book book;    public User(int userId, String userName, boolean isMale, Book book) {        this.userId = userId;        this.userName = userName;        this.isMale = isMale;        this.book = book;    }    // 内容描述    @Override    public int describeContents() {        return 0;    }    // 序列化    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeInt(userId);        dest.writeString(userName);        dest.writeInt(isMale ? 1 : 0);        dest.writeParcelable(book, 0);    }    // 反序列化    public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;(){        @Override        public User createFromParcel(Parcel source) {            return new User(source);        }        @Override        public User[] newArray(int size) {            return new User[size];        }    };    private User(Parcel source) {        userId = source.readInt();        userName = source.readString();        isMale = source.readInt() == 1;        book = source.readParcelable(Thread.currentThread().getContextClassLoader());    }}</code></pre><p>使用 Parcelable 序列化还是有点麻烦的，不过思路清晰。</p><p>Serializable 和 Parcelable 比较：</p><p>Serializable 是 Java 的序列化接口，需要大量 I/O 操作，开销比较大；<br>Parcelable 是 Android 中的序列化接口，效率更高，因此首选。</p><p>但是在将对象序列化到存储设备或者将对象序列化后的通过网络传输，建议使用 Serializable 接口。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.1 Android IPC 简介、2.3 IPC 基础概念介绍<br>2、Android IPC机制详解（一） - 简书<br><a href="https://www.jianshu.com/p/b9b3051a4ff6" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b9b3051a4ff6</a><br>3、Android 中的IPC机制 - CSDN博客<br><a href="https://blog.csdn.net/a565102223/article/details/70186070" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a565102223/article/details/70186070</a><br>4、Java 之 Serializable 序列化和反序列化的概念,作用的通俗易懂的解释 - CSDN博客<br><a href="https://blog.csdn.net/qq_27093465/article/details/78544505" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_27093465/article/details/78544505</a><br>5、详细介绍Android中Parcelable的原理和使用方法 - CSDN博客<br><a href="https://blog.csdn.net/justin_1107/article/details/72903006" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/justin_1107/article/details/72903006</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IPC（Inter-Process Communication，进程间通信）指两进程间进行数据交换的过程。&lt;/p&gt;&lt;p&gt;IPC 并不是 Android 独有的，Windows 上可通过剪切板、管道和油槽等来进行进程间通信；Linux 可通过命名管道、共享内存和信号量等实现进
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（八）</title>
    <link href="https://www.wshunli.com/posts/6374acae.html"/>
    <id>https://www.wshunli.com/posts/6374acae.html</id>
    <published>2018-06-05T02:05:40.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 网络编程</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第8章-使用网络技术"><a href="#第8章-使用网络技术" class="headerlink" title="第8章 使用网络技术"></a>第8章 使用网络技术</h1><h2 id="WebView-的用法"><a href="#WebView-的用法" class="headerlink" title="WebView 的用法"></a>WebView 的用法</h2><p>WebView 也是 Android 的一个控件，用来显示一些网页，内容也比较多。</p><p>针对 WebView 的封装，可以使用 AgentWeb :</p><p>Justson/AgentWeb: AgentWeb is a powerful library based on Android WebView.<br><a href="https://github.com/Justson/AgentWeb" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Justson/AgentWeb</a></p><p>优化首屏加载速度，可以使用 VasSonic ：</p><p>Tencent/VasSonic: VasSonic is a lightweight and high-performance Hybrid framework developed by tencent VAS team, which is intended to speed up the first screen of websites working on Android and iOS platform.<br><a href="https://github.com/Tencent/VasSonic" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Tencent/VasSonic</a></p><p>对于 WebView 有特殊要求的，可以使用一些浏览器内核：</p><p>Crosswalk - Embedding the Crosswalk Project<br><a href="https://crosswalk-project.org/documentation/android/embedding_crosswalk.html" rel="external nofollow noopener noreferrer" target="_blank">https://crosswalk-project.org/documentation/android/embedding_crosswalk.html</a></p><p>腾讯浏览服务：<br><a href="http://x5.tencent.com/" rel="external nofollow noopener noreferrer" target="_blank">http://x5.tencent.com/</a></p><p>本文只介绍 Android 系统 <a href="https://developer.android.com/reference/android/webkit/WebView" rel="external nofollow noopener noreferrer" target="_blank">WebView</a> 使用。</p><p>在 Android 4.4 以前使用基于 Android WebKit 的 WebView 实现；<br>在 Android 4.4 及以后使用基于 Chromium blink 的 WebView 实现；<br>从 Android 5.0 开始，Google 把 Chromium blink 内核作为 apk 单独从系统抽离出来。</p><pre><code class="Java">WebView webView = findViewById(R.id.webview);webView.getSettings().setJavaScriptEnabled(true);webView.setWebViewClient(new WebViewClient());webView.loadUrl(&quot;https://html5test.com/&quot;);</code></pre><p>这只是简单地显示网页，WebView 本身还有很多技巧。</p><h2 id="使用-HTTP-协议访问网络"><a href="#使用-HTTP-协议访问网络" class="headerlink" title="使用 HTTP 协议访问网络"></a>使用 HTTP 协议访问网络</h2><p>1、使用 HttpURLConnection</p><p>在 Android 上发送 HTTP 请求一般使用 HttpURLConnection 或者 HttpClient 。</p><p>不过 HttpClient 在 Android 6.0 已经废弃。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        HttpURLConnection connection = null;        BufferedReader reader = null;        try {            URL url = new URL(&quot;https://www.wshunli.com/&quot;);            connection = (HttpURLConnection) url.openConnection();            connection.setRequestMethod(&quot;GET&quot;);            connection.setConnectTimeout(8000);            connection.setReadTimeout(8000);            InputStream in = new BufferedInputStream(connection.getInputStream());            reader = new BufferedReader(new InputStreamReader(in));            String line;            while ((line = reader.readLine()) != null) {                Log.d(TAG, line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if (reader != null) {                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (connection != null) {                connection.disconnect();            }        }    }}).start();</code></pre><p>上面是发送 GET 请求，发送 POST 请求：</p><pre><code class="Java">connection.setRequestMethod(&quot;POST&quot;);DataOutputStream out = new DataOutputStream(connection.getOutputStream());out.writeBytes(&quot;username=wshunli&amp;password=123456&quot;);</code></pre><p>2、使用 OkHttp</p><p>在实际项目里面使用 HttpURLConnection 还是不太行的，往往使用一些开源的网络框架，比如 OkHttp 等等。</p><p><a href="http://square.github.io/okhttp/" rel="external nofollow noopener noreferrer" target="_blank">OkHttp</a>：An HTTP &amp; HTTP/2 client for Android and Java applications</p><p><a href="https://github.com/square/okhttp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/square/okhttp</a></p><p>首先添加 OkHttp 依赖：</p><pre><code class="groovy">implementation &#39;com.squareup.okhttp3:okhttp:3.10.0&#39;</code></pre><p>使用 OkHttp 发送 GET 请求：</p><pre><code class="Java">OkHttpClient client = new OkHttpClient();Request request = new Request.Builder()        .url(&quot;https://www.shunli.com&quot;)        .build();try {    Response response = client.newCall(request).execute();    String responseData = response.body().string();    Log.d(TAG, &quot;onCreate: &quot; + responseData);} catch (IOException e) {    e.printStackTrace();}</code></pre><p>整个过程清楚简洁。</p><pre><code class="Java">···RequestBody requestBody = new FormBody.Builder()        .add(&quot;username&quot;, &quot;wshunli&quot;)        .add(&quot;password&quot;, &quot;123456&quot;)        .build();Request request = new Request.Builder()        .url(&quot;https://www.shunli.com&quot;)        .post(requestBody)        .build();···</code></pre><p>发送 POST 请求有点不太一样，要使用 RequestBody 传递数据。</p><p>这里只是简单介绍了 OkHttp 的使用，还有很多东西，后面再介绍。</p><h2 id="解析-XML-格式数据"><a href="#解析-XML-格式数据" class="headerlink" title="解析 XML 格式数据"></a>解析 XML 格式数据</h2><p>在网络传递的数据主要有两种： XML 和 JSON 。</p><p>这里我们使用本站的 RSS 订阅源数据。</p><p><a href="https://www.wshunli.com/atom.xml">https://www.wshunli.com/atom.xml</a></p><p>1、Pull 解析方式</p><p>本方法是将请求的 XML 字符串传入 XmlPullParser 对象实例，然后根据节点名字遍历解析 XML 内容。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        OkHttpClient client = new OkHttpClient();        Request request = new Request.Builder()                .url(&quot;https://www.wshunli.com/atom.xml&quot;)                .build();        try {            Response response = client.newCall(request).execute();            String responseData = response.body().string();            parseXMLWithPull(responseData);        } catch (IOException e) {            e.printStackTrace();        }    }}).start();private void parseXMLWithPull(String xmlData) {    try {        XmlPullParserFactory factory = XmlPullParserFactory.newInstance();        XmlPullParser xmlPullParser = factory.newPullParser();        xmlPullParser.setInput(new StringReader(xmlData));        int eventType = xmlPullParser.getEventType();        String title = &quot;&quot;;        String id = &quot;&quot;;        String published = &quot;&quot;;        String updated = &quot;&quot;;        while (eventType != XmlPullParser.END_DOCUMENT) {            String nodeName = xmlPullParser.getName();            switch (eventType) {                case XmlPullParser.START_TAG:                    if (nodeName.equals(&quot;title&quot;)) {                        title = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;id&quot;)) {                        id = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;published&quot;)) {                        published = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;updated&quot;)) {                        updated = xmlPullParser.nextText();                    }                    break;                case XmlPullParser.END_TAG:                    if (nodeName.equals(&quot;entry&quot;)) {                        Log.d(TAG, &quot;文章标题: &quot; + title);                        Log.d(TAG, &quot;文章链接: &quot; + id);                        Log.d(TAG, &quot;发布时间: &quot; + published);                        Log.d(TAG, &quot;更新时间: &quot; + updated);                    }                    break;                default:                    break;            }            eventType = xmlPullParser.next();        }    } catch (XmlPullParserException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>解析结果示例：</p><pre><code class="TXT">文章标题: 《第一行代码》读书笔记（七）文章链接: https://www.wshunli.com/posts/941f84ed.html发布时间: 2018-06-04T08:41:39.000Z更新时间: 2018-06-04T15:14:46.188Z文章标题: 《第一行代码》读书笔记（六）文章链接: https://www.wshunli.com/posts/461ff372.html发布时间: 2018-06-03T13:54:38.000Z更新时间: 2018-06-04T15:14:46.188Z</code></pre><p>2、SAX 解析方式</p><p>SAX 解析方式也是一种比较常用的方法，虽然比 Pull 方式复杂，但是语义更容易理解。</p><p>通常会新建一个类继承 DefaultHandler ，并重写其方法。</p><pre><code class="Java">public class PostsHandler extends DefaultHandler {    @Override    public void startDocument() throws SAXException {        super.startDocument();    }    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {        super.startElement(uri, localName, qName, attributes);    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {        super.characters(ch, start, length);    }    @Override    public void endElement(String uri, String localName, String qName) throws SAXException {        super.endElement(uri, localName, qName);    }    @Override    public void endDocument() throws SAXException {        super.endDocument();    }}</code></pre><p>其中 startDocument 和 endDocument 分别在开始、结束 XMl 接解析时调用。<br>类似 startElement 和 endElement 分别在开始、结束解析某个节点时调用。<br>而 characters 方法会在获取节点内容时调用，可能会调用多次，注意换行符也会解析出来。</p><pre><code class="Java">public class PostsHandler extends DefaultHandler {    private static final String TAG = &quot;PostsHandler&quot;;    private String nodeName;    private StringBuilder title;    private StringBuilder id;    private StringBuilder published;    private StringBuilder updated;    @Override    public void startDocument() throws SAXException {        title = new StringBuilder();        id = new StringBuilder();        published = new StringBuilder();        updated = new StringBuilder();    }    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {        // 记录节点名称        nodeName = localName;    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {        // 根据节点名称将内容添加到 StringBuilder 中        if (nodeName.equals(&quot;title&quot;)) {            title.append(ch, start, length);        } else if (nodeName.equals(&quot;id&quot;)) {            id.append(ch, start, length);        } else if (nodeName.equals(&quot;published&quot;)) {            published.append(ch, start, length);        } else if (nodeName.equals(&quot;updated&quot;)) {            updated.append(ch, start, length);        }    }    @Override    public void endElement(String uri, String localName, String qName) throws SAXException {        if (localName.equals(&quot;entry&quot;)) {            Log.d(TAG, &quot;文章标题: &quot; + title.toString().trim());            Log.d(TAG, &quot;文章链接: &quot; + id.toString().trim());            Log.d(TAG, &quot;发布时间: &quot; + published.toString().trim());            Log.d(TAG, &quot;更新时间: &quot; + updated.toString().trim());            title.setLength(0);            id.setLength(0);            published.setLength(0);            updated.setLength(0);        }    }    @Override    public void endDocument() throws SAXException {        super.endDocument();    }}</code></pre><p>和前面 Pull 解析功能是一样的。</p><pre><code class="Java">private void parseXMLWithSAX(String xmlData) {    SAXParserFactory factory = SAXParserFactory.newInstance();    try {        XMLReader xmlReader = factory.newSAXParser().getXMLReader();        PostsHandler handler = new PostsHandler();        xmlReader.setContentHandler(handler);        xmlReader.parse(new InputSource(new StringReader(xmlData)));    } catch (SAXException e) {        e.printStackTrace();    } catch (ParserConfigurationException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>调用是使用 XMLReader 实例的 setContentHandler 方法。</p><h2 id="解析-JSON-格式数据"><a href="#解析-JSON-格式数据" class="headerlink" title="解析 JSON 格式数据"></a>解析 JSON 格式数据</h2><p>感觉平常 JSON 数据用得更多一些，JSON 和 XML 相比主要有优势在于体积更小。</p><p>以前本站是支持生成 JSON 文件的，因为上传太慢了就取消了。</p><p>这里使用随便使用一个 JSON 文件做测试吧。</p><p><a href="https://raw.githubusercontent.com/wshunli/wshunli.github.io/c28a64a898599442a10c9eee74fed8d54dc89e7f/api/posts.json" rel="external nofollow noopener noreferrer" target="_blank">https://raw.githubusercontent.com/wshunli/wshunli.github.io/c28a64a898599442a10c9eee74fed8d54dc89e7f/api/posts.json</a></p><p>1、使用 JSONObject</p><p>解析 JSON 数据可以使用 JSONObject 或者 GSON 开源库，还有一些 Jackson 、FastJSON 都不错。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        OkHttpClient client = new OkHttpClient();        Request request = new Request.Builder()                .url(&quot;https://raw.githubusercontent.com/wshunli/wshunli.github.io/c28a64a898599442a10c9eee74fed8d54dc89e7f/api/posts.json&quot;)                .build();        try {            Response response = client.newCall(request).execute();            String responseData = response.body().string();            parseJSONWithJSONObject(responseData);        } catch (IOException e) {            e.printStackTrace();        }    }}).start();private void parseJSONWithJSONObject(String jsonData) {    try {        JSONObject jsonObject = new JSONObject(jsonData);        if (jsonObject.has(&quot;data&quot;)){            String data = jsonObject.getString(&quot;data&quot;);            JSONArray jsonArray = new JSONArray(data);            for (int i = 0; i &lt; jsonArray.length(); i++) {                JSONObject object = jsonArray.getJSONObject(i);                String title = object.getString(&quot;title&quot;);                String path = object.getString(&quot;path&quot;);                String date = object.getString(&quot;date&quot;);                String updated = object.getString(&quot;updated&quot;);                Log.d(TAG, &quot;文章标题: &quot; + title);                Log.d(TAG, &quot;文章链接: &quot; + path);                Log.d(TAG, &quot;发布时间: &quot; + date);                Log.d(TAG, &quot;更新时间: &quot; + updated);            }        }    } catch (JSONException e) {        e.printStackTrace();    }}</code></pre><p>也就是使用构造函数传入 JSON 字符串获得 JSONObject 对象实例。</p><p>如果遇到数组的使用 JSONArray 实例逐条遍历即可。</p><p>2、使用 GSON 库</p><p>google/gson: A Java serialization/deserialization library to convert Java Objects into JSON and back<br><a href="https://github.com/google/gson" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/google/gson</a></p><p>使用 GSON 解析 JSON 数据特别简单。</p><pre><code class="groovy">implementation &#39;com.google.code.gson:gson:2.8.4&#39;</code></pre><p>首先根据 JSON 数据定义 Posts 类。</p><pre><code class="Java">public class Posts {    int total;    int pageSize;    int pageCount;    List&lt;Article&gt; data;    public static class Article{        String title;        String path;        String date;        String updated;        public String getTitle() {            return title;        }        public void setTitle(String title) {            this.title = title;        }        public String getPath() {            return path;        }        public void setPath(String path) {            this.path = path;        }        public String getDate() {            return date;        }        public void setDate(String date) {            this.date = date;        }        public String getUpdated() {            return updated;        }        public void setUpdated(String updated) {            this.updated = updated;        }    }    public int getTotal() {        return total;    }    public void setTotal(int total) {        this.total = total;    }    public int getPageSize() {        return pageSize;    }    public void setPageSize(int pageSize) {        this.pageSize = pageSize;    }    public int getPageCount() {        return pageCount;    }    public void setPageCount(int pageCount) {        this.pageCount = pageCount;    }    public List&lt;Article&gt; getData() {        return data;    }    public void setData(List&lt;Article&gt; data) {        this.data = data;    }}</code></pre><p>然后实例化 GSON 对象解析 JSON 字符串。</p><pre><code class="Java">private void parseJSONWithGSON(String jsonDate) {    Gson gson = new Gson();    Posts posts = gson.fromJson(jsonDate, Posts.class);    List&lt;Posts.Article&gt; data = posts.getData();    for (Posts.Article article : data) {        Log.d(TAG, &quot;文章标题: &quot; + article.getTitle());        Log.d(TAG, &quot;文章链接: &quot; + article.getPath());        Log.d(TAG, &quot;发布时间: &quot; + article.getDate());        Log.d(TAG, &quot;更新时间: &quot; + article.getUpdated());    }}</code></pre><p>GSON 也就介绍到这里。</p><blockquote><p>参考资料<br>1、Building Web Apps in WebView | Android Developers<br><a href="https://developer.android.com/guide/webapps/webview" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/webapps/webview</a><br>2、Android：最全面的 Webview 详解 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/52693322" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/52693322</a><br>3、Getting Started: WebView-based Applications for Web Developers - Google Chrome<br><a href="https://developer.chrome.com/multidevice/webview/gettingstarted" rel="external nofollow noopener noreferrer" target="_blank">https://developer.chrome.com/multidevice/webview/gettingstarted</a><br>4、X5 浏览器内核调研报告 - 简书<br><a href="https://www.jianshu.com/p/2a14d303308d" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/2a14d303308d</a><br>5、前端 WebView 指南之 Android 交互篇 - 怡红院落<br><a href="https://imnerd.org/android-webview-and-js.html" rel="external nofollow noopener noreferrer" target="_blank">https://imnerd.org/android-webview-and-js.html</a><br>6、在Android上使用JS引擎是一种什么样的体验？ | 网易杭州前端技术部<br><a href="https://neyoufan.github.io/2016/12/23/android/Android%20Js引擎/在Android上使用JS引擎是一种什么样的体验？/" rel="external nofollow noopener noreferrer" target="_blank">https://neyoufan.github.io/2016/12/23/android/Android%20Js引擎/在Android上使用JS引擎是一种什么样的体验？/</a></p></blockquote><hr><p>到这里可能算又浏览了一遍 《第一行代码》 。</p><p>这次有些内容没有看，比如第 3、12 章的 UI 部分。</p><p>还有 第 11 章 基于位置的服务也没有看，因为前面专业 GIS SDK 接触很多了。</p><p>最后是第 13、14 章的进阶、实战部分，后面再了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 网络编程&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href=&quot;https://www.wsh
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（七）</title>
    <link href="https://www.wshunli.com/posts/941f84ed.html"/>
    <id>https://www.wshunli.com/posts/941f84ed.html</id>
    <published>2018-06-04T08:41:39.000Z</published>
    <updated>2018-06-19T12:01:39.073Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 多媒体资源</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第8章-丰富你的程序"><a href="#第8章-丰富你的程序" class="headerlink" title="第8章 丰富你的程序"></a>第8章 丰富你的程序</h1><h2 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h2><p>1、通知的基本用法</p><p>通知 Notification 是 Android 系统中比较特色的功能，使用方式也很灵活。</p><p>首先获取 NotificationManager 对象，然后构建 Notification 实例，最后使用 notify 方法显示通知。</p><pre><code class="Java">NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        .setContentTitle(&quot;Hello Notification !&quot;)        .setContentText(&quot;This is content text&quot;)        .setWhen(System.currentTimeMillis())        .setSmallIcon(R.mipmap.ic_launcher_round)        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))        .setAutoCancel(true)        .build();notificationManager.notify(2333, notification);</code></pre><p>以上是书籍代码思路，在 Android 8.0 上是不显示通知的，我们作相应的修改。</p><pre><code class="Java">NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {    NotificationChannel channel = new NotificationChannel(&quot;2333&quot;, &quot;wshunli&quot;,NotificationManager.IMPORTANCE_HIGH);    notificationManager.createNotificationChannel(channel);}Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        .setContentTitle(&quot;Hello Notification !&quot;)        .setContentText(&quot;This is content text&quot;)        .setWhen(System.currentTimeMillis())        .setSmallIcon(R.mipmap.ic_launcher_round)        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))        .setAutoCancel(true)        .setChannelId(&quot;2333&quot;)        .build();notificationManager.notify(2333, notification);</code></pre><p>最终通知显示效果：</p><p><img src="https://img.wshunli.com/Android/第一行代码/7.Notification.png" alt="7.Notification.png"></p><p>这时候点击通知是没有效果的，对通知 <strong>添加点击效果</strong> 。</p><p>使用 <a href="https://developer.android.com/reference/android/app/PendingIntent" rel="external nofollow noopener noreferrer" target="_blank">PendingIntent</a> 来启动 Activity 、 Service 、发送广播等。</p><p>PendingIntent 会在何时和时机执行某个动作，而 Intent 会立即执行。</p><p>根据启动的 Android 组件不同可使用的方法也不同：</p><pre><code class="Java">getActivity(Context, int, Intent, int),getActivities(Context, int, Intent[], int), getBroadcast(Context, int, Intent, int), getService(Context, int, Intent, int);</code></pre><p>其中最后一个参数取值也很丰富，FLAG_ONE_SHOT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT, FLAG_UPDATE_CURRENT 。</p><p>使用示例：</p><pre><code class="Java">Intent intent = new Intent(getApplicationContext(), NotificationActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_ONE_SHOT);Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        .setContentTitle(&quot;Hello Notification !&quot;)        .setContentText(&quot;This is content text&quot;)        .setWhen(System.currentTimeMillis())        .setSmallIcon(R.mipmap.ic_launcher_round)        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))        .setAutoCancel(true)        .setChannelId(&quot;2333&quot;)        .setContentIntent(pendingIntent)        .build();</code></pre><p>使用 setContentIntent() 方法设置 PendingIntent 对象参数，点击即可跳转到 NotificationActivity 界面。</p><p>2、通知的进阶技巧</p><p>NotificationCompat.Builder 中有非常丰富的 API 来创建多样的通知效果。</p><p>2.1、设置声音</p><p>Notification.Builder setSound(Uri sound)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setSound(Uri.parse(&quot;/system/media/audio/ringtones/Luna.ogg&quot;))        .build();</code></pre><p>Android 8.0 要使用 NotificationChannel 设置：</p><p>void setSound (Uri sound, AudioAttributes audioAttributes)</p><pre><code class="Java">NotificationChannel channel = new NotificationChannel(&quot;2333&quot;, &quot;wshunli&quot;,NotificationManager.IMPORTANCE_HIGH);channel.setSound(Uri.parse(&quot;/system/media/audio/ringtones/Luna.ogg&quot;), null);notificationManager.createNotificationChannel(channel);</code></pre><p>2.2、设置震动</p><p>Notification.Builder setVibrate(long[] pattern)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setVibrate(new long[]{0, 1000, 1000, 1000})        .build();</code></pre><p>其中数组表示：先停顿 0 ms ，震动 1000 ms ，再停顿 1000 ms ， 最后震动 1000 ms ，后面以此类推。</p><p>需要申请权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;</code></pre><p>Android 8.0 要使用 NotificationChannel 设置：</p><p>void setVibrationPattern (long[] vibrationPattern)</p><pre><code class="Java">NotificationChannel channel = new NotificationChannel(&quot;2333&quot;, &quot;wshunli&quot;,NotificationManager.IMPORTANCE_HIGH);channel.setVibrationPattern(new long[]{0, 1000, 1000, 1000});notificationManager.createNotificationChannel(channel);</code></pre><p>3.3、设置 LED 灯</p><p>Notification.Builder setLights (int argb, int onMs, int offMs)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setLights(Color.GREEN, 1000, 1000)        .build();</code></pre><p>Android 8.0 要使用 NotificationChannel 设置：</p><p>void enableLights (boolean lights)</p><pre><code class="Java">channel.enableLights(true);</code></pre><p>3.4、默认设置</p><p>前面那么多设置，嫌麻烦可以直接使用默认效果。</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setDefaults(NotificationCompat.DEFAULT_ALL)        .build();</code></pre><p>Android 8.0 此方法过时，还要用前面适用于 8.0 的方法。</p><p>3、通知的高级功能</p><p>3.1、首先看 setStyle() 方法</p><p>Notification.Builder setStyle (Notification.Style style)</p><p>首先来看显示一段长文字：</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setContentText(&quot;com.wshunli.notification.demo/com.wshunli.notification.demo.MainActivity&quot;)        .build();</code></pre><p>这样文字过长，会以省略号代替。</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        // 使用 setStyle() 方法        .setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;com.wshunli.notification.demo/com.wshunli.notification.demo.MainActivity&quot;))        .build();</code></pre><p>这样文字会全部显示出来。</p><p>除了显示长文字外，通知还可以显示一张大图片：</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(),R.drawable.pano)))        .build();</code></pre><p>以上显示结果：</p><table><thead><tr><th style="text-align:center"><img src="https://img.wshunli.com/Android/第一行代码/7.Notification_Style1.png" alt="7.Notification.png"></th><th style="text-align:center"><img src="https://img.wshunli.com/Android/第一行代码/7.Notification_Style2.png" alt="7.Notification.png"></th><th style="text-align:center"><img src="https://img.wshunli.com/Android/第一行代码/7.Notification_Style3.png" alt="7.Notification.png"></th></tr></thead><tbody><tr><td style="text-align:center">通知文字过长</td><td style="text-align:center">显示长文字效果</td><td style="text-align:center">显示大图片效果</td></tr></tbody></table><p>3.2、通知的优先级</p><p>使用 setPriority 方法：</p><p>Notification.Builder setPriority (int pri)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setPriority(NotificationCompat.PRIORITY_DEFAULT)        .build();</code></pre><p>其中优先级可取值：PRIORITY_DEFAULT, PRIORITY_LOW, PRIORITY_MIN, PRIORITY_HIGH or PRIORITY_MAX.</p><p>Andorid 8.0 使用 <code>NotificationManager</code> 中 IMPORTANCE_DEFAULT, IMPORTANCE_HIGH, IMPORTANCE_LOW, IMPORTANCE_MAX, IMPORTANCE_MIN 代替。</p><p>方法也使用 NotificationChannel 中的 setImportance 方法：</p><p>void setImportance (int importance)</p><pre><code class="Java">channel.setImportance(NotificationManager.IMPORTANCE_DEFAULT);</code></pre><h2 id="调用摄像头相册"><a href="#调用摄像头相册" class="headerlink" title="调用摄像头相册"></a>调用摄像头相册</h2><p>1、调用摄像头拍照</p><p>首先应该申请相机权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</code></pre><pre><code class="Java">public static final int TAKE_PHOTO = 1;private Uri imageUri;// 创建 File 对象，用于存储拍照后的图片File outputImage = new File(getExternalCacheDir(), &quot;output_image.jpg&quot;);try {    if (outputImage.exists()) {        outputImage.delete();    }    outputImage.createNewFile();} catch (IOException e) {    e.printStackTrace();}// 将 File 转化为 Uri 对象if (Build.VERSION.SDK_INT &lt; 24) {    imageUri = Uri.fromFile(outputImage);} else {    imageUri = FileProvider.getUriForFile(MainActivity.this, &quot;com.wshunli.camera.demo.fileprovider&quot;, outputImage);}// 启动相机程序Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);startActivityForResult(intent, TAKE_PHOTO);</code></pre><p>对于 Android 7.0 以前，File 转化为 Uri 比较简单，但是 7.0 以后认为直接使用真实路径的 Uri 是不安全的。</p><p>所以使用 FileProvider 内容提供器来对数据进行保护，可以选择性地将封装过的 Uri 共享给外部。</p><p>在 Manifest 中，添加 provider 内容提供器 ：</p><pre><code class="XML">&lt;provider    android:name=&quot;android.support.v4.content.FileProvider&quot;    android:authorities=&quot;com.wshunli.camera.demo.fileprovider&quot;    android:exported=&quot;false&quot;    android:grantUriPermissions=&quot;true&quot;&gt;    &lt;meta-data        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;        android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt;</code></pre><p>在 <code>/app/src/main/res/xml/</code> 目录下创建 <code>file_paths.xml</code> 文件，并写入值：</p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;external-path        name=&quot;my_images&quot;        path=&quot;/&quot; /&gt;&lt;/paths&gt;</code></pre><p>最后在 onActivityResult 中接收拍照完成后返回的数据：</p><pre><code class="Java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    switch (requestCode) {        case TAKE_PHOTO:            if (resultCode == RESULT_OK) {                try {                    // 获取拍摄的照片                    Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));                    Log.d(TAG, &quot;onActivityResult: &quot; + bitmap.getRowBytes());                } catch (Exception e) {                    e.printStackTrace();                }            }            break;        default:            break;    }}</code></pre><p>2、从相册中选择照片</p><p>同样应该声明权限，在系统版本 6.0 一样应该申请运行时权限。</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</code></pre><p>打开相册还算比较简单：</p><pre><code class="Java">public static final int CHOOSE_PHOTO = 2;// 打开相册Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;);intent.setType(&quot;image/*&quot;);startActivityForResult(intent, CHOOSE_PHOTO);</code></pre><p>结果处理有点复杂：</p><pre><code class="Java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    switch (requestCode) {        ···        case CHOOSE_PHOTO:            if (resultCode == RESULT_OK) {                // 判断手机系统版本号                if (Build.VERSION.SDK_INT &gt;= 19) {                    // 4.4 及以上系统使用这个方法处理图片                    handleImageOnKitKat(data);                } else {                    // 4.4 以下系统使用这个方法处理图片                    handleImageBeforeKitKat(data);                }            }            break;        default:            break;    }}@TargetApi(19)private void handleImageOnKitKat(Intent data) {    String imagePath = null;    Uri uri = data.getData();    Log.d(&quot;TAG&quot;, &quot;handleImageOnKitKat: uri is &quot; + uri);    if (DocumentsContract.isDocumentUri(this, uri)) {        // 如果是 document 类型的 Uri ，则通过 document id 处理        String docId = DocumentsContract.getDocumentId(uri);        if(&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority())) {            String id = docId.split(&quot;:&quot;)[1]; // 解析出数字格式的 id            String selection = MediaStore.Images.Media._ID + &quot;=&quot; + id;            imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);        } else if (&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority())) {            Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(docId));            imagePath = getImagePath(contentUri, null);        }    } else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) {        // 如果是 content 类型的 Uri ，则使用普通方式处理        imagePath = getImagePath(uri, null);    } else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) {        // 如果是 file 类型的 Uri ，直接获取图片路径即可        imagePath = uri.getPath();    }    Log.d(TAG, &quot;handleImageOnKitKat: &quot; + imagePath);}private void handleImageBeforeKitKat(Intent data) {    Uri uri = data.getData();    String imagePath = getImagePath(uri, null);    Log.d(TAG, &quot;handleImageBeforeKitKat: &quot; + imagePath);}private String getImagePath(Uri uri, String selection) {    String path = null;    // 通过 Uri 和 selection 来获取真实的图片路径    Cursor cursor = getContentResolver().query(uri, null, selection, null, null);    if (cursor != null) {        if (cursor.moveToFirst()) {            path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));        }        cursor.close();    }    return path;}</code></pre><h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><p>1、播放音频</p><p>播放音频主要使用 <a href="https://developer.android.com/reference/android/media/MediaPlayer" rel="external nofollow noopener noreferrer" target="_blank">MediaPlayer</a> 类。</p><p>MedaiaPlayer 设置资源有三种类型：</p><p>(1) 本地资源</p><pre><code class="Java">MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file);mediaPlayer.start(); // no need to call prepare(); create() does that for you</code></pre><p>(2) 通过 URI 共享的资源</p><pre><code class="Java">Uri myUri = ....; // initialize Uri hereMediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(getApplicationContext(), myUri);mediaPlayer.prepare();mediaPlayer.start();</code></pre><p>(3) 通过网络 URL 资源</p><pre><code class="Java">String url = &quot;http://........&quot;; // your URL hereMediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(url);mediaPlayer.prepare(); // might take long! (for buffering, etc)mediaPlayer.start();</code></pre><p><a href="https://developer.android.com/guide/topics/media/mediaplayer" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/media/mediaplayer</a></p><p>获取 MediaPlayer 实例就可以控制音频播放了。</p><pre><code class="Java">mediaPlayer.prepare(); // 开始播放前准备工作mediaPlayer.start(); // 开始播放mediaPlayer.pause(); // 暂停播放mediaPlayer.reset(); // 停止播放mediaPlayer.seekTo(); // 指定位置播放mediaPlayer.stop(); // 停止播放，后面不能再播放音频mediaPlayer.release(); // 释放相关资源</code></pre><p>2、播放视频</p><p>播放视频主要使用 <a href="https://developer.android.com/reference/android/widget/VideoView" rel="external nofollow noopener noreferrer" target="_blank">VideoView</a> 控件。</p><p>使用 setVideoPath (String path) 或者 setVideoURI (Uri uri) 设置视频资源。</p><p>然后就可以使用相应方法控制播放了.</p><pre><code class="Java">videoView.start(); // 开始播放videoView.pause(); // 暂停播放videoView.resume(); // 重头开始播放videoView.seekTo(); // 指定位置播放</code></pre><p>对于音频视频播放还有官方框架 ExoPlayer ：</p><p><a href="https://github.com/google/ExoPlayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/google/ExoPlayer</a></p><blockquote><p>参考资料<br>1、Android O: How to Use Notification Channels - Your Web App<br><a href="http://forum.yourwebapp.mobi/android-o-how-to-use-notification-channels/" rel="external nofollow noopener noreferrer" target="_blank">http://forum.yourwebapp.mobi/android-o-how-to-use-notification-channels/</a><br>2、Android O 8.0系统下通知(Notification)、安装apk问题更新后的简单兼容写法 - CSDN博客<br><a href="https://blog.csdn.net/weitao_666/article/details/79142592" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/weitao_666/article/details/79142592</a><br>3、Audio &amp; Video | Android Developers<br><a href="https://developer.android.com/guide/topics/media/" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/media/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 多媒体资源&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href=&quot;https://www.ws
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（六）</title>
    <link href="https://www.wshunli.com/posts/461ff372.html"/>
    <id>https://www.wshunli.com/posts/461ff372.html</id>
    <published>2018-06-03T13:54:38.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 数据存储方案</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第6章-数据存储全方案"><a href="#第6章-数据存储全方案" class="headerlink" title="第6章 数据存储全方案"></a>第6章 数据存储全方案</h1><p>Android 系统中主要提供了 3 种方式：文件存储、SharedPreference 以及数据库存储。</p><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>对于文件存储，Android 系统不对数据进行格式化处理，适合一些简单的文本数据或者二进制数据。</p><p>1、将数据保存到文件中</p><pre><code class="Java">String FILENAME = &quot;hello_file&quot;;String string = &quot;hello world!&quot;;FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);fos.write(string.getBytes());fos.close();// 异常捕捉 ==&gt;FileOutputStream fos = null;try {    fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);    fos.write(string.getBytes());} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}finally {    try {        if (fos != null) {            fos.close();        }    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>书上是这样写的，主要为了提高性能：</p><pre><code class="Java">String FILENAME = &quot;hello_file&quot;;String string = &quot;hello world!&quot;;FileOutputStream fileOutputStream;BufferedWriter writer = null;try {    fileOutputStream = openFileOutput(FILENAME, Context.MODE_PRIVATE);    writer = new BufferedWriter(new OutputStreamWriter(fileOutputStream));    writer.write(string);} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (writer != null) {            writer.close();        }    } catch (IOException e) {        e.printStackTrace();    }</code></pre><p>其中 MODE_PRIVATE 表示新创建文件，已经存在的文件会覆盖掉；<br>如果使用 MODE_APPEND 表示向存在的文件中追加内容，如果文件不存在会新建。</p><p>还有 MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE 已经过时了。</p><p>2、从文件中读取数据</p><pre><code class="Java">int SIZE = 4096;byte[] buf = new byte[SIZE];FileInputStream fis = null;try {    fis = openFileInput(FILENAME);    int len = fis.read(buf);    while (len != -1) {        System.out.println(new String(buf, 0, len));    }} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (fis != null) {            fis.close();        }    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>书上是这样写的，也是为了提高性能：</p><pre><code class="Java">FileInputStream fileInputStream;BufferedReader reader = null;StringBuilder content = new StringBuilder();try {    fileInputStream = openFileInput(FILENAME);    reader = new BufferedReader(new InputStreamReader(fileInputStream));    String line;    while ((line = reader.readLine() )!= null) {        content.append(line);    }} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (reader != null) {            reader.close();        }    } catch (IOException e) {        e.printStackTrace();    }}System.out.println(content.toString());</code></pre><p>3、Android 系统数据存储位置</p><p>对于 Android 设备可分为 内部存储 和 外部存储。</p><p>3.1、<strong>内部存储</strong></p><p>内部存储默认应用私有，其他 <strong>应用（和用户）</strong> 不能访问这些文件。卸载应用系统会自动删除。</p><p>应用的内部存储空间一般会有 files 和 cache 两个文件夹，分别代表永久存储和缓存数据。</p><p><code>File Context.getFilesDir()</code> 方法 /data/user/0/com.wshunli.store.demo/files</p><p><code>File Context.getCacheDir()</code> 方法 /data/user/0/com.wshunli.store.demo/cache</p><p>其中 0 代表不同用户，Android 6.0 以前不存在。</p><p>文件在 /data/data/com.wshunli.store.demo/ 目录下可以看到。</p><p>3.2、<strong>外部存储</strong></p><p>外部存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储，用户可以删除。</p><p>使用外部存储前应 <strong>检查介质可用性</strong> ：</p><pre><code class="Java">/* Checks if external storage is available for read and write */public boolean isExternalStorageWritable() {    String state = Environment.getExternalStorageState();    if (Environment.MEDIA_MOUNTED.equals(state)) {        return true;    }    return false;}/* Checks if external storage is available to at least read */public boolean isExternalStorageReadable() {    String state = Environment.getExternalStorageState();    if (Environment.MEDIA_MOUNTED.equals(state) ||        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {        return true;    }    return false;}</code></pre><p>这部分比较特殊，也可以分为两种，<strong>可以保存与其他应用共享的文件，也可以保存应用私有文件</strong>（类似于内部存储）。</p><p>（1）对于外部存储的 <strong>私有</strong> 文件夹，一般也会有 files 和 cache 两个文件夹，4.4 及以后读写不再需要权限。</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;                     android:maxSdkVersion=&quot;18&quot; /&gt;</code></pre><p>访问私有文件夹主要有两种方法：</p><p><code>File Context.getExternalFilesDir()</code> 方法 /storage/emulated/0/Android/data/com.wshunli.store.demo/files</p><p><code>File Context.getExternalCacheDir()</code> 方法 /storage/emulated/0/Android/data/com.wshunli.store.demo/cache</p><p>其中 <a href="https://developer.android.com/reference/android/content/Context#getExternalFilesDir" rel="external nofollow noopener noreferrer" target="_blank">getExternalFilesDir()</a> 方法需要传入目录类型。传入 <code>null</code> 表示获取根目录。</p><p><strong>目录类型</strong> 包括以下几种: DIRECTORY_MUSIC, DIRECTORY_PODCASTS, DIRECTORY_RINGTONES, DIRECTORY_ALARMS, DIRECTORY_NOTIFICATIONS, DIRECTORY_PICTURES, DIRECTORY_MOVIES.<br><a href="https://developer.android.com/reference/android/os/Environment#DIRECTORY_MUSIC" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/reference/android/os/Environment#DIRECTORY_MUSIC</a></p><p>有时，已分配某个内部存储器 <strong>分区</strong> 用作外部存储的设备可能还提供了 SD 卡槽。</p><p>在 Android 4.3 以前 Context.getExternalFilesDir() 只能获取内部分区的访问权限；<br>从 Android 4.4 开始 Context.getExternalFilesDirs() 可以同时访问两个位置，及内部分区和 SD 卡。</p><p>对于 Android 4.3 或者更低版本使用 <a href="https://developer.android.com/reference/android/support/v4/content/ContextCompat#getexternalfilesdirs" rel="external nofollow noopener noreferrer" target="_blank">ContextCompat.getExternalFilesDirs()</a> 方法有同样的效果，可以同时访问两个位置。</p><p>（2）对于外部存储的 <strong>共享</strong> 文件夹，必须申请读写权限，而且 6.0 以后要申请运行时权限。</p><p><code>Environment.getExternalStorageDirectory()</code> 方法返回值 /storage/emulated/0</p><p>Android 7.0 提供简化的 API 来访问常见的外部存储目录。<br><a href="https://developer.android.com/training/articles/scoped-directory-access" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/training/articles/scoped-directory-access</a></p><p><code>Environment.getExternalStoragePublicDirectory()</code> 返回设备上的 “公共” 位置。</p><p>同样需要传入目录类型，例如：</p><pre><code class="Java">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);</code></pre><p>返回相机文件所在目录 /storage/emulated/0/DCIM</p><p>在外部文件目录中包含名为 <code>.nomedia</code> 的空文件（注意文件名中的点前缀），可在媒体扫描程序中隐藏文件。</p><p>4、应用安装包内文件数据访问</p><p>安装包内数据文件有很多种，这里主要介绍两部分：<strong>assets</strong> 和 <strong>raw</strong> 。</p><p>这两部分都会原封不动地打包进 apk 安装包，并不会编译成 二进制文件。</p><p><code>assets</code> 文件夹在 <code>app/src/main/assets/</code> 允许创建目录结构。</p><pre><code class="Java">AssetManager assetManager = getResources().getAssets();assetManager.open(FILENAME);</code></pre><p><code>raw</code> 文件夹在 <code>app/src/main/res/raw/</code> 不允许创建目录结构，但会在 R.java 中自动进行资源标识。</p><pre><code class="Java">InputStream inputStream = getResources().openRawResource(R.id.data);</code></pre><h2 id="SharedPreferences-存储"><a href="#SharedPreferences-存储" class="headerlink" title="SharedPreferences 存储"></a>SharedPreferences 存储</h2><p><a href="https://developer.android.com/reference/android/content/SharedPreferences" rel="external nofollow noopener noreferrer" target="_blank">SharedPreferences</a> 主要用于保存检索原始数据类型的永久性键值对。</p><p>1、使用 SharedPreferences 存储数据首先应 <strong>获取</strong> SharedPreferences 对象，主要有三种方法：</p><p>（1）Context 类中 的 getSharedPreferences 方法，按照文件名称识别 preferences 。</p><p>SharedPreferences getSharedPreferences (String name, int mode)</p><pre><code class="Java">SharedPreferences sharedPreferences = getSharedPreferences(PREFS_NAME, MODE_PRIVATE);</code></pre><p>其中 PREFS_NAME 表示 preferences 文件名称，在 /data/data/com.wshunli.store.demo/shared_prefs/ 路径下 。</p><p>MODE_PRIVATE 表示操作模式，目前只有这一种模式可选，其他 MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE , MODE_MULTI_PROCESS 已经废弃。</p><p>（2）Activity 类中的 getPreferences 方法，按照 Activity 识别 preferencs ，仅用于本 Activity 。</p><p>SharedPreferences getPreferences (int mode)</p><pre><code class="Java">SharedPreferences preferences = getPreferences(MODE_PRIVATE);</code></pre><p>仅指定 操作模式 即可。</p><p>（3）PreferenceManager 类中的 getDefaultSharedPreferences 静态方法，以应用包名作为前缀识别。</p><p>SharedPreferences getDefaultSharedPreferences (Context context)</p><pre><code class="Java">SharedPreferences defaultSharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);</code></pre><p>2、获取 SharedPreferences 对象后就可以 <strong>存储和检索</strong> 数据了。</p><p>对于 <strong>数据存储</strong> 需要使用 <a href="https://developer.android.com/reference/android/content/SharedPreferences.Editor" rel="external nofollow noopener noreferrer" target="_blank">SharedPreferences.Editor</a> 接口。</p><pre><code class="Java">public static final String PREFS_NAME = &quot;wshunli&quot;;SharedPreferences sharedPreferences = getSharedPreferences(PREFS_NAME, MODE_PRIVATE);SharedPreferences.Editor editor = sharedPreferences.edit();editor.putString(&quot;website&quot;, &quot;wshunli.com&quot;);editor.putBoolean(&quot;is&quot;, true);editor.apply();</code></pre><p>我们可以在 shared_prefs 文件夹下发现 <code>wshunli.xml</code> 文件：</p><pre><code class="XML">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt;&lt;map&gt;    &lt;string name=&quot;website&quot;&gt;wshunli.com&lt;/string&gt;    &lt;boolean name=&quot;is&quot; value=&quot;true&quot; /&gt;&lt;/map&gt;</code></pre><p>前面三种方式在 xml 文件命名不太一样，内容是一样的：</p><p>/data/data/com.wshunli.store.demo/shared_prefs/<code>wshunli.xml</code><br>/data/data/com.wshunli.store.demo/shared_prefs/<code>SPActivity.xml</code><br>/data/data/com.wshunli.store.demo/shared_prefs/<code>com.wshunli.store.demo_preferences.xml</code></p><p>SharedPreferences.Editor 提交数据有两种方法，apply() 和 commit() ，两者主要区别有两点：</p><p>(1) commit() 有返回值，apply() 没有返回值。apply() 失败了是不会报错的。<br>(2) apply() 写入文件的操作是 <strong>异步</strong> 的，会把 Runnable 放到线程池中执行，而 commit() 的写入文件的操作是在当前线程 <strong>同步</strong> 执行的。</p><p>因此当两者都可以使用的时候还是推荐使用 apply() ，因为 apply() 写入文件操作是异步执行的，不会占用主线程资源。</p><p>3、从 SharedPreferences 中读取数据</p><p>直接使用 SharedPreferences 对象实例方法即可。</p><p>String getString (String key, String defValue)</p><pre><code class="Java">String website = sharedPreferences.getString(&quot;website&quot;, &quot;&quot;);</code></pre><p>其他方法还有：<br>Map&lt;String, ?&gt; getAll () // 获取所有键值对<br>boolean contains (String key) // 是否包含某键值数据</p><h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><p>Android 提供了对 SQLite 数据库的完全支持。</p><p>也有很多其他数据库可以使用，比如 Realm 、ObjectBox 等等。<br>一些数据库 ORM 框架也要学习，比如 GreenDao 、LitePal 等等。</p><p>这里只介绍 SQLite 数据库。</p><p>1、创建数据库</p><p>在 Android 中操纵 SQLite 数据库可以使用 SQLiteOpenHelper 类。</p><pre><code class="Java">public class MSQLiteOpenHelper extends SQLiteOpenHelper {    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {        this(context, name, factory, version, null);    }    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) {        super(context, name, factory, version, errorHandler);    }    @Override    public void onCreate(SQLiteDatabase db) {    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}</code></pre><p>其中构造函数：context 即上下文；name 为数据库名称；factory 为自定义 Cursor ，一般传入 null ；version 为数据库版本号，用于数据库升级。</p><p>然后调用 SQLiteOpenHelper 对象实例的 getReadableDatabase() 或者 getWritableDatabase() 即可创建数据库。</p><pre><code class="Java">MSQLiteOpenHelper dbHelper = new MSQLiteOpenHelper(this, &quot;book.db&quot;, null, 1);dbHelper.getWritableDatabase();</code></pre><p>数据库文件存储位置：/data/data/com.wshunli.sqlite.demo/databases/book.db</p><p>2、添加表结构</p><p>前面只是创建了空数据库，下面添加表。</p><p>使用 SQLiteDatabase 对象的 execSQL(String sql) 方法。</p><pre><code class="Java">public class MSQLiteOpenHelper extends SQLiteOpenHelper {    public static final String CREATE_BOOK = &quot;create table Book (&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;author text, &quot;            + &quot;price real, &quot;            + &quot;pages integer, &quot;            + &quot;name text)&quot;;    private Context context;    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {        this(context, name, factory, version,null);    }    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) {        super(context, name, factory, version, errorHandler);        this.context = context;    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK);        Toast.makeText(context, &quot;数据写入成功&quot;, Toast.LENGTH_LONG).show();    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}  </code></pre><p>3、升级数据库</p><p>在添加数据库表时，非常有用。其实就是实现 onUpgrade 方法。</p><pre><code class="Java">public class MSQLiteOpenHelper extends SQLiteOpenHelper {    public static final String CREATE_BOOK = &quot;create table Book (&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;author text, &quot;            + &quot;price real, &quot;            + &quot;pages integer, &quot;            + &quot;name text)&quot;;    public static final String CREATE_CATEGORY = &quot;create table Category (&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;category_name text, &quot;            + &quot;category_code integer)&quot;;    private Context context;    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {        this(context, name, factory, version,null);    }    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) {        super(context, name, factory, version, errorHandler);        this.context = context;    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK);        db.execSQL(CREATE_CATEGORY);        Toast.makeText(context, &quot;数据写入成功&quot;, Toast.LENGTH_LONG).show();    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {        db.execSQL(&quot;drop table if exists Book&quot;);        db.execSQL(&quot;drop table if exists Category&quot;);        onCreate(db);    }}</code></pre><p>这时我们在构造函数中 版本号大于 1 即可。</p><pre><code class="Java">dbHelper = new MSQLiteOpenHelper(this, &quot;book.db&quot;, null, 2);</code></pre><p>如果在 onCreate 方法里直接添加 <code>db.execSQL(CREATE_CATEGORY);</code> 语句是不会执行的。</p><p>4、添加数据</p><p>对数据库的操作无非就是 CRUD ：C 添加、R 查询、U 更新、D 删除。</p><p>添加数据使用 SQLiteDatabase 对象的 insert 方法。</p><p>long insert(String table, String nullColumnHack, ContentValues values)</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();// 开始组装第一条数据values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 454);values.put(&quot;price&quot;, 16.96);db.insert(&quot;Book&quot;, null, values); // 插入第一条数据values.clear();// 开始组装第二条数据values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 510);values.put(&quot;price&quot;, 19.95);db.insert(&quot;Book&quot;, null, values); // 插入第二条数据</code></pre><p>其中第二个参数 nullColumnHack 用于未指定添加数据的情形，一般直接传入 null 即可。</p><p>5、更新数据</p><p>更新数据使用 SQLiteDatabase 对象的 update 方法。</p><p>int update(String table, ContentValues values, String whereClause, String[] whereArgs)</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put(&quot;price&quot;, 10.99);db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[] { &quot;The Da Vinci Code&quot; });</code></pre><p>其中 whereClause 、 whereArgs 用于约束数据第几行或者某几行，不指定则更新所有行。</p><p>6、删除数据</p><p>删除数据使用 SQLiteDatabase 对象的 delete 方法。</p><p>int delete(String table, String whereClause, String[] whereArgs)</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[] { &quot;500&quot; });</code></pre><p>其中 whereClause 、 whereArgs 用于约束数据第几行或者某几行，不指定则删除所有行。</p><p>7、查询数据</p><p>查询数据使用 SQLiteDatabase 对象的 query 方法。</p><pre><code class="Java">Cursor query(String table, String[] columns, // 指定表名、列名             String selection, String[] selectionArgs,              String groupBy, String having,              String orderBy)</code></pre><p>其中 selection 、 selectionArgs 用于约束数据第几行或者某几行，不指定则查询所有行。<br>然后 groupBy 指定 group by 的列，having 对 group by 结果进一步约束。<br>最后 orderBy 指定排序方式。</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();// 查询Book表中所有的数据Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null);if (cursor.moveToFirst()) {    do {        // 遍历Cursor对象，取出数据并打印        String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));        String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;));        int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));        double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));        Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name);        Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author);        Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages);        Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price);    } while (cursor.moveToNext());}cursor.close();</code></pre><p>8、使用 SQL 语句操纵数据库</p><p>使用 SQLiteDatabase 对象的 execSQL 方法，还是挺麻烦的，可以使用一些 ORM 框架。</p><blockquote><p>参考资料<br>1、存储选项 | Android Developers<br><a href="https://developer.android.com/guide/topics/data/data-storage" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/data/data-storage</a><br>2、FileInputStream读取文件数据的两种方式 - CSDN博客<br><a href="https://blog.csdn.net/a909301740/article/details/52574602" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a909301740/article/details/52574602</a><br>3、全面的Android文件目录解析和获取方法(包含对6.0系统的说明) - CSDN博客<br><a href="https://blog.csdn.net/zhangbuzhangbu/article/details/23257873" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhangbuzhangbu/article/details/23257873</a><br>4、android 目录/data/data/ 跟 /data/user/0/ 差别 - V2EX<br><a href="https://www.v2ex.com/t/259080" rel="external nofollow noopener noreferrer" target="_blank">https://www.v2ex.com/t/259080</a><br>5、提供资源 | Android Developers<br><a href="https://developer.android.com/guide/topics/resources/providing-resources" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/resources/providing-resources</a><br>6、Android数据存储之Assets、Raw - CSDN博客<br><a href="https://blog.csdn.net/sjm19901003/article/details/47026503" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/sjm19901003/article/details/47026503</a><br>7、SharePreferences源码分析（commit与apply的区别以及原理） - CSDN博客<br><a href="https://blog.csdn.net/Double2hao/article/details/53871640" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/Double2hao/article/details/53871640</a><br>8、Room，Realm,，ObjectBox 你选择哪个？ - 泡在网上的日子<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0926/8551.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0926/8551.html</a><br>9、【Android 数据库框架总结，总有一个适合你！】 - CSDN博客<br><a href="https://blog.csdn.net/da_caoyuan/article/details/61414626" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/da_caoyuan/article/details/61414626</a><br>10、android基础—-&gt;SQLite数据库的使用 - huhx - 博客园<br><a href="http://www.cnblogs.com/huhx/p/sqliteDatabase.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/huhx/p/sqliteDatabase.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 数据存储方案&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href=&quot;https://www.w
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（五）</title>
    <link href="https://www.wshunli.com/posts/2311b8ab.html"/>
    <id>https://www.wshunli.com/posts/2311b8ab.html</id>
    <published>2018-06-03T06:20:42.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 ContentProvider</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第7章-跨程序共享数据"><a href="#第7章-跨程序共享数据" class="headerlink" title="第7章 跨程序共享数据"></a>第7章 跨程序共享数据</h1><p>ContentProvider 主要用于不同程序之间实现数据共享的功能，同时保证被访问数据的安全。</p><p>目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。</p><p>ContentProvider 有两种用法，一是访问其他程序中的数据，另一种是创建自己的 ContentProvider 让其他程序访问。</p><h2 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h2><p>对于应用程序来说，访问内容提供器中共享的数据，要借助 ContentResolver 类，可以通过 Context 中的 getContentResolver() 方法获取该类的实例。</p><p>可以借助以下方法对共享的数据进行 CRUD 操作：</p><pre><code class="Java">Cursor query(@NonNull Uri uri,             @Nullable String[] projection,             @Nullable String selection,             @Nullable String[] selectionArgs,             @Nullable String sortOrder)</code></pre><pre><code class="Java">Uri insert(@NonNull Uri url,           @Nullable ContentValues values)</code></pre><pre><code class="Java">int update(@NonNull Uri uri,           @Nullable ContentValues values,           @Nullable String where,           @Nullable String[] selectionArgs)</code></pre><pre><code class="Java">int delete(@NonNull Uri url,           @Nullable String where,           @Nullable String[] selectionArgs)</code></pre><p>查询联系人示例：</p><pre><code class="Java">Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);if (cursor != null) {    while (cursor.moveToNext()) {        String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));        String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));        Log.d(TAG, name + &quot;: &quot; + number);    }    cursor.close();}</code></pre><h2 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h2><p>新建一个类继承 ContentProvider 即可创建自己的内容提供器。</p><pre><code class="Java">public class MContentProvider extends ContentProvider {    private static final int TABLE_DIR = 0;    private static final int TABLE_ITEM = 1;    private static UriMatcher uriMatcher;    static {        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(&quot;com.wshunli.provider.demo&quot;, &quot;table1&quot;, TABLE_DIR);        uriMatcher.addURI(&quot;com.wshunli.provider.demo&quot;, &quot;table1/#&quot;, TABLE_ITEM);    }    // 初始化内容提供器时调用。    @Override    public boolean onCreate() {        return false;    }    @Nullable    @Override    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {        switch (uriMatcher.match(uri)) {            case TABLE_DIR:                // 查询 table1 表中的所有数据                break;            case TABLE_ITEM:                // 查询 table1 表中的单挑数据                break;        }        return null;    }    // 根据传入的 URI 返回相应的 MIME 类型。    @Nullable    @Override    public String getType(@NonNull Uri uri) {        switch (uriMatcher.match(uri)) {            case TABLE_DIR:                return &quot;vnd.android.cursor.dir/vnd.com.wshunli.provider.demo.table1&quot;;            case TABLE_ITEM:                return &quot;vnd.android.cursor.item/vnd.com.wshunli.provider.demo.table1&quot;;        }        return null;    }    @Nullable    @Override    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {        return null;    }    @Override    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {        return 0;    }    @Override    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {        return 0;    }}</code></pre><p>对于 URI 有两种，一种是以路径结尾表示期望访问表中所有数据：</p><p><code>content://com.wshunli.provider.demo/table</code></p><p>另一种以 id 结尾表示期望访问该表中拥有相应 id 的数据：</p><p><code>content://com.wshunli.provider.demo/table/1</code></p><p>1、对于 UriMatcher 匹配 URI</p><p><code>*</code> 表示任意长度的字符，<code>#</code> 表示任意长度的数字。</p><p>2、对于返回 MIME 类型，分别使用</p><p>表示单行数据：<code>android.cursor.item/</code></p><p>表示多行数据：<code>android.cursor.dir/</code></p><p>其他 insert 、 delete 、 update 方法类似。</p><h2 id="实现跨程序数据共享"><a href="#实现跨程序数据共享" class="headerlink" title="实现跨程序数据共享"></a>实现跨程序数据共享</h2><p>首先实现自己的 ContentProvider ：</p><pre><code class="Java">public class DatabaseProvider extends ContentProvider {    public static final int BOOK_DIR = 0;    public static final int BOOK_ITEM = 1;    public static final int CATEGORY_DIR = 2;    public static final int CATEGORY_ITEM = 3;    public static final String AUTHORITY = &quot;com.wshunli.provider&quot;;    private static UriMatcher uriMatcher;    private MyDatabaseHelper dbHelper;    static {        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR);        uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM);        uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR);        uriMatcher.addURI(AUTHORITY, &quot;category/#&quot;, CATEGORY_ITEM);    }    @Override    public boolean onCreate() {        dbHelper = new MyDatabaseHelper(getContext(), &quot;BookStore.db&quot;, null, 2);        return true;    }    @Override    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {        // 查询数据        SQLiteDatabase db = dbHelper.getReadableDatabase();        Cursor cursor = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                cursor = db.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] { bookId }, null, null, sortOrder);                break;            case CATEGORY_DIR:                cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                cursor = db.query(&quot;Category&quot;, projection, &quot;id = ?&quot;, new String[] { categoryId }, null, null, sortOrder);                break;            default:                break;        }        return cursor;    }    @Override    public Uri insert(Uri uri, ContentValues values) {        // 添加数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        Uri uriReturn = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:            case BOOK_ITEM:                long newBookId = db.insert(&quot;Book&quot;, null, values);                uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId);                break;            case CATEGORY_DIR:            case CATEGORY_ITEM:                long newCategoryId = db.insert(&quot;Category&quot;, null, values);                uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/category/&quot; + newCategoryId);                break;            default:                break;        }        return uriReturn;    }    @Override    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {        // 更新数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int updatedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                updatedRows = db.update(&quot;Book&quot;, values, selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                updatedRows = db.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] { bookId });                break;            case CATEGORY_DIR:                updatedRows = db.update(&quot;Category&quot;, values, selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                updatedRows = db.update(&quot;Category&quot;, values, &quot;id = ?&quot;, new String[] { categoryId });                break;            default:                break;        }        return updatedRows;    }    @Override    public int delete(Uri uri, String selection, String[] selectionArgs) {        // 删除数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int deletedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                deletedRows = db.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] { bookId });                break;            case CATEGORY_DIR:                deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                deletedRows = db.delete(&quot;Category&quot;, &quot;id = ?&quot;, new String[] { categoryId });                break;            default:                break;        }        return deletedRows;    }    @Override    public String getType(Uri uri) {        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                return &quot;vnd.android.cursor.dir/vnd.com.wshunli.provider.book&quot;;            case BOOK_ITEM:                return &quot;vnd.android.cursor.item/vnd.com.wshunli.provider.book&quot;;            case CATEGORY_DIR:                return &quot;vnd.android.cursor.dir/vnd.com.wshunli.provider.category&quot;;            case CATEGORY_ITEM:                return &quot;vnd.android.cursor.item/vnd.com.wshunli.provider.category&quot;;        }        return null;    }}</code></pre><p>注意 ContentProvider 需要在 Manifest 中声明才能使用。</p><pre><code class="XML">&lt;provider    android:name=&quot;.MContentProvider&quot;    android:authorities=&quot;com.wshunli.provider.demo&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot; /&gt;</code></pre><p>然后就是访问 ContentProvider 了：</p><pre><code class="Java">private String newId;// 添加数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book&quot;);ContentValues values = new ContentValues();values.put(&quot;name&quot;, &quot;A Clash of Kings&quot;);values.put(&quot;author&quot;, &quot;George Martin&quot;);values.put(&quot;pages&quot;, 1040);values.put(&quot;price&quot;, 55.55);Uri newUri = getContentResolver().insert(uri, values);newId = newUri.getPathSegments().get(1);// 查询数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book&quot;);Cursor cursor = getContentResolver().query(uri, null, null, null, null);if (cursor != null) {    while (cursor.moveToNext()) {        String name = cursor.getString(cursor. getColumnIndex(&quot;name&quot;));        String author = cursor.getString(cursor. getColumnIndex(&quot;author&quot;));        int pages = cursor.getInt(cursor.getColumnIndex (&quot;pages&quot;));        double price = cursor.getDouble(cursor. getColumnIndex(&quot;price&quot;));        Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name);        Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author);        Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages);        Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price);    }    cursor.close();}// 更新数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book/&quot; + newId);ContentValues values = new ContentValues();values.put(&quot;name&quot;, &quot;A Storm of Swords&quot;);values.put(&quot;pages&quot;, 1216);values.put(&quot;price&quot;, 24.05);getContentResolver().update(uri, values, null, null);// 删除数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book/&quot; + newId);getContentResolver().delete(uri, null, null);</code></pre><p>也就是将前面的内容结合起来。</p><blockquote><p>参考资料<br>1、ContentProvider | Android Developers<br><a href="https://developer.android.com/guide/topics/providers/content-providers" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/providers/content-providers</a><br>2、Android深入四大组件（五）Content Provider的启动过程 | 刘望舒的博客<br><a href="http://liuwangshu.cn/framework/component/5-contentprovider-start.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/framework/component/5-contentprovider-start.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 ContentProvider&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>安利两款数据备份与无损分区软件</title>
    <link href="https://www.wshunli.com/posts/89531c6c.html"/>
    <id>https://www.wshunli.com/posts/89531c6c.html</id>
    <published>2018-06-01T13:24:45.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用软件前，请确认您熟悉数据备份及无损分区，理解执行每项操作的含义及后果，数据无价，谨慎操作</strong>。</p><p>机房电脑硬盘出问题了，换个新硬盘，没想到台式机的硬盘那么便宜，1T 机械硬盘还不到三百。</p><p>安利的两款软件叫 <strong>傲梅分区助手</strong> 和 <strong>傲梅轻松备份</strong> ，都是免费的。</p><p>机房电脑有两块硬盘，250G 固态硬盘装系统和软件，多余的空间还能存一些数据。</p><p>以前笔记本的 SSD 坏过一次，卖家保修期内免费换新，但是数据还没法恢复。从那以后就有系统数据备份的习惯，再者重要的代码都上传到 GitHub 私有仓库了，所以 SSD 这部分倒不是很担心。</p><p>另一块是这次出问题的机械硬盘，只是作为 QQ 和网易云音乐的缓存，系统运行状态下读写还是比较小的。</p><p>一直以来这个硬盘噪声都挺大的，但是最近磁盘活动时间总是 100% ，经常引起系统卡顿崩溃，前两天检测下硬盘已经有不少坏道了，这部分没有备份所以比较害怕，赶紧申请换块硬盘。</p><p>以上是背景，下面介绍 <strong>整个数据备份及恢复的过程</strong> 。</p><p><strong>复制粘贴</strong>：</p><p>硬盘出问题了，最重要的还是想法设法备份数据。下面是新买的硬盘。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/新硬盘.png" alt="新硬盘"></p><p>最开始直接使用拷贝的方式，也就是把硬盘里的数据 <strong>复制粘贴</strong> 到移动硬盘或者新硬盘。</p><p>但是我在拷贝的过程中系统未响应直接蓝屏了，开机后系统不识别，机械硬盘丢失，当时有点伤心了。<br>还好重启电脑后硬盘又出现，至今也不知道具体原因。</p><p>然后就是再次尝试，打开 DiskGenius 软件提示，分区表 CRC 错误。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/分区表错误.png" alt="分区表错误"></p><p>上次打开就有这个提示，我没有管，这次手贱点了一下，然后又对新硬盘分区。</p><p>在对新硬盘进行分区的过程中，系统蓝屏，然后循环自动修复进不去系统了。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/自动修复.png" alt="自动修复"></p><p>中间也试了不少方法，修复分区表啊，尝试修复了都不行，有点崩溃。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/自动修复日志.png" alt="自动修复日志"></p><p>上面这么折腾已经花费一天了。</p><p><strong>数据备份</strong>：</p><p>感觉系统修复无望后，晚上制作 PE ，使用 PE 安装 轻松备份 。</p><p>还是想先备份硬盘，包括 SSD 和机械硬盘。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/轻松备份-备份.png" alt="轻松备份-备份"></p><p>这时候已经不能使用系统备份了，只能使用磁盘备份或者分区备份。</p><p>整个过程很顺畅，SSD 备份在 150M+ ，机械硬盘在 30M+ ，机械硬盘明显不太行了。</p><p><strong>数据恢复</strong>：</p><p>以前笔记本和机房的系统都备份过，这次就想干脆用笔记本的系统算了。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/轻松备份-还原.png" alt="轻松备份-还原"></p><p>首先把笔记本备份的系统还原到机房电脑，然后进入系统逐个还原其他分区。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/数据备份恢复.png" alt="数据备份恢复"></p><p>最终以前笔记本的 C D 盘不变，把原来台式机 D 盘放到 E 盘。</p><p><strong>分区调整</strong>：</p><p>分区还原之后大小不是很理想，可以使用分区助手调整。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/分区操作.png" alt="分区操作"></p><p>调整分区大小，合并下分区的数据等等。</p><p><strong>满血复活</strong>：</p><p>这是还原完成后，系统界面（模糊处理），莫名感动，熟悉的界面失而复得很神奇：</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/ok.png" alt="ok"></p><p><strong>分区助手</strong> 和 <strong>轻松备份</strong> 是 <a href="https://www.disktool.cn/about-us.html" rel="external nofollow noopener noreferrer" target="_blank">成都傲梅科技有限公司</a> 两款免费软件，很优秀。</p><p><strong>傲梅分区助手（ <a href="https://www.disktool.cn/feature.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.disktool.cn/feature.html</a> )</strong> 是一个简单易用且免费的无损分区软件，作为无损分区的领导者，在它的帮助下，您可以无损数据地执行调整分区大小，移动分区位置，复制分区，快速分区，复制磁盘，合并分区，切割分区、恢复分区、迁移操作系统等操作。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/分区助手.png" alt="分区助手"></p><p><strong>轻松备份专业版（ <a href="https://www.disktool.cn/backup/backup-software.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.disktool.cn/backup/backup-software.html</a> ）</strong> 是一款免费的、简单易用的备份还原软件，不仅能轻松地 Ghost 系统实现系统备份，还能备份文件、文件夹、硬盘、分区，也能通过定时备份功能自动备份您想备份的数据和实时同步功能同步文件、文件夹到其他位置。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/轻松备份.png" alt="轻松备份"></p><p><strong>成都傲梅科技有限公司</strong>是一家致力于备份还原与磁盘分区软件产品开发的软件公司，从 2009 年底发布第一款产品以来就一直在这块领土上耕耘着，在基于文件系统与磁盘分区管理的产品开发方面积累了丰富的经验，同时也在备份还原上拥有核心的技术实力。</p><blockquote><p>整个过程折腾了两天，还有些软件版本需要升级，不过相比较重新安装那么多软件，配置环境已经快很多了。<br>主要时间还是花费在数据读写上了，至少 800G+ 的数据读写，明显机械硬盘读写太慢了。<br>以后不清楚的操作还是谨慎点，手残乱点容易出岔子。</p></blockquote><p><strong>数据无价，谨慎操作。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用软件前，请确认您熟悉数据备份及无损分区，理解执行每项操作的含义及后果，数据无价，谨慎操作&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;机房电脑硬盘出问题了，换个新硬盘，没想到台式机的硬盘那么便宜，1T 机械硬盘还不到三百。&lt;/p&gt;&lt;p&gt;安利的两款软件叫 &lt;stron
      
    
    </summary>
    
      <category term="瞎推荐" scheme="https://www.wshunli.com/categories/%E7%9E%8E%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="数据备份" scheme="https://www.wshunli.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    
      <category term="无损分区" scheme="https://www.wshunli.com/tags/%E6%97%A0%E6%8D%9F%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin for Android（一）Hello Kotlin !</title>
    <link href="https://www.wshunli.com/posts/591ca4ea.html"/>
    <id>https://www.wshunli.com/posts/591ca4ea.html</id>
    <published>2018-05-29T13:04:28.000Z</published>
    <updated>2018-06-19T12:01:39.069Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 是用于现代多平台应用的静态编程语言，与 Java™ 和 Android™ 100% 可互操作。</p><p>2017 年 5 月，Google 年度 I/O 大会上，宣布把 Kotlin 作为 Android 开发的首选语言。</p><p>今年 2018 Google I/O 大会上，示例 App 已经全部采用 Kotlin 编写了。</p><p>前面也一直想涉猎 Kotlin 方面的东西，但是一直没有时间，主要还是懒。。</p><p><strong>维基百科关于 Kotlin 的介绍</strong>：</p><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，它也可以被编译成为 JavaScript 源代码。它主要是由俄罗斯圣彼得堡的 JetBrains 开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。</p><p>2011年7月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。</p><p>JetBrains 负责人 Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外。但是，他指出了 Scala 的编译时间慢这一明显缺陷。<br>Kotlin 的既定目标之一是像 Java 一样快速编译。</p><p>2012年2月，JetBrains 以 Apache 2 许可证开源此项目。Jetbrains希望这个新语言能够推动IntelliJ IDEA的销售。</p><p>Kotlin v1.0 于 2016年2月15日 发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。</p><p><strong>官方及其中文网站</strong>：</p><p>Kotlin Programming Language:<br><a href="http://kotlinlang.org/" rel="external nofollow noopener noreferrer" target="_blank">http://kotlinlang.org/</a></p><p>Kotlin 语言中文站:<br><a href="https://www.kotlincn.net/" rel="external nofollow noopener noreferrer" target="_blank">https://www.kotlincn.net/</a></p><p>1、环境配置</p><p>Kotlin 是一种运行在 JVM 上的编程语言，所以和 Java 环境配置是一样的，这里就不多介绍了。</p><p>2、IntelliJ IDEA</p><p>Kotlin 是 JetBrains 推出的，我们就用大名鼎鼎的 IntelliJ IDEA 就好了。</p><p>3、Hello Kotlin !</p><p>我们在IDE 中新建项目，并写一个 HelloWorld 类：</p><p><img src="https://img.wshunli.com/Kotlin/kotlin-android/1.Hello.png" alt="Hello Kotlin"></p><p>和 Java 还是非常像的，学过 Java 的应该一下就能看懂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kotlin 是用于现代多平台应用的静态编程语言，与 Java™ 和 Android™ 100% 可互操作。&lt;/p&gt;&lt;p&gt;2017 年 5 月，Google 年度 I/O 大会上，宣布把 Kotlin 作为 Android 开发的首选语言。&lt;/p&gt;&lt;p&gt;今年 2018 Go
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://www.wshunli.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年春季快手实习生面试</title>
    <link href="https://www.wshunli.com/posts/cfc1cac2.html"/>
    <id>https://www.wshunli.com/posts/cfc1cac2.html</id>
    <published>2018-05-28T05:06:00.000Z</published>
    <updated>2018-06-19T12:01:39.077Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码（kuaishou）查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码（kuaishou）查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【密码公开】记录2018年春快手暑期实习生面试（客户端工程师）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Logger使用及源码解析</title>
    <link href="https://www.wshunli.com/posts/ca2fa1f1.html"/>
    <id>https://www.wshunli.com/posts/ca2fa1f1.html</id>
    <published>2018-05-22T14:46:58.000Z</published>
    <updated>2018-06-19T12:01:39.069Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 开发过程中打印日志必不可少，Logger 就是一款优秀的 Android 开源日志库。</p><p>Logger 使用简单，输出日志美观高效，支持 JSON 、XML 格式输出，支持打印 Arrays 、Collections 等对象。</p><p>Logger 地址 ：<a href="https://github.com/orhanobut/logger" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/orhanobut/logger</a></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>在项目中添加依赖：</p><pre><code class="Gradle">implementation &#39;com.orhanobut:logger:2.2.0&#39;</code></pre><p>快速开始：</p><pre><code class="Java">Logger.addLogAdapter(new AndroidLogAdapter());Logger.d(&quot;hello&quot;);</code></pre><p>这样就可以打印日志了。</p><p><img src="https://img.wshunli.com/Android/Logger/hello2.png" alt="hello"></p><p>当然不止打印这一种日志，和自带的函数类似：</p><pre><code class="Java">Logger.d(&quot;debug&quot;);Logger.e(&quot;error&quot;);Logger.w(&quot;warning&quot;);Logger.v(&quot;verbose&quot;);Logger.i(&quot;information&quot;);Logger.wtf(&quot;What a Terrible Failure&quot;);</code></pre><p>也支持格式化输出：</p><pre><code class="Java">Logger.d(&quot;hello %s&quot;, &quot;world&quot;);</code></pre><p>支持数字、集合对象的输出，注意只支持 Logger.d() 方法：</p><pre><code class="Java">Logger.d(MAP);Logger.d(SET);Logger.d(LIST);Logger.d(ARRAY);</code></pre><p>支持 JSON 和 XML 的输出：</p><pre><code class="Java">Logger.json(JSON_CONTENT);Logger.xml(XML_CONTENT);</code></pre><p>自定义 TAG ，仅本次日志打印有效：</p><pre><code class="Java">Logger.t(&quot;MainActivity&quot;).d(&quot;hello&quot;);</code></pre><p>支持把日志保存为文件：</p><pre><code class="Java">Logger.addLogAdapter(new DiskLogAdapter());Logger.d(&quot;hello&quot;);</code></pre><p>只需更改 LogAdapter 即可，其他使用相同。</p><pre><code class="Java">Logger.clearLogAdapters();</code></pre><p>清除 LogAdapter 方法。</p><h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><p>利用 PrettyFormatStrategy.newBuilder 还有更高级的设置，如：</p><pre><code class="Java">FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder()  .showThreadInfo(false)  // (Optional) Whether to show thread info or not. Default true  .methodCount(0)         // (Optional) How many method line to show. Default 2  .methodOffset(7)        // (Optional) Hides internal method calls up to offset. Default 5  .logStrategy(customLog) // (Optional) Changes the log strategy to print out. Default LogCat  .tag(&quot;My custom tag&quot;)   // (Optional) Global tag for every log. Default PRETTY_LOGGER  .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy));</code></pre><p>再者实现对打印日志的控制：</p><pre><code class="Java">Logger.addLogAdapter(new AndroidLogAdapter() {  @Override public boolean isLoggable(int priority, String tag) {    return BuildConfig.DEBUG;  }});</code></pre><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>先看官方对工作原理的介绍：</p><p><img src="https://img.wshunli.com/Android/Logger/how_it_works.png" alt="how_it_works"></p><p>Logger 打印日志整个流程非常明确：</p><p>Logger 负责整个对外的接口，LoggerPrinter 负责对不同日志的整合，LogAdapter 分别对 Logcat 和 Disk 的打印进行适配，FormatStrategy 负责打印输出的配置及美化，LogStrategy 负责最终的打印输出任务。</p><p>1、Logger.java 部分代码：</p><pre><code class="Java">private static Printer printer = new LoggerPrinter();public static Printer t(@Nullable String tag) {    return printer.t(tag);}</code></pre><p>这里只是提供了一系列的静态函数，包括前面对不同等级的日志的输出及 JSON、XML 的输出。</p><p>实际工作还是由 LoggerPrinter 来做。</p><p>还有就是对 LogAdapter 适配器的添加清除：</p><pre><code class="Java">public static void addLogAdapter(@NonNull LogAdapter adapter) {    printer.addAdapter(checkNotNull(adapter));}public static void clearLogAdapters() {    printer.clearLogAdapters();}</code></pre><p>2、LoggerPrinter 部分代码：</p><p>LoggerPrinter 实现 Printer 接口，负责不同日志的整合。</p><pre><code class="Java">@Override public void d(@NonNull String message, @Nullable Object... args) {    log(DEBUG, null, message, args);}@Override public void d(@Nullable Object object) {    log(DEBUG, null, Utils.toString(object));}@Override public void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {    log(ERROR, throwable, message, args);}@Override public void w(@NonNull String message, @Nullable Object... args) {    log(WARN, null, message, args);}  </code></pre><p>我们可以看到这些方法都是对 log() 方法的调用。</p><p>注意这里 d() 方法可以输出任意对象，还是对象转化为字符串输出。</p><p>我们接着看 log() 方法：</p><pre><code class="Java">private final ThreadLocal&lt;String&gt; localTag = new ThreadLocal&lt;&gt;();@Override public Printer t(String tag) {    if (tag != null) {        localTag.set(tag);    }    return this;}@Override public synchronized void log(int priority,                                         @Nullable String tag,                                         @Nullable String message,                                         @Nullable Throwable throwable) {    if (throwable != null &amp;&amp; message != null) {        message += &quot; : &quot; + Utils.getStackTraceString(throwable);    }    if (throwable != null &amp;&amp; message == null) {        message = Utils.getStackTraceString(throwable);    }    if (Utils.isEmpty(message)) {        message = &quot;Empty/NULL log message&quot;;    }    for (LogAdapter adapter : logAdapters) {        if (adapter.isLoggable(priority, tag)) {        adapter.log(priority, tag, message);        }    }}/*** This method is synchronized in order to avoid messy of logs&#39; order.*/private synchronized void log(int priority,                            @Nullable Throwable throwable,                            @NonNull String msg,                            @Nullable Object... args) {    checkNotNull(msg);    String tag = getTag();    String message = createMessage(msg, args);    log(priority, tag, message, throwable);}/*** @return the appropriate tag based on local or global*/@Nullable private String getTag() {String tag = localTag.get();    if (tag != null) {        localTag.remove();        return tag;    }    return null;}@NonNull private String createMessage(@NonNull String message, @Nullable Object... args) {    return args == null || args.length == 0 ? message : String.format(message, args);}</code></pre><p>我们可以看到这里是交由 LogAdapter 来实现打印：</p><pre><code class="Java">adapter.log(priority, tag, message);</code></pre><p>在调用之前添加了 tag ，对于一次性的 tag 是由 ThreadLocal 来存储的，避免线程的并发问题，并且在取出后将其置空。</p><p>3、LogAdapter 有两个实现</p><p>AndroidLogAdapter 与 DiskLogAdapter 分别对应 Logcat 输出与 Disk 保存。</p><p>4.1、AndroidLogAdapter 部分代码：</p><pre><code class="Java">public class AndroidLogAdapter implements LogAdapter {  @NonNull private final FormatStrategy formatStrategy;  public AndroidLogAdapter() {    this.formatStrategy = PrettyFormatStrategy.newBuilder().build();  }  public AndroidLogAdapter(@NonNull FormatStrategy formatStrategy) {    this.formatStrategy = checkNotNull(formatStrategy);  }  @Override public boolean isLoggable(int priority, @Nullable String tag) {    return true;  }  @Override public void log(int priority, @Nullable String tag, @NonNull String message) {    formatStrategy.log(priority, tag, message);  }}</code></pre><p>很明显只是对是否打印日志进行了控制，其他任务由 PrettyFormatStrategy 来做。</p><p>4.2、PrettyFormatStrategy 部分代码：</p><p>首先 PrettyFormatStrategy 使用 Builder 设计模式，从前面 AndroidLogAdapter 的构造函数中也可看出来。</p><pre><code class="Java">  public static class Builder {    int methodCount = 2;    int methodOffset = 0;    boolean showThreadInfo = true;    @Nullable LogStrategy logStrategy;    @Nullable String tag = &quot;PRETTY_LOGGER&quot;;    private Builder() {    }    @NonNull public Builder methodCount(int val) {      methodCount = val;      return this;    }    @NonNull public Builder methodOffset(int val) {      methodOffset = val;      return this;    }    @NonNull public Builder showThreadInfo(boolean val) {      showThreadInfo = val;      return this;    }    @NonNull public Builder logStrategy(@Nullable LogStrategy val) {      logStrategy = val;      return this;    }    @NonNull public Builder tag(@Nullable String tag) {      this.tag = tag;      return this;    }    @NonNull public PrettyFormatStrategy build() {      if (logStrategy == null) {        logStrategy = new LogcatLogStrategy();      }      return new PrettyFormatStrategy(this);    }  }</code></pre><p>这样就可以对打印的日志进行配置了，也就是前面进阶使用里面的内容。</p><p>下面来看具体打印的实现：</p><pre><code class="Java">  @Override public void log(int priority, @Nullable String onceOnlyTag, @NonNull String message) {    checkNotNull(message);    String tag = formatTag(onceOnlyTag);    logTopBorder(priority, tag);    logHeaderContent(priority, tag, methodCount);    //get bytes of message with system&#39;s default charset (which is UTF-8 for Android)    byte[] bytes = message.getBytes();    int length = bytes.length;    if (length &lt;= CHUNK_SIZE) {      if (methodCount &gt; 0) {        logDivider(priority, tag);      }      logContent(priority, tag, message);      logBottomBorder(priority, tag);      return;    }    if (methodCount &gt; 0) {      logDivider(priority, tag);    }    for (int i = 0; i &lt; length; i += CHUNK_SIZE) {      int count = Math.min(length - i, CHUNK_SIZE);      //create a new String with system&#39;s default charset (which is UTF-8 for Android)      logContent(priority, tag, new String(bytes, i, count));    }    logBottomBorder(priority, tag);  }  private void logTopBorder(int logType, @Nullable String tag) {    logChunk(logType, tag, TOP_BORDER);  }  @SuppressWarnings(&quot;StringBufferReplaceableByString&quot;)  private void logHeaderContent(int logType, @Nullable String tag, int methodCount) {    StackTraceElement[] trace = Thread.currentThread().getStackTrace();    if (showThreadInfo) {      logChunk(logType, tag, HORIZONTAL_LINE + &quot; Thread: &quot; + Thread.currentThread().getName());      logDivider(logType, tag);    }    String level = &quot;&quot;;    int stackOffset = getStackOffset(trace) + methodOffset;    //corresponding method count with the current stack may exceeds the stack trace. Trims the count    if (methodCount + stackOffset &gt; trace.length) {      methodCount = trace.length - stackOffset - 1;    }    for (int i = methodCount; i &gt; 0; i--) {      int stackIndex = i + stackOffset;      if (stackIndex &gt;= trace.length) {        continue;      }      StringBuilder builder = new StringBuilder();      builder.append(HORIZONTAL_LINE)          .append(&#39; &#39;)          .append(level)          .append(getSimpleClassName(trace[stackIndex].getClassName()))          .append(&quot;.&quot;)          .append(trace[stackIndex].getMethodName())          .append(&quot; &quot;)          .append(&quot; (&quot;)          .append(trace[stackIndex].getFileName())          .append(&quot;:&quot;)          .append(trace[stackIndex].getLineNumber())          .append(&quot;)&quot;);      level += &quot;   &quot;;      logChunk(logType, tag, builder.toString());    }  }  private void logBottomBorder(int logType, @Nullable String tag) {    logChunk(logType, tag, BOTTOM_BORDER);  }  private void logDivider(int logType, @Nullable String tag) {    logChunk(logType, tag, MIDDLE_BORDER);  }  private void logContent(int logType, @Nullable String tag, @NonNull String chunk) {    checkNotNull(chunk);    String[] lines = chunk.split(System.getProperty(&quot;line.separator&quot;));    for (String line : lines) {      logChunk(logType, tag, HORIZONTAL_LINE + &quot; &quot; + line);    }  }  private void logChunk(int priority, @Nullable String tag, @NonNull String chunk) {    checkNotNull(chunk);    logStrategy.log(priority, tag, chunk);  }</code></pre><p>这里就是对日志美化的核心了，但是最终每一行的输出还是不是在此，是由 LogcatLogStrategy 负责的。</p><p>4.3、LogcatLogStrategy 部分代码：</p><p>LogcatLogStrategy 负责打印每一行日志，当然已经美化过了。</p><pre><code class="Java">public class LogcatLogStrategy implements LogStrategy {  static final String DEFAULT_TAG = &quot;NO_TAG&quot;;  @Override public void log(int priority, @Nullable String tag, @NonNull String message) {    checkNotNull(message);    if (tag == null) {      tag = DEFAULT_TAG;    }    Log.println(priority, tag, message);  }}</code></pre><p>这里调用的是系统的 Log 方法逐行打印日志。</p><p>5.1、DiskLogAdapter 部分代码：</p><p>和 AndroidLogAdapter 类似，DiskLogAdapter 也只是负责控制是否打印日志，具体工作由 CsvFormatStrategy 实现。</p><pre><code class="Java">public class DiskLogAdapter implements LogAdapter {  @NonNull private final FormatStrategy formatStrategy;  public DiskLogAdapter() {    formatStrategy = CsvFormatStrategy.newBuilder().build();  }  public DiskLogAdapter(@NonNull FormatStrategy formatStrategy) {    this.formatStrategy = checkNotNull(formatStrategy);  }  @Override public boolean isLoggable(int priority, @Nullable String tag) {    return true;  }  @Override public void log(int priority, @Nullable String tag, @NonNull String message) {    formatStrategy.log(priority, tag, message);  }}</code></pre><p>5.2、CsvFormatStrategy 部分代码：</p><p>CsvFormatStrategy 处理后的日志要保存到文件，同样使用 Builder 设计模式：</p><p>我们来看下 build() 方法：</p><pre><code class="Java">@NonNull public CsvFormatStrategy build() {    if (date == null) {        date = new Date();    }    if (dateFormat == null) {        dateFormat = new SimpleDateFormat(&quot;yyyy.MM.dd HH:mm:ss.SSS&quot;, Locale.UK);    }    if (logStrategy == null) {        String diskPath = Environment.getExternalStorageDirectory().getAbsolutePath();        String folder = diskPath + File.separatorChar + &quot;logger&quot;;        HandlerThread ht = new HandlerThread(&quot;AndroidFileLogger.&quot; + folder);        ht.start();        Handler handler = new DiskLogStrategy.WriteHandler(ht.getLooper(), folder, MAX_BYTES);        logStrategy = new DiskLogStrategy(handler);    }    return new CsvFormatStrategy(this);}</code></pre><p>可以看到文件保存位置为 外置空间根目录 logger 文件夹下。</p><p>由 HandlerThread 启动了一个子线程，HandlerThread 实际上还是一个普通的 Thread，不过内部实现了 Looper 循环。</p><p>具体实现主要涉及字符串的拼接、格式的调整：</p><pre><code class="Java">  @Override public void log(int priority, @Nullable String onceOnlyTag, @NonNull String message) {    checkNotNull(message);    String tag = formatTag(onceOnlyTag);    date.setTime(System.currentTimeMillis());    StringBuilder builder = new StringBuilder();    // machine-readable date/time    builder.append(Long.toString(date.getTime()));    // human-readable date/time    builder.append(SEPARATOR);    builder.append(dateFormat.format(date));    // level    builder.append(SEPARATOR);    builder.append(Utils.logLevel(priority));    // tag    builder.append(SEPARATOR);    builder.append(tag);    // message    if (message.contains(NEW_LINE)) {      // a new line would break the CSV format, so we replace it here      message = message.replaceAll(NEW_LINE, NEW_LINE_REPLACEMENT);    }    builder.append(SEPARATOR);    builder.append(message);    // new line    builder.append(NEW_LINE);    logStrategy.log(priority, tag, builder.toString());  }  @Nullable private String formatTag(@Nullable String tag) {    if (!Utils.isEmpty(tag) &amp;&amp; !Utils.equals(this.tag, tag)) {      return this.tag + &quot;-&quot; + tag;    }    return this.tag;  }</code></pre><p>最终还是由 DiskLogStrategy 来负责打印输出日志。</p><p>5.3、DiskLogStrategy 部分代码：</p><p>这里使用了 Handler 实现线程间的通信：</p><pre><code class="Java">  @NonNull private final Handler handler;  public DiskLogStrategy(@NonNull Handler handler) {    this.handler = checkNotNull(handler);  }  @Override public void log(int level, @Nullable String tag, @NonNull String message) {    checkNotNull(message);    // do nothing on the calling thread, simply pass the tag/msg to the background thread    handler.sendMessage(handler.obtainMessage(level, message));  }</code></pre><p>每次有新的日志，调用 handler.sendMessage() 方法。</p><pre><code class="Java">@SuppressWarnings(&quot;checkstyle:emptyblock&quot;)@Override public void handleMessage(@NonNull Message msg) {    String content = (String) msg.obj;    FileWriter fileWriter = null;    File logFile = getLogFile(folder, &quot;logs&quot;);    try {    fileWriter = new FileWriter(logFile, true);    writeLog(fileWriter, content);    fileWriter.flush();    fileWriter.close();    } catch (IOException e) {    if (fileWriter != null) {        try {        fileWriter.flush();        fileWriter.close();        } catch (IOException e1) { /* fail silently */ }    }    }}</code></pre><p>最后 Handler 接收到消息，就把日志保存到文件中。</p><blockquote><p>Logger 源码分析就到这里了，作者代码写得很优雅，也非常感谢作者向开源社区贡献如此优秀的库。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Android 开发过程中打印日志必不可少，Logger 就是一款优秀的 Android 开源日志库。&lt;/p&gt;&lt;p&gt;Logger 使用简单，输出日志美观高效，支持 JSON 、XML 格式输出，支持打印 Arrays 、Collections 等对象。&lt;/p&gt;&lt;p&gt;Lo
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Logger" scheme="https://www.wshunli.com/tags/Logger/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Flutter开发环境与入门</title>
    <link href="https://www.wshunli.com/posts/a72058f7.html"/>
    <id>https://www.wshunli.com/posts/a72058f7.html</id>
    <published>2018-05-21T13:56:28.000Z</published>
    <updated>2018-06-19T12:01:39.069Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 是 Google 的移动应用程序 SDK，用于在 iOS 和 Android 上构建高质量的原生界面。 Flutter 与现有的代码一起工作，被全世界的开发者和组织使用，并且是免费和开源的。</p><p>本文介绍在 Windows 环境下 Flutter 环境的搭建及入门。</p><p>1、获取 Flutter SDK</p><p>可以从下载页面获取 Flutter SDK： <a href="https://flutter.io/sdk-archive/#windows" rel="external nofollow noopener noreferrer" target="_blank">https://flutter.io/sdk-archive/#windows</a> .</p><p>将压缩包解压到合适位置，比如本文解压到 ：<code>D:\Android\flutter</code> .</p><p>然后双击文件夹下 <code>flutter_console.bat</code> 文件即可。</p><p>2、设置环境变量</p><p>将 <code>flutter\bin</code> 目录加到系统环境变量 Path 中。</p><p>如本文的目录就是：<code>D:\Android\flutter\bin</code> .</p><p>3、运行 flutter doctor</p><p>在命令行中运行 <code>flutter doctor</code> 可以检查 flutter 插件及依赖安装情况。</p><p>4、Android 环境</p><p>Android 环境安装配置就不多介绍了。</p><p>在 Android Studio 安装 Flutter 、Dart 两个插件就可以直接创建 Flutter 应用了。</p><p>创建过程也基本上和普通 Android 应用差别不大。</p><p>本文源代码：<a href="https://github.com/wshunli/flutter_demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/flutter_demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flutter 是 Google 的移动应用程序 SDK，用于在 iOS 和 Android 上构建高质量的原生界面。 Flutter 与现有的代码一起工作，被全世界的开发者和组织使用，并且是免费和开源的。&lt;/p&gt;&lt;p&gt;本文介绍在 Windows 环境下 Flutter 环
      
    
    </summary>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Flutter" scheme="https://www.wshunli.com/tags/Flutter/"/>
    
      <category term="跨平台" scheme="https://www.wshunli.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（二）工厂方法模式</title>
    <link href="https://www.wshunli.com/posts/4982f93c.html"/>
    <id>https://www.wshunli.com/posts/4982f93c.html</id>
    <published>2018-05-21T11:52:25.000Z</published>
    <updated>2018-06-19T12:01:39.069Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式（Factory Pattern）定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>未完待续。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式（Factory Pattern）定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。&lt;/p&gt;&lt;h2 id=&quot;工厂方法模式&quot;&gt;&lt;a href=&quot;#工厂方法模式&quot; class=&quot;headerlink&quot; title=&quot;工厂方法
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
</feed>
