<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2018-03-17T17:17:52.768Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《第一行代码》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/4c8f7dec.html"/>
    <id>http://www.wshunli.com/posts/4c8f7dec.html</id>
    <published>2018-03-12T10:13:45.000Z</published>
    <updated>2018-03-17T17:17:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver</p><a id="more"></a><h1 id="第5章-全局大喇叭"><a href="#第5章-全局大喇叭" class="headerlink" title="第5章 全局大喇叭"></a>第5章 全局大喇叭</h1><p>BroadcastReceiver，广播接收者，它是一个系统全局的监听器，用于监听系统全局的 Broadcast 消息，所以它可以很方便的进行系统组件之间的通信。</p><p>BroadcastReceiver 属于系统级的监听器，它拥有自己的进程，只要存在与之匹配的 Broadcast 被以 Intent 的形式发送出来，BroadcastReceiver 就会被激活。</p><p>广播的使用场景：<br>（1）同一 APP 具有多进程的不同组件之间的信息通信。<br>（2）不同 APP 之间的组件之间信息通信。</p><p>Android中的广播分为两种类型，标准广播和有序广播</p><p>（1）标准广播<br>标准广播是一种完全异步执行的广播，在广播发出后所有的广播接收器会在同一时间接收到这条广播，之间没有先后顺序，效率比较高，且无法被截断。<br>（2）有序广播<br>有序广播是一种同步执行的广播，在广播发出后同一时刻只有一个广播接收器能够接收到， 优先级高的广播接收器会优先接收，当优先级高的广播接收器的 onReceiver() 方法运行结束后，广播才会继续传递，且前面的广播接收器可以选择截断广播，这样后面的广播接收器就无法接收到这条广播了。</p><h2 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h2><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册 BroadcastReceiver 是在代码中定义并设置好一个 IntentFilter 对象，然后在需要注册的地方调用 Context.registerReceiver() 方法，调用 Context.unregisterReceiver() 方法取消注册，此时就不需要在清单文件中注册。</p><pre><code class="Java">public class MainActivity extends AppCompatActivity {    private static final String TAG = &quot;MainActivity&quot;;    private IntentFilter intentFilter;    private NetWorkBroadcastReceiver netWorkBroadcastReceiver;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        intentFilter = new IntentFilter();        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);        netWorkBroadcastReceiver = new NetWorkBroadcastReceiver();        registerReceiver(netWorkBroadcastReceiver, intentFilter);    }    @Override    protected void onDestroy() {        super.onDestroy();        unregisterReceiver(netWorkBroadcastReceiver);    }    class NetWorkBroadcastReceiver extends BroadcastReceiver{        @Override        public void onReceive(Context context, Intent intent) {            Log.d(TAG, &quot;onReceive: &quot;+&quot;network changes&quot;);        }    }}</code></pre><p>动态注册广播接收器可以自由地控制注册与注销，但是必须程序启动之后才能收到广播，因为注册的逻辑是写在 onCreate() 方法中。</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册即在清单文件中为 BroadcastReceiver 进行注册，使用 &lt; receiver &gt; 标签声明，并在标签内用 &lt; intent-filter &gt; 标签设置过滤器。</p><p>这种形式的 BroadcastReceiver 的生命周期伴随着整个应用，如果这种方式处理的是系统广播，那么不管应用是否在运行，该广播接收器都能接收到该广播。</p><pre><code class="Java">public class BootCompleteReceiver extends BroadcastReceiver {    private static final String TAG = &quot;BootCompleteReceiver&quot;;    @Override    public void onReceive(Context context, Intent intent) {        Log.d(TAG, &quot;onReceive: &quot;+&quot;Boot Complete&quot;);    }}</code></pre><p>manifest 文件中声明：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&lt;receiver    android:name=&quot;.BootCompleteReceiver&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><p>前面是同通过广播接收器接收系统广播，接下来是发送自定义广播。</p><p>首先注册广播接收器，这里选择静态注册方法：</p><pre><code class="Java">public class CustomReceiver extends BroadcastReceiver {    private static final String TAG = &quot;CustomReceiver&quot;;    @Override    public void onReceive(Context context, Intent intent) {        Log.d(TAG, &quot;onReceive: &quot;+&quot;接收到自定义广播&quot;);    }}</code></pre><p>然后在 manifest 中声明 广播接收器：</p><pre><code class="XML">&lt;receiver    android:name=&quot;.CustomReceiver&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;com.wshunli.broadcastreceiverdemo.CUSTOM_BROADCAST&quot; /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><p>发送标准广播调用的是 sendBroadcast(Intent) 方法</p><pre><code class="Java">sendBroadcast(new Intent(&quot;com.wshunli.broadcastreceiverdemo.CUSTOM_BROADCAST&quot;));</code></pre><h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><p>发送有序广播调用的是 sendOrderedBroadcast(Intent , String) 方法，String 参数值在自定义权限时使用。</p><pre><code class="Java">sendOrderedBroadcast(new Intent(&quot;com.wshunli.broadcastreceiverdemo.CUSTOM_BROADCAST&quot;),null);</code></pre><p>Receiver 接收广播时不仅因为 “priority” 属性存在先后顺序，且 Receiver 之间也能够传递数据。</p><p>此外，BroadcastReceiver 也能调用 abortBroadcast() 方法截断广播，这样低优先级的广播接收器就无法接收到广播了。</p><h2 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h2><p>之前发送和接收到的广播全都是属于系统全局广播，即发出的广播可以被其他应用接收到，而且也可以接收到其他应用发送出的广播，这样可能会有不安全因素。</p><p>因此，在某些情况下可以采用本地广播机制，使用这个机制发出的广播只能在应用内部进行传递，而且广播接收器也只能接收本应用内自身发出的广播。</p><p>本地广播是使用 LocalBroadcastManager 来对广播进行管理。</p><p>首先，创建一个 BroadcastReceiver 用于接收本地广播：</p><pre><code class="Java">class LocalReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        Log.d(TAG, &quot;onReceive: &quot; + &quot;LocalReceiver&quot;);    }}</code></pre><p>然后使用 LocalBroadcastManager 注册或者注销 广播接收器：</p><pre><code class="Java">private IntentFilter intentFilter;private LocalReceiver localReceiver;private LocalBroadcastManager localBroadcastManager;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    intentFilter = new IntentFilter();    intentFilter.addAction(&quot;com.wshunli.broadcastreceiverdemo.LOCAL_BROADCAST&quot;);    localReceiver = new LocalReceiver();    localBroadcastManager = LocalBroadcastManager.getInstance(this);    localBroadcastManager.registerReceiver(localReceiver, intentFilter);}@Overrideprotected void onDestroy() {    super.onDestroy();    localBroadcastManager.unregisterReceiver(localReceiver);}</code></pre><p>最后通过 LocalBroadcastManager 发送本地广播：</p><pre><code class="Java">localBroadcastManager.sendBroadcast(new Intent(&quot;com.wshunli.broadcastreceiverdemo.LOCAL_BROADCAST&quot;));</code></pre><p>需要注意的是，本地广播是无法通过静态注册的方式来接收的，因为静态注册广播主要是为了在程序未启动的情况下也能接收广播，而本地广播是应用自己发送的，此时应用肯定是启动的了。</p><p>本地广播的优势：<br>（1）发送的广播不会离开我们的应用程序，所以不必担心机密数据泄露；<br>（2）其他程序的广播也无法发送到我们程序内部，不用担心会有安全漏洞；<br>（3）本地广播比发送系统全局广播将更加有效。</p><p>第7章 跨程序共享数据</p><p>未完待续。。</p><blockquote><p>参考资料<br>1、Broadcasts | Android Developers<br><a href="https://developer.android.com/guide/components/broadcasts.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/broadcasts.html</a><br>2、Android之BroadcastReceiver | 吴小龙同學<br><a href="http://wuxiaolong.me/2015/11/03/BroadcastReceiver/" rel="external nofollow noopener noreferrer" target="_blank">http://wuxiaolong.me/2015/11/03/BroadcastReceiver/</a><br>3、Android BroadcastReceiver使用详解 - 简书<br><a href="https://www.jianshu.com/p/f348f6d7fe59" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f348f6d7fe59</a><br>4、Android深入四大组件（四）广播的注册、发送和接收过程 | 刘望舒的博客<br><a href="http://liuwangshu.cn/framework/component/4-broadcastreceiver.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/framework/component/4-broadcastreceiver.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（十）</title>
    <link href="http://www.wshunli.com/posts/96840e7.html"/>
    <id>http://www.wshunli.com/posts/96840e7.html</id>
    <published>2018-03-09T07:02:07.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 并发。</p><a id="more"></a><h1 id="第21章-并发"><a href="#第21章-并发" class="headerlink" title="第21章 并发"></a>第21章 <strong>并发</strong></h1><p>Java 是一种多线程语言，并且提出了并发问题。</p><p>并发解决的问题大致可分为两类：速度，设计的可管理性。</p><h2 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h2><p>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。<strong>一个线程就是在进程中的一个单一的顺序控制流</strong>，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的 CPU 一样。其底层机制是切分 CPU 的时间。</p><p>1、定义任务</p><p>线程可以驱动任务，因此你需要一种描述任务的方式，这可以由 Runnable 接口来提供。</p><pre><code class="Java">public class LiftOff implements Runnable {  protected int countDown = 10; // Default  private static int taskCount = 0;  private final int id = taskCount++;  public LiftOff() {}  public LiftOff(int countDown) {    this.countDown = countDown;  }  public String status() {    return &quot;#&quot; + id + &quot;(&quot; +      (countDown &gt; 0 ? countDown : &quot;Liftoff!&quot;) + &quot;), &quot;;  }  public void run() {    while(countDown-- &gt; 0) {      System.out.print(status());      Thread.yield();    }  }} ///:~</code></pre><p><code>Thread.yield()</code> 的调用是对线程调度器的一种建议，建议线程调度器切换任务。</p><p>当从 Runnable 导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处–它不会产生任何内在的线程能力。要实现线程行为，你必须显式将一个线程附着在线程上。</p><pre><code class="Java">public class MainThread {  public static void main(String[] args) {    LiftOff launch = new LiftOff();    launch.run();  }} /* Output:#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),*///:~</code></pre><p>2、Thread 类</p><p>将 Runnable 对象转变为工作任务的传统方式是把它提交给一个 Thread 构造器。下面的示例展示了如何用 Thread 来驱动 LiftOff 对象。</p><pre><code class="Java">public class BasicThreads {  public static void main(String[] args) {    Thread t = new Thread(new LiftOff());    t.start();    System.out.println(&quot;Waiting for LiftOff&quot;);  }} /* Output: (90% match)Waiting for LiftOff#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),*///:~</code></pre><p>3、使用 Executor</p><pre><code class="Java">import java.util.concurrent.*;public class CachedThreadPool {  public static void main(String[] args) {    ExecutorService exec = Executors.newCachedThreadPool();    for(int i = 0; i &lt; 5; i++)      exec.execute(new LiftOff());    exec.shutdown();  }} /* Output: (Sample)#0(9), #0(8), #1(9), #2(9), #3(9), #4(9), #0(7), #1(8), #2(8), #3(8), #4(8), #0(6), #1(7), #2(7), #3(7), #4(7), #0(5), #1(6), #2(6), #3(6), #4(6), #0(4), #1(5), #2(5), #3(5), #4(5), #0(3), #1(4), #2(4), #3(4), #4(4), #0(2), #1(3), #2(3), #3(3), #4(3), #0(1), #1(2), #2(2), #3(2), #4(2), #0(Liftoff!), #1(1), #2(1), #3(1), #4(1), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),*///:~</code></pre><p><code>CachedThreadPool</code> 将为每个任务都创建一个线程，是合理得 Executor 的首选。</p><p><code>FixedThreadPool</code> 可以一次性预先执行代价高昂的线程分配，限制了线程数量。不用为每个任务都固定的付出创建线程的开销，所以省时间。限制线程数量的好处在于防止线程的滥用。</p><p><code>SingleThreadExecutor</code> 用于希望在另一个线程中连续运行的任何事物（长期存活的任务）。例如监听进入的套接字连接的任务（他只有一个线程）。</p><p>4、从任务中产生返回值</p><p>在 Java SE5 中引入的 Callable 是一种具有类型参数的泛型，它的类型参数表示的是从方法 call() 中返回的值的类型，并且必须使用ExecutorService.submit() 方法调用它。</p><pre><code class="Java">import java.util.concurrent.*;import java.util.*;class TaskWithResult implements Callable&lt;String&gt; {  private int id;  public TaskWithResult(int id) {    this.id = id;  }  public String call() {    return &quot;result of TaskWithResult &quot; + id;  }}public class CallableDemo {  public static void main(String[] args) {    ExecutorService exec = Executors.newCachedThreadPool();    ArrayList&lt;Future&lt;String&gt;&gt; results =      new ArrayList&lt;Future&lt;String&gt;&gt;();    for(int i = 0; i &lt; 10; i++)      results.add(exec.submit(new TaskWithResult(i)));    for(Future&lt;String&gt; fs : results)      try {        // get() blocks until completion:        System.out.println(fs.get());      } catch(InterruptedException e) {        System.out.println(e);        return;      } catch(ExecutionException e) {        System.out.println(e);      } finally {        exec.shutdown();      }  }} /* Output:result of TaskWithResult 0result of TaskWithResult 1result of TaskWithResult 2result of TaskWithResult 3result of TaskWithResult 4result of TaskWithResult 5result of TaskWithResult 6result of TaskWithResult 7result of TaskWithResult 8result of TaskWithResult 9*///:~</code></pre><p>5、休眠<br>影响任务行为的一种简单方法是调用 sleep()，这将使任务中止执行给定的时间。<br>sleep会使得线程睡眠（即阻塞），这使得线程调度器可以切换到另一个线程，进而驱动另一个任务。</p><p>6、优先级<br>调度器将倾向于优先权更高的线程先执行（执行的频率高），但 CPU 处理线程集的顺序还是不确定的。<br>可以通过 Thread.currentThread().setPriority(int) 设置优先级，getPriority()获取优先级。</p><p>7、让步<br>让步通过调用yield()方法来做出（<strong>不过这只是一个暗示，没有任何机制保证它将会被采纳</strong>）。<br>对于任何重要的控制或在调整应用时，都不能依赖于yield()。</p><p>8、后台线程<br>当所有非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。</p><p>必须在线程启动之前调用 setDaemon() 方法，才能把它设置为后台线程。即：</p><pre><code class="Java">Thread daemon = new Thread(new SimpleDaemons());daemon.setDaemon(true);daemon.start();</code></pre><h2 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h2><p>关键字 <code>synchronized</code> 为防止资源冲突提供内置支持。</p><blockquote><p>参考资料<br>1、java编程思想（读书笔记）：21.并发 - CSDN博客<br><a href="http://blog.csdn.net/he_world/article/details/52902701" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/he_world/article/details/52902701</a><br>2、《Java编程思想》——并发读书笔记 - CSDN博客<br><a href="http://blog.csdn.net/qq_35362055/article/details/78135854" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/qq_35362055/article/details/78135854</a><br>3、Java编程思想读书笔记一：并发 - CSDN博客<br><a href="http://blog.csdn.net/jiankunking/article/details/54799830" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/jiankunking/article/details/54799830</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 并发。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 从入门到放弃：Spring MVC 常用注解详解</title>
    <link href="http://www.wshunli.com/posts/4e57ccd.html"/>
    <id>http://www.wshunli.com/posts/4e57ccd.html</id>
    <published>2018-01-28T05:02:35.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Spring MVC 常用注解<a id="more"></a>，包括 @Controller、@RequestMapping、@PathVariable、@RequestParam、@RequestBody、@ResponseBody、@RestController 等等。</p><p>1、@Controller</p><p>Controller 控制器是通过服务接口定义的提供访问应用程序的一种行为，它解释用户的输入，将其转换成一个模型然后将试图呈献给用户。</p><p>其实 @Repository、@Controller、@Service 都组合了 @Component 元注解。</p><pre><code class="Java">@Controllerpublic class PersonController {}</code></pre><p>2、@RequestMapping</p><p>@RequestMapping 注解用于映射 Web 请求（访问路径和参数）、处理类和方法的。</p><p>@RequestMapping 可以注解在类和方法上，注解在方法上的路径会继承注解在类上的路径；支持 Servlet 的 request 和 response 作为参数。</p><pre><code class="Java">@Controller@RequestMapping(value = &quot;api/person&quot;)public class PersonController {    @RequestMapping(value = &quot;{name}&quot;, method = RequestMethod.GET)    @ResponseBody    public String index() {    }}</code></pre><p>@PathVariable 用来接收路径参数，比如 <code>/api/person/{name}</code> 可接受 <code>name</code> 作为参数。</p><pre><code class="Java">    @RequestMapping(value = &quot;/{name}&quot;, method = RequestMethod.GET)    @ResponseBody    public String index(            @PathVariable(&quot;name&quot;) String name) {        System.out.printf(&quot;Person name :&quot; + name);        return name;    }</code></pre><p>发送 GET 请求示例 ：<a href="http://127.0.0.1:8080/api/person/wshunli" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/api/person/wshunli</a></p><p>@RequestParam 用来接收参数，比如 <code>/api/person/?name=wshunli</code> 可接受 <code>name</code> 的值 <code>wshunli</code> 作为参数的值。</p><pre><code class="Java">    @RequestMapping(method = RequestMethod.POST)    @ResponseBody    public String create(            @RequestParam(value = &quot;name&quot;, required = false) String name) {        System.out.printf(&quot;Person name :&quot; + name);        return name;    }</code></pre><p>发送 POST 请求示例 ：<a href="http://127.0.0.1:8080/api/person?name=wshunli" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/api/person?name=wshunli</a></p><p>3、@RequestBody</p><p>@RequestBody 允许 request 的参数在 request 体内，而不是直接在地址后面。</p><p>未完待续。。</p><p>参考资料：<br>1、springmvc常用注解标签详解 - 木叔 - 博客园<br><a href="https://www.cnblogs.com/leskang/p/5445698.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/leskang/p/5445698.html</a><br>2、详解Spring MVC 常用的那些注解 - CSDN博客<br><a href="http://blog.csdn.net/u010783583/article/details/52176382" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/u010783583/article/details/52176382</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍 Spring MVC 常用注解
    
    </summary>
    
      <category term="后端技术" scheme="http://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.wshunli.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.wshunli.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 从入门到放弃：简单参数配置及环境分离</title>
    <link href="http://www.wshunli.com/posts/91672bd7.html"/>
    <id>http://www.wshunli.com/posts/91672bd7.html</id>
    <published>2018-01-26T12:54:53.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录下 Spring Boot 参数配置以及生产环境与开发环境分离配置。</p><a id="more"></a><p>推荐使用 yml 配置 Spring Boot ，可以省略重复内容，也有较好的提示。</p><p>直接修改 <code>application.properties</code> 为 <code>application.yml</code> 即可。</p><h1 id="简单参数配置"><a href="#简单参数配置" class="headerlink" title="简单参数配置"></a>简单参数配置</h1><p>我们在使用 Spring Boot 时难免会使用一些简单的配置配置，<br>也就是在配置文件 <code>application.yml</code> 配置相应变量的值，然后使用 <code>@Value</code> 注解取得。</p><pre><code class="Java">// application.ymlusename: wshunli// HelloController@Value(value = &quot;${usename}&quot;)String wshunli;</code></pre><p>这样还是有点麻烦，我们可以新建一个类：</p><pre><code class="Java">package com.wshunli.spring.boot.demo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;hello&quot;)public class Hello {    String name;    String content;    // 省略 get set 方法}</code></pre><p>这里可能提示添加依赖，我们根绝建议添加即可：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>在配置文件中这样写：</p><pre><code class="yml">hello:  name: hello prod  content: Spring Boot !</code></pre><p>在使用的地方：</p><pre><code class="Java">@AutowiredHello hello;</code></pre><p>使用 get 方法即可得到所需的值。</p><h1 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a>环境分离</h1><p>添加两个文件 <code>application-dev.yml</code> 和 <code>application-prod.yml</code> 分别代表开发环境和生产环境。</p><p>例如：</p><p><code>application-dev.yml</code></p><pre><code class="yml">server:  port: 8081hello:  name: hello dev  content: Spring Boot !</code></pre><p><code>application-prod.yml</code></p><pre><code class="yml">server:  port: 808hello:  name: hello prod  content: Spring Boot !</code></pre><p>在原来的配置文件中添加：</p><pre><code class="yml">spring:  profiles:    active: dev</code></pre><p>我们只需修改 <code>active</code> 的值即可在在环境之间切换，<br><code>dev</code> 代表开发环境配置，<code>prod</code> 代表生产环境配置。</p><p>本文源码：<a href="https://github.com/wshunli/spring-boot-demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/spring-boot-demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录下 Spring Boot 参数配置以及生产环境与开发环境分离配置。&lt;/p&gt;
    
    </summary>
    
      <category term="后端技术" scheme="http://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.wshunli.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.wshunli.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机操作系统（二）</title>
    <link href="http://www.wshunli.com/posts/84f52548.html"/>
    <id>http://www.wshunli.com/posts/84f52548.html</id>
    <published>2018-01-25T08:54:36.000Z</published>
    <updated>2018-03-17T17:17:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>计算机操作系统 <strong>进程管理</strong> 部分的内容。<a id="more"></a></p><p>感觉这部分面试问得也比较多，比如进程和线程得区别啥的。</p><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><p><img src="https://img.wshunli.com/计算机基础-计算机操作系统/0/2.png-hexo.png" alt="操作系统引论"></p><h2 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h2><p>程序顺序执行时的特征:<br>(1) 顺序性：处理机的操作严格按照程序所规定的顺序执行，即每一操作必须在上一个操作结束之后开始。<br>(2) 封闭性：程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。<br>(3) 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。<br>程序顺序执行时的特性，为程序员检测和校正程序的错误带来了很大的方便。</p><p>前趋图(Precedence Graph)是一个有向无循环图，记为DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。</p><p>又来活了，未完待续。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机操作系统 &lt;strong&gt;进程管理&lt;/strong&gt; 部分的内容。
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="《计算机操作系统》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机操作系统（一）</title>
    <link href="http://www.wshunli.com/posts/b4e3c990.html"/>
    <id>http://www.wshunli.com/posts/b4e3c990.html</id>
    <published>2018-01-22T05:13:26.000Z</published>
    <updated>2018-03-17T17:17:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>还要几天才能回家，就先看看计算机操作系统概论的内容<a id="more"></a> ，继续朝着目标前进。</p><p><strong>具备扎实的数据结构和计算机系统基础，编码功底扎实</strong>。</p><p>这次选择的课本是《计算机操作系统》（第三版），主编是汤小丹老师。</p><h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><p><img src="https://img.wshunli.com/计算机基础-计算机操作系统/0/1.png-hexo.png" alt="操作系统引论"></p><p>计算机系统由硬件和软件两部分组成。<br>操作系统(OS，Operating System)是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。</p><p>从一般用户的观点，可把 OS 看做是用户与计算机硬件系统之间的接口；<br>从资源管理的观点看，则可把 OS 视为计算机系统资源的管理者。<br>另外，OS 实现了对计算机资源的抽象，隐藏了对硬件操作的细节，使用户能更方便地使用机器。</p><h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><p>OS的形成迄今已有50多年的时间。<br>在上世纪50年代中期出现了单道批处理操作系统；60 年代中期产生了多道程序批处理系统；<br>不久又出现了基于多道程序的分时系统，与此同时也诞生了用于工业控制和武器控制的实时操作系统。</p><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><p>微机操作系统可分为单用户单任务操作系统、单用户多任务操作系统、多用户多任务操作系统，具有并发、共享、虚拟和异步这四个基本特征。</p><p>1、并发性</p><p>并行性和并发性(Concurrence)是既相似又有区别的两个概念，<br>并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。</p><p><strong>进程(Process)</strong>是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。</p><p>多个进程之间可以并发执行和交换信息。一个进程在运行时需要一定的资源，如CPU、存储空间及I/O 设备等。</p><p>通常在一个进程中可以包含若干个<strong>线程(Threads)</strong>，它们可以利用进程所拥有的资源。</p><p>在引入线程的OS中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。</p><p>由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效地提高系统内多个程序间并发执行的程度。</p><p>2、共享性</p><p>在操作系统环境下，所谓共享(Sharing)，是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用，相应地，把这种资源共同使用称为资源共享，或称为资源复用。</p><p>目前主要实现资源共享的方式有两种，即互斥共享方式和访问方式。</p><p>3、虚拟技术</p><p>操作系统中的所谓“虚拟”(Virtual)，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。</p><p>在操作系统中利用了两种方式实现虚拟技术，即时分复用技术和空分复用技术。</p><p>4、异步性</p><p>在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。</p><p>进程是以人们不可预知的速度向前推进，此即进程的异步性(Asynchronism)。</p><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><p>操作系统的主要任务，是为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率和方便用户的使用。为实现上述任务，操作系统应具有这样几方面的功能：处理机管理，存储器管理，设备管理和文件管理。</p><p>为了方便用户使用操作系统，还须向用户提供方便的用户接口。此外为了方便计算机联网，又在OS中增加了面向网络的服务功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还要几天才能回家，就先看看计算机操作系统概论的内容
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="《计算机操作系统》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（六）</title>
    <link href="http://www.wshunli.com/posts/9c05eee5.html"/>
    <id>http://www.wshunli.com/posts/9c05eee5.html</id>
    <published>2018-01-22T02:44:25.000Z</published>
    <updated>2018-03-17T17:17:52.768Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】生活是一条路，走走停停，停停走走
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK 开发入门</title>
    <link href="http://www.wshunli.com/posts/3eae2406.html"/>
    <id>http://www.wshunli.com/posts/3eae2406.html</id>
    <published>2018-01-19T13:00:14.000Z</published>
    <updated>2018-03-17T17:17:52.760Z</updated>
    
    <content type="html"><![CDATA[<p>Android NDK 是一套允许您使用原生代码语言（例如 C 和 C++）实现部分应用的工具集。<a id="more"></a>在开发某些类型应用时，这有助于您重复使用以这些语言编写的代码库。</p><p>那我们为什么要使用 NDK 呢?</p><ul><li>代码的保护。由于 apk 的 Java 层代码很容易被反编译，而 C/C++ 库反汇难度较大。</li><li>可以方便地使用现存的开源库。大部分现存的开源库都是 用C/C++ 代码编写的。</li><li>提高程序的执行效率。将要求高性能的应用逻辑使用 C 开发，从而提高应用程序的执行效率。</li><li>便于移植。用 C/C++ 写得库可以方便在其他的嵌入式平台上再次使用。</li></ul><p>上述文字致谢 <a href="http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html" rel="external nofollow noopener noreferrer" target="_blank">Devin Zhang</a> 提供理论支持</p><p>本文默认已配置好 Android 开发环境，<br>关于 Android 开发环境配置可参考：<a href="http://www.wshunli.com/posts/f6977dbb.html">http://www.wshunli.com/posts/f6977dbb.html</a></p><h1 id="NDK-环境配置"><a href="#NDK-环境配置" class="headerlink" title="NDK 环境配置"></a>NDK 环境配置</h1><p>1、首先应该下载 NDK</p><p>官方指定的下载地址：<a href="https://developer.android.google.cn/ndk/downloads/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.google.cn/ndk/downloads/index.html</a></p><p>可能因为网络原因打不开，而且我们也不要那么新的。</p><p>本文以 Android NDK r10e 版本为例：</p><p>下载地址：<a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" rel="external nofollow noopener noreferrer" target="_blank">https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip</a></p><p>下载好之后，解压即可，我们解压到：<code>D:\Android\android-ndk-r10e</code></p><p>2、和配置 Android 环境类似，配置 NDK 环境</p><p>新建变量：<code>ANDROID_NDK</code></p><pre><code class="TXT">D:\Android\android-ndk-r10e</code></pre><p>在 <code>Path</code> 中添加</p><pre><code class="TXT">%ANDROID_NDK%</code></pre><p>3、验证 NDK 环境</p><p>在 命令控制符 中输入 <code>ndk-build -version</code> 存在输出即可。</p><h1 id="第一个-Android-NDK-项目"><a href="#第一个-Android-NDK-项目" class="headerlink" title="第一个 Android NDK 项目"></a>第一个 Android NDK 项目</h1><p>在 Android Studio 中新建 Android NDK 项目特别简单，</p><p>只需在新建项目时，勾选 <code>include C++ support</code> 即可：</p><p><img src="https://img.wshunli.com/Android/NDK/1.新建NDK项目.png" alt="1.新建NDK项目.png"></p><p>点击运行即可看到效果：</p><p><img src="https://img.wshunli.com/Android/NDK/1.Screenshot_1516414188.png-hexo.png" alt="1.Screenshot_1516414188.png"></p><h1 id="向现有项目添加-C-C-代码"><a href="#向现有项目添加-C-C-代码" class="headerlink" title="向现有项目添加 C/C++ 代码"></a>向现有项目添加 C/C++ 代码</h1><p>如果您希望向现有项目添加原生代码，请执行以下步骤：</p><p>1、<a href="#创建新的原生源文件">创建新的原生源文件</a>并将其添加到您的 Android Studio 项目中。</p><p>如果您已经拥有原生代码或想要导入预构建的原生库，则可以跳过此步骤。</p><p>2、<a href="#创建CMake构建脚本">创建 CMake 构建脚本</a>，将您的原生源代码构建到库中。如果导入和关联预构建库或平台库，您也需要此构建脚本。</p><p>如果您的现有原生库已经拥有 <code>CMakeLists.txt</code> 构建脚本或者使用 ndk-build 并包含 Android.mk 构建脚本，则可以跳过此步骤。</p><p>3、提供一个指向您的 CMake 或 ndk-build 脚本文件的路径，<a href="#将Gradle关联到您的原生库">将 Gradle 关联到您的原生库</a>。Gradle 使用构建脚本将源代码导入您的 Android Studio 项目并将原生库（SO 文件）打包到 APK 中。</p><h2 id="创建新的原生源文件"><a href="#创建新的原生源文件" class="headerlink" title="创建新的原生源文件"></a>创建新的原生源文件</h2><p>1、选择 Project 视图，在 main 目录下，新建 cpp 文件夹；</p><p>2、在 cpp 文件夹下新建 C/C++ Source File ，本文以 <code>native-lib</code> 为例。</p><p><img src="https://img.wshunli.com/Android/NDK/1.创建新的原生源文件.png" alt="1.创建新的原生源文件.png"></p><h2 id="创建CMake构建脚本"><a href="#创建CMake构建脚本" class="headerlink" title="创建CMake构建脚本"></a>创建CMake构建脚本</h2><p>CMake 构建脚本是一个纯文本文件，您必须将其命名为 CMakeLists.txt。</p><p>在 Android 视图下，在 app 模块下右键，新建 File，文件名为 <code>CMakeLists.txt</code>。</p><p>文件内容如下：</p><pre><code class="TXT"># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# 指示 CMake 从原生源代码创建一个原生库add_library( # Sets the name of the library.             native-lib             # Sets the library as a shared library.             SHARED             # Provides a relative path to your source file(s).             src/main/cpp/native-lib.cpp )# 添加引用 NDK 库find_library( # Sets the name of the path variable.              log-lib              # Specifies the name of the NDK library that              # you want CMake to locate.              log )# 关联 NDK 库target_link_libraries( # Specifies the target library.                       native-lib                       # Links the target library to the log library                       # included in the NDK.                       ${log-lib} )</code></pre><h2 id="将Gradle关联到您的原生库"><a href="#将Gradle关联到您的原生库" class="headerlink" title="将Gradle关联到您的原生库"></a>将Gradle关联到您的原生库</h2><p>在 Android 视图下，右键点击您想要关联到原生库的模块（例如 app 模块），并从菜单中选择 <code>Link C++ Project with Gradle</code>。</p><p><img src="https://img.wshunli.com/Android/NDK/1.将Gradle关联到您的原生库.png" alt="1.将Gradle关联到您的原生库.png"></p><p>或者手动配置：</p><pre><code class="Gradle">android {  ...  defaultConfig {...}  buildTypes {...}  // Encapsulates your external native build configurations.  externalNativeBuild {    // Encapsulates your CMake build configurations.    cmake {      // Provides a relative path to your CMake build script.      path &quot;CMakeLists.txt&quot;    }  }}</code></pre><p>可选配置，可以包裹一些特定的示例代码：</p><pre><code class="Gradle">android {    compileSdkVersion 26    defaultConfig {        ···        externalNativeBuild {            cmake {                cppFlags &quot;-frtti -fexceptions&quot;            }        }        ndk {            // Specifies the ABI configurations of your native            // libraries Gradle should build and package with your APK.            abiFilters &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;        }    }</code></pre><p>最后运行即可，效果是一样的。</p><h1 id="添加-native-方法流程"><a href="#添加-native-方法流程" class="headerlink" title="添加 native 方法流程"></a>添加 native 方法流程</h1><p>在 <code>MainActivity</code> 中添加 native 方法：</p><pre><code class="Java">    public native void printLog();</code></pre><p>在 <code>native-lib.cpp</code> 中添加头文件及宏定义</p><pre><code class="C">#include &lt;android/log.h&gt;#define TAG &quot;native-lib&quot;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, TAG, __VA_ARGS__)</code></pre><p>实现 native 方法，我们这里打印个日志：</p><pre><code class="C">extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_wshunli_android_ndk_demo_MainActivity_printLog(JNIEnv *env, jobject instance) {    LOGV(&quot;log from native&quot;);}</code></pre><p>这个方法可以自动生成，在 native 方法下 <code>Alt + Enter</code> 即可。</p><p>本文源码：<a href="https://github.com/wshunli/android-ndk-demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/android-ndk-demo</a></p><blockquote><p>参考资料<br>1、Android NDK | Android Developers<br><a href="https://developer.android.com/ndk/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/ndk/index.html</a><br>2、Android-NDK入门-慕课网<br><a href="https://www.imooc.com/learn/411" rel="external nofollow noopener noreferrer" target="_blank">https://www.imooc.com/learn/411</a><br>3、Android-NDK进阶-慕课网<br><a href="https://www.imooc.com/learn/918" rel="external nofollow noopener noreferrer" target="_blank">https://www.imooc.com/learn/918</a><br>4、Android NDK开发(一) 入门 - 简书<br><a href="https://www.jianshu.com/p/0261e6cceb3e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0261e6cceb3e</a><br>5、向您的项目添加 C 和 C++ 代码 | Android Studio<br><a href="https://developer.android.com/studio/projects/add-native-code.html?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/studio/projects/add-native-code.html?hl=zh-cn</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android NDK 是一套允许您使用原生代码语言（例如 C 和 C++）实现部分应用的工具集。
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="NDK" scheme="http://www.wshunli.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android图片加载框架Glide简单使用</title>
    <link href="http://www.wshunli.com/posts/d82d8606.html"/>
    <id>http://www.wshunli.com/posts/d82d8606.html</id>
    <published>2018-01-19T12:14:17.000Z</published>
    <updated>2018-03-17T17:17:52.760Z</updated>
    
    <content type="html"><![CDATA[<p>Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。<a id="more"></a>Glide 提供了易用的 API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p><h1 id="Glide-介绍"><a href="#Glide-介绍" class="headerlink" title="Glide 介绍"></a>Glide 介绍</h1><p>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</p><p>虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。</p><h1 id="Glide-简单使用"><a href="#Glide-简单使用" class="headerlink" title="Glide 简单使用"></a>Glide 简单使用</h1><p>0、添加 Glide 依赖</p><pre><code class="gradle">dependencies {  implementation &#39;com.github.bumptech.glide:glide:4.5.0&#39;  annotationProcessor &#39;com.github.bumptech.glide:compiler:4.5.0&#39;}</code></pre><p>1、准备图片容器</p><p>我们在布局文件中添加 ImageView 控件：</p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#8f8f8f&quot;    tools:context=&quot;com.wshunli.glidedemo.MainActivity&quot;&gt;    &lt;Button        android:id=&quot;@+id/bt&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;@string/app_name&quot; /&gt;    &lt;ImageView        android:id=&quot;@+id/img&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>2、加载图片</p><p>我们以加载 <a href="https://img.wshunli.com/Android/Glide/Glide.min.png" rel="external nofollow noopener noreferrer" target="_blank">https://img.wshunli.com/Android/Glide/Glide.min.png</a> 为例。</p><pre><code class="Java">Glide.with(MainActivity.this)        .load(&quot;https://img.wshunli.com/Android/Glide/Glide.min.png&quot;)        .into(img);</code></pre><p>真的超级简单。</p><p>MainActivity 完整代码如下：</p><pre><code class="Java">package com.wshunli.glidedemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.ImageView;import com.bumptech.glide.Glide;public class MainActivity extends AppCompatActivity {    private ImageView img;    private Button bt;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        img = findViewById(R.id.img);        bt = findViewById(R.id.bt);        bt.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Glide.with(MainActivity.this)                        .load(&quot;https://img.wshunli.com/Android/Glide/Glide.min.png&quot;)                        .into(img);            }        });    }}</code></pre><p>注意别忘了声明权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></pre><p>3、取消加载图片</p><pre><code class="Java">Glide.with(MainActivity.this).clear(img);</code></pre><p>取消加载也超级简单。</p><p>4、最终加载效果</p><p><img src="https://img.wshunli.com/Android/Glide/Screenshot_1516366180.png-hexo.png" alt="Glide加载图图片"></p><h1 id="ProGuard-混淆规则"><a href="#ProGuard-混淆规则" class="headerlink" title="ProGuard 混淆规则"></a>ProGuard 混淆规则</h1><pre><code class="gradle">-keep public class * implements com.bumptech.glide.module.GlideModule-keep public class * extends com.bumptech.glide.module.AppGlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {  **[] $VALUES;  public *;}# for DexGuard only-keepresourcexmlelements manifest/application/meta-data@value=GlideModule</code></pre><blockquote><p>参考资料<br>1、bumptech/glide: An image loading and caching library for Android focused on smooth scrolling<br><a href="https://github.com/bumptech/glide" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/bumptech/glide</a><br>2、Android图片加载框架最全解析（一），Glide的基本用法 - 郭霖的专栏 - CSDN博客<br><a href="http://blog.csdn.net/guolin_blog/article/details/53759439" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/guolin_blog/article/details/53759439</a><br>3、Glide v4 : 快速高效的Android图片加载库<br><a href="https://muyangmin.github.io/glide-docs-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://muyangmin.github.io/glide-docs-cn/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="Glide" scheme="http://www.wshunli.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Android注入框架Butter Knife使用入门</title>
    <link href="http://www.wshunli.com/posts/896cb4b5.html"/>
    <id>http://www.wshunli.com/posts/896cb4b5.html</id>
    <published>2018-01-18T04:54:15.000Z</published>
    <updated>2018-03-17T17:17:52.760Z</updated>
    
    <content type="html"><![CDATA[<p>Butter Knife 是一个专注于 Android 系统的 View 注入框架<a id="more"></a>，可以减少大量的 findViewById 以及 setOnClickListener 代码，可视化一键生成。</p><h1 id="Butter-Knife-概述"><a href="#Butter-Knife-概述" class="headerlink" title="Butter Knife 概述"></a>Butter Knife 概述</h1><p>1.强大的View绑定和Click事件处理功能，简化代码，提升开发效率<br>2.方便的处理Adapter里的ViewHolder绑定问题<br>3.运行时不会影响APP效率，使用配置方便<br>4.代码清晰，可读性强</p><h1 id="Butter-Knife-上手使用"><a href="#Butter-Knife-上手使用" class="headerlink" title="Butter Knife 上手使用"></a>Butter Knife 上手使用</h1><p>0、首先为项目添加 Butter Knife 依赖：</p><pre><code class="gradle">dependencies {  compile &#39;com.jakewharton:butterknife:8.8.1&#39;  annotationProcessor &#39;com.jakewharton:butterknife-compiler:8.8.1&#39;}</code></pre><p>1、简单使用示例:</p><p>首先在 onCreate 绑定 Activity 实例。</p><pre><code class="Java">package com.wshunli.butterknifedemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.Button;import android.widget.Toast;import butterknife.BindString;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;public class MainActivity extends AppCompatActivity {    @BindView(R.id.button)    Button button;    @BindString(R.string.app_name)    String appName;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ButterKnife.bind(this);    }    @OnClick(R.id.button)    void clickButton() {        Toast.makeText(this, appName, Toast.LENGTH_LONG).show();    }}</code></pre><p>其中：<code>@BindView</code> 根据控件 id 绑定；<code>@BindString</code> 绑定资源中的字符串；<code>@OnClick</code> 绑定按钮的单击事件。</p><p>3、最终效果：</p><p>点击按钮，显示app名称。</p><p><img src="https://img.wshunli.com/Android/ButterKnife/Screenshot_1516251143.png-hexo.png" alt="最终效果"></p><h1 id="Butter-Knife-方法详解"><a href="#Butter-Knife-方法详解" class="headerlink" title="Butter Knife 方法详解"></a>Butter Knife 方法详解</h1><p>1、绑定 Activity 和 Fragment</p><p>在 onCreate 中绑定 Activity</p><pre><code class="Java">@Override public void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.simple_activity);    ButterKnife.bind(this);    // TODO Use fields...  }</code></pre><p>在 onCreateView 中绑定 Fragment</p><pre><code class="Java"> @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {    View view = inflater.inflate(R.layout.fancy_fragment, container, false);    ButterKnife.bind(this, view);    // TODO Use fields...    return view;  }</code></pre><p>2、绑定布局中的 View</p><pre><code class="Java">  @BindView(R.id.title) TextView title;  @BindView(R.id.subtitle) TextView subtitle;  @BindView(R.id.footer) TextView footer;</code></pre><p>3、在 Adapter ViewHolder 中绑定 View</p><pre><code class="Java">  static class ViewHolder {    @BindView(R.id.title) TextView name;    @BindView(R.id.job_title) TextView jobTitle;    public ViewHolder(View view) {      ButterKnife.bind(this, view);    }  }</code></pre><p>4、绑定资源</p><pre><code class="Java">  @BindString(R.string.title) String title;  @BindDrawable(R.drawable.graphic) Drawable graphic;  @BindColor(R.color.red) int red; // int or ColorStateList field  @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field  // ...</code></pre><p>5、绑定方法</p><pre><code class="Java">@OnClick(R.id.submit)public void submit() {  // TODO submit data to server...}</code></pre><p>或者</p><pre><code class="Java">@OnClick(R.id.submit)public void submit(View view) {  // TODO submit data to server...}</code></pre><p>甚至自动类型转换：</p><pre><code class="Java">@OnClick(R.id.submit)public void sayHi(Button button) {  button.setText(&quot;Hello!&quot;);}</code></pre><p>多个 View 绑定同一个事件：</p><pre><code class="Java">@OnClick({ R.id.door1, R.id.door2, R.id.door3 })public void pickDoor(DoorView door) {  if (door.hasPrizeBehind()) {    Toast.makeText(this, &quot;You win!&quot;, LENGTH_SHORT).show();  } else {    Toast.makeText(this, &quot;Try again&quot;, LENGTH_SHORT).show();  }}</code></pre><p>本文内容基于 Butter Knife 8.8.1 ，时间原因部分方法可能过时，最新版可参考 <a href="http://jakewharton.github.io/butterknife/" rel="external nofollow noopener noreferrer" target="_blank">http://jakewharton.github.io/butterknife/</a></p><blockquote><p>参考资料<br>1、JakeWharton/butterknife: Bind Android views and callbacks to fields and methods.<br><a href="https://github.com/JakeWharton/butterknife" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/JakeWharton/butterknife</a><br>2、ButterKnife使用详解 - ITjianghuxiaoxiong的专栏 - CSDN博客<br><a href="http://blog.csdn.net/itjianghuxiaoxiong/article/details/50177549" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/itjianghuxiaoxiong/article/details/50177549</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Butter Knife 是一个专注于 Android 系统的 View 注入框架
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="ButterKnife" scheme="http://www.wshunli.com/tags/ButterKnife/"/>
    
  </entry>
  
  <entry>
    <title>Android事件总线EventBus使用总结</title>
    <link href="http://www.wshunli.com/posts/6a115a99.html"/>
    <id>http://www.wshunli.com/posts/6a115a99.html</id>
    <published>2018-01-17T04:36:06.000Z</published>
    <updated>2018-03-17T17:17:52.760Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus是一款针对Android优化的<strong>发布/订阅</strong>事件总线<a id="more"></a>，简化了应用程序内各组件间、组件与后台线程间的通信。</p><p><img src="https://img.wshunli.com/Android/EventBus/EventBus-Publish-Subscribe.min.png" alt="EventBus 发布订阅模式"></p><p>主要是替代 handler BroadCast 在 Fragment 、Activity 、Service 线程之间传递消息。</p><h1 id="EventBus-概述"><a href="#EventBus-概述" class="headerlink" title="EventBus 概述"></a>EventBus 概述</h1><p>1、EventBus 有三个主要的元素：</p><ul><li>Event：事件，可以是任意类型的对象。</li><li>Subscriber：事件订阅者，<del>在EventBus3.0之前消息处理的方法只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，他们分别代表四种线程模型</del>。而在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING），四种线程模型下面会讲到。</li><li>Publisher：事件发布者，可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法。可以自己实例化EventBus对象，但一般使用EventBus.getDefault()就好了，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</li></ul><p>2、EventBus3.0有以下四种ThreadMode（线程模型）：</p><ul><li>POSTING（默认）：<strong>发布事件和接收事件在同一个线程</strong>，也就是说该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行。</li><li>MAIN: 事件的处理<strong>总是在UI线程</strong>中执行。</li><li>ASYNC：无论事件在哪个线程发布，该事件处理函数<strong>总是在新建的子线程</strong>中执行，同样，此事件处理函数中禁止进行UI更新操作。</li><li>BACKGROUND：如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。</li></ul><h1 id="EventBus-快速入门"><a href="#EventBus-快速入门" class="headerlink" title="EventBus 快速入门"></a>EventBus 快速入门</h1><p>0、首先为项目添加 EventBus 依赖：</p><pre><code class="gradle">compile &#39;org.greenrobot:eventbus:3.1.1&#39;</code></pre><p>1、定义事件类:</p><pre><code class="java">public static class MessageEvent { /* Additional fields if needed */ }</code></pre><p>2、准备订阅者:</p><pre><code class="java">@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent event) {/* Do something */};</code></pre><p>3、发送事件:</p><pre><code class="java">EventBus.getDefault().post(new MessageEvent());</code></pre><h1 id="EventBus-实际应用"><a href="#EventBus-实际应用" class="headerlink" title="EventBus 实际应用"></a>EventBus 实际应用</h1><p>这里举例子具体介绍 EventBus 的用法，实现Activity之间传值。</p><p>1、定义消息事件类</p><pre><code class="java">package com.wshunli.eventbusdemo;public class MessageEvent {    private String message;    public MessageEvent(String message) {        this.message = message;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }    @Override    public String toString() {        return &quot;MessageEvent{&quot; +                &quot;message=&#39;&quot; + message + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>2、注册和取消订阅事件</p><p>根据组件的声明周期，在 MainActivity.java 中注册/取消订阅事件。</p><pre><code class="java">package com.wshunli.eventbusdemo;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;import android.widget.Toast;import org.greenrobot.eventbus.EventBus;import org.greenrobot.eventbus.Subscribe;import org.greenrobot.eventbus.ThreadMode;public class MainActivity extends AppCompatActivity {    private TextView textView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        // 注册订阅事件        EventBus.getDefault().register(this);        // 跳转到 SecondActivity        findViewById(R.id.bt).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                startActivity(new Intent(MainActivity.this, SecondActivity.class));            }        });        textView = findViewById(R.id.text);    }    @Override    protected void onDestroy() {        super.onDestroy();        // 取消订阅事件        EventBus.getDefault().unregister(this);    }}</code></pre><p>3、添加消息处理函数</p><p>在 MainActivity.java 中添加事件的处理函数：</p><pre><code class="java">    @Subscribe(threadMode = ThreadMode.MAIN)    public void onMessageEvent(MessageEvent event) {        textView.setText(String.format(&quot;接收到发送的事件：%s&quot;, event.getMessage()));    }</code></pre><p>我们选择 <code>threadMode = ThreadMode.MAIN</code> 表示总是在 <strong>主线程</strong> 中执行。</p><p>4、发布事件</p><p>在 SecondActivity 中发布事件：</p><pre><code class="java">package com.wshunli.eventbusdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import org.greenrobot.eventbus.EventBus;public class SecondActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_second);        findViewById(R.id.bt).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                EventBus.getDefault().post(new MessageEvent(&quot;来自SecondActivity的消息&quot;));                finish();            }        });    }}</code></pre><p>5、接收到消息</p><p>在 MainActivity 接受到来自 SecondActivity 中发送的消息：</p><p><img src="https://img.wshunli.com/Android/EventBus/Screenshot_1516247350.png-hexo.png" alt="EventBus消息"></p><h1 id="ProGuard-混淆规则"><a href="#ProGuard-混淆规则" class="headerlink" title="ProGuard 混淆规则"></a>ProGuard 混淆规则</h1><pre><code class="gradle">-keepattributes *Annotation*-keepclassmembers class ** {    @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;}-keep enum org.greenrobot.eventbus.ThreadMode { *; }# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {    &lt;init&gt;(java.lang.Throwable);}</code></pre><blockquote><p>参考资料<br>1、greenrobot/EventBus: Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.<br><a href="https://github.com/greenrobot/EventBus" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/greenrobot/EventBus</a><br>2、Android事件总线（一）EventBus3.0用法全解析 - 刘望舒的专栏 - CSDN博客<br><a href="http://blog.csdn.net/itachi85/article/details/52205464" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/itachi85/article/details/52205464</a><br>3、EventBus 3.0的用法详解（一） - neu - SegmentFault<br><a href="https://segmentfault.com/a/1190000004279679" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000004279679</a><br>4、Android事件分发库的使用-慕课网<br><a href="https://www.imooc.com/learn/871" rel="external nofollow noopener noreferrer" target="_blank">https://www.imooc.com/learn/871</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus是一款针对Android优化的&lt;strong&gt;发布/订阅&lt;/strong&gt;事件总线
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="EventBus" scheme="http://www.wshunli.com/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>ClassNotFoundException</title>
    <link href="http://www.wshunli.com/posts/774f73e1.html"/>
    <id>http://www.wshunli.com/posts/774f73e1.html</id>
    <published>2018-01-10T12:23:30.000Z</published>
    <updated>2018-03-17T17:17:52.760Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ClassNotFoundException</strong> 是 java.lang.ClassNotFoundException 的简称<a id="more"></a>，是 Java 语言中的一个异常类，位于 java.lang 包中，父类是 java.lang.ReflectiveOperationException ，该异常指找不到指定的 Class。</p><p>常见的场景就是：</p><p>1 调用class的forName方法时，找不到指定的类。<br>2 ClassLoader 中的 findSystemClass() 方法时，找不到指定的类。<br>3 ClassLoader 中的 loadClass() 方法时，找不到指定的类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ClassNotFoundException&lt;/strong&gt; 是 java.lang.ClassNotFoundException 的简称
    
    </summary>
    
      <category term="技术分享" scheme="http://www.wshunli.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="ClassNotFoundException" scheme="http://www.wshunli.com/tags/ClassNotFoundException/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 从入门到放弃：Hello Spring Boot !</title>
    <link href="http://www.wshunli.com/posts/b93d59e.html"/>
    <id>http://www.wshunli.com/posts/b93d59e.html</id>
    <published>2018-01-05T03:19:35.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 入门 Hello Spring Boot !</p><a id="more"></a><p>前面在师兄的带领下，基于 nodejs 写了机房管理系统后端，也根据需要实现了简单三维重建的后端服务。<br>但是总感觉怪怪的，前者基于 Eggjs 后端框架，后者基于 Express 后端框架，好像跟 Java 没啥关系啊。</p><p>这几天刻意学习下 Spring Boot 后端框架，并把三维重建服务后端重写了。下面记录下学习过程。</p><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><p>Spring Boot 可以使用 Maven 或 Gradle 这样的构建系统，本文是基于 Maven（现在用得比较多，其实我更熟悉Gradle）。</p><h2 id="Spring-Boot-特性"><a href="#Spring-Boot-特性" class="headerlink" title="Spring Boot 特性"></a>Spring Boot 特性</h2><p>Spring将很多魔法带入了 Spring 应用程序的开发之中，其中最重要的是以下四个核心。</p><ul><li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置。</li><li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li><li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。</li><li>Actuator：让你能够深入运行中的Spring Boot应用程序，一探究竟。</li></ul><h2 id="Spring-Boot-环境"><a href="#Spring-Boot-环境" class="headerlink" title="Spring Boot 环境"></a>Spring Boot 环境</h2><p>首先 Spring Boot 需要 java 环境，需要使用 Gradle 2.3+ 或者 Maven 3.0+ 构建。</p><p>本文环境是 Java 1.8，Spring Boot (v1.5.9.RELEASE) 以及 Maven3.3.9 构建。开发工具使用 IntelliJ IDEA。</p><h1 id="初始化Spring-Boot项目"><a href="#初始化Spring-Boot项目" class="headerlink" title="初始化Spring Boot项目"></a>初始化Spring Boot项目</h1><p>本文使用 Spring Initializr 初始化 Spring Boot项目。</p><h2 id="通过-Spring-官网"><a href="#通过-Spring-官网" class="headerlink" title="通过 Spring 官网"></a>通过 Spring 官网</h2><p>1、打开 <a href="http://start.spring.io/" rel="external nofollow noopener noreferrer" target="_blank">http://start.spring.io/</a></p><p>2、选择构建工具 Maven Project、Spring Boot版本1.5.9 以及一些依赖，输入 Web 即可，如下图所示：</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/1.png" alt="初始化Spring Boot项目"></p><p>3、点击 <code>Generate Project</code> 即可下载项目压缩包</p><h2 id="通过IntelliJ-IDEA"><a href="#通过IntelliJ-IDEA" class="headerlink" title="通过IntelliJ IDEA"></a>通过IntelliJ IDEA</h2><p>1、在 IntelliJ IDEA 中新建项目，选择 Spring Initializr ，如下图所示：</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/2.png" alt="初始化Spring Boot项目2"></p><p>2、配置项目的基本信息</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/3.png" alt="初始化Spring Boot项目3"></p><p>3、配置项目的依赖，这里选择添加 Web 模块</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/4.png" alt="初始化Spring Boot项目4"></p><p>4、设置项目存储位置</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/5_1.png" alt="初始化Spring Boot项目5"></p><p>初始化Spring Boot项目完成</p><h2 id="Spring-Boot-项目结构"><a href="#Spring-Boot-项目结构" class="headerlink" title="Spring Boot 项目结构"></a>Spring Boot 项目结构</h2><p>Spring Boot 项目 初始化完成后，项目如下图所示：</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/6.png" alt="Spring Boot 项目结构"></p><p>SpringBootDemoApplication 是 Spring Boot 的程序的入口。</p><p>我们添加 <code>@RestController</code> 注解，及 <code>home()</code> 方法</p><pre><code class="Java">package com.wshunli.spring.boot.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class SpringBootDemoApplication {    @RequestMapping(&quot;/&quot;)    String home() {        return &quot;Hello Spring Boot !&quot;;    }    public static void main(String[] args) {        SpringApplication.run(SpringBootDemoApplication.class, args);    }}</code></pre><h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><p>1、可以在 IntelliJ IDEA 中点击 run 按钮启动应用。</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/7.png" alt="Spring Boot 项目启动"></p><p>2、也可以在项目根目录使用 <code>mvnw spring-boot:run</code> 命令。</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/8.png" alt="Spring Boot 项目启动"></p><p>如果提示无法识别 <code>mvnw</code> 命令，可改为 <code>.\mvnw spring-boot:run</code></p><p>3、使用 <code>mvnw clean package</code> 命令打包后启动</p><p><img src="https://img.wshunli.com/SpringBoot/1HelloSpringBoot/9.png" alt="Spring Boot 项目启动"></p><p>再执行一下命令启动：</p><pre><code class="bash">java -jar  target/demo-0.0.1-SNAPSHOT.jar</code></pre><p>其中 <code>demo-0.0.1-SNAPSHOT.jar</code> 替换为自己的 jar 包名字。</p><p>最后 打开 <a href="http://127.0.0.1:8080/" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/</a> 即可看到 <code>Hello Spring Boot !</code></p><p>本文源码：<a href="https://github.com/wshunli/spring-boot-demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/spring-boot-demo</a></p><blockquote><p>参考资料<br>1、Getting Started · Building an Application with Spring Boot<br><a href="https://spring.io/guides/gs/spring-boot/" rel="external nofollow noopener noreferrer" target="_blank">https://spring.io/guides/gs/spring-boot/</a><br>2、Spring Boot干货系列：（一）优雅的入门篇 | 嘟嘟独立博客<br><a href="http://tengj.top/2017/02/26/springboot1/" rel="external nofollow noopener noreferrer" target="_blank">http://tengj.top/2017/02/26/springboot1/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot 入门 Hello Spring Boot !&lt;/p&gt;
    
    </summary>
    
      <category term="后端技术" scheme="http://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.wshunli.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.wshunli.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>2017年终总结，我这一年的点点滴滴</title>
    <link href="http://www.wshunli.com/posts/33b6fcdd.html"/>
    <id>http://www.wshunli.com/posts/33b6fcdd.html</id>
    <published>2017-12-30T13:37:12.000Z</published>
    <updated>2018-03-17T17:17:52.760Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】 深自缄默，如云漂泊
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="年终总结" scheme="http://www.wshunli.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/fba26489.html"/>
    <id>http://www.wshunli.com/posts/fba26489.html</id>
    <published>2017-12-27T07:05:30.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 Service</p><a id="more"></a><h1 id="第10章-后台默默的劳动者"><a href="#第10章-后台默默的劳动者" class="headerlink" title="第10章 后台默默的劳动者"></a>第10章 后台默默的劳动者</h1><p>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。</p><p>服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。</p><h2 id="Android-多线程编程"><a href="#Android-多线程编程" class="headerlink" title="Android 多线程编程"></a>Android 多线程编程</h2><p>Android 多线程 和 Java 多线程基本相同。</p><p>定义一个线程只需要新建一个类继承自 Thread 或者 实现 Runnable 接口，然后重写或者实现 run() 方法。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {      // 异步操作    }}).start();</code></pre><p>1、Service 与 Thread 的区别：</p><p>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。<br>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。<br>Thread 是程序执行的最小单元，可以用 Thread 来执行一些异步的操作。</p><p><a href="http://blog.csdn.net/wei_chong_chong/article/details/52251193" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/wei_chong_chong/article/details/52251193</a></p><p>2、在子线程中更新 UI</p><p>(1) Activity 的 runOnUiThread() 方法</p><pre><code class="Java">runOnUiThread(new Runnable() {    @Override    public void run() {        // 更新 UI 操作    }});</code></pre><p>(2) View.post(Runnable r)</p><pre><code class="Java">textView.post(new Runnable() {    @Override    public void run() {        // 更新 UI 操作    }});</code></pre><p>其中 <code>textView</code> 可替换为其他 View 。</p><p>(3) Handler</p><p>新建 Handler 对象，重写 handleMessage() 方法，对 Message 进行处理。</p><pre><code class="Java">private Handler handler = new Handler() {    public void handleMessage(Message msg) {        switch (msg.what) {            case UPDATE_TEXT:                textView.setText(&quot;Nice to meet you!&quot;);        }    }};</code></pre><p>在子线程中使用 Hander 对象发送 Message 对象即可。</p><pre><code class="Java">Message message = new Message();message.what = UPDATE_TEXT;handler.sendMessage(message);</code></pre><p>3、异步消息处理机制</p><p>Message：消息，其中包含了消息ID，消息处理对象及处理的数据等，由MessageQueue统一列队，终由 Handler 处理。<br>Handler：处理者，负责 Message 的发送及处理。使用 Handler 时，需要实现 handleMessage(Message msg) 方法来对特定的 Message 进行处理，例如更新 UI 等。<br>MessageQueue：消息队列，用来存放 Handler 发送过来的消息，并按照 FIFO 规则执行。当然，存放 Message 并非实际意义的保存，而是将 Message 以链表的方式串联起来的，等待 Looper 的抽取。<br>Looper：消息泵，不断地从 MessageQueue 中抽取 Message 执行。因此，一个 MessageQueue 需要一个 Looper。</p><p><strong>Handler 的工作机制</strong>简单来说是这样的：</p><p>首先在主线程中新建 Handler 对象，并重写 handleMessage() 方法。然后当子线程中想更新 UI 时，就创建一个 Message 对象，并通过 Handler 将消息发送出去。之后消息会被添加到 MessageQueue 中等待被处理，而 Looper 则会一直尝试从 MessageQueue 中取出待处理的消息，最后分发回 Handler 的 handlerMessage() 方法中。</p><p><img src="https://img.wshunli.com/Android/第一行代码/3.Handler.png" alt="Handler"></p><p><a href="https://www.jianshu.com/p/9e4d1fab0f36" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/9e4d1fab0f36</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p><p>4、AsyncTask 的基本用法</p><p>AsyncTask 是一个抽象类，我们创建一个子类继承它。</p><p>AsyncTask 可以指定三个泛型参数：</p><p>(1) Params，在执行 AsyncTask 时需要传入的参数。<br>(2) Progress，后台计算过程中的进度单元类型。<br>(3) Result，后台运行的结果类型。</p><pre><code class="Java">private class AsyncTaskDemo extends AsyncTask&lt;Void, Integer, Boolean&gt; {    @Override    protected Boolean doInBackground(Void... voids) {        return true;    }}</code></pre><p>AsyncTask 常用的方法：</p><p><code>onPreExecute()</code> 此方法会在后台任务执行前被调用，用于进行一些准备工作。<br><code>doInBackground(Params… params)</code> 此方法中定义要执行的后台任务，在这个方法中可以调用 publishProgress() 来更新任务进度（publishProgress 内部会调用 onProgressUpdate 方法）。<br><code>onProgressUpdate(Progress… values)</code> 由 publishProgress() 内部调用，表示任务进度更新。<br><code>onPostExecute(Result result)</code> 后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果。<br><code>onCancelled()</code> 此方法会在后台任务被取消时被调用。</p><h2 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h2><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>要创建服务，您必须创建 Service 的子类（或使用它的一个现有子类），并且在使用清单文件声明服务。</p><pre><code class="Java">public class HelloService extends Service {    public HelloService() {    }    @Override    public IBinder onBind(Intent intent) {        // TODO: Return the communication channel to the service.        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);    }}</code></pre><h3 id="启动及停止服务"><a href="#启动及停止服务" class="headerlink" title="启动及停止服务"></a>启动及停止服务</h3><p>通过将 Intent（指定要启动的服务）传递给 startService()，从 Activity 或其他应用组件启动服务。Android 系统调用服务的 onStartCommand() 方法，并向其传递 Intent。（切勿直接调用 onStartCommand()。）</p><pre><code class="Java">Intent intent = new Intent(this, HelloService.class);startService(intent);</code></pre><p>服务必须通过调用 stopSelf() 自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。<br>一旦请求使用 stopSelf() 或 stopService() 停止服务，系统就会尽快销毁服务。</p><pre><code class="Java">Intent intent = new Intent(this, HelloService.class);stopService(intent);</code></pre><h3 id="活动与服务进行通信"><a href="#活动与服务进行通信" class="headerlink" title="活动与服务进行通信"></a>活动与服务进行通信</h3><p>Activity 与 Service 进行通信可以通过创建 Binder 对象来实现。</p><p>创建 Bindler 的子类，然后在内部提供自定义的方法，在 Service 的 onBind() 方法中返回 Bindler 对象。</p><pre><code class="Java">public class HelloService extends Service {    private static final String TAG = &quot;HelloService&quot;;    private DownloadBinder mBinder = new DownloadBinder();    public HelloService() {    }    @Override    public IBinder onBind(Intent intent) {        // TODO: Return the communication channel to the service.        return mBinder;    }    class DownloadBinder extends Binder {        public void startDownlaod() {            Log.d(TAG, &quot;startDownlaod: &quot;);        }        public int getProgress() {            Log.d(TAG, &quot;getProgress: &quot;);            return 0;        }    }}</code></pre><p>然后 绑定 Activity 和 Service ，就可以调用 Binder 提供的方法了。</p><p>1、首先创建 ServiceConnection 的匿名类，重写方法。</p><pre><code class="java">private HelloService.DownloadBinder downloadBinder;private ServiceConnection connection = new ServiceConnection() {    @Override    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {        downloadBinder = (HelloService.DownloadBinder) iBinder;        downloadBinder.startDownlaod();        downloadBinder.getProgress();    }    @Override    public void onServiceDisconnected(ComponentName componentName) {    }};</code></pre><p>2、然后使用 bindService() 方法绑定 Service 。</p><pre><code class="Java">bindService(new Intent(this, MyService.class), connection, BIND_AUTO_CREATE);</code></pre><h2 id="服务的声明周期"><a href="#服务的声明周期" class="headerlink" title="服务的声明周期"></a>服务的声明周期</h2><p>服务生命周期（从创建到销毁）可以遵循两条不同的路径：</p><ul><li>启动服务</li></ul><p>该服务在其他组件调用 startService() 时创建，然后无限期运行，且必须通过调用 stopSelf() 来自行停止运行。此外，其他组件也可以通过调用 stopService() 来停止服务。服务停止后，系统会将其销毁。</p><ul><li>绑定服务</li></ul><p>该服务在另一个组件（客户端）调用 bindService() 时创建。然后，客户端通过 IBinder 接口与服务进行通信。客户端可以通过调用 unbindService() 关闭连接。</p><p><img src="https://img.wshunli.com/Android/第一行代码/3.service_lifecycle.png" alt="3.service_lifecycle"></p><h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。</p><p>要请求让服务运行于前台，在 Service 中调用 startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification。例如：</p><pre><code class="Java">Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());Intent notificationIntent = new Intent(this, ExampleActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);startForeground(ONGOING_NOTIFICATION_ID, notification);</code></pre><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService 是一种异步的、可以自动停止的服务。</p><p>IntentService 执行以下操作：</p><ul><li>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</li><li>创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。</li><li>在处理完所有启动请求后停止服务，因此您永远不必调用 stopSelf()。</li><li>提供 onBind() 的默认实现（返回 null）。</li><li>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。</li></ul><p>综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。</p><pre><code class="Java">public class HelloIntentService extends IntentService {  /**   * A constructor is required, and must call the super IntentService(String)   * constructor with a name for the worker thread.   */  public HelloIntentService() {      super(&quot;HelloIntentService&quot;);  }  /**   * The IntentService calls this method from the default worker thread with   * the intent that started the service. When this method returns, IntentService   * stops the service, as appropriate.   */  @Override  protected void onHandleIntent(Intent intent) {      // Normally we would do some work here, like download a file.      // For our sample, we just sleep for 5 seconds.      try {          Thread.sleep(5000);      } catch (InterruptedException e) {          // Restore interrupt status.          Thread.currentThread().interrupt();      }  }}</code></pre><blockquote><p>参考资料<br>1、Service | Android Developers<br><a href="https://developer.android.com/guide/components/services.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/services.html</a><br>2、Service与Thread区别 - CSDN博客<br><a href="http://blog.csdn.net/wei_chong_chong/article/details/52251193" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/wei_chong_chong/article/details/52251193</a><br>3、android的消息机制——Handler机制 - 简书<br><a href="https://www.jianshu.com/p/9e4d1fab0f36" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/9e4d1fab0f36</a><br>4、Android异步消息处理机制完全解析，带你从源码的角度彻底理解 - CSDN博客<br><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 Service&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统下搭建Android开发环境</title>
    <link href="http://www.wshunli.com/posts/80d94eb7.html"/>
    <id>http://www.wshunli.com/posts/80d94eb7.html</id>
    <published>2017-12-26T05:25:55.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu 16.04 LTS 系统下搭建 Android 开发环境</p><a id="more"></a><p>昨天圣诞节在机房装了台 Ubuntu ，主要是想试下管理系统的部署，<br>原来在虚拟机下部署的没问题，在真机上部署基本上也没有什么问题。</p><p>有台 Ubuntu 还是很有必要的，后面编译软件会方便很多。<br>现在先学习搭建下 Android 开发环境。</p><h1 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a>Java 环境</h1><p>在比较新的版本 Android Studio 里面已经有 OpenJDK 了，但是 Oracle Java 更好点，我们直接使用命令安装。</p><pre><code class="bash">sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install java-common oracle-java8-installer</code></pre><p>在安装的过程会询问是否同意许可，选择同意即可。</p><p>配置 Java 环境变量，依次执行以下命令：</p><pre><code class="bash">sudo apt-get install oracle-java8-set-defaultsource /etc/profile</code></pre><p>默认安装路径在 <code>/usr/lib/jvm/java-8-oracle</code> .</p><h1 id="Android-环境"><a href="#Android-环境" class="headerlink" title="Android 环境"></a>Android 环境</h1><p>安装 Android Studio 和 安装 JDK 类似，执行一下命令：</p><pre><code class="bash">sudo add-apt-repository ppa:maarten-fonville/android-studiosudo apt updatesudo apt install android-studio`</code></pre><p>JDK 默认安装路径在 <code>/opt/android-studio</code> .</p><h2 id="配置-Android-环境变量："><a href="#配置-Android-环境变量：" class="headerlink" title="配置 Android 环境变量："></a>配置 Android 环境变量：</h2><pre><code class="bash">gedit ~/.bashrc</code></pre><p>在文件的末尾添加如下代码并保存</p><pre><code class="bash">export ANDROID_HOME=/home/wshunli/Android/Sdkexport PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH</code></pre><p>其中 <code>/home/wshunli/Android/Sdk</code> 替换为自己 SDK 的安装位置，一般在 <code>android-studio</code> 同级目录下。</p><p>应用环境变量：</p><pre><code class="bash">source ~/.bashrc</code></pre><p>测试下查看原来设置的目录：</p><pre><code class="bash">echo $ANDROID_HOME</code></pre><p>返回 SDK 所在目录，配置正确。</p><p>接下来就可以启动 Android Studio 了。</p><h2 id="NDK-安装及环境配置（可选）："><a href="#NDK-安装及环境配置（可选）：" class="headerlink" title="NDK 安装及环境配置（可选）："></a>NDK 安装及环境配置（可选）：</h2><p>可以在 Android Studio 中下载，也执行以下命令下载并解压</p><pre><code class="bash">wget -c https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zipunzip android-ndk-r10e-linux-x86_64.zip</code></pre><p>配置 NDK 环境变量，和 SDK 类似：</p><pre><code class="bash">gedit ~/.bashrc</code></pre><p>在文件的末尾添加如下代码并保存</p><pre><code class="bash">export ANDROID_NDK=/home/wshunli/Android/android-ndk-r10eexport PATH=$ANDROID_NDK:$PATH</code></pre><p>其中 <code>/home/wshunli/Android/android-ndk-r10e</code> 替换为自己 NDK 的安装位置</p><p>应用环境变量：</p><pre><code class="bash">source ~/.bashrc</code></pre><p>测试下查看原来设置的目录：</p><pre><code class="bash">echo $ANDROID_NDK</code></pre><p>Android Studio 中文社区(官网)下载所需开发工具。<br><a href="http://www.android-studio.org/" rel="external nofollow noopener noreferrer" target="_blank">http://www.android-studio.org/</a></p><blockquote><p>参考资料<br>1、2 Ways to Install Android Studio in Ubuntu 16.04 and Ubuntu 17.04 - LinuxBabe.Com<br><a href="https://www.linuxbabe.com/ubuntu/install-android-studio-ubuntu-16-04" rel="external nofollow noopener noreferrer" target="_blank">https://www.linuxbabe.com/ubuntu/install-android-studio-ubuntu-16-04</a><br>2、Ubuntu系统下配置Android开发环境 - 简书<br><a href="https://www.jianshu.com/p/949a5a2ddceb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/949a5a2ddceb</a><br>3、Ubuntu 16.04 搭建Android开发环境 - Droi - 博客园<br><a href="http://www.cnblogs.com/droi/p/5399975.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/droi/p/5399975.html</a><br>4、Ubuntu下安装Android NDK - 简书<br><a href="https://www.jianshu.com/p/b12d714435bc" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b12d714435bc</a><br>5、NDK:Linux下NDK安装和配置 - 简书<br><a href="https://www.jianshu.com/p/abdad7fd1367" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/abdad7fd1367</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu 16.04 LTS 系统下搭建 Android 开发环境&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="Ubuntu" scheme="http://www.wshunli.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（五）</title>
    <link href="http://www.wshunli.com/posts/f90ba53c.html"/>
    <id>http://www.wshunli.com/posts/f90ba53c.html</id>
    <published>2017-12-20T12:59:34.000Z</published>
    <updated>2018-03-17T17:17:52.768Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】今天又没找到对象
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/b6bcc7db.html"/>
    <id>http://www.wshunli.com/posts/b6bcc7db.html</id>
    <published>2017-12-06T07:35:48.000Z</published>
    <updated>2018-03-17T17:17:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 Activity</p><a id="more"></a><p>Android 应用的四大组件 Activity，Service，Broadcast Receiver， Content Provider 最为核心。</p><h1 id="第2章-先从看得到的入手"><a href="#第2章-先从看得到的入手" class="headerlink" title="第2章 先从看得到的入手"></a>第2章 先从看得到的入手</h1><p>Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片或查看地图等操作。</p><h2 id="Activity-创建、启动及销毁"><a href="#Activity-创建、启动及销毁" class="headerlink" title="Activity 创建、启动及销毁"></a>Activity 创建、启动及销毁</h2><p>要创建 Activity，必须创建 <a href="https://developer.android.com/reference/android/app/Activity.html" rel="external nofollow noopener noreferrer" target="_blank">Activity</a> 的子类（或使用其现有子类）。</p><h3 id="实现用户界面"><a href="#实现用户界面" class="headerlink" title="实现用户界面"></a>实现用户界面</h3><p>Activity 的用户界面是由层级式视图 — 衍生自 View 类的对象 — 提供的，也可以利用 Android 提供的现成视图设计和组织布局。</p><p>利用视图定义布局的最常见方法是借助保存在您的应用资源内的 XML 布局文件。</p><pre><code class="Java">setContentView(R.layout.activity_main);</code></pre><p>不过，也可以在 Activity 代码中创建新 View，并通过将新 View 插入 ViewGroup 来创建视图层次，然后通过将根 ViewGroup 传递到 setContentView() 来使用该布局。</p><h3 id="声明-Activity"><a href="#声明-Activity" class="headerlink" title="声明 Activity"></a>声明 Activity</h3><p>Activity 需要在 清单文件 中声明。</p><pre><code class="XML">&lt;manifest ... &gt;  &lt;application ... &gt;    &lt;activity android:name=&quot;.MainActivity&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    ...  &lt;/application ... &gt;  ...&lt;/manifest &gt;</code></pre><p><code>&lt;action&gt;</code> 元素指定这是应用的“主”入口点。<br><code>&lt;category&gt;</code> 元素指定此 Activity 应列入系统的应用启动器内（以便用户启动该 Activity）。</p><h3 id="启动-Activity"><a href="#启动-Activity" class="headerlink" title="启动 Activity"></a>启动 Activity</h3><p>可以通过调用 startActivity()，并将其传递给描述想启动的 Activity 的 Intent 来启动另一个 Activity。</p><pre><code class="Java">Intent intent = new Intent(Intent.ACTION_SEND);intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);startActivity(intent);</code></pre><p>启动 Activity 推荐写法：</p><pre><code class="Java">public class SecondActivity extends FirstActivity {    public static void actionStart(Context context, String data1, String data2) {        Intent intent = new Intent(context, SecondActivity.class);        intent.putExtra(&quot;param1&quot;, data1);        intent.putExtra(&quot;param2&quot;, data2);        context.startActivity(intent);    }    ···}</code></pre><p>可以通过调用 startActivityForResult() 方法启动 Activity 并实现 onActivityResult() 回调方法得到启动 Activity 的结果。</p><pre><code class="Java">private void pickContact() {    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);    startActivityForResult(intent, PICK_CONTACT_REQUEST);}@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST    if (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {        // Perform a query to the contact&#39;s content provider for the contact&#39;s name        Cursor cursor = getContentResolver().query(data.getData(),        new String[] {Contacts.DISPLAY_NAME}, null, null, null);        if (cursor.moveToFirst()) { // True if the cursor is not empty            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);            String name = cursor.getString(columnIndex);            // Do something with the selected contact&#39;s name...        }    }}</code></pre><p>处理 Activity 结果时应该在 onActivityResult() 方法中使用的基本逻辑。</p><p>检查请求是否成功以及requestCode 与随 startActivityForResult() 发送的第二个参数是否匹配。<br>代码通过查询 Intent 中返回的数据（data 参数）从该处开始处理 Activity 结果。</p><h3 id="结束-Activity"><a href="#结束-Activity" class="headerlink" title="结束 Activity"></a>结束 Activity</h3><p>通过调用 Activity 的 finish() 方法来结束该 Activity。也可以通过调用 finishActivity() 结束之前启动的另一个 Activity。</p><h2 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h2><h3 id="Activity-状态"><a href="#Activity-状态" class="headerlink" title="Activity 状态"></a>Activity 状态</h3><p>Activity 在其生命周期中最多有4种状态：</p><ul><li>运行状态：Activity 位于屏幕前台并具有用户焦点。</li><li>暂停状态：另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。</li><li>停止状态：该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。</li><li>销毁状态：系统结束 Activity （调用其 finish() 方法）或直接终止其进程，将其从内存中删除。</li></ul><h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>当一个 Activity 转入和转出上述不同状态时，系统会通过各种回调方法向其发出通知。</p><pre><code class="Java">public class ExampleActivity extends Activity {    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // The activity is being created.    }    @Override    protected void onStart() {        super.onStart();        // The activity is about to become visible.    }    @Override    protected void onResume() {        super.onResume();        // The activity has become visible (it is now &quot;resumed&quot;).    }    @Override    protected void onPause() {        super.onPause();        // Another activity is taking focus (this activity is about to be &quot;paused&quot;).    }    @Override    protected void onStop() {        super.onStop();        // The activity is no longer visible (it is now &quot;stopped&quot;)    }    @Override    protected void onDestroy() {        super.onDestroy();        // The activity is about to be destroyed.    }}</code></pre><p>这些方法共同定义 Activity 的整个生命周期。可以通过实现这些方法监控 Activity 生命周期中的三个嵌套循环：</p><ul><li><strong>完整生命周期</strong> 发生在 onCreate() 与 onDestroy() 之间，就是完整的生存期。</li><li><strong>可见生命周期</strong> 发生在 onStart() 与 onStop() 之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。</li><li><strong>前台生命周期</strong> 发生在 onResume() 与 onPause() 之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。</li></ul><center><img src="https://img.wshunli.com/Android/第一行代码/2.activity_lifecycle.png" alt="activity_lifecycle"></center><p>Activity 生命周期回调方法汇总表。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.activity_lifecycle_method.png" alt="activity_lifecycle"></p><p>名为“是否能事后终止？”的列表示系统是否能在不执行另一行 Activity 代码的情况下，在方法返回后随时终止承载 Activity 的进程。</p><h3 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h3><p>在 Activity 暂停或者停止时，Activity 的状态会得到保留。<br>但是当系统为了回复内存而销毁 Activity 时，Activity 对象也会被销毁，<br>我们可以使用 onSaveInstanceState() 方法保存 Acitivity 状态信息，使用 onRestoreInstanceState() 方法 恢复保存的状态信息。</p><center><img src="https://img.wshunli.com/Android/第一行代码/2.restore_instance.png" alt="restore_instance"></center><p>当 Activity A 启动 Activity B 时一系列操作的发生顺序：</p><ol><li>Activity A 的 onPause() 方法执行。</li><li>Activity B 的 onCreate()、onStart() 和 onResume() 方法依次执行。（Activity B 现在具有用户焦点。）</li><li>然后，如果 Activity A 在屏幕上不再可见，则其 onStop() 方法执行。</li></ol><h2 id="Intent-和-Intent-过滤器"><a href="#Intent-和-Intent-过滤器" class="headerlink" title="Intent 和 Intent 过滤器"></a>Intent 和 Intent 过滤器</h2><p>Intent 是一个消息传递对象，可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p><p><strong>启动 Activity</strong>：Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。</p><p>如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，您的 Activity 将结果作为单独的 Intent 对象接收。</p><p><strong>启动服务</strong>：Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。</p><p>如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。</p><p><strong>传递广播</strong>：广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。</p><h3 id="显示Intent和隐式Intent"><a href="#显示Intent和隐式Intent" class="headerlink" title="显示Intent和隐式Intent"></a>显示Intent和隐式Intent</h3><p>显式 Intent 按名称（完全限定类名）指定要启动的组件。</p><pre><code class="Java">startActivity(new Intent(this, SecondActivity.class));</code></pre><p>隐式 Intent 不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。</p><p>创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.intent-filters.png-hexo.png" alt="intent-filters"></p><p>隐式 Intent 如何通过系统传递以启动其他 Activity 的图解：<br>[1] Activity A 创建包含操作描述的 Intent，并将其传递给 startActivity()。<br>[2] Android 系统搜索所有应用中与 Intent 匹配的 Intent 过滤器。 找到匹配项之后，<br>[3] 该系统通过调用匹配 Activity（Activity B）的 onCreate() 方法并将其传递给 Intent，以此启动匹配 Activity。</p><h3 id="构建-Intent"><a href="#构建-Intent" class="headerlink" title="构建 Intent"></a>构建 Intent</h3><p>Intent 对象携带了 Android 系统用来确定要启动哪个组件的信息，以及收件人组件为了正确执行操作而使用的信息。</p><p>Intent 中包含的主要信息如下：</p><ul><li>组件名称(Component name)：要启动的组件名称。</li><li>操作(Action)：指定要执行的通用操作的字符串。如 ACTION_VIEW 、ACTION_SEND。</li><li>数据(Data)：引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。</li><li>类别(Category)：一个包含应处理 Intent 组件类型的附加信息的字符串。如 CATEGORY_BROWSABLE、CATEGORY_LAUNCHER。</li><li>Extra：携带完成请求操作所需的附加信息的键值对。</li><li>标志(Flags)：在 Intent 类中定义的、充当 Intent 元数据的标志。</li></ul><p>隐式创建 Intent 示例：</p><pre><code class="Java">// Create the text message with a stringIntent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);sendIntent.setType(&quot;text/plain&quot;);// Verify that the intent will resolve to an activityif (sendIntent.resolveActivity(getPackageManager()) != null) {    startActivity(sendIntent);}</code></pre><p>使用<strong>应用选择器</strong></p><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。</p><p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()。</p><pre><code class="Java">Intent sendIntent = new Intent(Intent.ACTION_SEND);...String title = getResources().getString(R.string.chooser_title);// Create intent to show the chooser dialogIntent chooser = Intent.createChooser(sendIntent, title);if (sendIntent.resolveActivity(getPackageManager()) != null) {    startActivity(chooser);}</code></pre><h3 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，需要在清单文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent 过滤器。</p><p>在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p><p><code>&lt;action&gt;</code> 在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。<br><code>&lt;data&gt;</code> 使用一个或多个指定数据 URI 各个方面（scheme、host、port、path 等）和 MIME 类型的属性，声明接受的数据类型。<br><code>&lt;category&gt;</code> 在 name 属性中，声明接受的 Intent 类别。该值必须是操作的文本字符串值，而不是类常量。</p><pre><code class="XML">&lt;activity android:name=&quot;ShareActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><h3 id="使用待定-Intent"><a href="#使用待定-Intent" class="headerlink" title="使用待定 Intent"></a>使用待定 Intent</h3><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p><p>待定 Intent 的主要用例包括：</p><ul><li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li><li>声明用户使用您的 应用小部件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li><li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li></ul><h3 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h3><p>当系统收到隐式 Intent 以启动 Activity 时，它根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p><ul><li>Intent 操作</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.EDIT&quot; /&gt;    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;    ...&lt;/intent-filter&gt;</code></pre><ul><li>Intent 数据（URI 和数据类型）</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;    ...&lt;/intent-filter&gt;</code></pre><ul><li>Intent 类别</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;data android:mimeType=&quot;video/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt;    &lt;data android:mimeType=&quot;audio/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt;    ...&lt;/intent-filter&gt;</code></pre><h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent 过滤器匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。<br>例如，主页应用通过使用指定 ACTION_MAIN 操作和 CATEGORY_LAUNCHER 类别的 Intent 过滤器查找所有 Activity，以此填充应用启动器。</p><p>PackageManager 提供了一整套 query…() 方法来返回所有能够接受特定 Intent 的组件，resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities()、queryIntentServices()、queryBroadcastReceivers()将返回能够执行那些作为参数传递的 Intent 的所有 组件 列表，但方法均不会激活组件，而只是列出能够响应的组件。</p><h3 id="通用-Intent"><a href="#通用-Intent" class="headerlink" title="通用 Intent"></a>通用 Intent</h3><p>主要是调用系统提供的一些服务，如闹钟、相机等等。</p><p><a href="https://developer.android.com/guide/components/intents-common.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/intents-common.html</a></p><h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><h3 id="任务和返回栈"><a href="#任务和返回栈" class="headerlink" title="任务和返回栈"></a>任务和返回栈</h3><p>任务是指在执行特定作业时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈（即返回栈）中。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.diagram_backstack.png" alt="diagram_backstack"></p><p>当前 Activity 启动另一个 Activity 时，新 Activity 会被推到栈顶，并获得焦点。当用户按返回按钮时，当前 Activity 会从栈顶弹出并销毁。</p><p>当用户直接按 Home 键回到主屏幕时，尽管该任务中的所有 Activity 全部停止，但是任务的返回栈仍然不变。</p><p>即使来自其他任务，Activity 也可以多次实例化。</p><h3 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h3><p>通过使用 <code>&lt;activity&gt;</code> 清单文件元素中的属性</p><ul><li>taskAffinity</li><li>launchMode</li><li>allowTaskReparenting</li><li>clearTaskOnLaunch</li><li>alwaysRetainTaskState</li><li>finishOnTaskLaunch</li></ul><p>以及传递给 <code>startActivity()</code> 的 Intent 中的标志</p><ul><li>FLAG_ACTIVITY_NEW_TASK</li><li>FLAG_ACTIVITY_CLEAR_TOP</li><li>FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>管理 Activity 如何与任务关联或者如何存在于返回栈中。</p><h3 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h3><p><strong>使用清单文件</strong>：</p><p>在清单文件中声明 Activity 时，您可以使用 <code>&lt;activity&gt;</code> 元素的 launchMode 属性指定 Activity 应该如何与任务关联。</p><p>launchMode 属性的启动模式共有四种：</p><p><strong>“standard”</strong>（默认模式）每次启动 Activity 系统都会在任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</p><p><strong>“singleTop”</strong> 如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的 Activity 并不是 Activity 的现有实例）。</p><p><strong>“singleTask”</strong> 系统创建新任务并实例化位于新任务底部的 Activity。但是如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。一次只能存在 Activity 的一个实例。</p><p><strong>“singleInstance”</strong> 与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。</p><p><strong>使用 Intent 标志</strong>：</p><p>启动 Activity 时，您可以通过在传递给 startActivity() 的 Intent 中加入相应的标志，修改 Activity 与其任务的默认关联方式。可用于修改默认行为的标志包括：</p><p><strong>FLAG_ACTIVITY_NEW_TASK</strong> 在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 onNewIntent() 中收到新 Intent。这会产生与 “singleTask” launchMode 值相同的行为。</p><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong> 如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 onNewIntent() 的调用，而不是创建 Activity 的新实例。这会产生与 “singleTop” launchMode 值相同的行为。</p><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong> 如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。产生这种行为的 launchMode 属性没有值。</p><h3 id="处理关联"><a href="#处理关联" class="headerlink" title="处理关联"></a>处理关联</h3><p>“关联”指示 Activity 优先属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此关联。</p><p>可以使用 <code>&lt;activity&gt;</code> 元素的 taskAffinity 属性修改任何给定 Activity 的关联。</p><p>taskAffinity 属性取字符串值，该值必须不同于在 <code>&lt;manifest&gt;</code> 元素中声明的默认软件包名称，因为系统使用该名称标识应用的默认任务关联。</p><p>在两种情况下，关联会起作用：</p><ul><li>启动 Activity 的 Intent 包含 FLAG_ACTIVITY_NEW_TASK 标志。</li><li>Activity 将其 allowTaskReparenting 属性设置为 “true”。</li></ul><h3 id="清理返回栈"><a href="#清理返回栈" class="headerlink" title="清理返回栈"></a>清理返回栈</h3><p>如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。<br>当用户再次返回到任务时，仅恢复根 Activity。</p><p><strong>alwaysRetainTaskState</strong> 如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。</p><p><strong>clearTaskOnLaunch</strong> 如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。</p><p><strong>finishOnTaskLaunch</strong> 此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。</p><h1 id="第4章-手机平板要兼容"><a href="#第4章-手机平板要兼容" class="headerlink" title="第4章 手机平板要兼容"></a>第4章 手机平板要兼容</h1><p>Fragment 表示 Activity 中的行为或部分用户界面。Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.fragments.png" alt="fragments"></p><h2 id="创建-Fragment"><a href="#创建-Fragment" class="headerlink" title="创建 Fragment"></a>创建 Fragment</h2><p>要想创建 Fragment，必须创建 Fragment 的子类（或已有其子类）。</p><center><img src="https://img.wshunli.com/Android/第一行代码/2.fragment_lifecycle.png" alt="fragment_lifecycle"></center><p>其他 Fragment 子类，DialogFragment、ListFragment、PreferenceFragment 。</p><h3 id="构造-Fragment-界面"><a href="#构造-Fragment-界面" class="headerlink" title="构造 Fragment 界面"></a>构造 Fragment 界面</h3><p>实现 onCreateView() 回调方法，Android 系统会在 Fragment 需要绘制其布局时调用该方法。</p><pre><code class="Java">public static class ExampleFragment extends Fragment {    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        return inflater.inflate(R.layout.example_fragment, container, false);    }}</code></pre><p>inflater 利用 XML 中定义的布局资源来拓展 Fragment 布局。</p><h3 id="向-Activity-添加-Fragment"><a href="#向-Activity-添加-Fragment" class="headerlink" title="向 Activity 添加 Fragment"></a>向 Activity 添加 Fragment</h3><p>可以通过两种方式向 Activity 布局添加 Fragment ：</p><p><strong>在 Activity 的布局文件内声明 Fragment</strong>：</p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleListFragment&quot;            android:id=&quot;@+id/list&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleReaderFragment&quot;            android:id=&quot;@+id/viewer&quot;            android:layout_weight=&quot;2&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>当系统创建此 Activity 布局时，会实例化在布局中指定的每个Fragment，并为每个Fragment调用 onCreateView() 方法，以检索每个Fragment的布局。系统会直接插入Fragment返回的 View 来替代 <code>&lt;fragment&gt;</code> 元素。</p><p><strong>或者通过编程方式将 Fragment 添加到某个现有 ViewGroup</strong>:</p><p>用 FragmentTransaction 添加、移除或替换 Fragment 。</p><pre><code class="Java">FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();// 使用 add() 方法添加一个 FragmentExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);fragmentTransaction.commit();</code></pre><p>添加没有 UI 的 Fragment ：</p><p>使用 add(Fragment, String) 方法在 Activity 添加 Fragment，可以使用 Fragment 为 Activity 提供后台行为，而不显示额外 UI。</p><h2 id="管理-Fragment"><a href="#管理-Fragment" class="headerlink" title="管理 Fragment"></a>管理 Fragment</h2><p>在 Activity 调用 getFragmentManager() 方法得到 FragmentManager 对象可以管理 Activity 中的 Fragment。</p><p>FragmentManager 执行的操作包括：</p><ul><li>findFragmentById()（对于在 Activity 布局中提供 UI 的 Fragment ）或 findFragmentByTag()（对于提供或不提供 UI 的 Fragment）获取 Activity 中存在的 Fragment。</li><li>popBackStack()（模拟用户发出的返回命令）将 Fragment 从返回栈中弹出。</li><li>addOnBackStackChangedListener() 注册一个侦听返回栈变化的侦听器。</li></ul><h2 id="执行-Fragment-事务"><a href="#执行-Fragment-事务" class="headerlink" title="执行 Fragment 事务"></a>执行 Fragment 事务</h2><p>从 FragmentManager 获取 FragmentTransaction 实例，使用 add()、remove() 和 replace() 等方法动态管理 Fragment。</p><pre><code class="Java">// Create new fragment and transactionFragment newFragment = new ExampleFragment();FragmentTransaction transaction = getFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,// and add the transaction to the back stacktransaction.replace(R.id.fragment_container, newFragment);transaction.addToBackStack(null);// Commit the transactiontransaction.commit();</code></pre><p>通过调用 addToBackStack() 可将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一 Fragment 。</p><h2 id="Fragment-与-Activity-通信"><a href="#Fragment-与-Activity-通信" class="headerlink" title="Fragment 与 Activity 通信"></a>Fragment 与 Activity 通信</h2><p>尽管 Fragment 是作为独立于 Activity 的对象实现，并且可在多个 Activity 内使用，但 Fragment 的特定实例会直接绑定到包含它的 Activity。</p><p>Fragment 可以通过 getActivity() 访问 Activity 实例，并轻松地执行在 Activity 布局中查找视图等任务。</p><pre><code class="Java">View listView = getActivity().findViewById(R.id.list);</code></pre><p>同样地，Activity 也可以使用 findFragmentById() 或 findFragmentByTag()，通过从 FragmentManager 获取对 Fragment 的引用来调用Fragment中的方法。例如：</p><pre><code class="Java">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</code></pre><h2 id="处理-Fragment-生命周期"><a href="#处理-Fragment-生命周期" class="headerlink" title="处理 Fragment 生命周期"></a>处理 Fragment 生命周期</h2><p>管理Fragment生命周期与管理 Activity 生命周期很相似。和 Activity 一样，Fragment也以三种状态存在：</p><p><strong>Resumed</strong> Fragment在运行中的 Activity 中可见。<br><strong>Paused</strong> 另一个 Activity 位于前台并具有焦点，但此Fragment所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。<br><strong>Stopped</strong> Fragment不可见。宿主 Activity 已停止，或Fragment已从 Activity 中移除，但已添加到返回栈。 停止Fragment仍然处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。</p><p>Activity 生命周期与 Fragment 生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。</p><p>默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈；<br>不过，仅当您在移除 Fragment 的事务执行期间通过调用 addToBackStack() 显式请求保存实例时，系统才会将 Fragment 放入由宿主 Activity 管理的返回栈。</p><h3 id="与-Activity-生命周期协调一致"><a href="#与-Activity-生命周期协调一致" class="headerlink" title="与 Activity 生命周期协调一致"></a>与 Activity 生命周期协调一致</h3><p>Fragment所在的 Activity 的生命周期会直接影响Fragment的生命周期，其表现为，Activity 的每次生命周期回调都会引发每个Fragment的类似回调。<br>例如，当 Activity 收到 onPause() 时，Activity 中的每个Fragment也会收到 onPause()。</p><p>不过，Fragment 还有几个额外的生命周期回调:</p><ul><li>onAttach() 在片段已与 Activity 关联时调用（Activity 传递到此方法内）。</li><li>onCreateView() 调用它可创建与片段关联的视图层次结构。</li><li>onActivityCreated() 在 Activity 的 onCreate() 方法已返回时调用。</li><li>onDestroyView() 在移除与片段关联的视图层次结构时调用。</li><li>onDetach() 在取消片段与 Activity 的关联时调用。</li></ul><center><img src="https://img.wshunli.com/Android/第一行代码/2.activity_fragment_lifecycle.png" alt="activity_fragment_lifecycle"></center><p>图示说明了受其宿主 Activity 影响的片段生命周期流。</p><blockquote><p>参考资料<br>1、Activity | Android Developers<br><a href="https://developer.android.com/guide/components/activities.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/activities.html</a><br>2、Activity/Service 生命周期 · 笔试面试知识整理<br><a href="https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html" rel="external nofollow noopener noreferrer" target="_blank">https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html</a><br>3、Intent 和 Intent 过滤器<br><a href="https://developer.android.com/guide/components/intents-filters.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/intents-filters.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 Activity&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/df51fd76.html"/>
    <id>http://www.wshunli.com/posts/df51fd76.html</id>
    <published>2017-12-06T03:33:44.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 平台架构</p><a id="more"></a><p>我最开始学习 Android 是在 2014 年下半年，看的是《疯狂Android讲义》。</p><p>在 2015 年参加 ESRI 中国组织的 GIS 开发大赛，也是主要在暑假学习了不少 Android 入门知识。</p><p>后面在较长一段时间，感觉停滞在 Android 入门的水平不前。也有尝试在项目中使用一些优秀的框架或者类库，但是感觉自身的水平并没有多大的提高。</p><p>所以有意在前面学习计算机基础、Java 语言基础，后面打算深入之后学习下数据结构及算法。也为明年找工作做准备。</p><p>其实这本书 《第一行代码》 在考研结束以后已经看过一遍了，这次再复习一遍，毕竟有一段时间没有具体做 Android 开发了，再者希望能记忆一些常用的知识点。</p><h1 id="第1章-开启启程"><a href="#第1章-开启启程" class="headerlink" title="第1章 开启启程"></a>第1章 开启启程</h1><h2 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h2><p>总的来说，Android的系统体系结构分为四层，自顶向下分别是：</p><ul><li>应用程序(Applications)</li><li>应用程序框架(Application Frameworks)</li><li>系统运行库与 Android 运行环境(Libraris &amp; Android Runtime)</li><li>Linux 核心层</li></ul><p><img src="https://img.wshunli.com/Android/第一行代码/1.Android系统架构.png" alt="1.Android系统架构"></p><h3 id="Linux核心层"><a href="#Linux核心层" class="headerlink" title="Linux核心层"></a>Linux核心层</h3><p><strong>Linux 内核</strong>(Linux Kernel)<br>Android 平台的基础是 Linux 内核，Linux 内核直接和硬件打交道。硬件驱动、进程管理、内存管理、网络管理的功能在这里实现。</p><p><strong>硬件抽象层</strong>(Hardware Abstraction Layer)<br>硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。<br>HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。</p><h3 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h3><p><strong>Android 运行环境</strong>(Android Runtime)<br>每个应用都在其自己的进程中运行，有其自己的 Android Runtime (ART) 实例（Android 5.0 之前是 Dalvik）。<br>并且 Android 还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能。</p><p><strong>原生C/C++ 库</strong>(Native C/C++ Libraries)<br>许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。<br>Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。</p><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><p><strong>Java API 框架</strong>(Java API Framework)</p><p>提供构建应用的各种 API 。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器。</li><li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件。</li><li>通知管理器，可让所有应用在状态栏中显示自定义提醒。</li><li>Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈。</li><li>内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据。</li></ul><p>开发者可以完全访问 Android 系统应用使用的框架 API。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>系统应用</strong>(System Apps)</p><p>所有安装在手机上的应用程序都属于应用层，包括系统自带的软件和自己开发的软件。</p><h2 id="搭建-Android-开发环境"><a href="#搭建-Android-开发环境" class="headerlink" title="搭建 Android 开发环境"></a>搭建 Android 开发环境</h2><p>前面已经写过了，不再重复。<br>《ArcGIS Runtime SDK for Android学习笔记》-1、Android开发环境搭建 | CirGIS<br><a href="https://www.wshunli.com/posts/f6977dbb.html">https://www.wshunli.com/posts/f6977dbb.html</a></p><blockquote><p>参考资料<br>1、平台架构 | Android Developers<br><a href="https://developer.android.com/guide/platform/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/platform/index.html</a><br>2、Android系统架构简介 - 简书<br><a href="http://www.jianshu.com/p/69f0d25c727a" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/69f0d25c727a</a><br>3、Android系统架构介绍 - LCore的专栏 - CSDN博客<br><a href="http://blog.csdn.net/lcore/article/details/20993367" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/lcore/article/details/20993367</a><br>4、android系统体系结构 - CSDN博客<br><a href="http://blog.csdn.net/spy19881201/article/details/5775484" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/spy19881201/article/details/5775484</a><br>5、Android系统开篇 - Gityuan博客 | 袁辉辉博客<br><a href="http://gityuan.com/android/" rel="external nofollow noopener noreferrer" target="_blank">http://gityuan.com/android/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 平台架构&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（九）</title>
    <link href="http://www.wshunli.com/posts/8c5a6523.html"/>
    <id>http://www.wshunli.com/posts/8c5a6523.html</id>
    <published>2017-12-05T09:51:24.000Z</published>
    <updated>2018-03-17T17:17:52.764Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 注解。</p><a id="more"></a><h1 id="第20章-注解"><a href="#第20章-注解" class="headerlink" title="第20章 注解"></a>第20章 <strong>注解</strong></h1><p>注解（也叫元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。</p><p>注解的优点：</p><p>1.可以提供用来完整地描述程序所需的信息（这些信息无法用Java表达）-&gt; 以将由编译器来测试和验证的格式存储有关程序的额外信息。<br>2.可以用来生成描述符文件或是新的类的定义-&gt;减轻编写”样板”代码的负担。<br>3.更加干净易读的代码以及编译器类型检查。</p><p>注解的语法：除@符号的使用外，其他和Java固有语法一样</p><p>Java SE5内置了三种，定义在java.lang中的注解：</p><p>@Override 当前的方法定义将覆盖父类（超类）中的方法。<br>@Deprecated 被注解的元素被取代，不推荐使用。<br>@SuppressWarnings 关闭不当的编译器警告信息。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>1.@Target 表示该注解可以用于什么地方。</p><p>ElementType参数包括：</p><pre><code class="Java">public enum ElementType {    //类、接口（包括注解类型）或是enum声明    TYPE,    //域声明(包括enum实例)    FIELD,    //方法声明    METHOD,    //参数声明    PARAMETER,   //构造器声明    CONSTRUCTOR,    //局部变量声明    LOCAL_VARIABLE,     //注解类型声明    ANNOTATION_TYPE,    //包声明    PACKAGE,    //类型参数声明（Java1.8开始使用）    TYPE_PARAMETER,    //类型使用（Java1.8开始使用）    TYPE_USE}</code></pre><p>2.@Retention 表示需要在什么级别保存该注解信息。</p><p>RetentionPolicy 参数包括:</p><pre><code class="Java">public enum RetentionPolicy {    /**     * Annotations are to be discarded by the compiler.     *注解将被编译器丢弃     */    SOURCE,    /**     * Annotations are to be recorded in the class file by the compiler     * but need not be retained by the VM at run time.  This is the default     * behavior.     *注解被编译器保存在类文件中。但在运行的时候没有被VM保存     */    CLASS,    /**     * Annotations are to be recorded in the class file by the compiler and     * retained by the VM at run time, so they may be read reflectively.     *     * @see java.lang.reflect.AnnotatedElement     *  注解将被编译器保存在类文件中，在运行的时候也会被VM保存。因此可通过反射机制读取注解的信息     */    RUNTIME}</code></pre><p>3.@Documented 将此注解包含在 Javadoc 中。</p><p>4.@Inherited 允许子类继承父类中的注解。</p><p>定义注解的语法:</p><pre><code class="Java">package com;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test {}</code></pre><p>使用注解的语法：</p><pre><code class="Java">package com;public class Testable {    public void execute(){        System.out.println(&quot;Executing...&quot;);    }    @Test void testExcute(){        execute();    }}</code></pre><blockquote><p>参考资料<br>1、Java编程思想学习笔记——注解 - JohnTsai - 博客园<br><a href="https://www.cnblogs.com/JohnTsai/p/4926203.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/JohnTsai/p/4926203.html</a><br>2、《Java编程思想》学习笔记17——注解Annotation - CSDN博客<br><a href="http://blog.csdn.net/z742182637/article/details/50454204" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/z742182637/article/details/50454204</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 注解。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
</feed>
