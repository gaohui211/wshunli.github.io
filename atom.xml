<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2017-12-04T14:49:15.646Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Java编程思想》读书笔记（七）</title>
    <link href="http://www.wshunli.com/posts/1fc6c3f.html"/>
    <id>http://www.wshunli.com/posts/1fc6c3f.html</id>
    <published>2017-12-04T13:54:10.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类型信息及泛型。</p><a id="more"></a><h1 id="第14章-类型信息"><a href="#第14章-类型信息" class="headerlink" title="第14章 类型信息"></a>第14章 类型信息</h1><p>RTTI (Run-Time Type Identification, 运行时类型识别) 是 Java 中非常有用的机制。</p><pre><code class="Java">abstract class Shape {  void draw() { System.out.println(this + &quot;.draw()&quot;); }  abstract public String toString();}class Circle extends Shape {  public String toString() { return &quot;Circle&quot;; }}class Square extends Shape {  public String toString() { return &quot;Square&quot;; }}public class Shapes {  public static void main(String[] args) {    List&lt;Shape&gt; shapeList = Arrays.asList(      new Circle(), new Square()    );    for(Shape shape : shapeList) shape.draw();  }}/* Output:Circle.draw()Square.draw()*/</code></pre><p>在Java运行时，RTTI 维护类的相关信息，识别一个对象的类型。</p><h1 id="第15章-泛型"><a href="#第15章-泛型" class="headerlink" title="第15章 泛型"></a>第15章 泛型</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类型信息及泛型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/d3fc1ba0.html"/>
    <id>http://www.wshunli.com/posts/d3fc1ba0.html</id>
    <published>2017-12-04T12:22:17.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。</p><a id="more"></a><h1 id="第13章-字符串"><a href="#第13章-字符串" class="headerlink" title="第13章 字符串"></a>第13章 字符串</h1><p>1.不可变的 String<br>String 对象是不可变的，每当修改 String 对象的时候，实际上都是创建了一个新的 String 对象，最初的 String 对象丝毫未动。</p><p>2.重载“+”与 StringBuilder<br>String 对象的不可变性带来一定的效率问题，例如为 String 对象重载的“+”操作符。（用于String的“+”、“+=”是 Java 中仅有的两个重载过的操作符，而 Java 并不允许程序员重载任何操作符）。</p><pre><code class="Java">public class WhitherStringBuilder {  public String implicit(String[] fields) {    String result = &quot;&quot;;    for(int i = 0; i &lt; fields.length; i++)      result += fields[i];    return result;  }  public String explicit(String[] fields) {    StringBuilder result = new StringBuilder();    for(int i = 0; i &lt; fields.length; i++)      result.append(fields[i]);    return result.toString();  }}</code></pre><p>StringBuilder 提供了丰富而全面的方法，包括 append(),toString(),delete(),insert(),replace(),substring() 甚至 reverse()。</p><p>3.String 上的操作</p><p><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">Java 字符串常用操作（String类）</a></p><p>String 是固定不变的，而 StringBuffer 和 StringBuilder 可以改变它们的值。<br>二者唯一的区别是 StringBuilder 是非同步的而 StringBuffer 是同步的。</p><p>4.格式化输出</p><p>Java SE5 推出了类似 C语言中 printf() 风格的格式化输出这一功能。</p><pre><code class="Java">public class SimpleFormat {  public static void main(String[] args) {    int x = 5;    double y = 5.332542;    // The old way:    System.out.println(&quot;Row 1: [&quot; + x + &quot; &quot; + y + &quot;]&quot;);    // The new way:    System.out.format(&quot;Row 1: [%d %f]\n&quot;, x, y);    // or    System.out.printf(&quot;Row 1: [%d %f]\n&quot;, x, y);  }}/* Output:Row 1: [5 5.332542]Row 1: [5 5.332542]Row 1: [5 5.332542]*/</code></pre><p>format() 和 printf() 是等价的。</p><p><strong>Formatter</strong> 看一看成一个翻译器，劲格式化字符串与数据翻译成需要的结果。</p><pre><code class="Java">private Formatter f = new Formatter(System.out);f.format(&quot;%s The Turtle is at (%d,%d)\n&quot;, name, x, y);</code></pre><p>5.正则表达式</p><p>6.扫描输入</p><p>Java SE5 新增了 Scanner 类接受任意类型的输入对象。</p><h1 id="第16章-数组"><a href="#第16章-数组" class="headerlink" title="第16章 数组"></a>第16章 数组</h1><h1 id="第19章-枚举类型"><a href="#第19章-枚举类型" class="headerlink" title="第19章 枚举类型"></a>第19章 枚举类型</h1><blockquote><p>参考资料<br>1、读书笔记 JAVA编程思想 第13章 字符串 - CSDN博客<br><a href="http://blog.csdn.net/imaginedranges/article/details/73335553" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/imaginedranges/article/details/73335553</a><br>2、Java 字符串常用操作（String类） - 薛遗山 - 博客园<br><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/b6f25079.html"/>
    <id>http://www.wshunli.com/posts/b6f25079.html</id>
    <published>2017-12-04T09:04:23.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 异常处理。</p><a id="more"></a><p>第12章 <strong>通过异常处理错误</strong></p><p>Java的基本理念是“结构不佳的代码不能运行”。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java异常.png" alt="Java异常"></p><p>Java 中的异常处理都是围绕着 try-catch-finally, throw, throws 这几个展开的，也就是：</p><p>try-catch-finally：捕获异常并处理。<br>throw：遇到错误的时候抛出一个异常。<br>throws：声明一个方法可能抛出的异常（所有可能抛出的异常都需要声明）。</p><pre><code class="Java">class ThreeException extends Exception {}public class FinallyWorks {  static int count = 0;  public static void main(String[] args) {    while(true) {      try {        // Post-increment is zero first time:        if(count++ == 0) throw new ThreeException();        System.out.println(&quot;No exception&quot;);      } catch(ThreeException e) {        System.out.println(&quot;ThreeException&quot;);      } finally {        System.out.println(&quot;In finally clause&quot;);        if(count == 2) break; // out of &quot;while&quot;      }    }  }}/* Output:ThreeExceptionIn finally clauseNo exceptionIn finally clause*/</code></pre><p>throw 与 throws 的差别</p><p>throw 是语句抛出一个 Throwable 类型的异常，总是出现在函数体中；程序会在 throw 语句之后立即终止。</p><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用 throws 子句来声明抛出异常；<br>throws 语句用在方法定义时声明该方法要抛出的异常类型，多个异常可使用逗号分割。</p><pre><code class="Java">f() throws Exception1, Exception2, Exception3, ... {    ...}</code></pre><p>例如：</p><pre><code class="Java">import java.lang.Exception;public class TestException {    public int div(int x, int y) throws MyException {        if (y == 0) {            throw new MyException(&quot;除数不能为0&quot;);        }        return (int)(x/y);    }    public static void main(String[] args) {        int x = 1;        int y = 0;        try {            int result = div(x, y);        } catch (MyException e) {            System.out.println(e.getMessage());        }    }}//自定义异常类class MyException extends Exception {    String message;    public MyException(String ErrorMessage) {        message = ErrorMessage;    }    public String getMessage() {        return message;    }}</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十二章 通过异常处理<br><a href="https://zhuanlan.zhihu.com/p/25935822" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25935822</a><br>2、Java编程思想第四版读书笔记——第十二章 通过异常处理错误 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/51780879" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/51780879</a><br>3、Java 异常处理<br><a href="https://zhuanlan.zhihu.com/p/24043941" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/24043941</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 异常处理。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/d96c953e.html"/>
    <id>http://www.wshunli.com/posts/d96c953e.html</id>
    <published>2017-12-03T11:07:09.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 集合。</p><a id="more"></a><p>这部分只是还是挺重要的，面试题里面有好多。</p><p>第11章 <strong>持有对象</strong></p><p>Java 容器类提供了完善的方法保存对象，并经其划分为 <strong>Collection</strong> 和 <strong>Map</strong> 两个不同的概念。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java容器.png" alt="Java容器"></p><p><strong>Collection</strong> 一个独立的元素序列；<strong>Map</strong> 一组成对的“键值对”对象。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>1.<strong>Collection</strong> 一个独立的元素序列，这些元素服从一条或者多条规则。</p><p>List 必须按照插入的顺序保存元素，而 Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序。</p><pre><code class="java">public class SimpleCollection {  public static void main(String[] args) {    Collection&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;();    for(int i = 0; i &lt; 10; i++)      c.add(i); // Autoboxing    for(Integer i : c)      System.out.print(i + &quot;, &quot;);  }}/* Output:0, 1, 2, 3, 4, 5, 6, 7, 8, 9,*/</code></pre><p>2.Arrays 和 Collections 类有很多实用的方法，可以在 Collection 中添加一组元素。</p><pre><code class="Java">public class AddingGroups {  public static void main(String[] args) {    Collection&lt;Integer&gt; collection =      new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5));    Integer[] moreInts = { 6, 7, 8, 9, 10 };    collection.addAll(Arrays.asList(moreInts));    // Runs significantly faster, but you can&#39;t    // construct a Collection this way:    Collections.addAll(collection, 11, 12, 13, 14, 15);    Collections.addAll(collection, moreInts);    // Produces a list &quot;backed by&quot; an array:    List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20);    list.set(1, 99); // OK -- modify an element    // list.add(21); // Runtime error because the                     // underlying array cannot be resized.  }}</code></pre><p>Arrays.asList() 接受一个数组或者可变参数列表，并将之转换为 List 对象。<br>需要注意的是，此种方式获得的 List 对象，由于底层实现仍然是数组，在添加或者删除元素时会出现 UnsupportedOperationException 异常。</p><p>Collections.addAll() 接收一个 Collection 对象、一个数组或者是可变参数列表作为参数，得到新的 Collection 对象。</p><p>3.容器的打印</p><pre><code class="Java">public class PrintingContainers {  static Collection fill(Collection&lt;String&gt; collection) {    collection.add(&quot;rat&quot;);    collection.add(&quot;cat&quot;);    collection.add(&quot;dog&quot;);    collection.add(&quot;dog&quot;);    return collection;  }  static Map fill(Map&lt;String,String&gt; map) {    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);    map.put(&quot;cat&quot;, &quot;Rags&quot;);    map.put(&quot;dog&quot;, &quot;Bosco&quot;);    map.put(&quot;dog&quot;, &quot;Spot&quot;);    return map;  }      public static void main(String[] args) {    print(fill(new ArrayList&lt;String&gt;()));    print(fill(new LinkedList&lt;String&gt;()));    print(fill(new HashSet&lt;String&gt;()));    print(fill(new TreeSet&lt;String&gt;()));    print(fill(new LinkedHashSet&lt;String&gt;()));    print(fill(new HashMap&lt;String,String&gt;()));    print(fill(new TreeMap&lt;String,String&gt;()));    print(fill(new LinkedHashMap&lt;String,String&gt;()));  }}/* Output:[rat, cat, dog, dog][rat, cat, dog, dog][dog, cat, rat][cat, dog, rat][rat, cat, dog]{dog=Spot, cat=Rags, rat=Fuzzy}{cat=Rags, dog=Spot, rat=Fuzzy}{rat=Fuzzy, cat=Rags, dog=Spot}*/</code></pre><p>Collection 打印出来的内容用 [ ] 括住，Map 打印出来的内容用 { } 括住。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口在 Collection 基础上添加了大量的方法。可分为 ArrayList 和 LinkedList 两种。</p><p><strong>ArrayList</strong> 数据结构采用的是线性表，优势是访问和查询十分方便，但添加和删除的时候效率很低。<br><strong>LinkedList</strong> 数据结构采用的是链表，优势是删除和添加的效率很高，但随机访问元素时效率较 ArrayList 类低。</p><p>List 重要价值在于提供了一种可修改的序列。</p><p>contains(Object o) 确定某个对象是否在列表中。<br>remove(int index) 移除指定位置上的元素。<br>indexOf() 返回列表中首次出现指定元素的索引，如果不包含该元素，返回-1。</p><p>LikedList 增加了可以使其用作栈、队列或双端队列的方法。</p><pre><code class="Java">public class Stack&lt;T&gt; {    private LinkedList&lt;T&gt; storage = new LinkedList&lt;&gt;();    public void push(T v){        storage.addFirst(v);    }    public T peek(){        return storage.getFirst();    }    public T pop(){        return storage.removeFirst();    }    public boolean empty(){        return storage.isEmpty();    }    public String toString(){        return storage.toString();    }}</code></pre><p>LikedList 具有直接实现栈（LIFO）的所有功能的方法。</p><p>addFirst(E e)/addLast(E e)：将元素添加到列表的开头/结尾<br>getFirst()/element()：返回列表的第一个元素<br>peek()/peekFirst()：获取但不移除列表的第一个元素<br>offer(E e)/offerLast(E e)：将元素插入到列表末尾</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列是典型的先进先出（FIFO）的容器。</p><pre><code class="Java">public class QueueDemo {    public static void printQ(Queue queue) {  while(queue.peek() != null)      System.out.print(queue.remove() + &quot; &quot;);  System.out.println();    }    public static void main(String[] args) {  Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();  Random random = new Random(47);  for(int i = 0; i &lt; 10; i++)      queue.offer(random.nextInt(i+10));  printQ(queue);  Queue&lt;Character&gt; qCharacters = new LinkedList&lt;Character&gt;();  for(char c : &quot;Brontosaurus&quot;.toCharArray())      qCharacters.offer(c);  printQ(qCharacters);    }}/* Output: 8 1 1 1 5 14 3 1 0 1 B r o n t o s a u r u s*/</code></pre><p>LinkedList 提供了方法以支持队列的行为，并且它实现了 Queue 接口，<br>因此 LinkedList 可以用作 Queue 的一种实现，也可以将 LinkedList 向上转型为 Queue 。</p><p><strong>PriorityQueue</strong> 优先级队列声明下一个弹出的元素是最需要的元素(具有最高的优先级)，可以确保当调用 peek()、poll() 和 remove() 方法时，获取的元素将是队列中优先级最高的元素。</p><pre><code class="java">PriorityQueue priorityQueue = new PriorityQueue&lt;Integer&gt;(  inis.size(),Collections.reverseOrder());</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 具有与 Collection 完全一样的接口，实际上就是 Collection ，只是行为不同。</p><p><strong>HashSet</strong> 数据结构采用的是散列表，主要是设计用来做高性能集运算的，例如对两个集合求交集、并集、差集等。<br>集合中包含一组不重复出现且无特性顺序的元素，其值是不可重复与无序的。</p><p>LinkedHashSet 的核心概念相对于 HashSet 来说就是一个可以保持顺序的Set集合。</p><p><strong>TreeSet</strong> 数据结构使用的是红黑树，性能上低于HashSet，用于排序。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map：一组成对的“键值对”对象，允许使用键来查找值；<br>映射表允许我们使用另一个对象来查找某个对象，它被称为“关联数组”，因为它将某些对象与另外一些对象关联在了一起，或者被称为“字典”</p><pre><code class="Java">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</code></pre><p>get(Object o)：返回指定键所映射的值，如果不包含该键的映射关系，返回 null 。<br>put(K key, V value)：将指定的值与此映射中的指定键关联，如果已经存在映射关系，更新值。<br>hashCode()：返回此映射的哈希码值。</p><h2 id="Map-的三种实现"><a href="#Map-的三种实现" class="headerlink" title="Map 的三种实现"></a>Map 的三种实现</h2><p>HashMap：基于“拉链法”实现的散列表，一般用于单线程中，不是线程安全的。<br>HashTable：基于“拉链法”实现的散列表，一般用于多线程中，是线程安全的。<br>TreeMap：有序的散列表，通过红黑树实现的，一般用于单线程中存储有序的映射。</p><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>迭代器，用于遍历容器，JDK源码如下：</p><pre><code class="Java">package java.util;import java.util.function.Consumer;public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}</code></pre><p>Java 的 Iterator 只能单向移动：</p><pre><code class="Java">public class SimpleIteration {  public static void main(String[] args) {    List&lt;Pet&gt; pets = Pets.arrayList(12);    Iterator&lt;Pet&gt; it = pets.iterator();    while(it.hasNext()) {      Pet p = it.next();      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    }    System.out.println();    // A simpler approach, when possible:    for(Pet p : pets)      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    System.out.println();        // An Iterator can also remove elements:    it = pets.iterator();    for(int i = 0; i &lt; 6; i++) {      it.next();      it.remove();    }    System.out.println(pets);  }}/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]*/</code></pre><p>Iterator() 要求容器返回一个Iterator。Iterator 准备好返回序列的第一个元素。<br>next() 获得序列中的下一个元素。<br>hasNext() 检查序列中是否还有元素。<br>remove() 将迭代器新近返回的元素删除。</p><h2 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h2><p>ListIterator 是 Iterator 的一个子类，只能用于各种List的访问。<br>ListIterator 可以双向移动，可以产生当前位置的前一个和后一个元素的索引，并且可以使用 set() 方法，将最近访问过的元素进行替换。<br>此外，还可以通过 listIterator(int index) 的方法，获得一个一开始就指向 index 位置的 ListIterator。</p><h1 id="Foreach-与迭代器"><a href="#Foreach-与迭代器" class="headerlink" title="Foreach 与迭代器"></a>Foreach 与迭代器</h1><p>foreach 语法主要用于数组，同样可以用于 Collection 对象。</p><pre><code class="Java">public class ForEachCollections {  public static void main(String[] args) {    Collection&lt;String&gt; cs = new LinkedList&lt;String&gt;();    Collections.addAll(cs,      &quot;Take the long way home&quot;.split(&quot; &quot;));    for(String s : cs)      System.out.print(&quot;&#39;&quot; + s + &quot;&#39; &quot;);  }}/* Output:&#39;Take&#39; &#39;the&#39; &#39;long&#39; &#39;way&#39; &#39;home&#39;*/</code></pre><p>因为 java SE5 引入了 Iterable 接口，该接口包含产生 Iterator 的 iterator 方法，<br>并且 Iterable 接口被 foreach 用来造序列中移动。</p><blockquote><p>参考资料<br>1、Java 容器知识整理 - FullStackDeveloper - SegmentFault<br><a href="https://segmentfault.com/a/1190000002903035" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002903035</a><br>2、Java编程思想读书笔记——持有对象 - CSDN博客<br><a href="http://blog.csdn.net/baidu_21088863/article/details/78175347" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/baidu_21088863/article/details/78175347</a><br>3、Java编程思想第四版读书笔记——第十一章 持有对象 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/49491441" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/49491441</a><br>4、深入Java源码解析容器类List、Set、Map - 简书<br><a href="http://www.jianshu.com/p/047e33fdefd2" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/047e33fdefd2</a><br>5、《Java编程思想》读书笔记 第十一章 持有对象 02 Map<br><a href="https://zhuanlan.zhihu.com/p/25816448" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25816448</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 集合。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入全景图片</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-panoview.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-panoview.html</id>
    <published>2017-11-30T09:14:59.000Z</published>
    <updated>2017-12-04T14:49:15.650Z</updated>
    
    <content type="html"><![CDATA[<p>一款基于 Three.js 全景显示的 Hexo 插件。</p><a id="more"></a><h1 id="Threejs-介绍"><a href="#Threejs-介绍" class="headerlink" title="Threejs 介绍"></a>Threejs 介绍</h1><p><a href="https://threejs.org/" rel="external nofollow noopener noreferrer" target="_blank">three.js</a> The aim of the project is to create an easy to use, lightweight, 3D library. The library provides <code>&lt;canvas&gt;</code>, <code>&lt;svg&gt;</code>, CSS3D and WebGL renderers.</p><div id="panoview1972" style="margin:0 auto"></div><script src="https://unpkg.com/three@0.88.0/build/three.min.js"></script><script>function init(){var e,n;(e=document.getElementById("panoview1972")).style.width;(camera=new THREE.PerspectiveCamera(75,2,1,1e3)).target=new THREE.Vector3(0,0,0),scene=new THREE.Scene;var t=new THREE.SphereBufferGeometry(500,60,40);t.scale(-1,1,1);var o=new THREE.MeshBasicMaterial({map:(new THREE.TextureLoader).load("https://img.wshunli.com/pano/pano2.jpg")});n=new THREE.Mesh(t,o),scene.add(n),(renderer=new THREE.WebGLRenderer).setPixelRatio(window.devicePixelRatio),renderer.setSize(window.innerWidth,window.innerHeight),renderer.domElement.style.width="800px",renderer.domElement.style.height="400px",e.appendChild(renderer.domElement),e.addEventListener("mousedown",onDocumentMouseDown,!1),e.addEventListener("mousemove",onDocumentMouseMove,!1),e.addEventListener("mouseup",onDocumentMouseUp,!1),e.addEventListener("dragover",function(e){e.preventDefault(),e.dataTransfer.dropEffect="copy"},!1),e.addEventListener("dragenter",function(e){document.body.style.opacity=.5},!1),e.addEventListener("dragleave",function(e){document.body.style.opacity=1},!1)}function onDocumentMouseDown(e){e.preventDefault(),isUserInteracting=!0,onMouseDownMouseX=e.clientX,onMouseDownMouseY=e.clientY,onMouseDownLon=lon,onMouseDownLat=lat}function onDocumentMouseMove(e){!0===isUserInteracting&&(lon=.1*(onMouseDownMouseX-e.clientX)+onMouseDownLon,lat=.1*(e.clientY-onMouseDownMouseY)+onMouseDownLat)}function onDocumentMouseUp(e){isUserInteracting=!1}function onDocumentMouseWheel(e){var n=camera.fov+.05*e.deltaY;return camera.fov=THREE.Math.clamp(n,10,75),camera.updateProjectionMatrix(),!1}function animate(){requestAnimationFrame(animate),update()}function update(){!1===isUserInteracting&&(lon+=.1),lat=Math.max(-85,Math.min(85,lat)),phi=THREE.Math.degToRad(90-lat),theta=THREE.Math.degToRad(lon),camera.target.x=500*Math.sin(phi)*Math.cos(theta),camera.target.y=500*Math.cos(phi),camera.target.z=500*Math.sin(phi)*Math.sin(theta),camera.lookAt(camera.target),renderer.render(scene,camera)}var camera,scene,renderer,isUserInteracting=!1,onMouseDownMouseX=0,onMouseDownMouseY=0,lon=0,onMouseDownLon=0,lat=0,onMouseDownLat=0,phi=0,theta=0;init(),animate()</script><h1 id="Hexo-中插入全景图片"><a href="#Hexo-中插入全景图片" class="headerlink" title="Hexo 中插入全景图片"></a>Hexo 中插入全景图片</h1><p><a href="https://github.com/wshunli/hexo-tag-panoview" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-panoview</a> 是一款在 Hexo 中使用 <strong>全景图片</strong> 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-panoview --save</code></pre><p>之后在文章内使用 <code>panoview</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% panoview "https://img.wshunli.com/pano/pano2.jpg" 400 800 %}{% endpanoview %}</code></pre><p>其中：<br><code>panoview</code> 和 <code>endpanoview</code> 是 Hexo 的标签，不需要修改；<br><code>https://img.wshunli.com/pano/pano2.jpg</code> 部分是全景照片，建议 1024*512 ；<br><code>400</code> 是指全景的高度；<br><code>800</code> 是指全景的宽度。</p><p>灵感来自 <a href="https://threejs.org/examples/?q=pano#webgl_panorama_equirectangular" rel="external nofollow noopener noreferrer" target="_blank">webgl_panorama_equirectangular</a><br>也是我发布的第二个 npm 组件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一款基于 Three.js 全景显示的 Hexo 插件。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="panoview" scheme="http://www.wshunli.com/tags/panoview/"/>
    
      <category term="hexo-tag-panoview" scheme="http://www.wshunli.com/tags/hexo-tag-panoview/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入 AntV 动态图表</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-antv.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-antv.html</id>
    <published>2017-11-30T02:53:24.000Z</published>
    <updated>2017-12-04T14:49:15.650Z</updated>
    
    <content type="html"><![CDATA[<p><strong>让数据栩栩如生</strong><br><a id="more"></a></p><div id="antv1424"></div><script src="https://gw.alipayobjects.com/as/g/datavis/assets/1.0.5/g2/3.0.0/g2.min.js"></script><script type="text/javascript">var chart=new G2.Chart({container:"antv1424",height:300,forceFit:!0,data:[{genre:"Sports",sold:275},{genre:"Strategy",sold:115},{genre:"Action",sold:120},{genre:"Shooter",sold:350},{genre:"Other",sold:150}],options:{scales:{genre:{alias:"游戏种类"},sold:{alias:"销售量"}},geoms:[{type:"interval",position:"genre*sold",color:"genre"}]}});chart.render()</script><h1 id="AntV-介绍"><a href="#AntV-介绍" class="headerlink" title="AntV 介绍"></a>AntV 介绍</h1><p><a href="https://antv.alipay.com" rel="external nofollow noopener noreferrer" target="_blank">AntV</a> 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。</p><h1 id="Hexo-中使用-AntV"><a href="#Hexo-中使用-AntV" class="headerlink" title="Hexo 中使用 AntV"></a>Hexo 中使用 AntV</h1><p><a href="https://github.com/wshunli/hexo-tag-antv" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-antv</a> 是一款在 Hexo 中使用 AntV 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-antv --save</code></pre><p>之后在文章内使用 <code>antv</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% antv 300 %}data:[    // TODO antv data goes here],options: {    // TODO antv options goes here}{% endantv %}</code></pre><p>其中：<br><code>antv</code> 和 <code>endantv</code> 是 Hexo 的标签，不需要修改；<br><code>300</code> 是指图表的高度，图表宽度是自适应的；<br><code>data</code> 部分是图表的数据；<br><code>options</code> 部分是图表的配置。</p><pre><code class="JavaSript">const options = {  scales: {object}, // 列定义声明  coord: {object}, // 坐标系配置  axes: {object}, // 坐标轴配置  legends: {object}, // 图例配置  guides: {array}, // 图表辅助元素配置  filters: {object}, // 数据过滤配置  tooltip: {object}, // 提示信息配置  facet: {object}, // 分面配置  geoms: {array} // 图形语法相关配置}</code></pre><p>更详细配置可参考官方文档：<a href="https://antv.alipay.com/zh-cn/g2/3.x/api/options.html" rel="external nofollow noopener noreferrer" target="_blank">配置项声明方式</a></p><p>下面我们来看一个饼图的使用样例：</p><pre><code class="javaSript">{% antv %}data:[  { genre: 'Sports', sold: 275 },  { genre: 'Strategy', sold: 115 },  { genre: 'Action', sold: 120 },  { genre: 'Shooter', sold: 350 },  { genre: 'Other', sold: 150 }],options: {    scales: {      'genre': {        alias: '游戏种类'      },      'sold': {        alias: '销售量'      }    },    geoms: [      {        type: 'percent',        position: 'genre*sold',        color: 'genre'      }    ]  }{% endantv %}</code></pre><p>即开头的图表效果。</p><p>灵感来自 <a href="https://github.com/quentin-chen/hexo-tag-echarts3" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-echarts3</a>，AntV 也刚刚发布了 3.0 版本所以就想尝试下。<br>最主要目的还是尝试发布自己的 npm 组件，可能现在还不够实用，后面我会不断完善。</p><blockquote><p>参考资料<br>1、发布自己的module - 我的第一个npm组件！<br><a href="https://segmentfault.com/a/1190000006250554" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000006250554</a><br>2、在 Hexo 中插入 ECharts 动态图表<br><a href="http://kchen.cc/2016/11/05/echarts-in-hexo/" rel="external nofollow noopener noreferrer" target="_blank">http://kchen.cc/2016/11/05/echarts-in-hexo/</a><br>3、标签插件（Tag） | Hexo<br><a href="https://hexo.io/zh-cn/api/tag.html" rel="external nofollow noopener noreferrer" target="_blank">https://hexo.io/zh-cn/api/tag.html</a><br>4、Hexo高级教程之插件开发<br><a href="http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;让数据栩栩如生&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="AntV" scheme="http://www.wshunli.com/tags/AntV/"/>
    
      <category term="hexo-tag-antv" scheme="http://www.wshunli.com/tags/hexo-tag-antv/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/6e418c5b.html"/>
    <id>http://www.wshunli.com/posts/6e418c5b.html</id>
    <published>2017-11-28T13:15:08.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类与接口。</p><a id="more"></a><h1 id="第5章-初始化与清理"><a href="#第5章-初始化与清理" class="headerlink" title="第5章 初始化与清理"></a>第5章 初始化与清理</h1><p>1.构造器初始化 initialize()<br>Java 采用构造器（constructor）<code>初始化</code>和<code>创建</code>对象，两个过程捆绑在一起。<br>类中没有构造器即构造函数时，编译器会自动创建一个默认构造器；反之，则不会自动创建。</p><p>2.方法重载：每个重载方法都有一个独一无二的参数类型列表。</p><p>3.this 关键字只能在方法内部使用，表示“调用方法的那个对象”。<br>static 方法就是没有 this 的方法，可以在没有创建对象的情况下仅仅通过类名本身调用 static 方法。</p><p>4.垃圾回收 finalize()</p><ul><li>对象可能不被垃圾回收。</li><li>垃圾回收并不等于“析构”。</li><li>垃圾回收只与内存有关。</li></ul><p>5.成员初始化及构造器初始化<br>Java 尽力保证：所有变量在使用前都能的到恰当的初始化。</p><p>6.初始化顺序：在类的内部，成员变量会在任何方法（包括构造器）调用之前初始化。<br>含静态数据的初始化：先静态对象后非静态对象。</p><p>7.声明数组变量</p><pre><code class="Java">int[] a;   // 首选的方法int a[];  // 效果相同，但不是首选方法</code></pre><p>初始化：</p><pre><code class="Java">int[] a = new int[5];int[] a = {1, 2, 3, 4, 5};</code></pre><p>可变参数列表：</p><pre><code class="Java">void fun (Object... args){  for(Object obj : args){    system.out.printf(obj + &quot;&quot;);  }}</code></pre><p>8.枚举类型 enum</p><pre><code class="Java">public enum Spiiness{  NOT, MILD, MEDIUM, HOT, FLAMING}</code></pre><h1 id="第6章-访问权限控制"><a href="#第6章-访问权限控制" class="headerlink" title="第6章 访问权限控制"></a>第6章 访问权限控制</h1><p>访问权限（由大到小）：public、protected、包访问权限和 private 。</p><ul><li>default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li></ul><p><img src="https://img.wshunli.com/Java/Java编程思想/访问控制.png-hexo.png" alt="访问控制"></p><h1 id="第7章-复用类"><a href="#第7章-复用类" class="headerlink" title="第7章 复用类"></a>第7章 复用类</h1><p>复用代码有两种方法：在新类中产生现有类的对象（组合）；按照现有类的类型创建新类（继承）。</p><p>1.组合，将对象的引用置于新类中即可。</p><p>2.继承，使用 extends 实现，导出类自动获得基类的所有域和方法。</p><p>没有参数的初始化构建过程，从基类“向外”扩散；带参数的构造器使用 super 显式地调用基类构造器语句。</p><p>3.代理是一种介于组合和继承的中庸之道，将成员对象置于构造地类中（类似组合），与此同时在新类中暴露该成员对象的所有方法（类似继承）。</p><pre><code class="Java">public class SpaceShipDelegation {  private String name;  private SpaceShipControls controls =    new SpaceShipControls();  public SpaceShipDelegation(String name) {    this.name = name;  }  // Delegated methods:  public void back(int velocity) {    controls.back(velocity);  }  public void forward(int velocity) {    controls.forward(velocity);  }  public static void main(String[] args) {    SpaceShipDelegation protector =      new SpaceShipDelegation(&quot;NSEA Protector&quot;);    protector.forward(100);  }}</code></pre><p>4.向上转型<br>新类和基类之间的关系，新类是现有类的一种类型。<br>基类所有的方法和属性在导出类中也同样存在，导出类可以转化为基类，即向上转型。</p><p>5.final 关键字，指“这是无法改变的”，可用在 <strong>数据、方法和类</strong> 上。</p><p>final 数据：一个永不改变的编译常量；一个运行时被初始化的值，而不希望被改变。<br>final 方法：方法锁定，在继承中保持行为不变，并且不会被覆盖；效率。<br>final 类：不允许继承。</p><p>final 强调不允许改变，static 强调只有一份。</p><p>6.初始化及类的加载</p><pre><code class="Java">//: reusing/Beetle.java// The full process of initialization.import static net.mindview.util.Print.*;class Insect {  private int i = 9;  protected int j;  Insect() {    print(&quot;i = &quot; + i + &quot;, j = &quot; + j);    j = 39;  }  private static int x1 =    printInit(&quot;static Insect.x1 initialized&quot;);  static int printInit(String s) {    print(s);    return 47;  }}public class Beetle extends Insect {  private int k = printInit(&quot;Beetle.k initialized&quot;);  public Beetle() {    print(&quot;k = &quot; + k);    print(&quot;j = &quot; + j);  }  private static int x2 =    printInit(&quot;static Beetle.x2 initialized&quot;);  public static void main(String[] args) {    print(&quot;Beetle constructor&quot;);    Beetle b = new Beetle();  }}/* Output:static Insect.x1 initializedstatic Beetle.x2 initializedBeetle constructori = 9, j = 0Beetle.k initializedk = 47j = 39*/</code></pre><h1 id="第8章-多态"><a href="#第8章-多态" class="headerlink" title="第8章 多态"></a>第8章 多态</h1><p>多态作用是消除类型之间的耦合关系，允许将多种类型视为同一类型处理。</p><p>1.方法调用绑定</p><p>将一个方法调用同一个方法主题关联起来被称作绑定：<br>前期绑定：在程序执行前进行绑定；<br>后期绑定：运行时根据对象的类型进行绑定。</p><p>Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定</p><pre><code class="Java">public class Shape {    public void draw() {}    public void erase() {}}class Circle extends Shape {    public void draw() { System.out.println(&quot;Circle.draw()&quot;); }    public void erase() { System.out.println(&quot;Circle.erase()&quot;); } }class Square extends Shape {    public void draw() { System.out.println(&quot;Square.draw()&quot;); }    public void erase() { System.out.println(&quot;Square.erase()&quot;); } }public static void main(String[] args) {    Shape shape = new Circle();    shape.draw();}/* Output:Circle.draw()*/</code></pre><p>因为继承，将 Shape 引用指向一个新创建的 Circle 对象不会有任何问题；<br>又因为时后期绑定，会使得程序能够正确调用 Circle.draw() 。</p><h1 id="第9章-接口"><a href="#第9章-接口" class="headerlink" title="第9章 接口"></a>第9章 接口</h1><p>接口和内部类为我们提供了一种将接口和实现分离的更加结构化的方法。</p><p>1.抽象类和抽象方法</p><p>抽象方法是不完整的，仅有声明而没有方法体。</p><pre><code class="Java">abstract void f();</code></pre><p>包含抽象方法的类叫做抽象类；如果一个类包含一个或多个抽象方法，该类必须被定义为抽象的。</p><p>继承自抽象类的新类需要提供所有抽象方法的定义，否则也是抽象类。</p><p>2.接口</p><p>interface 关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。<br>要让一个类遵循特定接口或者一组接口，需要使用 implements 关键字。</p><pre><code class="Java">interface Instrument {    int VALUE = 5;//final &amp;&amp; static    void play(String s);    void adjust();}class Wind implements Instrument {    public void play(String s) {        System.out.print(&quot;Wind.play()&quot;);    }    public void adjust() {        System.out.println(&quot;&quot;Wind.adjust()&quot;&quot;);    }}</code></pre><ul><li>接口中的方法默认是 public 的，不需要显式声明为 public 的；</li><li>接口中的任何域都自动是 static 和 final 的；</li><li>当要实现一个接口时，在接口中被定义的方法必须被显式声明为 public 的，否则只能得到默认的包访问权限。</li></ul><h1 id="第10章-内部类"><a href="#第10章-内部类" class="headerlink" title="第10章 内部类"></a>第10章 内部类</h1><p>将一个类的定义放在另一个类的定义的内部，这就是内部类。</p><pre><code class="Java">public class Parcel1 {  class Destination {    private String label;    Destination(String whereTo) {      label = whereTo;    }    String readLabel() { return label; }  }  // Using inner classes looks just like  // using any other class, within Parcel1:  public void ship(String dest) {    Destination d = new Destination(dest);    System.out.println(d.readLabel());  }  public static void main(String[] args) {    Parcel1 p = new Parcel1();    p.ship(&quot;Tasmania&quot;);  }}/* Output:Tasmania*/</code></pre><p>1.内部类不仅是一种名字隐藏和组织代码的模式，还拥有与其他外围类的所有元素的访问权限。</p><p>2.使用 .this 与 .new</p><p>.this 用来生成对外围对象的引用。</p><pre><code class="Java">public class DotThis {  void f() { System.out.println(&quot;DotThis.f()&quot;); }  public class Inner {    public DotThis outer() {      return DotThis.this;      // A plain &quot;this&quot; would be Inner&#39;s &quot;this&quot;    }  }  public Inner inner() { return new Inner(); }  public static void main(String[] args) {    DotThis dt = new DotThis();    DotThis.Inner dti = dt.inner();    dti.outer().f();  }}/* Output:DotThis.f()*/</code></pre><p>.new 用来创建外部类对象的内部类对象。</p><pre><code class="Java">public class DotNew {  public class Inner {}  public static void main(String[] args) {    DotNew dn = new DotNew();    DotNew.Inner dni = dn.new Inner();  }}</code></pre><p>3.匿名内部类</p><pre><code class="Java">public class Parcel7 {  public Contents contents() {    return new Contents() { // Insert a class definition      private int i = 11;      public int value() { return i; }    }; // Semicolon required in this case  }  public static void main(String[] args) {    Parcel7 p = new Parcel7();    Contents c = p.contents();  }}</code></pre><p>4.嵌套类</p><p>如果不需要内部类对象与外部类对象之间的联系，内部类声明可为 static ，通常称为嵌套类。</p><ul><li>创建嵌套类对象并不需要其外围对象。</li><li>不能从嵌套类对象中访问非静态的外围类对象。</li></ul><p>5.闭包和回调</p><p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。</p><p>回调（Callback）程序在特定时间自己回头调用预先实现的方法。</p><blockquote><p>参考资料<br>1、Java 修饰符<br><a href="http://www.runoob.com/java/java-modifier-types.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/java/java-modifier-types.html</a><br>2、《Java编程思想》读书笔记 第九章 接口<br><a href="https://zhuanlan.zhihu.com/p/25597956" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25597956</a><br>3、Java—内部类（二）—实现闭包与回调<br><a href="http://blog.csdn.net/yuwenhao07/article/details/53607117" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/yuwenhao07/article/details/53607117</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类与接口。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/235f2f09.html"/>
    <id>http://www.wshunli.com/posts/235f2f09.html</id>
    <published>2017-11-28T12:47:30.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 基础知识部分。</p><a id="more"></a><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a>第3章 操作符</h1><p>Java 中的数据是通过使用操作符来操作的。</p><ul><li>赋值操作符</li><li>算术操作符</li><li>关系操作符</li><li>逻辑操作符</li><li>按位操作符</li><li>其他操作符</li></ul><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a>第4章 控制执行流程</h1><p>1.Java 中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p>2.Foreach 语法，用于数组或容器</p><pre><code class="Java">int [] numbers = {10, 20, 30, 40, 50};for(int x : numbers ){    System.out.print( x );    System.out.print(&quot;,&quot;);}// 10,20,30,40,50,</code></pre><p>3.return、break、continue</p><p>return：指定方法的返回值或者退出当前方法。</p><p>break：主要用于循环或者 switch 语句，退出整个语句块。<br>continue：跳转到下一次循环迭代。</p><p>4.Java 分支结构：swich 语句与 if 语句</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 基础知识部分。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/1349c3d1.html"/>
    <id>http://www.wshunli.com/posts/1349c3d1.html</id>
    <published>2017-11-28T02:58:36.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 一切皆对象。</p><a id="more"></a><h1 id="第1章-对象导论"><a href="#第1章-对象导论" class="headerlink" title="第1章 对象导论"></a>第1章 对象导论</h1><p>本章主要介绍 OOP 面向对象的思想以及抽象、封装、继承、多态的概念。</p><p>JAVA 是一种面向对象编程语言：</p><ul><li>万物皆对象，每一个对象都会存储数据，并且可以对自身执行操作。因此，每一个对象包含两部分：成员变量和成员方法。在成员方法中可以改变成员变量的值。</li><li>程序是对象的集合，他们通过发送消息来告知彼此所要做的事情，也就是调用相应的成员函数。</li><li>每一个对象都有自己的由其他对象所构成的存储，也就是说在创建新对象的时候可以在成员变量中使用已存在的对象。</li><li>每个对象都拥有其类型，每个对象都是某个类的一个实例，每一个类区别于其它类的特性就是可以向它发送什么类型的消息，也就是它定义了哪些成员函数。</li><li>某一个特定类型的所有对象都可以接受同样的消息。</li></ul><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a>第2章 一切都是对象</h1><p>1.Java 中一切都被视为对象，但是操作的标识符实际是对象的引用。</p><pre><code class="Java">String s;                         // s 为引用，并不是对象。String s = new String(&quot;wshunli&quot;); // s 与新的对象关联String s = &quot;wshunli&quot;;             // 等价</code></pre><p>2.数据存储位置可分为：寄存器、堆栈、堆、常量存储、非 RAM 存储。</p><ul><li>寄存器位于处理器内部，最快的存储区；</li><li>堆栈通常位于 RAM 中，存储对象引用；</li><li>堆通常也是位于 RAM 中，存储所有 Java 对象；</li><li>常量存储直接存放在代码内部；</li><li>非 RAM 存储的数据完全存活于程序之外，比如流对象和持久化对象。</li></ul><p>3.Java 基本数据类型：</p><ul><li>byte、short、int、long</li><li>float、double</li><li>boolean</li><li>char</li></ul><p>4.类：字段、方法组成。</p><p>5.HelloWorld：</p><pre><code class="Java">public class HelloWorld {    /* 第一个Java程序     * 它将打印字符串 Hello World     */    public static void main(String []args) {        System.out.println(&quot;Hello World&quot;); // 打印 Hello World    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 一切皆对象。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（四）</title>
    <link href="http://www.wshunli.com/posts/9695607b.html"/>
    <id>http://www.wshunli.com/posts/9695607b.html</id>
    <published>2017-11-19T06:34:43.000Z</published>
    <updated>2017-12-04T14:49:15.650Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      看得更远，走得更远。
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《React Native开发指南》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/46b86b5e.html"/>
    <id>http://www.wshunli.com/posts/46b86b5e.html</id>
    <published>2017-11-18T04:23:39.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。<br><a id="more"></a></p><p>我选择的是先看 《React Native开发指南》 入门。</p><h1 id="第1章-初识-React-Native"><a href="#第1章-初识-React-Native" class="headerlink" title="第1章 初识 React Native"></a>第1章 初识 React Native</h1><p><a href="https://facebook.github.io/react-native/" rel="external nofollow noopener noreferrer" target="_blank">React Native</a> 是一款用来开发真正原生、可渲染 iOS 和 Android 移动应用的 JavaScript 框架。<br>React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。<br>在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。</p><h1 id="第2章-React-Native-工作原理"><a href="#第2章-React-Native-工作原理" class="headerlink" title="第2章 React Native 工作原理"></a>第2章 React Native 工作原理</h1><p>React Native 使用 Virtual DOM 作为中间层，介于开发者描述的视图与实际页面渲染的视图之间。<br>Virtual DOM 不仅能提升性能，而且提供了强大的抽象能力，在开发者代码和实际渲染之间加入一个抽象层。</p><p>React Native 调用 Objective-C 的 API 渲染 iOS 组件，调用 Java 接口渲染 Android 组件，而不是渲染到浏览器 DOM 上。</p><p>React Native 的渲染周期和 React 完全相同；组件也很类似，只是名称有差别，但是和原生的组件名字差不多；使用 JSX 以及 React 的内联样式。</p><p>React Native 同样可以调用宿主平台的接口，比如数据存储，操控硬件设备等等。</p><h1 id="第3章-构建你的第一个应用"><a href="#第3章-构建你的第一个应用" class="headerlink" title="第3章 构建你的第一个应用"></a>第3章 构建你的第一个应用</h1><p>类似 React ，使用 React Native 构建 Android 应用，可使用 <code>create-react-native-app</code> 脚手架工具。</p><pre><code class="JSX">npm install -g create-react-native-app</code></pre><p>安装完成后执行以下命令即可创建 React Native 项目：</p><pre><code class="JSX">create-react-native-app first-react-native-app// 打开项目目录cd first-react-native-appnpm start</code></pre><p>基本上就构建完成。</p><p>运行在 Andoroid 系统:</p><pre><code class="JSX">npm run android</code></pre><p>代码也比较容易理解：</p><pre><code class="JSX">import React from &#39;react&#39;;import { StyleSheet, Text, View } from &#39;react-native&#39;;export default class App extends React.Component {  render() {    return (      &lt;View style={styles.container}&gt;        &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt;        &lt;Text&gt;Changes you make will automatically reload.&lt;/Text&gt;        &lt;Text&gt;Shake your phone to open the developer menu.&lt;/Text&gt;      &lt;/View&gt;    );  }}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: &#39;#fff&#39;,    alignItems: &#39;center&#39;,    justifyContent: &#39;center&#39;,  },});</code></pre><p>感觉和 React.js 差不多，比较容易理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。&lt;br&gt;
    
    </summary>
    
      <category term="跨平台技术" scheme="http://www.wshunli.com/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React Native" scheme="http://www.wshunli.com/tags/React-Native/"/>
    
      <category term="《React Native开发指南》" scheme="http://www.wshunli.com/tags/%E3%80%8AReact-Native%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/86c8e45a.html"/>
    <id>http://www.wshunli.com/posts/86c8e45a.html</id>
    <published>2017-11-15T08:05:27.000Z</published>
    <updated>2017-12-04T14:49:15.650Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习 《深入浅出React和Redux》<br><a id="more"></a></p><h1 id="第3章-从-Flux-到-Redux"><a href="#第3章-从-Flux-到-Redux" class="headerlink" title="第3章 从 Flux 到 Redux"></a>第3章 从 Flux 到 Redux</h1><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>Redux 是 Flux 单向数据流思想的另一种实现方式，先介绍 Flux 的优缺点。</p><h3 id="MVC-介绍"><a href="#MVC-介绍" class="headerlink" title="MVC 介绍"></a>MVC 介绍</h3><p>MVC 框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分为三个部分：<br><img src="https://img.wshunli.com/React/深入浅出React和Redux/MVC.png-hexo.png" alt="MVC"></p><ul><li>Model （模型）负责管理数据，大部分业务逻辑也应该放在Model 中；</li><li>View （视图）负责渲染用户界面，应该避免在View 中涉及业务逻辑；</li><li>Controller （控制器）负责接受用户输入根据用户输入调用对应的Model 部分逻辑，把产生的数据结果交给View 部分，让View 渲染出必要的输出。</li></ul><p>MVC 框架提出的数据流很理想，用户请求先到达 Controller ，由 Controller 调用 Model 获得数据，然后把数据交给 View，但是在实际框架实现中，总是允许 View 和 Model 可以直接通信，MVC 很快就变得非常复杂。</p><p>Flux 执行更严格的数据流控制。一个 Flux 应用包含四个部分：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/Flux.png-hexo.png" alt="Flux"></p><ul><li>Dispatcher ，处理动作分发，维持Store 之间的依赖关系；</li><li>Store ，负责存储数据和处理数据相关逻辑；</li><li>Action ，驱动 Dispatcher 的JavaScript 对象；</li><li>View ，视图部分，负责显示用户界面。</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Flux 的基本原则是“单向数据流”， Redux 在此基础上强调三个基本原则：</p><ul><li>唯一数据源（ Single Source of Truth);</li><li>保持状态只读（ State is read-only);</li><li>数据改变只能通过纯函数完成（ Changes are made with pure functions ）。</li></ul><blockquote><p>参考资料<br>1、Flux | Application Architecture for Building User Interfaces<br><a href="https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow" rel="external nofollow noopener noreferrer" target="_blank">https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow</a><br>2、Flux 架构入门教程 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2016/01/flux.html</a><br>3、</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习 《深入浅出React和Redux》&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>又拍云CDN全站加速</title>
    <link href="http://www.wshunli.com/posts/97fe98e3.html"/>
    <id>http://www.wshunli.com/posts/97fe98e3.html</id>
    <published>2017-11-11T11:44:24.000Z</published>
    <updated>2017-12-04T14:49:15.650Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。</p><a id="more"></a><p>前几天使用 Travis CI 自动构建 Hexo 博客并且上传至 Github 和 Coding，就在想能不能同时上传至 <a href="https://console.upyun.com/register/?invite=H1_D-bC4W" rel="external nofollow noopener noreferrer" target="_blank">又拍云</a>。</p><p>今天晚上使用 ftp 上传至又拍云，网站实现全站 CDN 加速。</p><p>前面发现是有工具可以直接上传至又拍云：</p><p><a href="https://github.com/Menci/hexo-deployer-upyun" rel="external nofollow noopener noreferrer" target="_blank">hexo-deployer-upyun</a></p><p>但是这个工具在 Windows 系统下使用有问题，并且我已经使用 Travis CI 自动部署了，继续使用这个工具有<strong>令牌</strong>暴露的风险。</p><p>所以就想使用 ftp 上传至又拍云，然后就发现了这个工具：</p><p><a href="https://github.com/git-ftp/git-ftp" rel="external nofollow noopener noreferrer" target="_blank">Git-ftp</a> – uploads to FTP servers the Git way</p><p>在 linux 下的安装方法：</p><pre><code class="Shell">git clone https://github.com/git-ftp/git-ftp.gitcd git-ftp# choose the newest releasetag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;# checkout the latest taggit checkout &quot;$tag&quot;sudo make install</code></pre><p>配置 git-ftp ：</p><pre><code class="Shell">git config git-ftp.url &quot;ftp://ftp.example.net:21/public_html&quot;git config git-ftp.user &quot;ftp-user&quot;git config git-ftp.password &quot;secr3t&quot;</code></pre><p>第一次上传执行：</p><pre><code class="Shell">git ftp init</code></pre><p>后面上传执行，只会上传变化的部分：</p><pre><code class="Shell">git ftp push</code></pre><p>使用方法也很简单，下面就默认在原来 <a href="https://www.wshunli.com/posts/7dcaaf9e.html">Travis CI 自动部署</a> 的基础上:</p><p>在 <code>.travis.yml</code> 文件中修改：</p><pre><code class="Shell">install:  - npm install  - git clone https://github.com/git-ftp/git-ftp.git  - cd git-ftp  - tag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;  - git checkout &quot;$tag&quot;  - sudo make install  - cd ..</code></pre><p>在 <code>publish-to-gh-pages.sh</code> 中修改</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;git ftp init# git ftp push</code></pre><p>第一次上传之后，修改 <code>publish-to-gh-pages.sh</code> 文件</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;# git ftp initgit ftp push -v</code></pre><p>其中 UPYUN_USE 和 UPYUN_PSD 是在 Travis 中配置的 UPYUN ftp 用户名密码。<br>具体值可参考：<a href="https://docs.upyun.com/api/developer_tools/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.upyun.com/api/developer_tools/</a></p><p>其实有点弊端就是上传之后更新具有一定的延迟性，但是速度快很多。</p><blockquote><p>参考资料<br>1、travis-ci-deploy-ftp<br><a href="https://github.com/ansediao/travis-ci-deploy-ftp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ansediao/travis-ci-deploy-ftp</a><br>2、How to use git-ftp： 使用 git-ftp 管理你的 FTP<br><a href="https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9</a><br>3、使用 git-ftp 将 git 两次提交发生变化的文件上传到服务器<br><a href="http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server" rel="external nofollow noopener noreferrer" target="_blank">http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="Upyun" scheme="http://www.wshunli.com/tags/Upyun/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/d0f6201d.html"/>
    <id>http://www.wshunli.com/posts/d0f6201d.html</id>
    <published>2017-11-10T05:40:03.000Z</published>
    <updated>2017-12-04T14:49:15.650Z</updated>
    
    <content type="html"><![CDATA[<p>发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。</p><a id="more"></a><p>之间就简单地使用 <a href="https://reactjs.org" rel="external nofollow noopener noreferrer" target="_blank">React</a> 搭建过一次 Demo ，借这次机会把 React 给搞定了，至少能写个简单的界面。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React技术栈.png-hexo.png" alt="React技术栈"></p><p>看着这 React技术栈 ，还是压力山大啊。</p><p>这次选了两本书 《深入浅出React和Redux》 和 《React全栈》。书都很新也很薄，这次先看一本入门。</p><h1 id="第1章-React-新的前端思维方式"><a href="#第1章-React-新的前端思维方式" class="headerlink" title="第1章 React 新的前端思维方式"></a>第1章 React 新的前端思维方式</h1><p>首先使用 <code>creat-react-app</code> 创建一个 React 应用。</p><p>在确认 Node.js 和 npm 安装好之后，在命令行执行以下命令安装 <code>creat-react-app</code> 工具。</p><pre><code class="Shell">npm install -g create-react-appcreate-react-app first-react-appnpm start</code></pre><p>浏览器会自动打开 <a href="http://localhost:3000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:3000/</a> 显示如下界面：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app.png-hexo.png" alt="first-react-app"></p><p>我们来看一下 first-react-app 的目录结构：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app2.png-hexo.png" alt="first-react-app"></p><p>在开发过程中，我们主要关注 src 目录的内容。</p><p>其中 <code>src/index.js</code> 文件是应用的入口文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import App from &#39;./App&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>这里的代码渲染了一个 App 组件，效果就是首页界面。<br>我们看下 App 组件是怎么定义的，在 <code>src/App.js</code> 文件中：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import logo from &#39;./logo.svg&#39;;import &#39;./App.css&#39;;class App extends Component {  render() {    return (      &lt;div className=&quot;App&quot;&gt;        &lt;header className=&quot;App-header&quot;&gt;          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;        &lt;/header&gt;        &lt;p className=&quot;App-intro&quot;&gt;          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.        &lt;/p&gt;      &lt;/div&gt;    );  }}export default App;</code></pre><p>React 应用实际上依赖很复杂的技术栈，我们使用 <code>creat-react-app</code> 避免一开始就浪费太多精力配置技术栈。</p><p>我们启动 React 的命令是 <code>npm start</code> ，在 <code>package.json</code> 中：</p><pre><code class="JS">  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  }</code></pre><p>npm build 可以创建生产环境优化代码；<br>npm teat 用于单元测试；<br>npm eject 把 react-scripts 技术栈配置都弹射到应用顶层，不可逆。</p><h2 id="添加-React-组件"><a href="#添加-React-组件" class="headerlink" title="添加 React 组件"></a>添加 React 组件</h2><p>仿照着增加一个新的 React 组件。同样在 src 目录新建文件 <code>ClickCounter.js</code> 写入如下代码：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;class ClickCounter extends Component {  constructor(props) {    super(props);    this.onClickButton = this.onClickButton.bind(this);    this.state = {      count: 0    }  }  onClickButton() {    this.setState({count: this.state.count + 1});  }  render() {    const counterStyle = {      margin: &#39;16px&#39;    }    return (      &lt;div style={counterStyle}&gt;        &lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;        &lt;div&gt;          Click Count: &lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    );  }}export default ClickCounter;</code></pre><p>修改 <code>src/index.js</code> 文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import ClickCounter from &#39;./ClickCounter&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;ClickCounter /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>其中在 index.js 中使用 import 导入 ClickCounter 组件，替代之前的 App 组件。</p><pre><code class="JSX">import ClickCounter from &#39;./ClickCounter&#39;;</code></pre><p>在 ClickCounter.js 的第一行我们以同样的方式引入 React 和 Component 。</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;</code></pre><p>Component 为所有组件的基类，提供很多组件共有的功能。</p><pre><code class="JSX">class ClickCounter extends Component {}</code></pre><p>React 没有在代码中直接使用，但在 JSX 使用的范围内必须有 React，因为 JSX 最终会被转译成依赖 React 的表达式。</p><p><strong>JSX</strong>：JSX 是 JavaScript 的一种扩展语法，使我们能够在 JavaScript 中编写类似 HTML 的代码。<br>JSX 的基本语法规则：遇到 HTML 标签（以&lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。</p><p>首先，在 JSX 中使用的元素不限于 HTML 元素，可以是 React 组件。而区分二者的方法是首字母是否大写。<br>其次，在 JSX 中可以通过 onClick 这样的方式为元素添加事件处理函数。</p><pre><code class="JSX">&lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;</code></pre><h2 id="React-的工作方式"><a href="#React-的工作方式" class="headerlink" title="React 的工作方式"></a>React 的工作方式</h2><p>React的理念归结为一个公式：UI=render(data) 。</p><p>用户看到的界面（UI）是一个函数（render）的执行结果，只接受数据（data）作为参数。这是一个纯函数，即输出只依赖于输入的函数，两次函数的调用如果输入相同，那么输出也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于data ，哪些属于render ，想要更新用户界面，要做的就是更新data ，用户界面自然会做出响应，所以React 实践的也是“响应式编程”（ Reactive Programming ）的思想。</p><p><strong>Virtual DOM</strong>：是对DOM树的抽象，它并不触及浏览器部分，只是存在于 JavaScript 空间的树形结构，每次在渲染 React 组件，React 会对前后两次产生的 Virtual DOM 进行比较，最后只有发生了改变的地方会被重新渲染。</p><blockquote><p>总而言之，React利用函数式编程的思维来解决用户界面渲染的问题，强制所有组件都以数据驱动渲染的模式进行开发。</p></blockquote><h1 id="第2章-设计高质量的-React-组件"><a href="#第2章-设计高质量的-React-组件" class="headerlink" title="第2章 设计高质量的 React 组件"></a>第2章 设计高质量的 React 组件</h1><p>作为软件设计的通则，组件的划分要满足高内聚（High Cohesion ）和低搞合（ Low Coupling）的原则。</p><h2 id="React-组件的数据"><a href="#React-组件的数据" class="headerlink" title="React 组件的数据"></a>React 组件的数据</h2><p>React 组件的数据分为两种， prop 和 state。</p><p>prop 是组件的对外接口， state 是组件的内部状态，对外用 prop ，内部用 state 。</p><h3 id="React-的-prop"><a href="#React-的-prop" class="headerlink" title="React 的 prop"></a>React 的 prop</h3><p>prop ( property 的简写）是外部传递给组件的数据， React 组件通过定义自己能够接受的 prop 就定义了自己的对外公共接口。</p><pre><code class="JSX">&lt;SampleButtonid= &quot;sample&quot; borderWidth={2} onClick={onButtonClick}style={{color :"red"}}/&gt;</code></pre><p>当 prop 的值不是字符串类型时，在 JSX 中必须用花括号 {} 包住，<br>所以 style 的值有两层花括号，外层花括号代表是 JSX 的语法，内层的花括号代表这是一个对象常量。</p><pre><code class="JSX">class ControlPanel extends Component {  render() {    console.log(&#39;enter ControlPanel render&#39;);    return (      &lt;div&gt;        &lt;Counter caption=&quot;First&quot; initValue={0}/&gt;        &lt;Counter caption=&quot;Second&quot; initValue={10} /&gt;        &lt;Counter caption=&quot;Third&quot; initValue={20} /&gt;      &lt;/div&gt;    );  }}</code></pre><p>上面是给 prop 赋值，下面读取 prop 的值：</p><pre><code class="JSX">class Counter extends Component {  constructor(props) {    console.log(&#39;enter constructor: &#39; + props.caption);    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue || 0    }  }  ···</code></pre><p>在构造函数中可以通过参数 props 获得传人 prop 值，在其他函数中则可以通过 <code>this.props</code> 访问传人 prop 的值。</p><pre><code class="JSX">  ··· render() {    console.log(&#39;enter render &#39; + this.props.caption);    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }</code></pre><p><strong>propTypes 检查</strong>：组件声明接口规范，即组件支持的 prop 及其格式。</p><pre><code class="JSX">Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number};</code></pre><p>建议在开发阶段使用，产品环境下去除。</p><h3 id="React-的-state"><a href="#React-的-state" class="headerlink" title="React 的 state"></a>React 的 state</h3><p>state 代表组件的内部状态。</p><p>1、初始化 state</p><p>通常在组件的构造函数结尾处初始化 state 。</p><pre><code class="JSX">constructor(props) {    ···    this.state = {      count: props.initValue || 0    }  }</code></pre><p>React 的 defaultProps 给 prop 默认初始值：</p><pre><code class="JSX">Counter.defaultProps = {  initValue: 0}// this.state 可省去判断this.state = {  count: props.initValue}</code></pre><p>2、读取更新 state</p><p>this.state 读取 state<br>this.setState 更新 state</p><pre><code class="JSX">onClickIncrementButton() {  this.setState({count: this.state.count + 1});}</code></pre><h3 id="prop-和state-的区别"><a href="#prop-和state-的区别" class="headerlink" title="prop 和state 的区别"></a>prop 和state 的区别</h3><ul><li>prop 用于定义外部接口， state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时， state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><p>组件是绝不应该去修改传人的 props 值，否则会影响其他组件。</p><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：</p><ul><li>装载过程（ Mount ），也就是把组件第一次在DOM 树中渲染的过程；</li><li>更新过程（ Update ），当组件被重新渲染的过程；</li><li>卸载过程（ Unmount ），组件从DOM 中删除的过程。</li></ul><p>三种不同的过程， React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React组件生命周期.png-hexo.png" alt="React组件生命周期"></p><p><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a></p><h3 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h3><p>当组件第一次渲染的时候，依次调用的函数如下：</p><ul><li>constructor()</li><li>getlnitialState()</li><li>getDefaultProps()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p>1、constructor()<br>ES6 中类的构造函数，主要是初始化 state 和绑定成员函数的 this 环境。</p><p>2、getlnitialState() 和 getDefaultProps()<br>getlnitialState() 返回值用来初始化组件的 this.state ，getDefaultProps() 返回值用来作为 prop 的初始值。<br>这两个方法只有用 React.createClass 方法创建组件类时才会生效。</p><pre><code class="JSX">const Sample = React.createClass({  getInitialState() {    console.log(&#39;enter getInitialState&#39;);  }  getDefaultProps() {    console.log(&#39;enter getDefaultProps&#39;);  }});</code></pre><p>而在 ES6 中使用 defaultProps 指定初试 prop 初始值。</p><pre><code class="JSX">const Sample extends React.Component({  constructor(props) {    super(props);    this.state = {foo: &quot;bar&quot;}  }}Sample.defaultProps = {  return {sampleProp: 0}};</code></pre><p>React.createClass 已经被 Facebook 官方逐渐废弃。</p><p>3、render()</p><p>render() 函数在 React 中必须实现，其他生命周期函数在 React.Component 中都有默认实现。</p><p>render() 并不做实际的渲染动作，只是返回 JSX 描述的结构，最终由 React 操作渲染过程。<br>不需要渲染界面可以返回 null 或者 false 。</p><p>4、componentWillMount() 和 componentDidMount()</p><p>在装载过程中，componentWillMount() 会在调用 render() 函数之前被调用， componentDidMount() 会在调用 render() 函数之后被调用。</p><p>componentWillMount() 是将要装载，虽然还没有渲染出来结果，但是修改组件状态已经晚了。<br>componentDidMount() 是 render() 函数返回的内容已经渲染好了，组件已经被装载在 DOM 树上了。</p><p>componentWilIMount() 和 componentDidMount() 这对兄弟函数还有一个区别：<br>componentWillMount() 可以在服务器端被调用，也可以在浏览器端被调用；<br>而componentDidMount() 只能在浏览器端被调用，在服务器端使用 React 的时候不会被调用。</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>当组件的 props 或者 state 被修改的时候，就会引发组件的更新过程。<br>更新过程会依次调用下面的生命周期函数：</p><ul><li>componentWillReceiveProps(nextProps)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><p>1、componentWillReceiveProps(nextProps)</p><p>只要是父组件的 render() 函数被调用，在 render() 函数里面被谊染的子组件就会经历更新过程，<br>不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps() 函数。</p><p>componentWillReceiveProps(nextProps) 适合根据新的 props 值（也就是参数 nextProps ）来计算出是不是要更新内部状态state 。</p><p>注意，更新组件内部状态的方法 this.setState() 方法触发的更新过程不会调用这个函数，否则会导致 componentWillReceiveProps 再次被调用，陷入死循环。</p><p>当组件的 props 发生改变：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当组件的 state 发生改变：</p><pre><code class="TXT">&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当父组件导致子组件重新渲染：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>2、shouldComponentUpdate(nextProps, nextState)</p><p>shouldComponentUpdate() 函数决定组件是否需要渲染，返回布尔值。</p><pre><code class="JSX">shouldComponentUpdate(nextProps, nextState) {  return (nextProps.caption !== this.props.caption) ||         (nextState.count !== this.state.count);}</code></pre><p>3、componentWillUpdate() 和 componentDidUpdate()</p><p>当组件的 shouldComponentUpdate() 函数返回 true ,React 接下来依次调用对应组件的 componentWillUpdate()、render() 和 componentDidUpdate() 函数。</p><p>和装载过程不同的是，当在服务器端使用 React 渲染时，二者都可以在服务端调用。</p><h3 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h3><p>componentWillUnmount() 表示组件要从 DOM 树上删除掉之前，比较适合做一些清理工作。</p><h2 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h2><p><code>ControlPanel.js</code></p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import Counter from &#39;./Counter.js&#39;;const style = {  margin: &#39;20px&#39;};class ControlPanel extends Component {  constructor(props) {    super(props);    this.onCounterUpdate = this.onCounterUpdate.bind(this);    this.initValues = [ 0, 10, 20];    const initSum = this.initValues.reduce((a, b) =&gt; a+b, 0);    this.state = {      sum: initSum    };  }  onCounterUpdate(newValue, previousValue) {    const valueChange = newValue - previousValue;    this.setState({ sum: this.state.sum + valueChange});  }  render() {    return (      &lt;div style={style}&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;First&quot; /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Second&quot; initValue={this.initValues[1]} /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Third&quot; initValue={this.initValues[2]} /&gt;        &lt;hr/&gt;        &lt;div&gt;Total Count: {this.state.sum}&lt;/div&gt;      &lt;/div&gt;    );  }}export default ControlPanel;</code></pre><p><code>Counter.js</code></p><pre><code class="JSX">import React, { Component, PropTypes } from &#39;react&#39;;const buttonStyle = {  margin: &#39;10px&#39;};class Counter extends Component {  constructor(props) {    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue    }  }  onClickIncrementButton() {    this.updateCount(true);  }  onClickDecrementButton() {    this.updateCount(false);  }  updateCount(isIncrement) {    const previousValue = this.state.count;    const newValue = isIncrement ? previousValue + 1 : previousValue - 1;    this.setState({count: newValue})    this.props.onUpdate(newValue, previousValue)  }  render() {    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }}Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number,  onUpdate: PropTypes.func};Counter.defaultProps = {  initValue: 0,  onUpdate: f =&gt; f //什么都不做的函数};export default Counter;</code></pre><blockquote><p>参考资料<br>1、React.Component - React<br><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a><br>2、React组件生命周期<br><a href="https://nsne.github.io/2017/02/15/react-component-lifecycle/" rel="external nofollow noopener noreferrer" target="_blank">https://nsne.github.io/2017/02/15/react-component-lifecycle/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署Hexo博客</title>
    <link href="http://www.wshunli.com/posts/7dcaaf9e.html"/>
    <id>http://www.wshunli.com/posts/7dcaaf9e.html</id>
    <published>2017-11-09T11:14:08.000Z</published>
    <updated>2017-12-04T14:49:15.650Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。</p><a id="more"></a><p>我一般都是将博客的源文件保存到私有仓库中，虽然几个简单地命令就能部署，但是过程还是很繁琐。最近申请了 Github Student Developer Pack ，就想利用软件开发中的持续集成工具 Travis CI 来帮助完成 Hexo 博客的部署过程。这样就只需要把源代码 push 到仓库就能自动部署好了。</p><p>CI 是 Continuous Integration 的缩写，持续集成之意。持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><h1 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h1><p>关于 Hexo 博客的搭建请参考文章：<a href="https://www.wshunli.com/posts/9642fffa.html">https://www.wshunli.com/posts/9642fffa.html</a></p><h1 id="Travis-CI-配置"><a href="#Travis-CI-配置" class="headerlink" title="Travis CI 配置"></a>Travis CI 配置</h1><p>1.使用 GitHub 账户登录 <a href="https://travis-ci.org" rel="external nofollow noopener noreferrer" target="_blank">Travis CI</a> 官网，然后用 Github 账号登陆，就可以看到可以持续集成的仓库。</p><p>还有个地址 <a href="https://travis-ci.com" rel="external nofollow noopener noreferrer" target="_blank">https://travis-ci.com</a> 可以部署 Github 私有仓库。</p><p>选择要启用的项目，打开<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo1.png" alt=""></p><p>然后选择一些通用的设置<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo2.png" alt=""></p><p>2.登陆 GitHub –Settings -Developer Settings 选项，找到 Personal access tokens 页面。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo3.png" alt=""></p><p>点击右上角的 Generate new token 按钮会生成新的token，点击后提示输入密码后继续，然后来到如下界面。<br>取个名字，勾选相应权限，这里只需要 repo 下全部和 user 下的 user:email 即可。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo4.png" alt=""></p><p>生成完成后，将该token拷贝下来。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo5.png" alt=""></p><p><strong>如果需要将代码同时部署到 Coding 类似</strong>：<br>3.登陆 Coding ，账户 -访问令牌，新建访问令牌：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding1.png" alt=""></p><p>勾选相应权限：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding2.png" alt=""></p><p>4.将上面获取到的token添加到 Environment Variables 部分，值为该 token ，而名称为 GH_TOKEN、CD_TOKEN 。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo6.png" alt=""></p><h1 id="创建-travis-yml"><a href="#创建-travis-yml" class="headerlink" title="创建 .travis.yml"></a>创建 .travis.yml</h1><p>要想自动部署还需在博客源码新增加 <code>.travis.yml</code> 配置文件。</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - npm install -g hexo-cliinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:    - cd ./public    - git init    - git config user.name &quot;yourname&quot; # 修改name    - git config user.email &quot;youremail&quot; # 修改email    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master     # GH_TOKEN 是在 Travis 中配置 token 的名称branches:    only:        - master #只监测 master 分支，master是我的分支的名称，可根据自己情况设置env:    global:        - GH_REF: github.com/yourname/yourname.github.io.git         # 设置 GH_REF，注意更改 yourname</code></pre><h1 id="实现自动部署"><a href="#实现自动部署" class="headerlink" title="实现自动部署"></a>实现自动部署</h1><p>将原代码 push 到 Github 即可，如果配置没问题就该自动构建了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>虽然实现了基本的自动部署，还是有问题的。</p><h2 id="master-commit-树被清空"><a href="#master-commit-树被清空" class="headerlink" title="master commit 树被清空"></a>master commit 树被清空</h2><p>自动部署会把原来的 commit 清空，显然不是我们想要的结果。</p><p>为了解决这个问题，将配置文件改为了如下的内容：</p><pre><code class="TXT">after_script:    - git clone https://${GH_REF} .deploy_git    - cd .deploy_git    - git checkout master    - cd ../    - mv .deploy_git/.git/ ./public/    - cd ./public    - git config user.name &quot;yourname&quot;    - git config user.email &quot;your email&quot;    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master</code></pre><h2 id="添加-commit-时间戳"><a href="#添加-commit-时间戳" class="headerlink" title="添加 commit 时间戳"></a>添加 commit 时间戳</h2><p>commit 的描述一直是 <code>Travis CI Auto Builder</code> 。</p><pre><code class="TXT">Travis CI Auto BuilderTravis CI Auto BuilderTravis CI Auto Builder// 之前Site updated: 2017-11-07 22:05:16Site updated: 2017-11-07 17:19:32Site updated: 2017-11-06 18:04:53</code></pre><p>最终 <code>.travis.yml</code> 配置文件：</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - export TZ=&#39;Asia/Shanghai&#39;  - npm install -g hexo-cli  - chmod +x ./publish-to-gh-pages.shinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:  - ./publish-to-gh-pages.shenv:    global:        - GH_REF: github.com/yourname/yourname.github.io.git        # 设置GH_REF，注意更改成自己的仓库地址        - CD_REF: git.coding.net/yourname/repository.git        # 同时部署到 Coding，repository 为仓库名称</code></pre><p>其中 <code>publish-to-gh-pages.sh</code> 文件：</p><pre><code class="TXT">#!/bin/bashset -evgit clone https://${GH_REF} .deploy_gitcd .deploy_gitgit checkout mastercd ../mv .deploy_git/.git/ ./public/cd ./publicgit config user.name  &quot;yourname&quot;git config user.email &quot;youremail&quot;git add .git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot;git push --force --quiet &quot;https://${TravisCIToken}@${GH_REF}&quot; master:mastergit push --force --quiet &quot;https://yourname:${CD_TOKEN}@${CD_REF}&quot; master:master# 同时部署到 Coding，注意修改 yourname</code></pre><blockquote><p>参考资料<br>1、使用Travis CI自动部署Hexo博客<br><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" rel="external nofollow noopener noreferrer" target="_blank">http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a><br>2、使用 Travis CI 自动部署 Hexo<br><a href="http://www.jianshu.com/p/5e74046e7a0f" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/5e74046e7a0f</a><br>3、使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器<br><a href="https://segmentfault.com/a/1190000009054888" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000009054888</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="TravisCI" scheme="http://www.wshunli.com/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/2a9bf8cf.html"/>
    <id>http://www.wshunli.com/posts/2a9bf8cf.html</id>
    <published>2017-11-09T06:52:46.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>这部分学习 ES6 中新增的数据类型。</p><h1 id="第10章-Symbol"><a href="#第10章-Symbol" class="headerlink" title="第10章 Symbol"></a>第10章 Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。</p><pre><code class="JavaScript">let s = Symbol();typeof s // &quot;symbol&quot;// 字符串参数let s1 = Symbol(&#39;foo&#39;);s1.toString() // &quot;Symbol(foo)&quot;// 对象参数-调用 toString 方法const obj = {  toString() {    return &#39;abc&#39;;  }};const sym = Symbol(obj);sym // Symbol(abc)</code></pre><p>Symbol 值不能与其他类型的值进行运算；可显式转为字符串或布尔值，但不能转为数值。</p><pre><code class="JavaScript">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym // TypeError: can&#39;t convert symbol to string// 字符串String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;// 布尔值let sym = Symbol();Boolean(sym) // true!sym  // false</code></pre><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>Symbol 值唯一，能保证对象不会出现同名的属性。</p><pre><code class="JavaScript">let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = &#39;Hello!&#39;;// 第二种写法let a = {  [mySymbol]: &#39;Hello!&#39;};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });// 以上写法都得到同样结果console.log(a[mySymbol]); // &quot;Hello!&quot;</code></pre><pre><code class="JavaScript"></code></pre><h1 id="第11章-Set-和-Map-数据结构"><a href="#第11章-Set-和-Map-数据结构" class="headerlink" title="第11章 Set 和 Map 数据结构"></a>第11章 Set 和 Map 数据结构</h1><h1 id="第12章-Proxy"><a href="#第12章-Proxy" class="headerlink" title="第12章 Proxy"></a>第12章 Proxy</h1><h1 id="第13章-Reflect"><a href="#第13章-Reflect" class="headerlink" title="第13章 Reflect"></a>第13章 Reflect</h1><h1 id="第14章-Promise-对象"><a href="#第14章-Promise-对象" class="headerlink" title="第14章 Promise 对象"></a>第14章 Promise 对象</h1><h1 id="第15章-Iterator-和-for…of-循环"><a href="#第15章-Iterator-和-for…of-循环" class="headerlink" title="第15章 Iterator 和 for…of 循环"></a>第15章 Iterator 和 for…of 循环</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/281a70b1.html"/>
    <id>http://www.wshunli.com/posts/281a70b1.html</id>
    <published>2017-11-09T06:44:01.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(六) 学习JavaScript的一些高级技巧及实践方案。</strong>(22-25章)</p><h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><p>这部分后面再看吧，现在那么水，估计还用不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/4d143b68.html"/>
    <id>http://www.wshunli.com/posts/4d143b68.html</id>
    <published>2017-11-08T13:12:48.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(五) 学习 JavaScript 对各数据载体的操作方法（如JSON、XML），学会 Ajax 的使用方法。</strong>(18-21章)</p><h1 id="第十八章-JavaScript-与-XML"><a href="#第十八章-JavaScript-与-XML" class="headerlink" title="第十八章 JavaScript 与 XML"></a>第十八章 JavaScript 与 XML</h1><h2 id="浏览器对-XML-DOM-的支持"><a href="#浏览器对-XML-DOM-的支持" class="headerlink" title="浏览器对 XML DOM 的支持"></a>浏览器对 XML DOM 的支持</h2><p>如何检测浏览器是否支持DOM2级XML：</p><pre><code class="JavaScript">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;,&quot;2.0&quot;);</code></pre><p>在支持DOM2级的浏览器中创建一个空白XML:</p><pre><code class="JavaScript">var xmldom = document.implemention.createDocument(namespaceUri,root,docype);</code></pre><p>通过 JavaScript 处理XML时，通常只使用参数root，这个参数指定的是XML DOM文档元素的标签名。</p><pre><code class="JavaScript">var xmldom = document.implementation.createDocument(&quot;&quot;,&quot;root&quot;,null);console.log(xmldom.documentElement.tagName);  //&quot;root&quot;var child = xmldom.createElement(&quot;child&quot;);xmldom.documentElement.appendChild(child);</code></pre><p><strong>DOMParser 类型</strong>：将 XML 解析为 DOM 文档。</p><p><strong>XMLSerializer 类型</strong>：将 DOM 文档序列化为 XML 字符串。</p><pre><code class="JavaScript">var parser = new DOMParser();var xmldom = parser.parseFromString(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;, &quot;text/xml&quot;);//convert back into XMLvar serializer = new XMLSerializer();var xml = serializer.serializeToString(xmldom);console.log(xml);</code></pre><h2 id="浏览器对XPath的支持"><a href="#浏览器对XPath的支持" class="headerlink" title="浏览器对XPath的支持"></a>浏览器对XPath的支持</h2><p>XPath 是设计用来在 DOM 文档中查找节点的一种手段。</p><h2 id="浏览器对XSLT的支持"><a href="#浏览器对XSLT的支持" class="headerlink" title="浏览器对XSLT的支持"></a>浏览器对XSLT的支持</h2><p>XSLT 是与 XML 相关的一种技术，它利用 XPath 将文档从一种表现形式转换成另一种表现形式。</p><h1 id="第十九章-E4X"><a href="#第十九章-E4X" class="headerlink" title="第十九章 E4X"></a>第十九章 E4X</h1><p>E4X 本身不是一门语言，它只是 ECMAScript 语言的可选扩展。<br>就其本身而言，E4X 为处理 XML 定义了新的语法，也定义了特定于 XML 的对象。</p><h1 id="第二十章-JSON"><a href="#第二十章-JSON" class="headerlink" title="第二十章 JSON"></a>第二十章 JSON</h1><p>JSON（Javascript Object Notaion，Javascript对象表示法）是一种数据格式。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON有3种类型的值：简单值、对象 和 数组。</p><ul><li>简单值：字符串、数值、布尔值、null（JSON不支持JavaScript的特殊值undefined）。</li><li>对象：一组无序键值对。值可为简单值，或对象和数组。</li><li>数组：一组有序值的列表。值可为简单值，或对象和数组。</li></ul><p>JSON不支持变量、函数 和 对象实例。</p><p><strong>简单值</strong>：最简单的 JSON 数据形式就是简单值。</p><pre><code class="JSON">6&quot;Hello World!&quot; //必须为双引号</code></pre><p>布尔值和 null 也是有效的 JSON 数据形式，但简单值往往是复杂数据结构的一部分。</p><p><strong>对象</strong>：</p><pre><code class="JSON">// JavaScript对象字面量：var object = {  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29};// JSON 表示方式如下：{  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29}</code></pre><p>JSON 对象 与 JavaScript 的对象字面量相比：首先，没有声明变量（JSON 中没有变量的概念）；其次，没有末尾的分号；JSON 对象的属性必须加双引号。</p><p><strong>数组</strong>：JSON 数组采用的就是 JavaScript 中的数组字面量形式。</p><pre><code class="JSON">// JavaScript 中的数组字面量：var values = [25, &quot;hi&quot;, true];// JSON 表示数组：[25, &quot;hi&quot;, true]</code></pre><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><p>ECMAScript5 对解析 JSON 进行了规范，定义了全局对象 JSON。</p><p>JSON 对象有两个方法：stringify() 和 parse()，分别用于把 JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。</p><pre><code class="JavaScript">var book = {        title: &quot;Professional JavaScript&quot;,        authors: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011    };var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);console.log(jsonText);// {&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011}var bookCopy =JSON.parse(jsonText);</code></pre><p><strong>序列化选项</strong>: JSON.stringify() 除了要序列化的 JavaScript 对象外，还可以接收另外两个参数指定以不同的方式序列化。<br>第一个参数是数据，第二个参数是个过滤器，可以是一个数组或函数；第三个参数是一个选项，表示是否在 JSON 字符串中保留缩进。</p><p>1.过滤结果：</p><p>如果过滤器参数是<strong>数组</strong>，那么 JSON.stringify()的结果中将只包含数组中列出的属性。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3}</code></pre><p>如果过滤器参数是<strong>函数</strong>，传入的函数接收两个参数，属性（键）名和属性值。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, function(key, value){   switch(key){       case &quot;authors&quot;:           return value.join(&quot;,&quot;)       case &quot;year&quot;:           return 5000;       case &quot;edition&quot;:           return undefined;       default:           return value;   }});//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000}</code></pre><p>2.字符串缩进</p><p>JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。<br>如果这个参数是一个<strong>数值</strong>，那它表示的是每个级别缩进的空格数。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, 4);</code></pre><p>结果：</p><pre><code class="JSON">{    &#39;title&#39;: &#39;Professional JavaScript&#39;,    &#39;authors&#39;: [        &#39;Nicholas C. Zakas&#39;    ],    &#39;edition&#39;: 3,    &#39;year&#39;: 2011}</code></pre><p>如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON 字符串中被用作缩进字符（不再使用空格）。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, &quot; - -&quot;);</code></pre><p>结果：</p><pre><code class="JSON">{ - -&#39;title&#39;: &#39;Professional JavaScript&#39;, - -&#39;authors&#39;: [ - - - -&#39;Nicholas C. Zakas&#39; - -], - -&#39;edition&#39;: 3, - -&#39;year&#39;: 2011}</code></pre><p>缩进字符串最长不能超过 10 个字符长。如果字符串长度超过了 10 个，结果中将只出现前 10 个字符。</p><p>3.toJSON()方法</p><p>给对象自定义 toJSON() 方法，返回其自身的 JSON 数据格式。</p><pre><code class="JavaScript">var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        toJSON: function(){            return this.title;        }    };var jsonText = JSON.stringify(book);console.log(jsonText);</code></pre><p>假设把一个对象传入 JSON.stringify()，序列化该对象的顺序如下：<br>(1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。<br>(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。<br>(3) 对第(2)步返回的每个值进行相应的序列化。<br>(4) 如果提供了第三个参数，执行相应的格式化。</p><p><strong>解析选项</strong>：JSON.parse() 方法也可以接收另一个参数，该参数是一个函数（还原函数），将在每个键值对儿上调用。<br>如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</p><pre><code class="JavaScript"> var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        releaseDate: new Date(2011, 11, 1)    };var jsonText = JSON.stringify(book);console.log(jsonText);var bookCopy = JSON.parse(jsonText, function(key, value){    if (key == &quot;releaseDate&quot;){        return undefined;    } else {        return value;    }});console.log(&quot;releaseDate&quot; in bookCopy);</code></pre><h1 id="第二十一章-Ajax-与-Comet"><a href="#第二十一章-Ajax-与-Comet" class="headerlink" title="第二十一章 Ajax 与 Comet"></a>第二十一章 Ajax 与 Comet</h1><p>Ajax(Asynchronous Javascript + XML)技术的核心是 XMLHttpRequest 对象，即: XHR。<br>它所指的仅仅是<strong>无须刷新页面即可从服务器端获取数据</strong>的技术，其通信与数据格式无关，并不一定是 XML 数据。</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p><strong>XHR的用法</strong>：</p><p>使用 XMLHttpRequest 构造函数来创建 XHR 对象。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();</code></pre><p>使用 XHR对象的时候，要调用的第一个方法是open()，它接受3个参数:</p><ol><li>要发送请求的类型，如: get/post</li><li>请求的 url</li><li>是否异步发送请求，这个参数是一个布尔值</li></ol><p>再调用 send() 方法，才会真正发起 ajax 请求。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.php&#39;, false)xhr.send(null);</code></pre><p>本例中的请求是同步的，Javascript 代码会等到服务器响应之后再执行。<br>收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性有:</p><ul><li>responseText: 作为响应主体被返回的文本。</li><li>responseXML: 如果响应的内容类型是 “text/xml” 或者 “application/xml”，那么这个属性中将保存着包含响应数据的 XML DOM 文档。</li><li>status: 响应的 HTTP 状态。</li><li>statusText: HTTP 状态的说明。</li></ul><p>发送异步请求：JavaScript 继续执行而不必等待。<br>此时，我们可以检测readyState属性，该属性表示请求/响应过程的当前活动阶段。它的可取值有如下几种：</p><ul><li>0: 未初始化。 尚未调用 open() 方法。</li><li>1: 启动。 已经调用open()方法，但，尚未调用send()方法。</li><li>2: 发送。 已经调用send()方法，但，尚未接收到响应。</li><li>3: 接收。 已经接收到部分响应数据。</li><li>4: 完成。 已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p>readyState 属性的每一次变化，都会触发一次 readyStateChange 事件，我们可以利用这个事件来检测 readyState 值。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    if(xhr.readyState == 4){        if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){            console.log(xhr.responseText);        }        else{            console.log(&#39;fail, &#39; + xhr.status);        }    }}xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.send(null);</code></pre><p>在接收到响应之前，可以调用 abort() 方法来取消异步请求。</p><pre><code class="JavaScript">xhr.abort();</code></pre><p><strong>HTTP 头部信息</strong>：XHR 对象提供了操作头部信息的方法，包括对请求头部和响应头部的操作。</p><p>默认情况下，发送XHR请求的同时，还会发送以下头部信息:</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language: 浏览器当前设置的语言</li><li>Connection: 浏览器与服务器之间的连接类型</li><li>Cookie: 当前页面的任何Cookie</li><li>Host: 发出请求的页面，所在的域</li><li>Referer: 发出请求的页面的URI</li><li>User-Agent: 浏览器的用户代理字符串</li></ul><p>setRequestHeader()：自定义的头部信息。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.setRequestHeader(&quot;MySite&quot;, &quot;wshunli.com&quot;);xhr.send(null);</code></pre><p>getResponseHeader()：获取响应头部信息。</p><pre><code class="JavaScript">var mySite = xhr.getResponseHeader(&#39;MySite&#39;); // wshunli.com</code></pre><p>getAllResponseHeaders()：在服务器端，也可以利用头部信息向浏览器发送额外的结构化数据。</p><pre><code class="JavaScript">var allHeaders = xhr.getAllResponseHeaders();// 返回内容Date: Sun, 14 Nov 2004 18:04:22 GMTServer: Apache/1.3.29 (Unix)Vary: AcceptX-Powerd-By: PHP/4.3.8Connection: closeContent-Type: text/html; charset=iso-8859-1</code></pre><p><strong>GET 请求</strong>：向服务器查询某些信息。</p><pre><code class="JavaScript">xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true);</code></pre><p><strong>POST 请求</strong>：向服务器发送应该被保存的数据。</p><pre><code class="JavaScript">xhr.open(&quot;post&quot;, &quot;post.php&quot;, true);xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);var form = document.getElementById(&quot;my-form&quot;);xhr.send(serialize(form));</code></pre><h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><p><strong>FormData</strong>：</p><p>XMLHttpRequest 2 级定义了 FormData 类型，来处理表单数据的序列化，以及创建与表单格式相同的数据。</p><pre><code class="JavaScript">var data = new FormData();// 添加键值对data.append(&#39;site&#39;, &#39;wshunli.com&#39;);// 直接传入表单元素var data = new FormData(document.forms[0]);</code></pre><p>创建 FromData 的实例后，就可以传给 XHR 的 send() 方法。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest(); ···var form = document.getElementById(&#39;site-info&#39;);xhr.send(new FormData(form));</code></pre><p>XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。</p><p><strong>超时设定</strong>：</p><p>XHR 对象添加了一个 timeout 属性，表示请求在等待多少毫秒之后就终止。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    try{        if(xhr.readyState == 4){            if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){                console.log(xhr.responseText);            }            else{                console.log(&#39;fail, &#39; + xhr.status);            }        }    }    catch(ex){    }}xhr.open(&#39;get&#39;, &#39;example.php&#39;, true);xhr.timeout = 1000; // 1秒超时，仅适用IE8+xhr.ontimeout = function(){    console.log(&#39;fail, timeout&#39;);}xhr.send(null);</code></pre><p>在给 timeout 设置一个数值后，如果在规定时间内浏览器没有接收到响应信息，就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。<br>如果在超时终止请求之后再访问 status 属性，就会导致错误。因此，将相关的代码封装到 try-catch 语句中。</p><p><strong>overrideMimeType() 方法</strong>：重写 XHR 响应的 MIME 类型。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.open(&#39;get&#39;, &#39;text.php&#39;, true);xhr.overrideMimeType(&#39;text/xml&#39;);xhr.send(null);</code></pre><h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><p>进度事件包括以下6个：</p><ul><li>loadstart: 在接收到响应数据的第一个字节时触发</li><li>progress: 在接收响应期间持续不断地触发</li><li>error: 在请求发生错误时触发</li><li>abort: 在因为调用 abort() 方法而终止连接时触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 在通信完成或者触发 error、abort 或 load 事件之后触发</li></ul><p>每个请求都从触发 loadstart 事件开始，接下来是一个或多个 progress 事件，然后触发 error、abort 或者 load 事件中的一个，最后以触发 loadend 事件结束。</p><p><strong>load 事件</strong>：响应接收完毕后将触发 load 事件，因此就没有必要再去检查 readyState 属性了。</p><p><strong>progress 事件</strong>：progress 事件会在浏览器接收新数据的过程中周期性地被触发。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.onload = function(){    if( (xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300) || xhr.status ==304 ){        console.log(xhr.responseText);    }    else{        console.log(&#39;fail, &#39; + xhr.status);    }}xhr.onprogress = function(event){    var statusDiv = document.getElementById(&#39;status&#39;);    if( event.lengthComputable ){        statusDiv.innerHTML = &#39;Received &#39; + event.position + &#39; of &#39; + event.totalSize + &#39; bytes&#39;;    }}xhr.open(&#39;get&#39;, &#39;progress.php&#39;, true);xhr.send(null);</code></pre><p>onprogress 事件处理程序，会接收到一个event对象，其 target 属性是 XHR 对象。<br>event 对象还包含了另外3个额外属性：lengthComputable、position、totalSize。</p><ul><li>lengthComputable 是一个布尔值，它表示进度信息是否可用；</li><li>position 表示已经接收的字节数；</li><li>totalSize 表示根据 Content-Length 响应头确定的预期字节数。</li></ul><h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）：使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。IE中要使用XDR对象实现，其他浏览器XHR对象原生支持。</p><pre><code class="JavaScript">// 发送请求附加 Origin 头部Origin: http://www.wshunli.com// 响应请求Access-Control-Allow-Origin: http://www.wshunli.com</code></pre><p><strong>图像 Ping</strong>：动态创建图像经常用于图像 Ping 。</p><pre><code class="JavaScript">var img = new Image();img.onload = img.onerror = function(){    console.log(&#39;Done&#39;);}img.src = &#39;http://www.wshunli.com/test?action=click&#39;;</code></pre><p>我们可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。</p><p><strong>JSOUP</strong>：(JSON with padding，填充式 JSON 或参数式 JSON) 它看起来与 JSON 非常相似，只不过是被包含在函数调用中的 JSON。</p><pre><code class="JavaScript">function handleResponse(response){    console.log(&quot;You&#39;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);}var script = document.createElement(&quot;script&quot;);script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);</code></pre><p><strong>Comet</strong>: 一种服务器向页面推送数据的技术。</p><p>实现Comet有 2 种方式: 长轮询和流。<br>1.长轮询是相对于传统轮询(短轮询)而言的，传统轮询即浏览器定时向服务器发送请求，查看是否有数据更新。<br>而长轮询则是，页面向服务器发起一个请求后，服务器一直保持连接打开，直到有数据可以发送。<br>发送完数据后，浏览器关闭连接，随即又向服务器发起一个新的请求。<br>这一过程在页面打开期间一直持续不断。<br>2.另外一种实现 Comet 的方式就是HTTP流。流的特点是，在页面的整个生命周期内只有使用一个HTTP连接。<br>也就是说，浏览器向服务器发送一个请求后，服务器保持连接打开，然后周期性地向浏览器发送数据</p><p><strong>服务器发送事件</strong>：SSE(Server-Sent Events)服务器发送事件，是围绕只读 Comet 交互推出的 API 或者模式。</p><p><strong>Web Sockets</strong>：Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。</p><p>创建 Web Sockets，可以先实例一个 WebSocket 对象并传入要连接 URL:</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);</code></pre><p>实例化 WebSocket 对象之后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket也有一个表示当前状态的 readyState 属性。</p><ul><li>WebSocket.OPENING (0) : 正在建立连接</li><li>WebSocket.OPEN (1): 已经建立连接</li><li>WebSocket.CLOSING (2): 正在关闭连接</li><li>WebSocket.CLOSE (3): 已经关闭连接</li></ul><p>WebSocket 没有 readystatechange 事件，readyState 的值永远从0开始。<br>要关闭 Web Socket 连接，可以在任何时候调用close()方法。<br>调用该方法后，readyState 的值立即变为2(正在关闭)，当成功关闭连接后变为3。</p><pre><code class="JavaScript">socket.close();</code></pre><p>发送和接收数据：Web Socket 打开之后就可以通过连接发送和接收数据。</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);socket.send(&quot;Hello World!&quot;);</code></pre><p>Web Socket 只能通过连接发送纯文本数据，对于复杂数据必须进行序列化。</p><pre><code class="JavaScript">socket.onmessage = function(event){    var data = event.data;}</code></pre><p>当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。</p><p>WebSocket 对象的其他事件：<br>WebSocket对象还有其他3个事件，在连接生命周期的不同阶段触发。</p><ul><li>open: 在成功建立连接时触发</li><li>error: 在发生错误时触发，连接不能持续</li><li>close: 在连接关闭时触发</li></ul><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/server.php&#39;);socket.onopen = function(){    console.log(&#39;WebSocket Opened.&#39;)}socket.onerror = function(){    console.log(&#39;WebSocket Error.&#39;)}socket.onclose = function(){    console.log(&#39;WebSocket Closed.&#39;)}</code></pre><p>其中只有 close 事件的event的对象有额外的信息。这个事件的事件对象有3个额外属性: wasClean、code 和 reason。<br>其中，wasClean 是一个布尔值，表示连接是否已经明确关闭；code 是服务器返回的数值状态码；而 reason 是一个字符串，包含服务器发回的信息。</p><pre><code class="JavaScript">socket.onclose = function(event){    console.log(event.wasClean + &#39;,&#39; + event.code + &#39;,&#39; + event.reason);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/228afe2f.html"/>
    <id>http://www.wshunli.com/posts/228afe2f.html</id>
    <published>2017-11-08T09:06:23.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(四) 学习在浏览器中进行实际开发时的错误调试技巧。</strong>(17章)</p><h1 id="第十七章-错误处理与调试"><a href="#第十七章-错误处理与调试" class="headerlink" title="第十七章 错误处理与调试"></a>第十七章 错误处理与调试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>try-catch 语句</strong>：</p><p>try-catch 语句 和 Java 很类似。</p><pre><code class="JavaScript">function testFinally(){    try {        return 2;    } catch (error){        return 1;    } finally {        return 0;    }}function testWithoutFinally(){    try {        return 2;    } catch (error){        return 1;    }}alert(testFinally());alert(testWithoutFinally());</code></pre><p>我们把可能会抛出错误的语句放到 try 语句中，处理错误的代码放到 catch 块中，finally 语句块无论如何都会执行。</p><p><strong>抛出错误</strong>：与 try-catch 语句相配的还有一个 throw 操作符，用于随时抛出自定义错误 。</p><p>在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时，代码才回继续执行。</p><pre><code class="JavaScript">if (!(values instanceof Array)){    throw new Error(&quot;process(): Argument must be an array.&quot;);}</code></pre><p>捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。</p><p><strong>常见的错误类型</strong>：类型转换错误、数据类型错误、通信错误。</p><h2 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h2><p><strong>将消息记录到控制台</strong>：通过 console 对象向 JavaScript 控制台中写入消息。</p><p>error(message): 将错误消息记录到控制台<br>info(message): 将信息性消息记录到控制台<br>log(message): 将一般消息记录到控制台<br>warn(message): 将警告消息记录到控制台</p><p><strong>将消息记录到当前页面</strong>：在页面中开辟一小块区域，用以显示消息。</p><p><strong>抛出错误</strong>：自定义 assert() 函数。<br>两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。</p><pre><code class="JavaScript">function assert(condition, message){    if (!condition){        throw new Error(message);    }}function divide(num1, num2){    assert(typeof num1 == &quot;number&quot; &amp;&amp; typeof num2 == &quot;number&quot;,            &quot;divide(): Both arguments must be numbers.&quot;);    return num1 / num2;}var result = divide(10, 23);result = divide(&quot;hi&quot;, 3);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/95a7e74a.html"/>
    <id>http://www.wshunli.com/posts/95a7e74a.html</id>
    <published>2017-11-07T14:07:10.000Z</published>
    <updated>2017-12-04T14:49:15.646Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/demobox.css">《JavaScript高级程序设计》读书笔记<br><br><a id="more"></a><p><strong>学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。</strong>(15-16章)</p><h1 id="第十五章-使用-Canvas-绘图"><a href="#第十五章-使用-Canvas-绘图" class="headerlink" title="第十五章 使用 Canvas 绘图"></a>第十五章 使用 Canvas 绘图</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>使用 <code>&lt;canves&gt;</code> 元素；指定 width 和 height 属性。</p><pre><code class="JavaScript">&lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;Your browser doesn&#39;t support canvas&lt;/canvas&gt;</code></pre><p>要在画布上绘制，还需取得绘图上下文。</p><pre><code class="JavaScript">var drawing = document.getElementById(&quot;drawing&quot;),//make sure &lt;canvas&gt; is completely supportedif (drawing.getContext){    var context = drawing.getContext(&quot;2d&quot;);}</code></pre><h2 id="2D-上下文"><a href="#2D-上下文" class="headerlink" title="2D 上下文"></a>2D 上下文</h2><p><strong>填充和描边</strong>：2D 上下文的两种基本绘图操作。<br>fillStyle 属性（填充）：指定的样式（颜色、渐变或图像）填充图形；<br>strokeStyle 属性（描边）：只在图形边缘画线。</p><p><strong>绘制矩形</strong>：矩形是唯一一种可以直接在 2D上下文中绘制的形状。</p><p>与矩形有关的方法包括fillRect()、strokeRect和clearRect()。<br>这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形的宽度和矩形高度。</p><div class="demobox"><div class="demobox-result"><canvas id="drawing" width="200" height="100">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing");if(t.getContext){var e=t.getContext("2d");e.fillStyle="#ff0000",e.fillRect(10,10,50,50),e.strokeStyle="rgba(0,0,255,0.5)",e.strokeRect(30,30,50,50),e.clearRect(40,40,10,10)}}()</script></div><div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x77E9;&#x5F62;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.strokeStyle = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>;</span><br><span class="line">    context.strokeRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.clearRect(<span class="number">40</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>绘制路径</strong>：</p><p>首先调用 beginPath() 方法；<br>然后调用一下方法：<br>arc(x,y,radius,startAngle,endAngle,bool);<br>arcTo(x1,y1,x2,y2,radius);<br>lineTo(x,y);<br>moveTo(x,y);<br>rect(x,y,w,h);<br>最后调用 closePath() 方法。</p><p><strong>绘制文本</strong>：fillText(str, x, y, width);strokeText(str, x, y, width)。</p>    <div class="demobox">      <div class="demobox-result">  <canvas id="drawing2" width="200" height="200">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing2");if(t.getContext){var e=t.getContext("2d");e.beginPath(),e.arc(100,100,99,0,2*Math.PI,!1),e.moveTo(194,100),e.arc(100,100,94,0,2*Math.PI,!1),e.moveTo(100,100),e.lineTo(100,15),e.moveTo(100,100),e.lineTo(35,100),e.stroke(),e.strokeText?(e.font="bold 14px Arial",e.textAlign="center",e.textBaseline="middle",e.fillText("12",100,20),e.textAlign="start",e.fillText("12",100,40),e.textAlign="end",e.fillText("12",100,60)):console.log("Your browser doesn't support the canvas text API.")}}()</script></div>    <div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x8DEF;&#x5F84;&#x548C;&#x6587;&#x672C;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">194</span>, <span class="number">100</span>);</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">100</span>, <span class="number">15</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">35</span>, <span class="number">100</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line">    <span class="keyword">if</span> (context.strokeText){</span><br><span class="line">        context.font = <span class="string">&quot;bold 14px Arial&quot;</span>;</span><br><span class="line">        context.textAlign = <span class="string">&quot;center&quot;</span>;</span><br><span class="line">        context.textBaseline = <span class="string">&quot;middle&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Your browser doesn&apos;t support the canvas text API.&quot;</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>变换</strong>：<br>rotate(angle): 围绕原点旋转图像angle角度。<br>scale(scaleX, scaleY): 缩放图像。<br>translate(x,y)：将坐标原点移到（x,y）。</p><p><strong>阴影</strong>：<br>shadowColor()<br>shadowOffsetX:x方向的阴影偏移量。<br>shadowOffsetY:y方向的阴影偏移量。<br>shadowBlur:模糊的像素数，默认为0不模糊。</p><p><strong>渐变</strong>：渐变由 CanvasGradient 实例表示。</p><p>线性渐变：createLinearGradient(x1,y1,x2,y2);</p><pre><code class="JavaScript">var gradient = context.createLinearGradient(30,30,70,70);    gradient.addColorStop(0,&quot;orange&quot;);    gradient.addColorStop(1, &quot;blue&quot;);    context.fillStyle = gradient;    context.fillRect(30, 30,70,70);</code></pre><p>径向渐变：createRadialGradient(x1,y1,r1,x2,y2,r2);</p><pre><code class="JavaScript">var gra = context.createRadialGradient(55,55,10,55,55,30);    gra.addColorStop(0, &quot;blue&quot;);    gra.addColorStop(1, &quot;orange&quot;);    context.fillStyle = gra;    context.fillRect(30,30,50,50);</code></pre><p><strong>模式</strong>：模式就是重复的图像，可以用来填充或描边图形。</p><p>createPattern(img, str);<br>img： 表示一个 HTML 的 img 元素；<br>str： 可取值 “repeat”、“repeat-x”、“repeat-y”和“no-repeat”。</p><pre><code class="JavaScript">var img = document.images[0];var pattern = context.createPattern(img, &quot;repeat&quot;);context.fillStyle = pattern;context.fillRect(10,10,150,150);</code></pre><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p>WebGL 是针对 Canvas 的 3D 上下文。</p><h1 id="第十六章-HTML5-脚本编程"><a href="#第十六章-HTML5-脚本编程" class="headerlink" title="第十六章 HTML5 脚本编程"></a>第十六章 HTML5 脚本编程</h1><h2 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h2><p>跨文档消息传递，简称XDM，指的是来自不同域的页面间传递消息。</p><p>postMessage() 发送消息：</p><pre><code class="JavaScript">var iframeWindow = document.getElementById(&quot;myFrame&quot;).contentWindow;iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wshunli.com&quot;);</code></pre><p>接收消息，触发 window 对象的 message 事件，异步方式。</p><pre><code class="JavaScript">window.addEventListener(&quot;message&quot;,function(){    if(event.origin == &quot;http://www.wshunli.com&quot;){//发送消息的文档所在的域      processMessage(event.data); //处理接收的数据      event.source.postMessage(&quot;Received!&quot;, &quot;http://github.com&quot;); //可选：向来源窗口发送回执  }},false)</code></pre><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p>HTML5新增了 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 两个标签。</p><pre><code class="JavaScript">&lt;video src=&quot;conference.mpg&quot; id=&quot;muvideo&quot;&gt;video palyer not available&lt;/video&gt;&lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;audio player not available&lt;/audio&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/demobox.css&quot;&gt;《JavaScript高级程序设计》读书笔记&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
</feed>
