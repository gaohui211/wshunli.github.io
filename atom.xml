<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2018-06-05T09:20:28.125Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《第一行代码》读书笔记（八）</title>
    <link href="https://www.wshunli.com/posts/6374acae.html"/>
    <id>https://www.wshunli.com/posts/6374acae.html</id>
    <published>2018-06-05T02:05:40.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 网络编程</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第8章-使用网络技术"><a href="#第8章-使用网络技术" class="headerlink" title="第8章 使用网络技术"></a>第8章 使用网络技术</h1><h2 id="WebView-的用法"><a href="#WebView-的用法" class="headerlink" title="WebView 的用法"></a>WebView 的用法</h2><p>WebView 也是 Android 的一个控件，用来显示一些网页，内容也比较多。</p><p>针对 WebView 的封装，可以使用 AgentWeb :</p><p>Justson/AgentWeb: AgentWeb is a powerful library based on Android WebView.<br><a href="https://github.com/Justson/AgentWeb" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Justson/AgentWeb</a></p><p>优化首屏加载速度，可以使用 VasSonic ：</p><p>Tencent/VasSonic: VasSonic is a lightweight and high-performance Hybrid framework developed by tencent VAS team, which is intended to speed up the first screen of websites working on Android and iOS platform.<br><a href="https://github.com/Tencent/VasSonic" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Tencent/VasSonic</a></p><p>对于 WebView 有特殊要求的，可以使用一些浏览器内核：</p><p>Crosswalk - Embedding the Crosswalk Project<br><a href="https://crosswalk-project.org/documentation/android/embedding_crosswalk.html" rel="external nofollow noopener noreferrer" target="_blank">https://crosswalk-project.org/documentation/android/embedding_crosswalk.html</a></p><p>腾讯浏览服务：<br><a href="http://x5.tencent.com/" rel="external nofollow noopener noreferrer" target="_blank">http://x5.tencent.com/</a></p><p>本文只介绍 Android 系统 <a href="https://developer.android.com/reference/android/webkit/WebView" rel="external nofollow noopener noreferrer" target="_blank">WebView</a> 使用。</p><p>在 Android 4.4 以前使用基于 Android WebKit 的 WebView 实现；<br>在 Android 4.4 及以后使用基于 Chromium blink 的 WebView 实现；<br>从 Android 5.0 开始，Google 把 Chromium blink 内核作为 apk 单独从系统抽离出来。</p><pre><code class="Java">WebView webView = findViewById(R.id.webview);webView.getSettings().setJavaScriptEnabled(true);webView.setWebViewClient(new WebViewClient());webView.loadUrl(&quot;https://html5test.com/&quot;);</code></pre><p>这只是简单地显示网页，WebView 本身还有很多技巧。</p><h2 id="使用-HTTP-协议访问网络"><a href="#使用-HTTP-协议访问网络" class="headerlink" title="使用 HTTP 协议访问网络"></a>使用 HTTP 协议访问网络</h2><p>1、使用 HttpURLConnection</p><p>在 Android 上发送 HTTP 请求一般使用 HttpURLConnection 或者 HttpClient 。</p><p>不过 HttpClient 在 Android 6.0 已经废弃。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        HttpURLConnection connection = null;        BufferedReader reader = null;        try {            URL url = new URL(&quot;https://www.wshunli.com/&quot;);            connection = (HttpURLConnection) url.openConnection();            connection.setRequestMethod(&quot;GET&quot;);            connection.setConnectTimeout(8000);            connection.setReadTimeout(8000);            InputStream in = new BufferedInputStream(connection.getInputStream());            reader = new BufferedReader(new InputStreamReader(in));            String line;            while ((line = reader.readLine()) != null) {                Log.d(TAG, line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if (reader != null) {                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (connection != null) {                connection.disconnect();            }        }    }}).start();</code></pre><p>上面是发送 GET 请求，发送 POST 请求：</p><pre><code class="Java">connection.setRequestMethod(&quot;POST&quot;);DataOutputStream out = new DataOutputStream(connection.getOutputStream());out.writeBytes(&quot;username=wshunli&amp;password=123456&quot;);</code></pre><p>2、使用 OkHttp</p><p>在实际项目里面使用 HttpURLConnection 还是不太行的，往往使用一些开源的网络框架，比如 OkHttp 等等。</p><p><a href="http://square.github.io/okhttp/" rel="external nofollow noopener noreferrer" target="_blank">OkHttp</a>：An HTTP &amp; HTTP/2 client for Android and Java applications</p><p><a href="https://github.com/square/okhttp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/square/okhttp</a></p><p>首先添加 OkHttp 依赖：</p><pre><code class="groovy">implementation &#39;com.squareup.okhttp3:okhttp:3.10.0&#39;</code></pre><p>使用 OkHttp 发送 GET 请求：</p><pre><code class="Java">OkHttpClient client = new OkHttpClient();Request request = new Request.Builder()        .url(&quot;https://www.shunli.com&quot;)        .build();try {    Response response = client.newCall(request).execute();    String responseData = response.body().string();    Log.d(TAG, &quot;onCreate: &quot; + responseData);} catch (IOException e) {    e.printStackTrace();}</code></pre><p>整个过程清楚简洁。</p><pre><code class="Java">···RequestBody requestBody = new FormBody.Builder()        .add(&quot;username&quot;, &quot;wshunli&quot;)        .add(&quot;password&quot;, &quot;123456&quot;)        .build();Request request = new Request.Builder()        .url(&quot;https://www.shunli.com&quot;)        .post(requestBody)        .build();···</code></pre><p>发送 POST 请求有点不太一样，要使用 RequestBody 传递数据。</p><p>这里只是简单介绍了 OkHttp 的使用，还有很多东西，后面再介绍。</p><h2 id="解析-XML-格式数据"><a href="#解析-XML-格式数据" class="headerlink" title="解析 XML 格式数据"></a>解析 XML 格式数据</h2><p>在网络传递的数据主要有两种： XML 和 JSON 。</p><p>这里我们使用本站的 RSS 订阅源数据。</p><p><a href="https://www.wshunli.com/atom.xml">https://www.wshunli.com/atom.xml</a></p><p>1、Pull 解析方式</p><p>本方法是将请求的 XML 字符串传入 XmlPullParser 对象实例，然后根据节点名字遍历解析 XML 内容。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        OkHttpClient client = new OkHttpClient();        Request request = new Request.Builder()                .url(&quot;https://www.wshunli.com/atom.xml&quot;)                .build();        try {            Response response = client.newCall(request).execute();            String responseData = response.body().string();            parseXMLWithPull(responseData);        } catch (IOException e) {            e.printStackTrace();        }    }}).start();private void parseXMLWithPull(String xmlData) {    try {        XmlPullParserFactory factory = XmlPullParserFactory.newInstance();        XmlPullParser xmlPullParser = factory.newPullParser();        xmlPullParser.setInput(new StringReader(xmlData));        int eventType = xmlPullParser.getEventType();        String title = &quot;&quot;;        String id = &quot;&quot;;        String published = &quot;&quot;;        String updated = &quot;&quot;;        while (eventType != XmlPullParser.END_DOCUMENT) {            String nodeName = xmlPullParser.getName();            switch (eventType) {                case XmlPullParser.START_TAG:                    if (nodeName.equals(&quot;title&quot;)) {                        title = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;id&quot;)) {                        id = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;published&quot;)) {                        published = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;updated&quot;)) {                        updated = xmlPullParser.nextText();                    }                    break;                case XmlPullParser.END_TAG:                    if (nodeName.equals(&quot;entry&quot;)) {                        Log.d(TAG, &quot;文章标题: &quot; + title);                        Log.d(TAG, &quot;文章链接: &quot; + id);                        Log.d(TAG, &quot;发布时间: &quot; + published);                        Log.d(TAG, &quot;更新时间: &quot; + updated);                    }                    break;                default:                    break;            }            eventType = xmlPullParser.next();        }    } catch (XmlPullParserException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>解析结果示例：</p><pre><code class="TXT">文章标题: 《第一行代码》读书笔记（七）文章链接: https://www.wshunli.com/posts/941f84ed.html发布时间: 2018-06-04T08:41:39.000Z更新时间: 2018-06-04T15:14:46.188Z文章标题: 《第一行代码》读书笔记（六）文章链接: https://www.wshunli.com/posts/461ff372.html发布时间: 2018-06-03T13:54:38.000Z更新时间: 2018-06-04T15:14:46.188Z</code></pre><p>2、SAX 解析方式</p><p>SAX 解析方式也是一种比较常用的方法，虽然比 Pull 方式复杂，但是语义更容易理解。</p><p>通常会新建一个类继承 DefaultHandler ，并重写其方法。</p><pre><code class="Java">public class PostsHandler extends DefaultHandler {    @Override    public void startDocument() throws SAXException {        super.startDocument();    }    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {        super.startElement(uri, localName, qName, attributes);    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {        super.characters(ch, start, length);    }    @Override    public void endElement(String uri, String localName, String qName) throws SAXException {        super.endElement(uri, localName, qName);    }    @Override    public void endDocument() throws SAXException {        super.endDocument();    }}</code></pre><p>其中 startDocument 和 endDocument 分别在开始、结束 XMl 接解析时调用。<br>类似 startElement 和 endElement 分别在开始、结束解析某个节点时调用。<br>而 characters 方法会在获取节点内容时调用，可能会调用多次，注意换行符也会解析出来。</p><pre><code class="Java">public class PostsHandler extends DefaultHandler {    private static final String TAG = &quot;PostsHandler&quot;;    private String nodeName;    private StringBuilder title;    private StringBuilder id;    private StringBuilder published;    private StringBuilder updated;    @Override    public void startDocument() throws SAXException {        title = new StringBuilder();        id = new StringBuilder();        published = new StringBuilder();        updated = new StringBuilder();    }    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {        // 记录节点名称        nodeName = localName;    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {        // 根据节点名称将内容添加到 StringBuilder 中        if (nodeName.equals(&quot;title&quot;)) {            title.append(ch, start, length);        } else if (nodeName.equals(&quot;id&quot;)) {            id.append(ch, start, length);        } else if (nodeName.equals(&quot;published&quot;)) {            published.append(ch, start, length);        } else if (nodeName.equals(&quot;updated&quot;)) {            updated.append(ch, start, length);        }    }    @Override    public void endElement(String uri, String localName, String qName) throws SAXException {        if (localName.equals(&quot;entry&quot;)) {            Log.d(TAG, &quot;文章标题: &quot; + title.toString().trim());            Log.d(TAG, &quot;文章链接: &quot; + id.toString().trim());            Log.d(TAG, &quot;发布时间: &quot; + published.toString().trim());            Log.d(TAG, &quot;更新时间: &quot; + updated.toString().trim());            title.setLength(0);            id.setLength(0);            published.setLength(0);            updated.setLength(0);        }    }    @Override    public void endDocument() throws SAXException {        super.endDocument();    }}</code></pre><p>和前面 Pull 解析功能是一样的。</p><pre><code class="Java">private void parseXMLWithSAX(String xmlData) {    SAXParserFactory factory = SAXParserFactory.newInstance();    try {        XMLReader xmlReader = factory.newSAXParser().getXMLReader();        PostsHandler handler = new PostsHandler();        xmlReader.setContentHandler(handler);        xmlReader.parse(new InputSource(new StringReader(xmlData)));    } catch (SAXException e) {        e.printStackTrace();    } catch (ParserConfigurationException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>调用是使用 XMLReader 实例的 setContentHandler 方法。</p><h2 id="解析-JSON-格式数据"><a href="#解析-JSON-格式数据" class="headerlink" title="解析 JSON 格式数据"></a>解析 JSON 格式数据</h2><p>感觉平常 JSON 数据用得更多一些，JSON 和 XML 相比主要有优势在于体积更小。</p><p>以前本站是支持生成 JSON 文件的，因为上传太慢了就取消了。</p><p>这里使用随便使用一个 JSON 文件做测试吧。</p><p><a href="https://cdn.wshunli.com/posts.json" rel="external nofollow noopener noreferrer" target="_blank">https://cdn.wshunli.com/posts.json</a></p><p>1、使用 JSONObject</p><p>解析 JSON 数据可以使用 JSONObject 或者 GSON 开源库，还有一些 Jackson 、FastJSON 都不错。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        OkHttpClient client = new OkHttpClient();        Request request = new Request.Builder()                .url(&quot;https://cdn.wshunli.com/posts.json&quot;)                .build();        try {            Response response = client.newCall(request).execute();            String responseData = response.body().string();            parseJSONWithJSONObject(responseData);        } catch (IOException e) {            e.printStackTrace();        }    }}).start();private void parseJSONWithJSONObject(String jsonData) {    try {        JSONObject jsonObject = new JSONObject(jsonData);        if (jsonObject.has(&quot;data&quot;)){            String data = jsonObject.getString(&quot;data&quot;);            JSONArray jsonArray = new JSONArray(data);            for (int i = 0; i &lt; jsonArray.length(); i++) {                JSONObject object = jsonArray.getJSONObject(i);                String title = object.getString(&quot;title&quot;);                String path = object.getString(&quot;path&quot;);                String date = object.getString(&quot;date&quot;);                String updated = object.getString(&quot;updated&quot;);                Log.d(TAG, &quot;文章标题: &quot; + title);                Log.d(TAG, &quot;文章链接: &quot; + path);                Log.d(TAG, &quot;发布时间: &quot; + date);                Log.d(TAG, &quot;更新时间: &quot; + updated);            }        }    } catch (JSONException e) {        e.printStackTrace();    }}</code></pre><p>也就是使用构造函数传入 JSON 字符串获得 JSONObject 对象实例。</p><p>如果遇到数组的使用 JSONArray 实例逐条遍历即可。</p><p>2、使用 GSON 库</p><p>google/gson: A Java serialization/deserialization library to convert Java Objects into JSON and back<br><a href="https://github.com/google/gson" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/google/gson</a></p><p>使用 GSON 解析 JSON 数据特别简单。</p><pre><code class="groovy">implementation &#39;com.google.code.gson:gson:2.8.4&#39;</code></pre><p>首先根据 JSON 数据定义 Posts 类。</p><pre><code class="Java">public class Posts {    int total;    int pageSize;    int pageCount;    List&lt;Article&gt; data;    public static class Article{        String title;        String path;        String date;        String updated;        public String getTitle() {            return title;        }        public void setTitle(String title) {            this.title = title;        }        public String getPath() {            return path;        }        public void setPath(String path) {            this.path = path;        }        public String getDate() {            return date;        }        public void setDate(String date) {            this.date = date;        }        public String getUpdated() {            return updated;        }        public void setUpdated(String updated) {            this.updated = updated;        }    }    public int getTotal() {        return total;    }    public void setTotal(int total) {        this.total = total;    }    public int getPageSize() {        return pageSize;    }    public void setPageSize(int pageSize) {        this.pageSize = pageSize;    }    public int getPageCount() {        return pageCount;    }    public void setPageCount(int pageCount) {        this.pageCount = pageCount;    }    public List&lt;Article&gt; getData() {        return data;    }    public void setData(List&lt;Article&gt; data) {        this.data = data;    }}</code></pre><p>然后实例化 GSON 对象解析 JSON 字符串。</p><pre><code class="Java">private void parseJSONWithGSON(String jsonDate) {    Gson gson = new Gson();    Posts posts = gson.fromJson(jsonDate, Posts.class);    List&lt;Posts.Article&gt; data = posts.getData();    for (Posts.Article article : data) {        Log.d(TAG, &quot;文章标题: &quot; + article.getTitle());        Log.d(TAG, &quot;文章链接: &quot; + article.getPath());        Log.d(TAG, &quot;发布时间: &quot; + article.getDate());        Log.d(TAG, &quot;更新时间: &quot; + article.getUpdated());    }}</code></pre><p>GSON 也就介绍到这里。</p><blockquote><p>参考资料<br>1、Building Web Apps in WebView | Android Developers<br><a href="https://developer.android.com/guide/webapps/webview" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/webapps/webview</a><br>2、Android：最全面的 Webview 详解 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/52693322" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/52693322</a><br>3、Getting Started: WebView-based Applications for Web Developers - Google Chrome<br><a href="https://developer.chrome.com/multidevice/webview/gettingstarted" rel="external nofollow noopener noreferrer" target="_blank">https://developer.chrome.com/multidevice/webview/gettingstarted</a><br>4、X5 浏览器内核调研报告 - 简书<br><a href="https://www.jianshu.com/p/2a14d303308d" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/2a14d303308d</a><br>5、前端 WebView 指南之 Android 交互篇 - 怡红院落<br><a href="https://imnerd.org/android-webview-and-js.html" rel="external nofollow noopener noreferrer" target="_blank">https://imnerd.org/android-webview-and-js.html</a><br>6、在Android上使用JS引擎是一种什么样的体验？ | 网易杭州前端技术部<br><a href="https://neyoufan.github.io/2016/12/23/android/Android%20Js引擎/在Android上使用JS引擎是一种什么样的体验？/" rel="external nofollow noopener noreferrer" target="_blank">https://neyoufan.github.io/2016/12/23/android/Android%20Js引擎/在Android上使用JS引擎是一种什么样的体验？/</a></p></blockquote><hr><p>到这里可能算又浏览了一遍 《第一行代码》 。</p><p>这次有些内容没有看，比如第 3、12 章的 UI 部分。</p><p>还有 第 11 章 基于位置的服务也没有看，因为前面专业 GIS SDK 接触很多了。</p><p>最后是第 13、14 章的进阶、实战部分，后面再了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 网络编程&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href=&quot;https://www.wsh
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（七）</title>
    <link href="https://www.wshunli.com/posts/941f84ed.html"/>
    <id>https://www.wshunli.com/posts/941f84ed.html</id>
    <published>2018-06-04T08:41:39.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 多媒体资源</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第8章-丰富你的程序"><a href="#第8章-丰富你的程序" class="headerlink" title="第8章 丰富你的程序"></a>第8章 丰富你的程序</h1><h2 id="使用通知"><a href="#使用通知" class="headerlink" title="使用通知"></a>使用通知</h2><p>1、通知的基本用法</p><p>通知 Notification 是 Android 系统中比较特色的功能，使用方式也很灵活。</p><p>首先获取 NotificationManager 对象，然后构建 Notification 实例，最后使用 notify 方法显示通知。</p><pre><code class="Java">NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        .setContentTitle(&quot;Hello Notification !&quot;)        .setContentText(&quot;This is content text&quot;)        .setWhen(System.currentTimeMillis())        .setSmallIcon(R.mipmap.ic_launcher_round)        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))        .setAutoCancel(true)        .build();notificationManager.notify(2333, notification);</code></pre><p>以上是书籍代码思路，在 Android 8.0 上是不显示通知的，我们作相应的修改。</p><pre><code class="Java">NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {    NotificationChannel channel = new NotificationChannel(&quot;2333&quot;, &quot;wshunli&quot;,NotificationManager.IMPORTANCE_HIGH);    notificationManager.createNotificationChannel(channel);}Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        .setContentTitle(&quot;Hello Notification !&quot;)        .setContentText(&quot;This is content text&quot;)        .setWhen(System.currentTimeMillis())        .setSmallIcon(R.mipmap.ic_launcher_round)        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))        .setAutoCancel(true)        .setChannelId(&quot;2333&quot;)        .build();notificationManager.notify(2333, notification);</code></pre><p>最终通知显示效果：</p><p><img src="https://img.wshunli.com/Android/第一行代码/7.Notification.png" alt="7.Notification.png"></p><p>这时候点击通知是没有效果的，对通知 <strong>添加点击效果</strong> 。</p><p>使用 <a href="https://developer.android.com/reference/android/app/PendingIntent" rel="external nofollow noopener noreferrer" target="_blank">PendingIntent</a> 来启动 Activity 、 Service 、发送广播等。</p><p>PendingIntent 会在何时和时机执行某个动作，而 Intent 会立即执行。</p><p>根据启动的 Android 组件不同可使用的方法也不同：</p><pre><code class="Java">getActivity(Context, int, Intent, int),getActivities(Context, int, Intent[], int), getBroadcast(Context, int, Intent, int), getService(Context, int, Intent, int);</code></pre><p>其中最后一个参数取值也很丰富，FLAG_ONE_SHOT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT, FLAG_UPDATE_CURRENT 。</p><p>使用示例：</p><pre><code class="Java">Intent intent = new Intent(getApplicationContext(), NotificationActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_ONE_SHOT);Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        .setContentTitle(&quot;Hello Notification !&quot;)        .setContentText(&quot;This is content text&quot;)        .setWhen(System.currentTimeMillis())        .setSmallIcon(R.mipmap.ic_launcher_round)        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))        .setAutoCancel(true)        .setChannelId(&quot;2333&quot;)        .setContentIntent(pendingIntent)        .build();</code></pre><p>使用 setContentIntent() 方法设置 PendingIntent 对象参数，点击即可跳转到 NotificationActivity 界面。</p><p>2、通知的进阶技巧</p><p>NotificationCompat.Builder 中有非常丰富的 API 来创建多样的通知效果。</p><p>2.1、设置声音</p><p>Notification.Builder setSound(Uri sound)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setSound(Uri.parse(&quot;/system/media/audio/ringtones/Luna.ogg&quot;))        .build();</code></pre><p>Android 8.0 要使用 NotificationChannel 设置：</p><p>void setSound (Uri sound, AudioAttributes audioAttributes)</p><pre><code class="Java">NotificationChannel channel = new NotificationChannel(&quot;2333&quot;, &quot;wshunli&quot;,NotificationManager.IMPORTANCE_HIGH);channel.setSound(Uri.parse(&quot;/system/media/audio/ringtones/Luna.ogg&quot;), null);notificationManager.createNotificationChannel(channel);</code></pre><p>2.2、设置震动</p><p>Notification.Builder setVibrate(long[] pattern)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setVibrate(new long[]{0, 1000, 1000, 1000})        .build();</code></pre><p>其中数组表示：先停顿 0 ms ，震动 1000 ms ，再停顿 1000 ms ， 最后震动 1000 ms ，后面以此类推。</p><p>需要申请权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;</code></pre><p>Android 8.0 要使用 NotificationChannel 设置：</p><p>void setVibrationPattern (long[] vibrationPattern)</p><pre><code class="Java">NotificationChannel channel = new NotificationChannel(&quot;2333&quot;, &quot;wshunli&quot;,NotificationManager.IMPORTANCE_HIGH);channel.setVibrationPattern(new long[]{0, 1000, 1000, 1000});notificationManager.createNotificationChannel(channel);</code></pre><p>3.3、设置 LED 灯</p><p>Notification.Builder setLights (int argb, int onMs, int offMs)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setLights(Color.GREEN, 1000, 1000)        .build();</code></pre><p>Android 8.0 要使用 NotificationChannel 设置：</p><p>void enableLights (boolean lights)</p><pre><code class="Java">channel.enableLights(true);</code></pre><p>3.4、默认设置</p><p>前面那么多设置，嫌麻烦可以直接使用默认效果。</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setDefaults(NotificationCompat.DEFAULT_ALL)        .build();</code></pre><p>Android 8.0 此方法过时，还要用前面适用于 8.0 的方法。</p><p>3、通知的高级功能</p><p>3.1、首先看 setStyle() 方法</p><p>Notification.Builder setStyle (Notification.Style style)</p><p>首先来看显示一段长文字：</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setContentText(&quot;com.wshunli.notification.demo/com.wshunli.notification.demo.MainActivity&quot;)        .build();</code></pre><p>这样文字过长，会以省略号代替。</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        // 使用 setStyle() 方法        .setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;com.wshunli.notification.demo/com.wshunli.notification.demo.MainActivity&quot;))        .build();</code></pre><p>这样文字会全部显示出来。</p><p>除了显示长文字外，通知还可以显示一张大图片：</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(),R.drawable.pano)))        .build();</code></pre><p>以上显示结果：</p><table><thead><tr><th style="text-align:center"><img src="https://img.wshunli.com/Android/第一行代码/7.Notification_Style1.png" alt="7.Notification.png"></th><th style="text-align:center"><img src="https://img.wshunli.com/Android/第一行代码/7.Notification_Style2.png" alt="7.Notification.png"></th><th style="text-align:center"><img src="https://img.wshunli.com/Android/第一行代码/7.Notification_Style3.png" alt="7.Notification.png"></th></tr></thead><tbody><tr><td style="text-align:center">通知文字过长</td><td style="text-align:center">显示长文字效果</td><td style="text-align:center">显示大图片效果</td></tr></tbody></table><p>3.2、通知的优先级</p><p>使用 setPriority 方法：</p><p>Notification.Builder setPriority (int pri)</p><pre><code class="Java">Notification notification = new NotificationCompat.Builder(getApplicationContext(), &quot;wshunli&quot;)        ···        .setPriority(NotificationCompat.PRIORITY_DEFAULT)        .build();</code></pre><p>其中优先级可取值：PRIORITY_DEFAULT, PRIORITY_LOW, PRIORITY_MIN, PRIORITY_HIGH or PRIORITY_MAX.</p><p>Andorid 8.0 使用 <code>NotificationManager</code> 中 IMPORTANCE_DEFAULT, IMPORTANCE_HIGH, IMPORTANCE_LOW, IMPORTANCE_MAX, IMPORTANCE_MIN 代替。</p><p>方法也使用 NotificationChannel 中的 setImportance 方法：</p><p>void setImportance (int importance)</p><pre><code class="Java">channel.setImportance(NotificationManager.IMPORTANCE_DEFAULT);</code></pre><h2 id="调用摄像头相册"><a href="#调用摄像头相册" class="headerlink" title="调用摄像头相册"></a>调用摄像头相册</h2><p>1、调用摄像头拍照</p><p>首先应该申请相机权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</code></pre><pre><code class="Java">public static final int TAKE_PHOTO = 1;private Uri imageUri;// 创建 File 对象，用于存储拍照后的图片File outputImage = new File(getExternalCacheDir(), &quot;output_image.jpg&quot;);try {    if (outputImage.exists()) {        outputImage.delete();    }    outputImage.createNewFile();} catch (IOException e) {    e.printStackTrace();}// 将 File 转化为 Uri 对象if (Build.VERSION.SDK_INT &lt; 24) {    imageUri = Uri.fromFile(outputImage);} else {    imageUri = FileProvider.getUriForFile(MainActivity.this, &quot;com.wshunli.camera.demo.fileprovider&quot;, outputImage);}// 启动相机程序Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);startActivityForResult(intent, TAKE_PHOTO);</code></pre><p>对于 Android 7.0 以前，File 转化为 Uri 比较简单，但是 7.0 以后认为直接使用真实路径的 Uri 是不安全的。</p><p>所以使用 FileProvider 内容提供器来对数据进行保护，可以选择性地将封装过的 Uri 共享给外部。</p><p>在 Manifest 中，添加 provider 内容提供器 ：</p><pre><code class="XML">&lt;provider    android:name=&quot;android.support.v4.content.FileProvider&quot;    android:authorities=&quot;com.wshunli.camera.demo.fileprovider&quot;    android:exported=&quot;false&quot;    android:grantUriPermissions=&quot;true&quot;&gt;    &lt;meta-data        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;        android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt;</code></pre><p>在 <code>/app/src/main/res/xml/</code> 目录下创建 <code>file_paths.xml</code> 文件，并写入值：</p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;external-path        name=&quot;my_images&quot;        path=&quot;/&quot; /&gt;&lt;/paths&gt;</code></pre><p>最后在 onActivityResult 中接收拍照完成后返回的数据：</p><pre><code class="Java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    switch (requestCode) {        case TAKE_PHOTO:            if (resultCode == RESULT_OK) {                try {                    // 获取拍摄的照片                    Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));                    Log.d(TAG, &quot;onActivityResult: &quot; + bitmap.getRowBytes());                } catch (Exception e) {                    e.printStackTrace();                }            }            break;        default:            break;    }}</code></pre><p>2、从相册中选择照片</p><p>同样应该声明权限，在系统版本 6.0 一样应该申请运行时权限。</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</code></pre><p>打开相册还算比较简单：</p><pre><code class="Java">public static final int CHOOSE_PHOTO = 2;// 打开相册Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;);intent.setType(&quot;image/*&quot;);startActivityForResult(intent, CHOOSE_PHOTO);</code></pre><p>结果处理有点复杂：</p><pre><code class="Java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    switch (requestCode) {        ···        case CHOOSE_PHOTO:            if (resultCode == RESULT_OK) {                // 判断手机系统版本号                if (Build.VERSION.SDK_INT &gt;= 19) {                    // 4.4 及以上系统使用这个方法处理图片                    handleImageOnKitKat(data);                } else {                    // 4.4 以下系统使用这个方法处理图片                    handleImageBeforeKitKat(data);                }            }            break;        default:            break;    }}@TargetApi(19)private void handleImageOnKitKat(Intent data) {    String imagePath = null;    Uri uri = data.getData();    Log.d(&quot;TAG&quot;, &quot;handleImageOnKitKat: uri is &quot; + uri);    if (DocumentsContract.isDocumentUri(this, uri)) {        // 如果是 document 类型的 Uri ，则通过 document id 处理        String docId = DocumentsContract.getDocumentId(uri);        if(&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority())) {            String id = docId.split(&quot;:&quot;)[1]; // 解析出数字格式的 id            String selection = MediaStore.Images.Media._ID + &quot;=&quot; + id;            imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);        } else if (&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority())) {            Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(docId));            imagePath = getImagePath(contentUri, null);        }    } else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) {        // 如果是 content 类型的 Uri ，则使用普通方式处理        imagePath = getImagePath(uri, null);    } else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) {        // 如果是 file 类型的 Uri ，直接获取图片路径即可        imagePath = uri.getPath();    }    Log.d(TAG, &quot;handleImageOnKitKat: &quot; + imagePath);}private void handleImageBeforeKitKat(Intent data) {    Uri uri = data.getData();    String imagePath = getImagePath(uri, null);    Log.d(TAG, &quot;handleImageBeforeKitKat: &quot; + imagePath);}private String getImagePath(Uri uri, String selection) {    String path = null;    // 通过 Uri 和 selection 来获取真实的图片路径    Cursor cursor = getContentResolver().query(uri, null, selection, null, null);    if (cursor != null) {        if (cursor.moveToFirst()) {            path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));        }        cursor.close();    }    return path;}</code></pre><h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><p>1、播放音频</p><p>播放音频主要使用 <a href="https://developer.android.com/reference/android/media/MediaPlayer" rel="external nofollow noopener noreferrer" target="_blank">MediaPlayer</a> 类。</p><p>MedaiaPlayer 设置资源有三种类型：</p><p>(1) 本地资源</p><pre><code class="Java">MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file);mediaPlayer.start(); // no need to call prepare(); create() does that for you</code></pre><p>(2) 通过 URI 共享的资源</p><pre><code class="Java">Uri myUri = ....; // initialize Uri hereMediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(getApplicationContext(), myUri);mediaPlayer.prepare();mediaPlayer.start();</code></pre><p>(3) 通过网络 URL 资源</p><pre><code class="Java">String url = &quot;http://........&quot;; // your URL hereMediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(url);mediaPlayer.prepare(); // might take long! (for buffering, etc)mediaPlayer.start();</code></pre><p><a href="https://developer.android.com/guide/topics/media/mediaplayer" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/media/mediaplayer</a></p><p>获取 MediaPlayer 实例就可以控制音频播放了。</p><pre><code class="Java">mediaPlayer.prepare(); // 开始播放前准备工作mediaPlayer.start(); // 开始播放mediaPlayer.pause(); // 暂停播放mediaPlayer.reset(); // 停止播放mediaPlayer.seekTo(); // 指定位置播放mediaPlayer.stop(); // 停止播放，后面不能再播放音频mediaPlayer.release(); // 释放相关资源</code></pre><p>2、播放视频</p><p>播放视频主要使用 <a href="https://developer.android.com/reference/android/widget/VideoView" rel="external nofollow noopener noreferrer" target="_blank">VideoView</a> 控件。</p><p>使用 setVideoPath (String path) 或者 setVideoURI (Uri uri) 设置视频资源。</p><p>然后就可以使用相应方法控制播放了.</p><pre><code class="Java">videoView.start(); // 开始播放videoView.pause(); // 暂停播放videoView.resume(); // 重头开始播放videoView.seekTo(); // 指定位置播放</code></pre><p>对于音频视频播放还有官方框架 ExoPlayer ：</p><p><a href="https://github.com/google/ExoPlayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/google/ExoPlayer</a></p><blockquote><p>参考资料<br>1、Android O: How to Use Notification Channels - Your Web App<br><a href="http://forum.yourwebapp.mobi/android-o-how-to-use-notification-channels/" rel="external nofollow noopener noreferrer" target="_blank">http://forum.yourwebapp.mobi/android-o-how-to-use-notification-channels/</a><br>2、Android O 8.0系统下通知(Notification)、安装apk问题更新后的简单兼容写法 - CSDN博客<br><a href="https://blog.csdn.net/weitao_666/article/details/79142592" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/weitao_666/article/details/79142592</a><br>3、Audio &amp; Video | Android Developers<br><a href="https://developer.android.com/guide/topics/media/" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/media/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 多媒体资源&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href=&quot;https://www.ws
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（六）</title>
    <link href="https://www.wshunli.com/posts/461ff372.html"/>
    <id>https://www.wshunli.com/posts/461ff372.html</id>
    <published>2018-06-03T13:54:38.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 数据存储方案</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第6章-数据存储全方案"><a href="#第6章-数据存储全方案" class="headerlink" title="第6章 数据存储全方案"></a>第6章 数据存储全方案</h1><p>Android 系统中主要提供了 3 种方式：文件存储、SharedPreference 以及数据库存储。</p><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>对于文件存储，Android 系统不对数据进行格式化处理，适合一些简单的文本数据或者二进制数据。</p><p>1、将数据保存到文件中</p><pre><code class="Java">String FILENAME = &quot;hello_file&quot;;String string = &quot;hello world!&quot;;FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);fos.write(string.getBytes());fos.close();// 异常捕捉 ==&gt;FileOutputStream fos = null;try {    fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);    fos.write(string.getBytes());} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}finally {    try {        if (fos != null) {            fos.close();        }    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>书上是这样写的，主要为了提高性能：</p><pre><code class="Java">String FILENAME = &quot;hello_file&quot;;String string = &quot;hello world!&quot;;FileOutputStream fileOutputStream;BufferedWriter writer = null;try {    fileOutputStream = openFileOutput(FILENAME, Context.MODE_PRIVATE);    writer = new BufferedWriter(new OutputStreamWriter(fileOutputStream));    writer.write(string);} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (writer != null) {            writer.close();        }    } catch (IOException e) {        e.printStackTrace();    }</code></pre><p>其中 MODE_PRIVATE 表示新创建文件，已经存在的文件会覆盖掉；<br>如果使用 MODE_APPEND 表示向存在的文件中追加内容，如果文件不存在会新建。</p><p>还有 MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE 已经过时了。</p><p>2、从文件中读取数据</p><pre><code class="Java">int SIZE = 4096;byte[] buf = new byte[SIZE];FileInputStream fis = null;try {    fis = openFileInput(FILENAME);    int len = fis.read(buf);    while (len != -1) {        System.out.println(new String(buf, 0, len));    }} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (fis != null) {            fis.close();        }    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>书上是这样写的，也是为了提高性能：</p><pre><code class="Java">FileInputStream fileInputStream;BufferedReader reader = null;StringBuilder content = new StringBuilder();try {    fileInputStream = openFileInput(FILENAME);    reader = new BufferedReader(new InputStreamReader(fileInputStream));    String line;    while ((line = reader.readLine() )!= null) {        content.append(line);    }} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (reader != null) {            reader.close();        }    } catch (IOException e) {        e.printStackTrace();    }}System.out.println(content.toString());</code></pre><p>3、Android 系统数据存储位置</p><p>对于 Android 设备可分为 内部存储 和 外部存储。</p><p>3.1、<strong>内部存储</strong></p><p>内部存储默认应用私有，其他 <strong>应用（和用户）</strong> 不能访问这些文件。卸载应用系统会自动删除。</p><p>应用的内部存储空间一般会有 files 和 cache 两个文件夹，分别代表永久存储和缓存数据。</p><p><code>File Context.getFilesDir()</code> 方法 /data/user/0/com.wshunli.store.demo/files</p><p><code>File Context.getCacheDir()</code> 方法 /data/user/0/com.wshunli.store.demo/cache</p><p>其中 0 代表不同用户，Android 6.0 以前不存在。</p><p>文件在 /data/data/com.wshunli.store.demo/ 目录下可以看到。</p><p>3.2、<strong>外部存储</strong></p><p>外部存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储，用户可以删除。</p><p>使用外部存储前应 <strong>检查介质可用性</strong> ：</p><pre><code class="Java">/* Checks if external storage is available for read and write */public boolean isExternalStorageWritable() {    String state = Environment.getExternalStorageState();    if (Environment.MEDIA_MOUNTED.equals(state)) {        return true;    }    return false;}/* Checks if external storage is available to at least read */public boolean isExternalStorageReadable() {    String state = Environment.getExternalStorageState();    if (Environment.MEDIA_MOUNTED.equals(state) ||        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {        return true;    }    return false;}</code></pre><p>这部分比较特殊，也可以分为两种，<strong>可以保存与其他应用共享的文件，也可以保存应用私有文件</strong>（类似于内部存储）。</p><p>（1）对于外部存储的 <strong>私有</strong> 文件夹，一般也会有 files 和 cache 两个文件夹，4.4 及以后读写不再需要权限。</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;                     android:maxSdkVersion=&quot;18&quot; /&gt;</code></pre><p>访问私有文件夹主要有两种方法：</p><p><code>File Context.getExternalFilesDir()</code> 方法 /storage/emulated/0/Android/data/com.wshunli.store.demo/files</p><p><code>File Context.getExternalCacheDir()</code> 方法 /storage/emulated/0/Android/data/com.wshunli.store.demo/cache</p><p>其中 <a href="https://developer.android.com/reference/android/content/Context#getExternalFilesDir" rel="external nofollow noopener noreferrer" target="_blank">getExternalFilesDir()</a> 方法需要传入目录类型。传入 <code>null</code> 表示获取根目录。</p><p><strong>目录类型</strong> 包括以下几种: DIRECTORY_MUSIC, DIRECTORY_PODCASTS, DIRECTORY_RINGTONES, DIRECTORY_ALARMS, DIRECTORY_NOTIFICATIONS, DIRECTORY_PICTURES, DIRECTORY_MOVIES.<br><a href="https://developer.android.com/reference/android/os/Environment#DIRECTORY_MUSIC" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/reference/android/os/Environment#DIRECTORY_MUSIC</a></p><p>有时，已分配某个内部存储器 <strong>分区</strong> 用作外部存储的设备可能还提供了 SD 卡槽。</p><p>在 Android 4.3 以前 Context.getExternalFilesDir() 只能获取内部分区的访问权限；<br>从 Android 4.4 开始 Context.getExternalFilesDirs() 可以同时访问两个位置，及内部分区和 SD 卡。</p><p>对于 Android 4.3 或者更低版本使用 <a href="https://developer.android.com/reference/android/support/v4/content/ContextCompat#getexternalfilesdirs" rel="external nofollow noopener noreferrer" target="_blank">ContextCompat.getExternalFilesDirs()</a> 方法有同样的效果，可以同时访问两个位置。</p><p>（2）对于外部存储的 <strong>共享</strong> 文件夹，必须申请读写权限，而且 6.0 以后要申请运行时权限。</p><p><code>Environment.getExternalStorageDirectory()</code> 方法返回值 /storage/emulated/0</p><p>Android 7.0 提供简化的 API 来访问常见的外部存储目录。<br><a href="https://developer.android.com/training/articles/scoped-directory-access" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/training/articles/scoped-directory-access</a></p><p><code>Environment.getExternalStoragePublicDirectory()</code> 返回设备上的 “公共” 位置。</p><p>同样需要传入目录类型，例如：</p><pre><code class="Java">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM);</code></pre><p>返回相机文件所在目录 /storage/emulated/0/DCIM</p><p>在外部文件目录中包含名为 <code>.nomedia</code> 的空文件（注意文件名中的点前缀），可在媒体扫描程序中隐藏文件。</p><p>4、应用安装包内文件数据访问</p><p>安装包内数据文件有很多种，这里主要介绍两部分：<strong>assets</strong> 和 <strong>raw</strong> 。</p><p>这两部分都会原封不动地打包进 apk 安装包，并不会编译成 二进制文件。</p><p><code>assets</code> 文件夹在 <code>app/src/main/assets/</code> 允许创建目录结构。</p><pre><code class="Java">AssetManager assetManager = getResources().getAssets();assetManager.open(FILENAME);</code></pre><p><code>raw</code> 文件夹在 <code>app/src/main/res/raw/</code> 不允许创建目录结构，但会在 R.java 中自动进行资源标识。</p><pre><code class="Java">InputStream inputStream = getResources().openRawResource(R.id.data);</code></pre><h2 id="SharedPreferences-存储"><a href="#SharedPreferences-存储" class="headerlink" title="SharedPreferences 存储"></a>SharedPreferences 存储</h2><p><a href="https://developer.android.com/reference/android/content/SharedPreferences" rel="external nofollow noopener noreferrer" target="_blank">SharedPreferences</a> 主要用于保存检索原始数据类型的永久性键值对。</p><p>1、使用 SharedPreferences 存储数据首先应 <strong>获取</strong> SharedPreferences 对象，主要有三种方法：</p><p>（1）Context 类中 的 getSharedPreferences 方法，按照文件名称识别 preferences 。</p><p>SharedPreferences getSharedPreferences (String name, int mode)</p><pre><code class="Java">SharedPreferences sharedPreferences = getSharedPreferences(PREFS_NAME, MODE_PRIVATE);</code></pre><p>其中 PREFS_NAME 表示 preferences 文件名称，在 /data/data/com.wshunli.store.demo/shared_prefs/ 路径下 。</p><p>MODE_PRIVATE 表示操作模式，目前只有这一种模式可选，其他 MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE , MODE_MULTI_PROCESS 已经废弃。</p><p>（2）Activity 类中的 getPreferences 方法，按照 Activity 识别 preferencs ，仅用于本 Activity 。</p><p>SharedPreferences getPreferences (int mode)</p><pre><code class="Java">SharedPreferences preferences = getPreferences(MODE_PRIVATE);</code></pre><p>仅指定 操作模式 即可。</p><p>（3）PreferenceManager 类中的 getDefaultSharedPreferences 静态方法，以应用包名作为前缀识别。</p><p>SharedPreferences getDefaultSharedPreferences (Context context)</p><pre><code class="Java">SharedPreferences defaultSharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);</code></pre><p>2、获取 SharedPreferences 对象后就可以 <strong>存储和检索</strong> 数据了。</p><p>对于 <strong>数据存储</strong> 需要使用 <a href="https://developer.android.com/reference/android/content/SharedPreferences.Editor" rel="external nofollow noopener noreferrer" target="_blank">SharedPreferences.Editor</a> 接口。</p><pre><code class="Java">public static final String PREFS_NAME = &quot;wshunli&quot;;SharedPreferences sharedPreferences = getSharedPreferences(PREFS_NAME, MODE_PRIVATE);SharedPreferences.Editor editor = sharedPreferences.edit();editor.putString(&quot;website&quot;, &quot;wshunli.com&quot;);editor.putBoolean(&quot;is&quot;, true);editor.apply();</code></pre><p>我们可以在 shared_prefs 文件夹下发现 <code>wshunli.xml</code> 文件：</p><pre><code class="XML">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt;&lt;map&gt;    &lt;string name=&quot;website&quot;&gt;wshunli.com&lt;/string&gt;    &lt;boolean name=&quot;is&quot; value=&quot;true&quot; /&gt;&lt;/map&gt;</code></pre><p>前面三种方式在 xml 文件命名不太一样，内容是一样的：</p><p>/data/data/com.wshunli.store.demo/shared_prefs/<code>wshunli.xml</code><br>/data/data/com.wshunli.store.demo/shared_prefs/<code>SPActivity.xml</code><br>/data/data/com.wshunli.store.demo/shared_prefs/<code>com.wshunli.store.demo_preferences.xml</code></p><p>SharedPreferences.Editor 提交数据有两种方法，apply() 和 commit() ，两者主要区别有两点：</p><p>(1) commit() 有返回值，apply() 没有返回值。apply() 失败了是不会报错的。<br>(2) apply() 写入文件的操作是 <strong>异步</strong> 的，会把 Runnable 放到线程池中执行，而 commit() 的写入文件的操作是在当前线程 <strong>同步</strong> 执行的。</p><p>因此当两者都可以使用的时候还是推荐使用 apply() ，因为 apply() 写入文件操作是异步执行的，不会占用主线程资源。</p><p>3、从 SharedPreferences 中读取数据</p><p>直接使用 SharedPreferences 对象实例方法即可。</p><p>String getString (String key, String defValue)</p><pre><code class="Java">String website = sharedPreferences.getString(&quot;website&quot;, &quot;&quot;);</code></pre><p>其他方法还有：<br>Map&lt;String, ?&gt; getAll () // 获取所有键值对<br>boolean contains (String key) // 是否包含某键值数据</p><h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><p>Android 提供了对 SQLite 数据库的完全支持。</p><p>也有很多其他数据库可以使用，比如 Realm 、ObjectBox 等等。<br>一些数据库 ORM 框架也要学习，比如 GreenDao 、LitePal 等等。</p><p>这里只介绍 SQLite 数据库。</p><p>1、创建数据库</p><p>在 Android 中操纵 SQLite 数据库可以使用 SQLiteOpenHelper 类。</p><pre><code class="Java">public class MSQLiteOpenHelper extends SQLiteOpenHelper {    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {        this(context, name, factory, version, null);    }    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) {        super(context, name, factory, version, errorHandler);    }    @Override    public void onCreate(SQLiteDatabase db) {    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}</code></pre><p>其中构造函数：context 即上下文；name 为数据库名称；factory 为自定义 Cursor ，一般传入 null ；version 为数据库版本号，用于数据库升级。</p><p>然后调用 SQLiteOpenHelper 对象实例的 getReadableDatabase() 或者 getWritableDatabase() 即可创建数据库。</p><pre><code class="Java">MSQLiteOpenHelper dbHelper = new MSQLiteOpenHelper(this, &quot;book.db&quot;, null, 1);dbHelper.getWritableDatabase();</code></pre><p>数据库文件存储位置：/data/data/com.wshunli.sqlite.demo/databases/book.db</p><p>2、添加表结构</p><p>前面只是创建了空数据库，下面添加表。</p><p>使用 SQLiteDatabase 对象的 execSQL(String sql) 方法。</p><pre><code class="Java">public class MSQLiteOpenHelper extends SQLiteOpenHelper {    public static final String CREATE_BOOK = &quot;create table Book (&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;author text, &quot;            + &quot;price real, &quot;            + &quot;pages integer, &quot;            + &quot;name text)&quot;;    private Context context;    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {        this(context, name, factory, version,null);    }    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) {        super(context, name, factory, version, errorHandler);        this.context = context;    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK);        Toast.makeText(context, &quot;数据写入成功&quot;, Toast.LENGTH_LONG).show();    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}  </code></pre><p>3、升级数据库</p><p>在添加数据库表时，非常有用。其实就是实现 onUpgrade 方法。</p><pre><code class="Java">public class MSQLiteOpenHelper extends SQLiteOpenHelper {    public static final String CREATE_BOOK = &quot;create table Book (&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;author text, &quot;            + &quot;price real, &quot;            + &quot;pages integer, &quot;            + &quot;name text)&quot;;    public static final String CREATE_CATEGORY = &quot;create table Category (&quot;            + &quot;id integer primary key autoincrement, &quot;            + &quot;category_name text, &quot;            + &quot;category_code integer)&quot;;    private Context context;    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {        this(context, name, factory, version,null);    }    public MSQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) {        super(context, name, factory, version, errorHandler);        this.context = context;    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK);        db.execSQL(CREATE_CATEGORY);        Toast.makeText(context, &quot;数据写入成功&quot;, Toast.LENGTH_LONG).show();    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {        db.execSQL(&quot;drop table if exists Book&quot;);        db.execSQL(&quot;drop table if exists Category&quot;);        onCreate(db);    }}</code></pre><p>这时我们在构造函数中 版本号大于 1 即可。</p><pre><code class="Java">dbHelper = new MSQLiteOpenHelper(this, &quot;book.db&quot;, null, 2);</code></pre><p>如果在 onCreate 方法里直接添加 <code>db.execSQL(CREATE_CATEGORY);</code> 语句是不会执行的。</p><p>4、添加数据</p><p>对数据库的操作无非就是 CRUD ：C 添加、R 查询、U 更新、D 删除。</p><p>添加数据使用 SQLiteDatabase 对象的 insert 方法。</p><p>long insert(String table, String nullColumnHack, ContentValues values)</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();// 开始组装第一条数据values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 454);values.put(&quot;price&quot;, 16.96);db.insert(&quot;Book&quot;, null, values); // 插入第一条数据values.clear();// 开始组装第二条数据values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;);values.put(&quot;author&quot;, &quot;Dan Brown&quot;);values.put(&quot;pages&quot;, 510);values.put(&quot;price&quot;, 19.95);db.insert(&quot;Book&quot;, null, values); // 插入第二条数据</code></pre><p>其中第二个参数 nullColumnHack 用于未指定添加数据的情形，一般直接传入 null 即可。</p><p>5、更新数据</p><p>更新数据使用 SQLiteDatabase 对象的 update 方法。</p><p>int update(String table, ContentValues values, String whereClause, String[] whereArgs)</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put(&quot;price&quot;, 10.99);db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[] { &quot;The Da Vinci Code&quot; });</code></pre><p>其中 whereClause 、 whereArgs 用于约束数据第几行或者某几行，不指定则更新所有行。</p><p>6、删除数据</p><p>删除数据使用 SQLiteDatabase 对象的 delete 方法。</p><p>int delete(String table, String whereClause, String[] whereArgs)</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[] { &quot;500&quot; });</code></pre><p>其中 whereClause 、 whereArgs 用于约束数据第几行或者某几行，不指定则删除所有行。</p><p>7、查询数据</p><p>查询数据使用 SQLiteDatabase 对象的 query 方法。</p><pre><code class="Java">Cursor query(String table, String[] columns, // 指定表名、列名             String selection, String[] selectionArgs,              String groupBy, String having,              String orderBy)</code></pre><p>其中 selection 、 selectionArgs 用于约束数据第几行或者某几行，不指定则查询所有行。<br>然后 groupBy 指定 group by 的列，having 对 group by 结果进一步约束。<br>最后 orderBy 指定排序方式。</p><pre><code class="Java">SQLiteDatabase db = dbHelper.getWritableDatabase();// 查询Book表中所有的数据Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null);if (cursor.moveToFirst()) {    do {        // 遍历Cursor对象，取出数据并打印        String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));        String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;));        int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));        double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));        Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name);        Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author);        Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages);        Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price);    } while (cursor.moveToNext());}cursor.close();</code></pre><p>8、使用 SQL 语句操纵数据库</p><p>使用 SQLiteDatabase 对象的 execSQL 方法，还是挺麻烦的，可以使用一些 ORM 框架。</p><blockquote><p>参考资料<br>1、存储选项 | Android Developers<br><a href="https://developer.android.com/guide/topics/data/data-storage" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/data/data-storage</a><br>2、FileInputStream读取文件数据的两种方式 - CSDN博客<br><a href="https://blog.csdn.net/a909301740/article/details/52574602" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a909301740/article/details/52574602</a><br>3、全面的Android文件目录解析和获取方法(包含对6.0系统的说明) - CSDN博客<br><a href="https://blog.csdn.net/zhangbuzhangbu/article/details/23257873" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhangbuzhangbu/article/details/23257873</a><br>4、android 目录/data/data/ 跟 /data/user/0/ 差别 - V2EX<br><a href="https://www.v2ex.com/t/259080" rel="external nofollow noopener noreferrer" target="_blank">https://www.v2ex.com/t/259080</a><br>5、提供资源 | Android Developers<br><a href="https://developer.android.com/guide/topics/resources/providing-resources" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/resources/providing-resources</a><br>6、Android数据存储之Assets、Raw - CSDN博客<br><a href="https://blog.csdn.net/sjm19901003/article/details/47026503" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/sjm19901003/article/details/47026503</a><br>7、SharePreferences源码分析（commit与apply的区别以及原理） - CSDN博客<br><a href="https://blog.csdn.net/Double2hao/article/details/53871640" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/Double2hao/article/details/53871640</a><br>8、Room，Realm,，ObjectBox 你选择哪个？ - 泡在网上的日子<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0926/8551.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0926/8551.html</a><br>9、【Android 数据库框架总结，总有一个适合你！】 - CSDN博客<br><a href="https://blog.csdn.net/da_caoyuan/article/details/61414626" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/da_caoyuan/article/details/61414626</a><br>10、android基础—-&gt;SQLite数据库的使用 - huhx - 博客园<br><a href="http://www.cnblogs.com/huhx/p/sqliteDatabase.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/huhx/p/sqliteDatabase.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 数据存储方案&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href=&quot;https://www.w
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（五）</title>
    <link href="https://www.wshunli.com/posts/2311b8ab.html"/>
    <id>https://www.wshunli.com/posts/2311b8ab.html</id>
    <published>2018-06-03T06:20:42.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 ContentProvider</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第7章-跨程序共享数据"><a href="#第7章-跨程序共享数据" class="headerlink" title="第7章 跨程序共享数据"></a>第7章 跨程序共享数据</h1><p>ContentProvider 主要用于不同程序之间实现数据共享的功能，同时保证被访问数据的安全。</p><p>目前，使用 ContentProvider 是 Android 实现跨程序共享数据的标准方式。</p><p>ContentProvider 有两种用法，一是访问其他程序中的数据，另一种是创建自己的 ContentProvider 让其他程序访问。</p><h2 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h2><p>对于应用程序来说，访问内容提供器中共享的数据，要借助 ContentResolver 类，可以通过 Context 中的 getContentResolver() 方法获取该类的实例。</p><p>可以借助以下方法对共享的数据进行 CRUD 操作：</p><pre><code class="Java">Cursor query(@NonNull Uri uri,             @Nullable String[] projection,             @Nullable String selection,             @Nullable String[] selectionArgs,             @Nullable String sortOrder)</code></pre><pre><code class="Java">Uri insert(@NonNull Uri url,           @Nullable ContentValues values)</code></pre><pre><code class="Java">int update(@NonNull Uri uri,           @Nullable ContentValues values,           @Nullable String where,           @Nullable String[] selectionArgs)</code></pre><pre><code class="Java">int delete(@NonNull Uri url,           @Nullable String where,           @Nullable String[] selectionArgs)</code></pre><p>查询联系人示例：</p><pre><code class="Java">Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null);if (cursor != null) {    while (cursor.moveToNext()) {        String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));        String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));        Log.d(TAG, name + &quot;: &quot; + number);    }    cursor.close();}</code></pre><h2 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h2><p>新建一个类继承 ContentProvider 即可创建自己的内容提供器。</p><pre><code class="Java">public class MContentProvider extends ContentProvider {    private static final int TABLE_DIR = 0;    private static final int TABLE_ITEM = 1;    private static UriMatcher uriMatcher;    static {        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(&quot;com.wshunli.provider.demo&quot;, &quot;table1&quot;, TABLE_DIR);        uriMatcher.addURI(&quot;com.wshunli.provider.demo&quot;, &quot;table1/#&quot;, TABLE_ITEM);    }    // 初始化内容提供器时调用。    @Override    public boolean onCreate() {        return false;    }    @Nullable    @Override    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {        switch (uriMatcher.match(uri)) {            case TABLE_DIR:                // 查询 table1 表中的所有数据                break;            case TABLE_ITEM:                // 查询 table1 表中的单挑数据                break;        }        return null;    }    // 根据传入的 URI 返回相应的 MIME 类型。    @Nullable    @Override    public String getType(@NonNull Uri uri) {        switch (uriMatcher.match(uri)) {            case TABLE_DIR:                return &quot;vnd.android.cursor.dir/vnd.com.wshunli.provider.demo.table1&quot;;            case TABLE_ITEM:                return &quot;vnd.android.cursor.item/vnd.com.wshunli.provider.demo.table1&quot;;        }        return null;    }    @Nullable    @Override    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {        return null;    }    @Override    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {        return 0;    }    @Override    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {        return 0;    }}</code></pre><p>对于 URI 有两种，一种是以路径结尾表示期望访问表中所有数据：</p><p><code>content://com.wshunli.provider.demo/table</code></p><p>另一种以 id 结尾表示期望访问该表中拥有相应 id 的数据：</p><p><code>content://com.wshunli.provider.demo/table/1</code></p><p>1、对于 UriMatcher 匹配 URI</p><p><code>*</code> 表示任意长度的字符，<code>#</code> 表示任意长度的数字。</p><p>2、对于返回 MIME 类型，分别使用</p><p>表示单行数据：<code>android.cursor.item/</code></p><p>表示多行数据：<code>android.cursor.dir/</code></p><p>其他 insert 、 delete 、 update 方法类似。</p><h2 id="实现跨程序数据共享"><a href="#实现跨程序数据共享" class="headerlink" title="实现跨程序数据共享"></a>实现跨程序数据共享</h2><p>首先实现自己的 ContentProvider ：</p><pre><code class="Java">public class DatabaseProvider extends ContentProvider {    public static final int BOOK_DIR = 0;    public static final int BOOK_ITEM = 1;    public static final int CATEGORY_DIR = 2;    public static final int CATEGORY_ITEM = 3;    public static final String AUTHORITY = &quot;com.wshunli.provider&quot;;    private static UriMatcher uriMatcher;    private MyDatabaseHelper dbHelper;    static {        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR);        uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM);        uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR);        uriMatcher.addURI(AUTHORITY, &quot;category/#&quot;, CATEGORY_ITEM);    }    @Override    public boolean onCreate() {        dbHelper = new MyDatabaseHelper(getContext(), &quot;BookStore.db&quot;, null, 2);        return true;    }    @Override    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {        // 查询数据        SQLiteDatabase db = dbHelper.getReadableDatabase();        Cursor cursor = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                cursor = db.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] { bookId }, null, null, sortOrder);                break;            case CATEGORY_DIR:                cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                cursor = db.query(&quot;Category&quot;, projection, &quot;id = ?&quot;, new String[] { categoryId }, null, null, sortOrder);                break;            default:                break;        }        return cursor;    }    @Override    public Uri insert(Uri uri, ContentValues values) {        // 添加数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        Uri uriReturn = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:            case BOOK_ITEM:                long newBookId = db.insert(&quot;Book&quot;, null, values);                uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId);                break;            case CATEGORY_DIR:            case CATEGORY_ITEM:                long newCategoryId = db.insert(&quot;Category&quot;, null, values);                uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/category/&quot; + newCategoryId);                break;            default:                break;        }        return uriReturn;    }    @Override    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {        // 更新数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int updatedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                updatedRows = db.update(&quot;Book&quot;, values, selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                updatedRows = db.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] { bookId });                break;            case CATEGORY_DIR:                updatedRows = db.update(&quot;Category&quot;, values, selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                updatedRows = db.update(&quot;Category&quot;, values, &quot;id = ?&quot;, new String[] { categoryId });                break;            default:                break;        }        return updatedRows;    }    @Override    public int delete(Uri uri, String selection, String[] selectionArgs) {        // 删除数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int deletedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                deletedRows = db.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] { bookId });                break;            case CATEGORY_DIR:                deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                deletedRows = db.delete(&quot;Category&quot;, &quot;id = ?&quot;, new String[] { categoryId });                break;            default:                break;        }        return deletedRows;    }    @Override    public String getType(Uri uri) {        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                return &quot;vnd.android.cursor.dir/vnd.com.wshunli.provider.book&quot;;            case BOOK_ITEM:                return &quot;vnd.android.cursor.item/vnd.com.wshunli.provider.book&quot;;            case CATEGORY_DIR:                return &quot;vnd.android.cursor.dir/vnd.com.wshunli.provider.category&quot;;            case CATEGORY_ITEM:                return &quot;vnd.android.cursor.item/vnd.com.wshunli.provider.category&quot;;        }        return null;    }}</code></pre><p>注意 ContentProvider 需要在 Manifest 中声明才能使用。</p><pre><code class="XML">&lt;provider    android:name=&quot;.MContentProvider&quot;    android:authorities=&quot;com.wshunli.provider.demo&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot; /&gt;</code></pre><p>然后就是访问 ContentProvider 了：</p><pre><code class="Java">private String newId;// 添加数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book&quot;);ContentValues values = new ContentValues();values.put(&quot;name&quot;, &quot;A Clash of Kings&quot;);values.put(&quot;author&quot;, &quot;George Martin&quot;);values.put(&quot;pages&quot;, 1040);values.put(&quot;price&quot;, 55.55);Uri newUri = getContentResolver().insert(uri, values);newId = newUri.getPathSegments().get(1);// 查询数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book&quot;);Cursor cursor = getContentResolver().query(uri, null, null, null, null);if (cursor != null) {    while (cursor.moveToNext()) {        String name = cursor.getString(cursor. getColumnIndex(&quot;name&quot;));        String author = cursor.getString(cursor. getColumnIndex(&quot;author&quot;));        int pages = cursor.getInt(cursor.getColumnIndex (&quot;pages&quot;));        double price = cursor.getDouble(cursor. getColumnIndex(&quot;price&quot;));        Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name);        Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author);        Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages);        Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price);    }    cursor.close();}// 更新数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book/&quot; + newId);ContentValues values = new ContentValues();values.put(&quot;name&quot;, &quot;A Storm of Swords&quot;);values.put(&quot;pages&quot;, 1216);values.put(&quot;price&quot;, 24.05);getContentResolver().update(uri, values, null, null);// 删除数据Uri uri = Uri.parse(&quot;content://com.wshunli.provider/book/&quot; + newId);getContentResolver().delete(uri, null, null);</code></pre><p>也就是将前面的内容结合起来。</p><blockquote><p>参考资料<br>1、ContentProvider | Android Developers<br><a href="https://developer.android.com/guide/topics/providers/content-providers" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/topics/providers/content-providers</a><br>2、Android深入四大组件（五）Content Provider的启动过程 | 刘望舒的博客<br><a href="http://liuwangshu.cn/framework/component/5-contentprovider-start.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/framework/component/5-contentprovider-start.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 ContentProvider&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>安利两款数据备份与无损分区软件</title>
    <link href="https://www.wshunli.com/posts/89531c6c.html"/>
    <id>https://www.wshunli.com/posts/89531c6c.html</id>
    <published>2018-06-01T13:24:45.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用软件前，请确认您熟悉数据备份及无损分区，理解执行每项操作的含义及后果，数据无价，谨慎操作</strong>。</p><p>机房电脑硬盘出问题了，换个新硬盘，没想到台式机的硬盘那么便宜，1T 机械硬盘还不到三百。</p><p>安利的两款软件叫 <strong>傲梅分区助手</strong> 和 <strong>傲梅轻松备份</strong> ，都是免费的。</p><p>机房电脑有两块硬盘，250G 固态硬盘装系统和软件，多余的空间还能存一些数据。</p><p>以前笔记本的 SSD 坏过一次，卖家保修期内免费换新，但是数据还没法恢复。从那以后就有系统数据备份的习惯，再者重要的代码都上传到 GitHub 私有仓库了，所以 SSD 这部分倒不是很担心。</p><p>另一块是这次出问题的机械硬盘，只是作为 QQ 和网易云音乐的缓存，系统运行状态下读写还是比较小的。</p><p>一直以来这个硬盘噪声都挺大的，但是最近磁盘活动时间总是 100% ，经常引起系统卡顿崩溃，前两天检测下硬盘已经有不少坏道了，这部分没有备份所以比较害怕，赶紧申请换块硬盘。</p><p>以上是背景，下面介绍 <strong>整个数据备份及恢复的过程</strong> 。</p><p><strong>复制粘贴</strong>：</p><p>硬盘出问题了，最重要的还是想法设法备份数据。下面是新买的硬盘。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/新硬盘.png" alt="新硬盘"></p><p>最开始直接使用拷贝的方式，也就是把硬盘里的数据 <strong>复制粘贴</strong> 到移动硬盘或者新硬盘。</p><p>但是我在拷贝的过程中系统未响应直接蓝屏了，开机后系统不识别，机械硬盘丢失，当时有点伤心了。<br>还好重启电脑后硬盘又出现，至今也不知道具体原因。</p><p>然后就是再次尝试，打开 DiskGenius 软件提示，分区表 CRC 错误。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/分区表错误.png" alt="分区表错误"></p><p>上次打开就有这个提示，我没有管，这次手贱点了一下，然后又对新硬盘分区。</p><p>在对新硬盘进行分区的过程中，系统蓝屏，然后循环自动修复进不去系统了。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/自动修复.png" alt="自动修复"></p><p>中间也试了不少方法，修复分区表啊，尝试修复了都不行，有点崩溃。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/自动修复日志.png" alt="自动修复日志"></p><p>上面这么折腾已经花费一天了。</p><p><strong>数据备份</strong>：</p><p>感觉系统修复无望后，晚上制作 PE ，使用 PE 安装 轻松备份 。</p><p>还是想先备份硬盘，包括 SSD 和机械硬盘。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/轻松备份-备份.png" alt="轻松备份-备份"></p><p>这时候已经不能使用系统备份了，只能使用磁盘备份或者分区备份。</p><p>整个过程很顺畅，SSD 备份在 150M+ ，机械硬盘在 30M+ ，机械硬盘明显不太行了。</p><p><strong>数据恢复</strong>：</p><p>以前笔记本和机房的系统都备份过，这次就想干脆用笔记本的系统算了。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/轻松备份-还原.png" alt="轻松备份-还原"></p><p>首先把笔记本备份的系统还原到机房电脑，然后进入系统逐个还原其他分区。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/数据备份恢复.png" alt="数据备份恢复"></p><p>最终以前笔记本的 C D 盘不变，把原来台式机 D 盘放到 E 盘。</p><p><strong>分区调整</strong>：</p><p>分区还原之后大小不是很理想，可以使用分区助手调整。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/分区操作.png" alt="分区操作"></p><p>调整分区大小，合并下分区的数据等等。</p><p><strong>满血复活</strong>：</p><p>这是还原完成后，系统界面（模糊处理），莫名感动，熟悉的界面失而复得很神奇：</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/ok.png" alt="ok"></p><p><strong>分区助手</strong> 和 <strong>轻松备份</strong> 是 <a href="https://www.disktool.cn/about-us.html" rel="external nofollow noopener noreferrer" target="_blank">成都傲梅科技有限公司</a> 两款免费软件，很优秀。</p><p><strong>傲梅分区助手（ <a href="https://www.disktool.cn/feature.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.disktool.cn/feature.html</a> )</strong> 是一个简单易用且免费的无损分区软件，作为无损分区的领导者，在它的帮助下，您可以无损数据地执行调整分区大小，移动分区位置，复制分区，快速分区，复制磁盘，合并分区，切割分区、恢复分区、迁移操作系统等操作。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/分区助手.png" alt="分区助手"></p><p><strong>轻松备份专业版（ <a href="https://www.disktool.cn/backup/backup-software.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.disktool.cn/backup/backup-software.html</a> ）</strong> 是一款免费的、简单易用的备份还原软件，不仅能轻松地 Ghost 系统实现系统备份，还能备份文件、文件夹、硬盘、分区，也能通过定时备份功能自动备份您想备份的数据和实时同步功能同步文件、文件夹到其他位置。</p><p><img src="https://img.wshunli.com/瞎推荐/傲梅科技/轻松备份.png" alt="轻松备份"></p><p><strong>成都傲梅科技有限公司</strong>是一家致力于备份还原与磁盘分区软件产品开发的软件公司，从 2009 年底发布第一款产品以来就一直在这块领土上耕耘着，在基于文件系统与磁盘分区管理的产品开发方面积累了丰富的经验，同时也在备份还原上拥有核心的技术实力。</p><blockquote><p>整个过程折腾了两天，还有些软件版本需要升级，不过相比较重新安装那么多软件，配置环境已经快很多了。<br>主要时间还是花费在数据读写上了，至少 800G+ 的数据读写，明显机械硬盘读写太慢了。<br>以后不清楚的操作还是谨慎点，手残乱点容易出岔子。</p></blockquote><p><strong>数据无价，谨慎操作。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用软件前，请确认您熟悉数据备份及无损分区，理解执行每项操作的含义及后果，数据无价，谨慎操作&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;机房电脑硬盘出问题了，换个新硬盘，没想到台式机的硬盘那么便宜，1T 机械硬盘还不到三百。&lt;/p&gt;&lt;p&gt;安利的两款软件叫 &lt;stron
      
    
    </summary>
    
      <category term="瞎推荐" scheme="https://www.wshunli.com/categories/%E7%9E%8E%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="数据备份" scheme="https://www.wshunli.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    
      <category term="无损分区" scheme="https://www.wshunli.com/tags/%E6%97%A0%E6%8D%9F%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin for Android（一）Hello Kotlin !</title>
    <link href="https://www.wshunli.com/posts/591ca4ea.html"/>
    <id>https://www.wshunli.com/posts/591ca4ea.html</id>
    <published>2018-05-29T13:04:28.000Z</published>
    <updated>2018-06-05T09:20:28.121Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 是用于现代多平台应用的静态编程语言，与 Java™ 和 Android™ 100% 可互操作。</p><p>2017 年 5 月，Google 年度 I/O 大会上，宣布把 Kotlin 作为 Android 开发的首选语言。</p><p>今年 2018 Google I/O 大会上，示例 App 已经全部采用 Kotlin 编写了。</p><p>前面也一直想涉猎 Kotlin 方面的东西，但是一直没有时间，主要还是懒。。</p><p><strong>维基百科关于 Kotlin 的介绍</strong>：</p><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，它也可以被编译成为 JavaScript 源代码。它主要是由俄罗斯圣彼得堡的 JetBrains 开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。</p><p>2011年7月，JetBrains 推出 Kotlin 项目，这是一个面向 JVM 的新语言，它已被开发一年之久。</p><p>JetBrains 负责人 Dmitry Jemerov 说，大多数语言没有他们正在寻找的特性，Scala 除外。但是，他指出了 Scala 的编译时间慢这一明显缺陷。<br>Kotlin 的既定目标之一是像 Java 一样快速编译。</p><p>2012年2月，JetBrains 以 Apache 2 许可证开源此项目。Jetbrains希望这个新语言能够推动IntelliJ IDEA的销售。</p><p>Kotlin v1.0 于 2016年2月15日 发布。这被认为是第一个官方稳定版本，并且 JetBrains 已准备从该版本开始的长期向后兼容性。</p><p><strong>官方及其中文网站</strong>：</p><p>Kotlin Programming Language:<br><a href="http://kotlinlang.org/" rel="external nofollow noopener noreferrer" target="_blank">http://kotlinlang.org/</a></p><p>Kotlin 语言中文站:<br><a href="https://www.kotlincn.net/" rel="external nofollow noopener noreferrer" target="_blank">https://www.kotlincn.net/</a></p><p>1、环境配置</p><p>Kotlin 是一种运行在 JVM 上的编程语言，所以和 Java 环境配置是一样的，这里就不多介绍了。</p><p>2、IntelliJ IDEA</p><p>Kotlin 是 JetBrains 推出的，我们就用大名鼎鼎的 IntelliJ IDEA 就好了。</p><p>3、Hello Kotlin !</p><p>我们在IDE 中新建项目，并写一个 HelloWorld 类：</p><p><img src="https://img.wshunli.com/Kotlin/kotlin-android/1.Hello.png" alt="Hello Kotlin"></p><p>和 Java 还是非常像的，学过 Java 的应该一下就能看懂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kotlin 是用于现代多平台应用的静态编程语言，与 Java™ 和 Android™ 100% 可互操作。&lt;/p&gt;&lt;p&gt;2017 年 5 月，Google 年度 I/O 大会上，宣布把 Kotlin 作为 Android 开发的首选语言。&lt;/p&gt;&lt;p&gt;今年 2018 Go
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="https://www.wshunli.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年春季快手实习生面试</title>
    <link href="https://www.wshunli.com/posts/cfc1cac2.html"/>
    <id>https://www.wshunli.com/posts/cfc1cac2.html</id>
    <published>2018-05-28T05:06:00.000Z</published>
    <updated>2018-06-05T09:20:28.129Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码（kuaishou）查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码（kuaishou）查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【密码公开】记录2018年春快手暑期实习生面试（客户端工程师）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Logger使用及源码解析</title>
    <link href="https://www.wshunli.com/posts/ca2fa1f1.html"/>
    <id>https://www.wshunli.com/posts/ca2fa1f1.html</id>
    <published>2018-05-22T14:46:58.000Z</published>
    <updated>2018-06-05T09:20:28.121Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 开发过程中打印日志必不可少，Logger 就是一款优秀的 Android 开源日志库。</p><p>Logger 使用简单，输出日志美观高效，支持 JSON 、XML 格式输出，支持打印 Arrays 、Collections 等对象。</p><p>Logger 地址 ：<a href="https://github.com/orhanobut/logger" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/orhanobut/logger</a></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>在项目中添加依赖：</p><pre><code class="Gradle">implementation &#39;com.orhanobut:logger:2.2.0&#39;</code></pre><p>快速开始：</p><pre><code class="Java">Logger.addLogAdapter(new AndroidLogAdapter());Logger.d(&quot;hello&quot;);</code></pre><p>这样就可以打印日志了。</p><p><img src="https://img.wshunli.com/Android/Logger/hello2.png" alt="hello"></p><p>当然不止打印这一种日志，和自带的函数类似：</p><pre><code class="Java">Logger.d(&quot;debug&quot;);Logger.e(&quot;error&quot;);Logger.w(&quot;warning&quot;);Logger.v(&quot;verbose&quot;);Logger.i(&quot;information&quot;);Logger.wtf(&quot;What a Terrible Failure&quot;);</code></pre><p>也支持格式化输出：</p><pre><code class="Java">Logger.d(&quot;hello %s&quot;, &quot;world&quot;);</code></pre><p>支持数字、集合对象的输出，注意只支持 Logger.d() 方法：</p><pre><code class="Java">Logger.d(MAP);Logger.d(SET);Logger.d(LIST);Logger.d(ARRAY);</code></pre><p>支持 JSON 和 XML 的输出：</p><pre><code class="Java">Logger.json(JSON_CONTENT);Logger.xml(XML_CONTENT);</code></pre><p>自定义 TAG ，仅本次日志打印有效：</p><pre><code class="Java">Logger.t(&quot;MainActivity&quot;).d(&quot;hello&quot;);</code></pre><p>支持把日志保存为文件：</p><pre><code class="Java">Logger.addLogAdapter(new DiskLogAdapter());Logger.d(&quot;hello&quot;);</code></pre><p>只需更改 LogAdapter 即可，其他使用相同。</p><pre><code class="Java">Logger.clearLogAdapters();</code></pre><p>清除 LogAdapter 方法。</p><h1 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h1><p>利用 PrettyFormatStrategy.newBuilder 还有更高级的设置，如：</p><pre><code class="Java">FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder()  .showThreadInfo(false)  // (Optional) Whether to show thread info or not. Default true  .methodCount(0)         // (Optional) How many method line to show. Default 2  .methodOffset(7)        // (Optional) Hides internal method calls up to offset. Default 5  .logStrategy(customLog) // (Optional) Changes the log strategy to print out. Default LogCat  .tag(&quot;My custom tag&quot;)   // (Optional) Global tag for every log. Default PRETTY_LOGGER  .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy));</code></pre><p>再者实现对打印日志的控制：</p><pre><code class="Java">Logger.addLogAdapter(new AndroidLogAdapter() {  @Override public boolean isLoggable(int priority, String tag) {    return BuildConfig.DEBUG;  }});</code></pre><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>先看官方对工作原理的介绍：</p><p><img src="https://img.wshunli.com/Android/Logger/how_it_works.png" alt="how_it_works"></p><p>Logger 打印日志整个流程非常明确：</p><p>Logger 负责整个对外的接口，LoggerPrinter 负责对不同日志的整合，LogAdapter 分别对 Logcat 和 Disk 的打印进行适配，FormatStrategy 负责打印输出的配置及美化，LogStrategy 负责最终的打印输出任务。</p><p>1、Logger.java 部分代码：</p><pre><code class="Java">private static Printer printer = new LoggerPrinter();public static Printer t(@Nullable String tag) {    return printer.t(tag);}</code></pre><p>这里只是提供了一系列的静态函数，包括前面对不同等级的日志的输出及 JSON、XML 的输出。</p><p>实际工作还是由 LoggerPrinter 来做。</p><p>还有就是对 LogAdapter 适配器的添加清除：</p><pre><code class="Java">public static void addLogAdapter(@NonNull LogAdapter adapter) {    printer.addAdapter(checkNotNull(adapter));}public static void clearLogAdapters() {    printer.clearLogAdapters();}</code></pre><p>2、LoggerPrinter 部分代码：</p><p>LoggerPrinter 实现 Printer 接口，负责不同日志的整合。</p><pre><code class="Java">@Override public void d(@NonNull String message, @Nullable Object... args) {    log(DEBUG, null, message, args);}@Override public void d(@Nullable Object object) {    log(DEBUG, null, Utils.toString(object));}@Override public void e(@Nullable Throwable throwable, @NonNull String message, @Nullable Object... args) {    log(ERROR, throwable, message, args);}@Override public void w(@NonNull String message, @Nullable Object... args) {    log(WARN, null, message, args);}  </code></pre><p>我们可以看到这些方法都是对 log() 方法的调用。</p><p>注意这里 d() 方法可以输出任意对象，还是对象转化为字符串输出。</p><p>我们接着看 log() 方法：</p><pre><code class="Java">private final ThreadLocal&lt;String&gt; localTag = new ThreadLocal&lt;&gt;();@Override public Printer t(String tag) {    if (tag != null) {        localTag.set(tag);    }    return this;}@Override public synchronized void log(int priority,                                         @Nullable String tag,                                         @Nullable String message,                                         @Nullable Throwable throwable) {    if (throwable != null &amp;&amp; message != null) {        message += &quot; : &quot; + Utils.getStackTraceString(throwable);    }    if (throwable != null &amp;&amp; message == null) {        message = Utils.getStackTraceString(throwable);    }    if (Utils.isEmpty(message)) {        message = &quot;Empty/NULL log message&quot;;    }    for (LogAdapter adapter : logAdapters) {        if (adapter.isLoggable(priority, tag)) {        adapter.log(priority, tag, message);        }    }}/*** This method is synchronized in order to avoid messy of logs&#39; order.*/private synchronized void log(int priority,                            @Nullable Throwable throwable,                            @NonNull String msg,                            @Nullable Object... args) {    checkNotNull(msg);    String tag = getTag();    String message = createMessage(msg, args);    log(priority, tag, message, throwable);}/*** @return the appropriate tag based on local or global*/@Nullable private String getTag() {String tag = localTag.get();    if (tag != null) {        localTag.remove();        return tag;    }    return null;}@NonNull private String createMessage(@NonNull String message, @Nullable Object... args) {    return args == null || args.length == 0 ? message : String.format(message, args);}</code></pre><p>我们可以看到这里是交由 LogAdapter 来实现打印：</p><pre><code class="Java">adapter.log(priority, tag, message);</code></pre><p>在调用之前添加了 tag ，对于一次性的 tag 是由 ThreadLocal 来存储的，避免线程的并发问题，并且在取出后将其置空。</p><p>3、LogAdapter 有两个实现</p><p>AndroidLogAdapter 与 DiskLogAdapter 分别对应 Logcat 输出与 Disk 保存。</p><p>4.1、AndroidLogAdapter 部分代码：</p><pre><code class="Java">public class AndroidLogAdapter implements LogAdapter {  @NonNull private final FormatStrategy formatStrategy;  public AndroidLogAdapter() {    this.formatStrategy = PrettyFormatStrategy.newBuilder().build();  }  public AndroidLogAdapter(@NonNull FormatStrategy formatStrategy) {    this.formatStrategy = checkNotNull(formatStrategy);  }  @Override public boolean isLoggable(int priority, @Nullable String tag) {    return true;  }  @Override public void log(int priority, @Nullable String tag, @NonNull String message) {    formatStrategy.log(priority, tag, message);  }}</code></pre><p>很明显只是对是否打印日志进行了控制，其他任务由 PrettyFormatStrategy 来做。</p><p>4.2、PrettyFormatStrategy 部分代码：</p><p>首先 PrettyFormatStrategy 使用 Builder 设计模式，从前面 AndroidLogAdapter 的构造函数中也可看出来。</p><pre><code class="Java">  public static class Builder {    int methodCount = 2;    int methodOffset = 0;    boolean showThreadInfo = true;    @Nullable LogStrategy logStrategy;    @Nullable String tag = &quot;PRETTY_LOGGER&quot;;    private Builder() {    }    @NonNull public Builder methodCount(int val) {      methodCount = val;      return this;    }    @NonNull public Builder methodOffset(int val) {      methodOffset = val;      return this;    }    @NonNull public Builder showThreadInfo(boolean val) {      showThreadInfo = val;      return this;    }    @NonNull public Builder logStrategy(@Nullable LogStrategy val) {      logStrategy = val;      return this;    }    @NonNull public Builder tag(@Nullable String tag) {      this.tag = tag;      return this;    }    @NonNull public PrettyFormatStrategy build() {      if (logStrategy == null) {        logStrategy = new LogcatLogStrategy();      }      return new PrettyFormatStrategy(this);    }  }</code></pre><p>这样就可以对打印的日志进行配置了，也就是前面进阶使用里面的内容。</p><p>下面来看具体打印的实现：</p><pre><code class="Java">  @Override public void log(int priority, @Nullable String onceOnlyTag, @NonNull String message) {    checkNotNull(message);    String tag = formatTag(onceOnlyTag);    logTopBorder(priority, tag);    logHeaderContent(priority, tag, methodCount);    //get bytes of message with system&#39;s default charset (which is UTF-8 for Android)    byte[] bytes = message.getBytes();    int length = bytes.length;    if (length &lt;= CHUNK_SIZE) {      if (methodCount &gt; 0) {        logDivider(priority, tag);      }      logContent(priority, tag, message);      logBottomBorder(priority, tag);      return;    }    if (methodCount &gt; 0) {      logDivider(priority, tag);    }    for (int i = 0; i &lt; length; i += CHUNK_SIZE) {      int count = Math.min(length - i, CHUNK_SIZE);      //create a new String with system&#39;s default charset (which is UTF-8 for Android)      logContent(priority, tag, new String(bytes, i, count));    }    logBottomBorder(priority, tag);  }  private void logTopBorder(int logType, @Nullable String tag) {    logChunk(logType, tag, TOP_BORDER);  }  @SuppressWarnings(&quot;StringBufferReplaceableByString&quot;)  private void logHeaderContent(int logType, @Nullable String tag, int methodCount) {    StackTraceElement[] trace = Thread.currentThread().getStackTrace();    if (showThreadInfo) {      logChunk(logType, tag, HORIZONTAL_LINE + &quot; Thread: &quot; + Thread.currentThread().getName());      logDivider(logType, tag);    }    String level = &quot;&quot;;    int stackOffset = getStackOffset(trace) + methodOffset;    //corresponding method count with the current stack may exceeds the stack trace. Trims the count    if (methodCount + stackOffset &gt; trace.length) {      methodCount = trace.length - stackOffset - 1;    }    for (int i = methodCount; i &gt; 0; i--) {      int stackIndex = i + stackOffset;      if (stackIndex &gt;= trace.length) {        continue;      }      StringBuilder builder = new StringBuilder();      builder.append(HORIZONTAL_LINE)          .append(&#39; &#39;)          .append(level)          .append(getSimpleClassName(trace[stackIndex].getClassName()))          .append(&quot;.&quot;)          .append(trace[stackIndex].getMethodName())          .append(&quot; &quot;)          .append(&quot; (&quot;)          .append(trace[stackIndex].getFileName())          .append(&quot;:&quot;)          .append(trace[stackIndex].getLineNumber())          .append(&quot;)&quot;);      level += &quot;   &quot;;      logChunk(logType, tag, builder.toString());    }  }  private void logBottomBorder(int logType, @Nullable String tag) {    logChunk(logType, tag, BOTTOM_BORDER);  }  private void logDivider(int logType, @Nullable String tag) {    logChunk(logType, tag, MIDDLE_BORDER);  }  private void logContent(int logType, @Nullable String tag, @NonNull String chunk) {    checkNotNull(chunk);    String[] lines = chunk.split(System.getProperty(&quot;line.separator&quot;));    for (String line : lines) {      logChunk(logType, tag, HORIZONTAL_LINE + &quot; &quot; + line);    }  }  private void logChunk(int priority, @Nullable String tag, @NonNull String chunk) {    checkNotNull(chunk);    logStrategy.log(priority, tag, chunk);  }</code></pre><p>这里就是对日志美化的核心了，但是最终每一行的输出还是不是在此，是由 LogcatLogStrategy 负责的。</p><p>4.3、LogcatLogStrategy 部分代码：</p><p>LogcatLogStrategy 负责打印每一行日志，当然已经美化过了。</p><pre><code class="Java">public class LogcatLogStrategy implements LogStrategy {  static final String DEFAULT_TAG = &quot;NO_TAG&quot;;  @Override public void log(int priority, @Nullable String tag, @NonNull String message) {    checkNotNull(message);    if (tag == null) {      tag = DEFAULT_TAG;    }    Log.println(priority, tag, message);  }}</code></pre><p>这里调用的是系统的 Log 方法逐行打印日志。</p><p>5.1、DiskLogAdapter 部分代码：</p><p>和 AndroidLogAdapter 类似，DiskLogAdapter 也只是负责控制是否打印日志，具体工作由 CsvFormatStrategy 实现。</p><pre><code class="Java">public class DiskLogAdapter implements LogAdapter {  @NonNull private final FormatStrategy formatStrategy;  public DiskLogAdapter() {    formatStrategy = CsvFormatStrategy.newBuilder().build();  }  public DiskLogAdapter(@NonNull FormatStrategy formatStrategy) {    this.formatStrategy = checkNotNull(formatStrategy);  }  @Override public boolean isLoggable(int priority, @Nullable String tag) {    return true;  }  @Override public void log(int priority, @Nullable String tag, @NonNull String message) {    formatStrategy.log(priority, tag, message);  }}</code></pre><p>5.2、CsvFormatStrategy 部分代码：</p><p>CsvFormatStrategy 处理后的日志要保存到文件，同样使用 Builder 设计模式：</p><p>我们来看下 build() 方法：</p><pre><code class="Java">@NonNull public CsvFormatStrategy build() {    if (date == null) {        date = new Date();    }    if (dateFormat == null) {        dateFormat = new SimpleDateFormat(&quot;yyyy.MM.dd HH:mm:ss.SSS&quot;, Locale.UK);    }    if (logStrategy == null) {        String diskPath = Environment.getExternalStorageDirectory().getAbsolutePath();        String folder = diskPath + File.separatorChar + &quot;logger&quot;;        HandlerThread ht = new HandlerThread(&quot;AndroidFileLogger.&quot; + folder);        ht.start();        Handler handler = new DiskLogStrategy.WriteHandler(ht.getLooper(), folder, MAX_BYTES);        logStrategy = new DiskLogStrategy(handler);    }    return new CsvFormatStrategy(this);}</code></pre><p>可以看到文件保存位置为 外置空间根目录 logger 文件夹下。</p><p>由 HandlerThread 启动了一个子线程，HandlerThread 实际上还是一个普通的 Thread，不过内部实现了 Looper 循环。</p><p>具体实现主要涉及字符串的拼接、格式的调整：</p><pre><code class="Java">  @Override public void log(int priority, @Nullable String onceOnlyTag, @NonNull String message) {    checkNotNull(message);    String tag = formatTag(onceOnlyTag);    date.setTime(System.currentTimeMillis());    StringBuilder builder = new StringBuilder();    // machine-readable date/time    builder.append(Long.toString(date.getTime()));    // human-readable date/time    builder.append(SEPARATOR);    builder.append(dateFormat.format(date));    // level    builder.append(SEPARATOR);    builder.append(Utils.logLevel(priority));    // tag    builder.append(SEPARATOR);    builder.append(tag);    // message    if (message.contains(NEW_LINE)) {      // a new line would break the CSV format, so we replace it here      message = message.replaceAll(NEW_LINE, NEW_LINE_REPLACEMENT);    }    builder.append(SEPARATOR);    builder.append(message);    // new line    builder.append(NEW_LINE);    logStrategy.log(priority, tag, builder.toString());  }  @Nullable private String formatTag(@Nullable String tag) {    if (!Utils.isEmpty(tag) &amp;&amp; !Utils.equals(this.tag, tag)) {      return this.tag + &quot;-&quot; + tag;    }    return this.tag;  }</code></pre><p>最终还是由 DiskLogStrategy 来负责打印输出日志。</p><p>5.3、DiskLogStrategy 部分代码：</p><p>这里使用了 Handler 实现线程间的通信：</p><pre><code class="Java">  @NonNull private final Handler handler;  public DiskLogStrategy(@NonNull Handler handler) {    this.handler = checkNotNull(handler);  }  @Override public void log(int level, @Nullable String tag, @NonNull String message) {    checkNotNull(message);    // do nothing on the calling thread, simply pass the tag/msg to the background thread    handler.sendMessage(handler.obtainMessage(level, message));  }</code></pre><p>每次有新的日志，调用 handler.sendMessage() 方法。</p><pre><code class="Java">@SuppressWarnings(&quot;checkstyle:emptyblock&quot;)@Override public void handleMessage(@NonNull Message msg) {    String content = (String) msg.obj;    FileWriter fileWriter = null;    File logFile = getLogFile(folder, &quot;logs&quot;);    try {    fileWriter = new FileWriter(logFile, true);    writeLog(fileWriter, content);    fileWriter.flush();    fileWriter.close();    } catch (IOException e) {    if (fileWriter != null) {        try {        fileWriter.flush();        fileWriter.close();        } catch (IOException e1) { /* fail silently */ }    }    }}</code></pre><p>最后 Handler 接收到消息，就把日志保存到文件中。</p><blockquote><p>Logger 源码分析就到这里了，作者代码写得很优雅，也非常感谢作者向开源社区贡献如此优秀的库。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Android 开发过程中打印日志必不可少，Logger 就是一款优秀的 Android 开源日志库。&lt;/p&gt;&lt;p&gt;Logger 使用简单，输出日志美观高效，支持 JSON 、XML 格式输出，支持打印 Arrays 、Collections 等对象。&lt;/p&gt;&lt;p&gt;Lo
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Logger" scheme="https://www.wshunli.com/tags/Logger/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Flutter开发环境与入门</title>
    <link href="https://www.wshunli.com/posts/a72058f7.html"/>
    <id>https://www.wshunli.com/posts/a72058f7.html</id>
    <published>2018-05-21T13:56:28.000Z</published>
    <updated>2018-06-05T09:20:28.117Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter 是 Google 的移动应用程序 SDK，用于在 iOS 和 Android 上构建高质量的原生界面。 Flutter 与现有的代码一起工作，被全世界的开发者和组织使用，并且是免费和开源的。</p><p>本文介绍在 Windows 环境下 Flutter 环境的搭建及入门。</p><p>1、获取 Flutter SDK</p><p>可以从下载页面获取 Flutter SDK： <a href="https://flutter.io/sdk-archive/#windows" rel="external nofollow noopener noreferrer" target="_blank">https://flutter.io/sdk-archive/#windows</a> .</p><p>将压缩包解压到合适位置，比如本文解压到 ：<code>D:\Android\flutter</code> .</p><p>然后双击文件夹下 <code>flutter_console.bat</code> 文件即可。</p><p>2、设置环境变量</p><p>将 <code>flutter\bin</code> 目录加到系统环境变量 Path 中。</p><p>如本文的目录就是：<code>D:\Android\flutter\bin</code> .</p><p>3、运行 flutter doctor</p><p>在命令行中运行 <code>flutter doctor</code> 可以检查 flutter 插件及依赖安装情况。</p><p>4、Android 环境</p><p>Android 环境安装配置就不多介绍了。</p><p>在 Android Studio 安装 Flutter 、Dart 两个插件就可以直接创建 Flutter 应用了。</p><p>创建过程也基本上和普通 Android 应用差别不大。</p><p>本文源代码：<a href="https://github.com/wshunli/flutter_demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/flutter_demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flutter 是 Google 的移动应用程序 SDK，用于在 iOS 和 Android 上构建高质量的原生界面。 Flutter 与现有的代码一起工作，被全世界的开发者和组织使用，并且是免费和开源的。&lt;/p&gt;&lt;p&gt;本文介绍在 Windows 环境下 Flutter 环
      
    
    </summary>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Flutter" scheme="https://www.wshunli.com/tags/Flutter/"/>
    
      <category term="跨平台" scheme="https://www.wshunli.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>《设计模式之禅》读书笔记</title>
    <link href="https://www.wshunli.com/posts/ed1425c1.html"/>
    <id>https://www.wshunli.com/posts/ed1425c1.html</id>
    <published>2018-05-21T09:43:14.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式也是比较欠缺的一方面，这次看的是 《设计模式之禅》 ，前面看了一点 《Head First 设计模式》感觉都是图片有点乱。</p><h1 id="第一部分-设计原则"><a href="#第一部分-设计原则" class="headerlink" title="第一部分 设计原则"></a>第一部分 设计原则</h1><p>单一职责原则：应该有且仅有一个原因引起类的变更，对于接口设计时要做到单一职责。</p><p>里氏替换原则：只要有父类出现的地方，替换为子类也不会产生任何问题或异常。<br>　　<br>依赖倒置原则：模块间的依赖关系是通过接口或抽象类产生的（面向接口编程）。</p><p>接口隔离原则：客户不应该依赖它不需要的接口；类间的依赖关系应建立在最小的接口上；尽量使用多个专门的接口。</p><p>迪米特法则：一个对象应对其他对象有最少的了解；只和直接朋友交流，朋友间也是有距离的；一个方法中尽量不引入类中不存在的对象；减少 public 方法和属性。</p><p>开闭原则：对扩展开放，对修改关闭；通过扩展来实现变化；不允许出现接口或抽象方法中不存在的 public 方法。</p><h1 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分 设计模式"></a>第二部分 设计模式</h1><p>设计模式根据目的可以分为三大类，分别是 <strong>创建型设计模式、行为型设计模式以及结构型设计模式</strong> 。</p><p><strong>创建型模式</strong> 涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解藕。</p><p>单例模式(Singleton)<br>构建模式(Builder)<br>原型模式(Prototype)<br>抽象工厂模式(Abstract Factory)<br>工厂方法模式(Factory Method)</p><p><strong>行为型模式</strong> 涉及到类和对象如何交互及分配职责。</p><p>策略模式(Strategy)<br>状态模式(State)<br>责任链模式(Chain of Responsibility)<br>解释器模式(Interpreter)<br>命令模式(Command)<br>观察者模式(Observer)<br>备忘录模式(Memento)<br>迭代器模式(Iterator)<br>模板方法模式(Template Method)<br>访问者模式(Visitor)<br>中介者模式(Mediator)</p><p><strong>结构型模式</strong> 可以让你把类或对象组合到更大的结构中。</p><p>装饰者模式(Decorator)<br>代理模式(Proxy)<br>组合模式(Composite)<br>桥连接模式(Bridge)<br>适配器模式(Adapter)<br>蝇量模式(Flyweight)<br>外观模式(Facade)</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>单例模式的其他几种实现方式：</p><p>1、饿汉模式</p><pre><code class="Java">public class Singleton {    private static final Singleton instance = new Singleton();    private Singleton() {    }    public static Singleton getInstance() {        return instance;    }}</code></pre><p>2、懒汉模式：</p><pre><code class="Java">public class Singleton {    private static Singleton instance;    private Singleton() {    }    public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>3、懒汉模式、线程安全：</p><pre><code class="Java">public class Singleton {    private static Singleton instance;    private Singleton() {    }    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>4、双检锁/双重校验锁（DCL，即 double-checked locking）</p><pre><code class="Java">public class Singleton {    private volatile static Singleton instance;    private Singleton() {    }    public static Singleton getInstance() {        if (instance == null) {            synchronized (Singleton.class) {                if (instance == null) {                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><p>单例模式 | 菜鸟教程：<br><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/singleton-pattern.html</a></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂模式（Factory Pattern）定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>未完待续。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式也是比较欠缺的一方面，这次看的是 《设计模式之禅》 ，前面看了一点 《Head First 设计模式》感觉都是图片有点乱。&lt;/p&gt;&lt;h1 id=&quot;第一部分-设计原则&quot;&gt;&lt;a href=&quot;#第一部分-设计原则&quot; class=&quot;headerlink&quot; title=&quot;第一
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>中兴事件，比罚单更沉重的反思</title>
    <link href="https://www.wshunli.com/posts/8cba90ed.html"/>
    <id>https://www.wshunli.com/posts/8cba90ed.html</id>
    <published>2018-05-20T08:59:46.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>分享下《工程伦理》的 PPT ，不是最终的版本，后来又修改了。</p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片1.PNG" alt="幻灯片1"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片2.PNG" alt="幻灯片2"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片3.PNG" alt="幻灯片3"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片4.PNG" alt="幻灯片4"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片5.PNG" alt="幻灯片5"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片6.PNG" alt="幻灯片6"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片7.PNG" alt="幻灯片7"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片8.PNG" alt="幻灯片8"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片9.PNG" alt="幻灯片9"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片10.PNG" alt="幻灯片10"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片11.PNG" alt="幻灯片11"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片12.PNG" alt="幻灯片12"></p><p><img src="https://img.wshunli.com/胡思乱想/ZTE/幻灯片13.PNG" alt="幻灯片13"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享下《工程伦理》的 PPT ，不是最终的版本，后来又修改了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.wshunli.com/胡思乱想/ZTE/幻灯片1.PNG&quot; alt=&quot;幻灯片1&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.wshunl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>唯代码与爱不可辜负</title>
    <link href="https://www.wshunli.com/posts/d51d2546.html"/>
    <id>https://www.wshunli.com/posts/d51d2546.html</id>
    <published>2018-05-20T05:14:00.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>唯代码与爱不可辜负</p><p>认真做技术，永远做极客</p><p>愿往后有房有车有姑娘 能吹能闹能干架 纵情豁达</p><p>愿今后能哭能笑能随性 敢爱敢恨敢追逐 干净明亮</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;唯代码与爱不可辜负&lt;/p&gt;&lt;p&gt;认真做技术，永远做极客&lt;/p&gt;&lt;p&gt;愿往后有房有车有姑娘 能吹能闹能干架 纵情豁达&lt;/p&gt;&lt;p&gt;愿今后能哭能笑能随性 敢爱敢恨敢追逐 干净明亮&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》读书笔记</title>
    <link href="https://www.wshunli.com/posts/7eb96b02.html"/>
    <id>https://www.wshunli.com/posts/7eb96b02.html</id>
    <published>2018-05-17T04:53:59.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>Java 虚拟机也是需要学习的一块内容 ，这次选择的书籍是 《深入理解Java虚拟机：JVM高级特性与最佳实践》。</p><p>Java 虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。 JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><blockquote align="center">第一部分 走进 Java</blockquote><h1 id="第一章-走进-Java"><a href="#第一章-走进-Java" class="headerlink" title="第一章 走进 Java"></a>第一章 走进 Java</h1><p>主要介绍了 Java 的历史、现在和未来的发展趋势。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/Java技术体系.png" alt="Java技术体系"></p><p align="center">Java 技术体系</p><blockquote align="center">第二部分 自动内存管理机制</blockquote><h1 id="第二章-Java-内存区域与内存溢出异常"><a href="#第二章-Java-内存区域与内存溢出异常" class="headerlink" title="第二章 Java 内存区域与内存溢出异常"></a>第二章 Java 内存区域与内存溢出异常</h1><p>本章介绍 Java 虚拟机内存的各个区域的作用、服务对象及其可能出现的问题。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/Java虚拟机运行时数据区.png" alt="Java虚拟机运行时数据区"></p><p>1、程序计数器</p><p>当前线程所执行的字节码的行号指示器。</p><p>唯一一个没有规定任何 OOM 情况的区域。</p><p>2、Java 虚拟机栈</p><p>虚拟机栈描述的是 Java 方法执行的内存模型。</p><p>每个方法在执行的同时都会创建一个栈帧(Stack Frame)（指向堆的地址）用于存储局部变量表、操作数栈、动态连接、方法出口等信息<br>每个方法从调用直至执行完成的过程==&gt;一个栈帧在虚拟机栈中入栈到出栈的过程</p><p>3、本地方法栈</p><p>本地方法栈为虚拟机使用到的 Native 方法服务。</p><p>4、Java 堆</p><p>所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。</p><p>5、方法区</p><p>各线程共享内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p><strong>运行时常量池</strong>：</p><p>运行时常量池是方法区的一部分。</p><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p><strong>直接内存</strong>：</p><p>不是虚拟机运行时数据区的一部分，也与 Java 虚拟机规范中定义的内存区域无关。</p><p>基于通道(Channel)与缓冲区(Buffer)的I/O方式。</p><p>它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。<br>这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><p>Java虚拟机运行时数据区-学习记录-51CTO博客：<br><a href="http://blog.51cto.com/turnsole/2057198" rel="external nofollow noopener noreferrer" target="_blank">http://blog.51cto.com/turnsole/2057198</a></p><h2 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h2><p>本节主要介绍了对象的创建、内存布局及访问定位的问题。</p><h2 id="OutOfMemoryError-异常"><a href="#OutOfMemoryError-异常" class="headerlink" title="OutOfMemoryError 异常"></a>OutOfMemoryError 异常</h2><p>在 Java 虚拟机规范的描述中，除程序计数器外，虚拟机内存的其他几个运行区域都有可能发生 OOM 异常。</p><h1 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h1><p>前面介绍了 Java 内存运行时各区域，其中程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊得执行者出栈和入栈操作。而每个栈帧分配的内存基本确定，内存的分配和回收也就确定了，方法结束或者线程结束后，内存自然就跟着回收了。</p><p>而 <strong>Java 堆和方法区</strong> 不一样，这部分的内训分配和回收都是动态的，所以垃圾收集器主要关注的指这部分内容。</p><h2 id="对象是否存活"><a href="#对象是否存活" class="headerlink" title="对象是否存活"></a>对象是否存活</h2><p>垃圾收集器在对堆进行回收前，应该确定对象是否存活。</p><p>（1）引用计数法</p><p>给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加 1，当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。</p><p>引用计数法很难解决对象之间的相互循环引用问题。</p><pre><code class="Java">ReferenceCountingGC objA = new ReferenceCountingGC();ReferenceCountingGC objB = new ReferenceCountingGC();objA.instance = objB;objB.instance = objA;objA = null;objB = null;// 假设在这行发生GC，objA和objB是否能被回收？System.gc();</code></pre><p>上述代码，当方法运行完成后，对象就不能再被访问，可是 objA &lt;&gt; objB 循环引用着。</p><p>而 Java 垃圾收集器会回收内存，所以 Java 虚拟机不是通过引用计数器来判断对象是否存活的。</p><p>（2）可达性分析算法</p><p>通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。</p><p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</p><p>1、虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>2、方法区中类静态属性引用的对象。<br>3、方法区中常量引用的对象。<br>4、本地方法栈中JNI（即一般说的Native方法）引用的对象。</p><p>（3）对象引用</p><p>Java 对象引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4中，这 4 中引用强度异常逐渐减弱。</p><p>1、强引用就是指在程序代码之中普遍存在的，类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，来及收集器永远不会回收掉被引用的对象。</p><p>2、软引用是用来描述一些还在用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。</p><p>3、弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论是当前内存是否足够，都会回收掉只被若引用关联的对象。在 JDK1.2 之后，提供了 WeakReference 类来实现弱引用。</p><p>4、虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间过长影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，在 JDK1.2 之后，提供了 PhantomReference 类来实现虚引用。</p><p>（4）对象的回收的两次标记过程</p><p>在可达性分析算法中不可达的对象被回收，要警告过两次标记过程：</p><p>1、第一次标记的同时会进行一次筛选，筛选此对象是否有必要执行 finalize() 方法。</p><p>当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>2、如果有必要执行 finalize() 方法，此对象会放到 F-Queue 队列中，稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。</p><p>对象只要在 finalize() 方法中重新与引用链上的任何一个对象建立关联即可避免被回收。</p><pre><code class="java">/** * 此代码演示了两点：  * 1.对象可以在被GC时自我拯救。  * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次 */public class FinalizeEscapeGC {    public static FinalizeEscapeGC SAVE_HOOK = null;    public void isAlive() {        System.out.println(&quot;yes, i am still alive :)&quot;);    }    @Override    protected void finalize() throws Throwable {        super.finalize();        System.out.println(&quot;finalize mehtod executed!&quot;);        FinalizeEscapeGC.SAVE_HOOK = this;    }    public static void main(String[] args) throws Throwable {        SAVE_HOOK = new FinalizeEscapeGC();        //对象第一次成功拯救自己        SAVE_HOOK = null;        System.gc();        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它        Thread.sleep(500);        if (SAVE_HOOK != null) {            SAVE_HOOK.isAlive();        } else {            System.out.println(&quot;no, i am dead :(&quot;);        }        // 下面这段代码与上面的完全相同，但是这次自救却失败了        SAVE_HOOK = null;        System.gc();        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它        Thread.sleep(500);        if (SAVE_HOOK != null) {            SAVE_HOOK.isAlive();        } else {            System.out.println(&quot;no, i am dead :(&quot;);        }    }}</code></pre><p>注意，finalize() 方法只会被系统自动调用一次。</p><p>（5）回收方法区</p><p>方法区垃圾收集主要回收两部分：废弃常量和无用的类。</p><p>对于常量，没有任何对象引用常量池中的常量，虚拟机就可以把常量清出常量池。</p><p>对于类，同时满足以下三个条件才能算是 “无用的类”：</p><p>1、该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。<br>2、加载该类的 ClassLoader 已经被回收。<br>3、该类对应的 java.lang.Class 对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。</p><p>虚拟机 <strong>可以</strong> 对满足上述3个条件的无用类进行回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>（1）标记 — 清除算法（Mark-Sweep）</p><p>首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集算法1.png" alt="垃圾收集算法1"></p><p>它的主要不足有两个：<br>1、效率问题，标记和清除两个过程的效率都不高；<br>2、标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序中运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p>（2）复制算法（Copying）</p><p>将可用内存按容量划分为大小相等的两块，每次只是用其中的一块，当这一块的内存用完了，就将存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集算法2.png" alt="垃圾收集算法2"></p><p>现在的商业虚拟机都采用这种收集算法来回收 <strong>新生代</strong> ，新生代的对象98%是“朝生夕死”的，所以并不需要按照 1:1 比例来划分内存空间。</p><p>（3）标记 — 整理算法（Mark-Compact）</p><p>“标记-整理”算法，标记过程任然与“标记-清理”算法一样，但后续步骤不是直接可对回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集算法3.png" alt="垃圾收集算法3"></p><p>（4）分代收集算法（Generational Collection）</p><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，一般是 Java 堆分成新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>在新生代中，每次垃圾收集时都发现有大批量的对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成手机。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p><p>Java虚拟机内存分配策略 | hua的博客：<br><a href="http://www.zhangrenhua.com/2016/11/09/Java虚拟机内存分配策略/" rel="external nofollow noopener noreferrer" target="_blank">http://www.zhangrenhua.com/2016/11/09/Java虚拟机内存分配策略/</a></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集器就是内存回收的具体实现。新生代的垃圾回收器包括 Serial、ParNew、Parallel Scavenge，老年代的垃圾回收器包括 CMS、Serial Old、Parallel Old。其中新生代的三种垃圾回收器都采用了复制算法。</p><center><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集器.png" alt="垃圾收集器"></center><p>1、Serial 收集器</p><p>Serial 收集器是一个单线程收集器，这个“单线程”不只是说它只会使用一个 CPU 或者一条线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它垃圾收集结束。它对于运行在 client 模式下的虚拟机来说是一个不错的选择。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集器1.png" alt="垃圾收集器1"></p><p>2、ParNew 收集器</p><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，由于除了 Serial 收集器外，只有它能够与 CMS 收集器配合工作，因此，在运行在 Server 模式下的虚拟机中，ParNew 收集器是首选的新生代收集器。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集器2.png" alt="垃圾收集器2"></p><p>3、Parallel Scavenge 收集器</p><p>Parallel Scavenge 收集器也是一个并行的新生代垃圾收集器，不同于其他收集器（以尽可能缩短垃圾收集时用户线程的停顿时间为目的），它是唯一一个以达到一个可控制的吞吐量为目标的垃圾收集器。</p><p>吞吐量 = 运行用户代码的时间 / 总时间（垃圾收集时间＋运行用户代码的时间）。</p><p>在后台运算的任务中，不需要太多的交互，保证运行的高吞吐量可以高效地利用CPU时间，尽快完成程序的运算任务。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集器3.png" alt="垃圾收集器3"></p><p>4、Serial Old 收集器</p><p>Serial Old 收集器是 Serial 收集器的老年代版本，同样是单线程的收集器，使用标记–整理算法对老年代垃圾进行回收。</p><p>它主要的两大用途：1. 配合 Parallel Scavenge 收集器；2. 作为 CMS 收集器在并发收集出现 Concurrent Mode Failure 时使用的后备预案。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集器4.png" alt="垃圾收集器4"></p><p>5、Parallel Old 收集器</p><p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理算法。</p><p>在注重吞吐量和 CPU 资源敏感的场合，优先考虑使用 Parallel Scavenge + Parallel Old 收集器的组合，切记 Parallel Scavenge 是无法与 CMS 收集器组合使用的。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集器5.png" alt="垃圾收集器5"></p><p>6、Concurrent Mark Sweep 收集器</p><p>CMS 收集器是一款并发收集器，是一种以获取最短回收停顿时间为目标的收集器，它是基于标记–清除算法实现的。</p><p>它整个过程包含四个有效的步骤：</p><p>1) 初始标记（CMS initial mark）<br>2) 并发标记（CMS concurrent mark）<br>3) 重新标记（CMS remark）<br>4) 并发清除（CMS concurrent sweep）</p><p>CMS的主要优点是并发收集、低停顿，也称之为并发收集低停顿收集器（Concurrent Low Pause Collector）。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/垃圾收集器6.png" alt="垃圾收集器6"></p><p>7、 G1 收集器</p><p>G1 基于“标记–整理”算法实现，不会产生空间碎片，对于长时间运行的应用系统来说非常重要；另外它可以非常精准地控制停顿，既能让使用者指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><p>G1 收集器可以实现在基本不牺牲吞吐的前提下完成低停顿的内存回收，这是由于它能够避免全区域的垃圾回收，而 G1 将 Java 堆（包括新生代、老生代）划分成多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的由来）。</p><p>JVM（二）垃圾收集算法与收集器 – charles：<br><a href="http://alicharles.com/article/jvm-gc/" rel="external nofollow noopener noreferrer" target="_blank">http://alicharles.com/article/jvm-gc/</a></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>Java 技术体系中所提倡的自动内存管理最终可归结为自动化解决两个问题：给对象分配内存以及回收分配给对象的内存。</p><p>1、对象优先分配在 Eden 区</p><p>大多数情况下，对象首先会被分配到新生代 Eden 区，当 Eden 区满了，会触发一次 Minor GC 。</p><p>2、大对象直接进入老年区</p><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的 byte[] 数组就是典型的大对象）。</p><p>虚拟机提供了一个 -XX：PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p><p>3、长期存活的对象进入老年区</p><p>对象在 Survivor 区中每“熬过”一次 Minor GC ，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p><p>对象晋升老年代的年龄阈值，可以通过参数 -XX：MaxTenuringThreshold 设置。</p><p>4、动态对象年龄的判断</p><p>虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p><p>5、空间分配担保</p><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。</p><p>如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。</p><p>如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC ，尽管这次 Minor GC 是有风险的，如果担保失败则会进行一次 Full GC ；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC 。</p><p>读《深入理解Java虚拟机》 - 轩宇一页 - 博客园：<br><a href="http://www.cnblogs.com/zhouxuanyu/p/6942417.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/zhouxuanyu/p/6942417.html</a></p><p>本章介绍了垃圾收集的算法、垃圾收集器的特点及运作原理、Java 虚拟机中的自动内存分配与回收机制。</p><h1 id="第四章-虚拟机性能监控与故障处理工具"><a href="#第四章-虚拟机性能监控与故障处理工具" class="headerlink" title="第四章 虚拟机性能监控与故障处理工具"></a>第四章 虚拟机性能监控与故障处理工具</h1><p>本章介绍了一些命令行及可视化的故障处理工具。</p><h1 id="第五章-调优案例分析与实战"><a href="#第五章-调优案例分析与实战" class="headerlink" title="第五章 调优案例分析与实战"></a>第五章 调优案例分析与实战</h1><p>本章介绍了一些案例及调优方法。</p><blockquote align="center">第三部分 虚拟机执行子系统</blockquote><h1 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h1><p>Sun 公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现“一次编写，到处运行”。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/语言无关性2.png" alt="语言无关性"></p><p>Java Class文件结构如下图所示:</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/Class文件结构.png" alt="Class文件结构"></p><p>对于以下 Java 源文件代码:</p><pre><code class="Java">public class Main {    public static void main(String[] args) {        System.out.println(&quot;Hello World!&quot;);    }}</code></pre><p>生成的类文件字节码为:</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/Java字节码.png" alt="Java字节码"></p><p>JVM（四）类文件结构解析 – charles:<br><a href="http://alicharles.com/article/jvm-class/" rel="external nofollow noopener noreferrer" target="_blank">http://alicharles.com/article/jvm-class/</a></p><h1 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h1><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 java 类型，这就是虚拟机的类加载机制。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括以下7个阶段：加载，验证，准备，解析，初始化，使用，卸载。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/类的生命周期2.png" alt="类的生命周期"></p><p>其中加载，验证，准备，初始化，卸载这5个阶段的顺序是确定。而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的运行时绑定（也称为动态绑定或晚期绑定）。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>类加载的过程也就是类加载机制，分为 加载，验证，准备，解析，初始化 这 5 个阶段。</p><p>1、加载</p><p>“加载”是“类加载”过程中的一个阶段。在加载阶段，虚拟机会做 3 件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>2、验证</p><p>验证是连接阶段的第一步。目的是确保 Class 文件的字节流中包含的信息不会危害到虚拟机自身的安全。</p><p>包含：文件格式验证，元数据验证，字节码验证，符号引用验证。</p><p>3、准备</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p><p>其中初始值“通常情况下”是数据类型的零值。</p><p>4、解析</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用和直接引用的关联如下：</p><p>符号引用（Symbol References）： 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的 Class 文件格式中。</p><p>直接引用（Direct References）： 直接引用可以是直接目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在。</p><p>5、初始化</p><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p><p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源，简单说，初始化阶段即虚拟机执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p>下面来详细讲解<code>&lt;clinit&gt;()</code>方法是怎么生成的，首先来了解此方法执行过程中可能会影响到程序运行行为的特点和细节：</p><p>1) <code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（ <code>static{}</code> 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p><pre><code class="Java">public class Test {    static {        i = 0;  // 给变量复制可以正常编译通过        System.out.print(i);  // 这句编译器会提示“非法向前引用”      }    static int i = 1;}</code></pre><p>2) <code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器 <code>&lt;init&gt;()</code> 方法）不同，不需要显式的调用父类的()方法。虚拟机会自动保证在子类的<code>&lt;clinit&gt;()</code>方法运行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行结束。因此虚拟机中第一个执行<code>&lt;clinit&gt;()</code>方法的类肯定为java.lang.Object。</p><p>3) 由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</p><pre><code class="Java">static class Parent {        public static int A = 1;        static {            A = 2;        }}static class Sub extends Parent {        public static int B = A;}public static void main(String[] args) {        System.out.println(Sub.B);//输出结果是父类中的静态变量值A，也就是2}</code></pre><p>4) <code>&lt;clinit&gt;()</code>方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成<code>&lt;clinit&gt;()</code>方法。<br>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的</p><p>5) <code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p><p>6) 虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的<code>&lt;clinit&gt;()</code>方法，其它线程都会阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。</p><p>深入理解JVM(5)——虚拟机类加载机制 - 王泽远的博客 | Crow’s Blog :<br><a href="https://crowhawk.github.io/2017/08/21/jvm_5/" rel="external nofollow noopener noreferrer" target="_blank">https://crowhawk.github.io/2017/08/21/jvm_5/</a></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责，通过一个类的全限定类名来获取描述此类的二进制字节流。</p><p>对于任意一个类，都需要由他的类加载器和这个类本身共同确立其在 Java 虚拟机中的唯一性。</p><pre><code class="Java">package com.wshunli.jvm.demo;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest {    public static void main(String[] args) throws Exception {        ClassLoader myLoader = new ClassLoader() {            @Override            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {                try {                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;                    InputStream is = getClass().getResourceAsStream(fileName);                    if (is == null) {                        return super.loadClass(name);                    }                    byte[] b = new byte[is.available()];                    is.read(b);                    return defineClass(name, b, 0, b.length);                } catch (IOException e) {                    throw new ClassNotFoundException(name);                }            }        };        Object obj = myLoader.loadClass(&quot;com.wshunli.jvm.demo.ClassLoaderTest&quot;).newInstance();        System.out.println(obj.getClass());        System.out.println(obj instanceof com.wshunli.jvm.demo.ClassLoaderTest);    }}/* * class com.wshunli.jvm.demo.ClassLoaderTest * false */</code></pre><p>每一个类加载器，都拥有一个独立的类名称空间。简言之，比较两个类是否“相等”只有在这两个类是由同一个类加载器加载的前提下才有意义。</p><p>（1）双亲委派模型</p><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：</p><p>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；<br>另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p><p>从Java开发人员的角度来看，有三种类加载器：</p><p><strong>启动类加载器</strong> (Bootstrap ClassLoader)：负责加载<code>&lt;JAVA_HOME&gt;\lib</code>目录或者由参数 -Xbootclasspath 指定路径中并且是虚拟机识别的类库加载到虚拟机内存中。</p><p><strong>扩展类加载器</strong> (Extension ClassLoader)：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中或者被 java.ext.dirs 系统变量指定路径中所有的类库。</p><p><strong>应用程序加载器</strong> (Application ClassLoader)：负责加载由 CLASSPATH 指定的类库，如果程序没有自定义类加载器，程序默认使用该加载器。</p><p>类加载器的双亲委派模型：</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/类加载器2.png" alt="类加载器"></p><p><strong>双亲委派模型的工作过程是</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p>实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法之中，实现如下：</p><pre><code class="Java">protected Class&lt;?&gt; loadClass(String name, boolean resolve)        throws ClassNotFoundException    {        synchronized (getClassLoadingLock(name)) {            // First, check if the class has already been loaded            Class&lt;?&gt; c = findLoadedClass(name);            if (c == null) {                long t0 = System.nanoTime();                try {                    if (parent != null) {                        c = parent.loadClass(name, false);                    } else {                        c = findBootstrapClassOrNull(name);                    }                } catch (ClassNotFoundException e) {                    // ClassNotFoundException thrown if class not found                    // from the non-null parent class loader                }                if (c == null) {                    // If still not found, then invoke findClass in order                    // to find the class.                    long t1 = System.nanoTime();                    c = findClass(name);                    // this is the defining class loader; record the stats                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    sun.misc.PerfCounter.getFindClasses().increment();                }            }            if (resolve) {                resolveClass(c);            }            return c;        }    }</code></pre><p><strong>双亲委派模型的实现逻辑</strong>：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的findClass() 方法进行加载。</p><h1 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h1><p>本章从虚拟机字节码执行引擎的概念模型角度来介绍虚拟机方法调用和字节码执行。</p><h2 id="运行时帧栈结构"><a href="#运行时帧栈结构" class="headerlink" title="运行时帧栈结构"></a>运行时帧栈结构</h2><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。</p><p>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。</p><p>每一个方法从调用开始到执行完成的过程都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/运行时栈帧结构.png" alt="运行时栈帧结构"></p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，暂时还不涉及方法内部的具体运行过程。</p><p>按照调用方式共分为两类：</p><p><strong>解析调用</strong> 是静态的过程，在编译期间就完全确定目标方法。</p><p><strong>分派调用</strong> 即可能是静态，也可能是动态的，根据分派标准可以分为单分派和多分派。两两组合有形成了静态单分派、静态多分派、动态单分派、动态多分派。</p><p>（1）解析</p><p>所有方法调用中的目标方法在 Class 文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。</p><p>（2）分派</p><p>1、静态分派</p><p>所有依赖静态类型3来定位方法执行版本的分派成为静态分派，发生在编译阶段，典型应用是方法重载。</p><p>2、动态分派</p><p>在运行期间根据实际类型4来确定方法执行版本的分派成为动态分派，发生在程序运行期间，典型的应用是方法的重写。</p><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p>Java 编译器输入的指令流基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。</p><p>另外一种指令集架构则是基于寄存器的指令集架构，典型的应用是 x86 的二进制指令集，比如传统的 PC 以及 Android 的 Davlik 虚拟机。</p><p>两者之间最直接的区别是：<br>基于栈的指令集架构不需要硬件的支持，而基于寄存器的指令集架构则完全依赖硬件，<br>这意味基于寄存器的指令集架构执行效率更高，单可移植性差，而基于栈的指令集架构的移植性更高，但执行效率相对较慢，除此之外，相同的操作，基于栈的指令集往往需要更多的指令。</p><h1 id="第九章-类加载级执行子系统的案例及实战"><a href="#第九章-类加载级执行子系统的案例及实战" class="headerlink" title="第九章 类加载级执行子系统的案例及实战"></a>第九章 类加载级执行子系统的案例及实战</h1><p>本章主要介绍了类加载器和字节码的案例。</p><blockquote align="center">第四部分 程序编译与代码优化</blockquote><h1 id="第十章-早期（编译器）优化"><a href="#第十章-早期（编译器）优化" class="headerlink" title="第十章 早期（编译器）优化"></a>第十章 早期（编译器）优化</h1><h1 id="第十一章-晚期（运行器）优化"><a href="#第十一章-晚期（运行器）优化" class="headerlink" title="第十一章 晚期（运行器）优化"></a>第十一章 晚期（运行器）优化</h1><p>第四部分主要介绍了 Java 源程序从源代码编译成字节码和从字节码编译成本地机器码的过程，从 javac 字节码编译器到虚拟机内的 JIT 编译器执行过程合并起来其实就等同于一个传统编译器所执行的编译工程。</p><blockquote align="center">第五部分 高效并发</blockquote><h1 id="Java-内存模型与线程"><a href="#Java-内存模型与线程" class="headerlink" title="Java 内存模型与线程"></a>Java 内存模型与线程</h1><p>Java 虚拟机规范试图定义一种内存模型 （Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，实现 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。</p><p>此处的变量与 Java 编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。</p><p><img src="https://img.wshunli.com/Java/深入理解Java虚拟机/jvm_memory_thread2.png" alt="Java内存模型"></p><p>Java 内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如图所示。</p><p>(1) 内存间交互操作</p><p>一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，JMM 定义了一下八种操作来完成：</p><ul><li>lock（锁定）：作用域主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存变量，它变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行 read 和 load 操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间，store 和 write 之间是可以插入其他指令的，如对主内存中的变量 a、b 进行访问时，可能的顺序是 read a，read b，load b， load a。</p><p>Java 内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>不允许 read 和 load、store 和 write 操作之一单独出现，如不允许从主内存读取了但工作内存不接受</li><li>不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</li><li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，lock 和 unlock 必须成对出现。</li><li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行 load 或 assign 操作初始化变量的值</li><li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作；也不允许去 unlock 一个被其他线程锁定的变量。</li><li>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）。</li></ul><p>深入理解JVM之高效并发 - 倔强的荔枝：<br><a href="http://wanglizhi.github.io/2016/07/16/JVM-JMM-And-Thread/" rel="external nofollow noopener noreferrer" target="_blank">http://wanglizhi.github.io/2016/07/16/JVM-JMM-And-Thread/</a></p><p>(2) 对于volatile型变量的特殊规则</p><p>使用 volatile 变量可以保证线程之间的可见性，再者禁止指令重排序优化。</p><p>由于 volatile 变量只能保证可见性，在 <strong>不符合</strong> 以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li><li>变量不需要与其他状态变量共同参与不变约束</li></ul><p>(3) 对于long和double型变量的特殊规则</p><p>JVM 规范允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行。</p><p>但是各种虚拟机实现几乎把 64 位数据的读写作为原子操作来对待。</p><p>(4) 原子性、可见性和有序性</p><p>原子性（Atomicity）：大致认为基本数据类型的访问读写是具备原子性的。JMM 提供 lock 和 unlock 保证原子性，对应代码中的 synchronized 关键字。</p><p>可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile 保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新。除了volatile外，synchronized 和 final 两个关键字也能实现可见性，其中同步块是有 lock 和 unloc k机制决定的，而 final 关键字一旦初始化完成，其他线程就能看见 final 字段的值。</p><p>有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程内观察另一个线程，所有操作都是无序的。Java 提供了 volatile 和synchronized 关键字来保证线程之间操作的有序性。</p><p>(5) 先行发生原则</p><p>先行发生原则：如果操作 A 先发生于操作 B，操作 A 产生的影响能被操作 B 观察到，“影响”包括：修改了内存中共享变量的值、发送了消息、调用了方法。</p><ul><li>程序次序规则：写在程序签名的操作先行发生于书写在后面的操作</li><li>管程锁定规则：一个 unlock 操作先行发生于后面对 <strong>同一个锁</strong> 的 lock 操作</li><li>volatile变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</li><li>线程启动规则：Thread 对象的 start 方法先行发生于此线程的每一个动作</li><li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测</li><li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>对象终结规则：一个对象初始化完成先行发生于它的 finalize 方法的开始</li><li>传递性：如果操作 A 先于操作 B，操作 B 先行于操作 C，那么操作A先行发生于操作 C</li></ul><h2 id="Java-与线程"><a href="#Java-与线程" class="headerlink" title="Java 与线程"></a>Java 与线程</h2><p>（1）线程的实现</p><p>实现线程主要有三种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级混合线程实现。</p><p>（2）Java 线程调度</p><p>线程调剂是指系统为线程分配处理器使用权过程：协同式线程调度、抢占式线程调度。</p><p>协同式调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完后，要主动通知系统切换到另一个线程上去。</p><p>抢占式调度：每个线程由系统来分配执行时间，线程切换不由线程本身来决定。Java 使用的就是抢占式调度。</p><p>Java 一种设置了 10 个级别的线程优先级，在两个线程同时处于 Ready 状态时，优先级越高的线程越容易被系统选择执行。但是并不是太靠谱，优先级可能会被系统自行改变。</p><p>（3）线程状态转换</p><p>Java 语言定义了六种线程状态。</p><ol><li><p>新建（New）：创建后尚未启动的线程处于这种状态。</p></li><li><p>运行（Runable）：包括了操作系统线程状态中的 Running 和 Ready，可能正在执行，也可能等待着CPU为它分配执行时间。</p></li><li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其他线程显式地唤醒。</p></li><li><p>限期等待（Timed Waiting）：处于这种状态也不会被分配 CPU 执行时间，在一定时间之后它们由系统自动唤醒。</p></li><li><p>阻塞（Blocked）：在等待获取一个排它锁，这个时间将在另外一个小城放弃这个锁的时候发生；在等待进入同步区域的时候。</p></li><li><p>结束（Terminated）：已终止线程的线程状态。</p></li></ol><p>深入理解Java虚拟机——高效并发 - CSDN博客：<br><a href="https://blog.csdn.net/hanxueyu666/article/details/53729491" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hanxueyu666/article/details/53729491</a></p><h1 id="第十三章-线程安全与锁优化"><a href="#第十三章-线程安全与锁优化" class="headerlink" title="第十三章 线程安全与锁优化"></a>第十三章 线程安全与锁优化</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>当多个线程接见一个对象时，若不考虑这些线程在运行时环境下的调度和交替执行，也不须要进行额外的同步，或者调用方进行任何其他的协调操纵，调用这个对象的行动都可以获得正确的成果，那这个对象就是线程安全的。</p><p>线程安全强弱分成五类：</p><p>1、不可变：只要一个不可变的对象被正确地构建出来。</p><p>应用 final 关键字修饰的基本数据类型；若是共享数据是一个对象，那就须要保证对象的行动不会对其状况产生任何影响（String 类的对象）。</p><p>办法：把对象中带有状况的变量都申明为 final ，如 Integer 类。除 String 以外还有列举类型、Number 的部分子类（AtomicInteger 和 AtomicLong 除外）。</p><p>2、绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施。大部分 Java API 都不是绝对的线程安全。</p><p>3、相对线程安全：它需要包成对这个对象单独的操作时线程安全的，对于一些特定的顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><p>4、线程兼容：对象本身并不是线程安全的，需要经由过程调用规矩确地应用同步手段来保证对象在并发环境中安全地应用。</p><p>5、线程对立：不管调用端是否采取了同步措施，都无法在多线程环境中并发应用的代码。</p><p>如：Thread 类的 suspend() 和 resume() 方法，System.setIn（）、System.setOut（）、System.runFinalizersOnExit（）。</p><p><strong>线程安全的实现方法</strong>：</p><p>1、互斥同步</p><p>互斥同步（Mutual Exclusion &amp; Synchronization）是最常见的一种并发正确性保障手段，同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。</p><p>2、非阻塞同步</p><p>互斥同步主要问题是进行现场阻塞和唤醒的性能问题，这种同步称为阻塞同步，另外它属于一种悲观的并发策略，总是认为不加锁肯定会出问题。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗讲就是先进行操作，没有冲突就成功，有冲突就进行补偿（如重试直到成功），这种乐观的并发策略成为非阻塞同步。</p><p>3、无同步方案</p><p>要保证线程安全，并不一定要进行同步，如果一个方法不涉及共享数据，那它就无须任何同步措施去保证正确性。</p><p><strong>可重入代码</strong>（Reentrant Code）：也叫做纯代码，可以在代码执行的任何时刻中断它，转而执行另一段代码，返回后不会出现任何错误。可重入代码有一些共同的特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态都由参数传入、不调用非可重入的方法等。</p><p><strong>线程本地存储</strong>（Thread Local Storage）：把共享数据的可见范围限制在同一个线程内，无须同步，如：经典Web交互模型中的”一个请求对应一个服务器线程“的处理方式。java.lang.ThreadLocal 类来实现线程本地存储的功能，每个线程的 Thread 对象都有一个 ThreadLocalMap 对象，以 threadLocalHashCode 为键，以本地线程变量为值。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>本部分介绍了一些锁优化的技术，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。</p><blockquote><p>本书也看完了，只是选择了比较重要的部分仔细阅读，其他的都是大概浏览一遍，后面有机会再读加深理解。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 虚拟机也是需要学习的一块内容 ，这次选择的书籍是 《深入理解Java虚拟机：JVM高级特性与最佳实践》。&lt;/p&gt;&lt;p&gt;Java 虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。 JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年春季中国银联实习生面试</title>
    <link href="https://www.wshunli.com/posts/60f1f107.html"/>
    <id>https://www.wshunli.com/posts/60f1f107.html</id>
    <published>2018-05-14T06:24:49.000Z</published>
    <updated>2018-06-05T09:20:28.129Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码（unionpay）查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码（unionpay）查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【密码公开】记录2018年春中国银联暑期实习生面试（系统与应用开发）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>我本将心向明月，奈何明月照沟渠</title>
    <link href="https://www.wshunli.com/posts/2739df62.html"/>
    <id>https://www.wshunli.com/posts/2739df62.html</id>
    <published>2018-05-08T06:06:23.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<p>我本将心向明月，奈何明月照沟渠，<br>落花有意随流水，流水无心恋落花。</p><p>简历初筛未通过，笔试机会都没有。</p><p>滴，好人卡。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我本将心向明月，奈何明月照沟渠，&lt;br&gt;落花有意随流水，流水无心恋落花。&lt;/p&gt;&lt;p&gt;简历初筛未通过，笔试机会都没有。&lt;/p&gt;&lt;p&gt;滴，好人卡。。&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Java多线程编程核心技术》读书笔记</title>
    <link href="https://www.wshunli.com/posts/4e70966b.html"/>
    <id>https://www.wshunli.com/posts/4e70966b.html</id>
    <published>2018-05-05T14:47:09.000Z</published>
    <updated>2018-06-05T09:20:28.121Z</updated>
    
    <content type="html"><![CDATA[<p>前面面试什么的多线程部分问的比较多，需要加强下，这里记录总结 《Java多线程编程核心技术》 读书情况。</p><h1 id="第一章-Java-多线程技能"><a href="#第一章-Java-多线程技能" class="headerlink" title="第一章 Java 多线程技能"></a>第一章 Java 多线程技能</h1><p>本章主要介绍了线程概念、核心方法以及优先级。</p><p>1、进程和线程的区别</p><p><strong>进程</strong>是受操作系统管理的基本运行单元，是系统进行资源分配和调度的独立单位。<br><strong>线程</strong>是在进程中独立运行的子任务，CPU 在这些任务之间不停地切换，各子任务共享程序的内存空间。</p><p>线程和进程的区别是什么？ - 知乎：<br><a href="https://www.zhihu.com/question/25532384" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/25532384</a></p><p>2、线程的创建</p><p>（1）继承 <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.html" rel="external nofollow noopener noreferrer" target="_blank">Thread</a> 类</p><p>（2）实现 <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Runnable.html" rel="external nofollow noopener noreferrer" target="_blank">Runnable</a> 接口</p><p>其中 Thread 类实现了 Runable 接口，都需要重写里面 run 方法。</p><p>两种方式的区别：</p><p>实现 Runnable 的类更具有健壮性，避免了单继承的局限。<br>Runnable 更容易实现资源共享，能多个线程同时处理一个资源。</p><p>Java中 Thread和Runnable实现多线程的区别和联系 - CSDN博客:<br><a href="https://blog.csdn.net/oxuanboy1/article/details/51733279" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/oxuanboy1/article/details/51733279</a></p><p><strong>非线程安全</strong> 主要是指多个线程对同一对象中的同一变量实例进行操作时会出现值被修改、值不同步的现象。</p><p>3、线程的启动和停止</p><p>线程的启动可以使用 start() 或者 run() 方法，</p><p>调用 start() 方法，虚拟机会创建新的线程运行 run 方法；<br>调用 run() 方法后，会在调用的线程执行，不会创建新的线程。</p><p>线程的终止方法有三种：</p><p>（1）使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>（2）使用 stop() 方法强行终止线程（这个方法不推荐使用，因为 stop() 和 suspend()、resume() 一样，也可能发生不可预料的结果）。<br>（3）使用 interrupt() 方法中断线程。</p><p>下面介绍了 interrupt() 方法停止线程，调用该方法知识在当前线程中打了一个停止的标记，并不是真的停止线程。</p><p>如何判断线程的状态是不是停止的：</p><p>（1）this.interrupted() 测试 <strong>当前线程</strong> 是否已经中断，会将状态标志置清为 false 。</p><pre><code class="Java">public static boolean interrupted() {}</code></pre><p>（2）this.isInterrupted() 测试线程是否已经中断，不清除状态标志。</p><pre><code class="Java">public boolean isInterrupted() {}</code></pre><p>Java并发（基础知识）—— 创建、运行以及停止一个线程 - Tim-Tom - 博客园：<br><a href="https://www.cnblogs.com/timlearn/p/4007982.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/timlearn/p/4007982.html</a></p><p>其他方法 stop()、suspend()、resume() 不推荐使用。</p><p>4、线程的主要方法</p><p>Thread.currentThread() 返回代码段正在被哪个线程调用的信息。</p><p>isAlive() 判断当前线程是否处于活动状态，即线程已经启动但尚未终止。</p><pre><code class="Java">package com.wshunli.thread;public class CountOperate extends Thread{    public CountOperate(){        System.out.println(&quot;CountOperate---begin&quot;);        System.out.println(&quot;Thread.currentThread().getName()=&quot; + Thread.currentThread().getName());//获取线程名        System.out.println(&quot;Thread.currentThread().isAlive()=&quot; + Thread.currentThread().isAlive()); //查看线程是否存活        System.out.println(&quot;this.getName=&quot; + this.getName());        System.out.println(&quot;this.isAlive()=&quot; + this.isAlive());        System.out.println(&quot;CountOperate---end &quot;);        System.out.println(&quot;Thread.currentThread()==this :&quot;+ (Thread.currentThread() == this));    }    @Override    public void run() {        System.out.println(&quot;run---begin&quot;);        System.out.println(&quot;Thread.currentThread().getName=&quot; + Thread.currentThread().getName());        System.out.println(&quot;Thread.currentThread().isAlive()&quot; + Thread.currentThread().isAlive());        System.out.println(&quot;Thread.currentThread()==this :&quot;+ (Thread.currentThread() == this));        System.out.println(&quot;this.getName()=&quot; + this.getName());        System.out.println(&quot;this.isAlive()=&quot; + this.isAlive());        System.out.println(&quot;run --- end&quot;);    }}package com.wshunli.thread;public class Main {    public static void main(String[] args) {        CountOperate c = new CountOperate();//        c.start();        Thread t1 = new Thread(c);        System.out.println(&quot;main begin t1 isAlive=&quot; + t1.isAlive());        t1.setName(&quot;A&quot;);        t1.start();        System.out.println(&quot;main end t1 isAlive=&quot; + t1.isAlive());    }}/* * CountOperate---begin * Thread.currentThread().getName()=main * Thread.currentThread().isAlive()=true * this.getName=Thread-0 * this.isAlive()=false * CountOperate---end * Thread.currentThread()==this :false * main begin t1 isAlive=false * main end t1 isAlive=true * run---begin * Thread.currentThread().getName=A * Thread.currentThread().isAlive()true * Thread.currentThread()==this :false * this.getName()=Thread-0 * this.isAlive()=false * run --- end */</code></pre><p>Thread.sleep() 方法是在指定的毫秒数内让“当前正在执行的线程”休眠（暂停执行）。</p><p>yield() 放弃当前 CPU 资源，将它让给其他任务占用 CPU 时间。</p><p>5、线程的优先级</p><p>在 Java 中线程的优先级分为 1 ~ 10 这 10 个等级，可以使用 setPriority​(int newPriority) 方法设置。</p><p>优先级较高的线程得到的 CPU 资源较多，CPU 会尽量优先执行，并不一定先执行完。</p><p>线程的优先级具有继承性。</p><p>6、守护线程</p><p>在 java 中线程有两种：用户线程、守护线程。</p><p>守护线程的作用是为其他线程提供便利服务，当进程中不存在非守护线程了，守护线程会自动销毁。</p><p>守护线程最典型的应用就是 GC （垃圾回收器）。</p><h1 id="第二章-对象及变量的并发访问"><a href="#第二章-对象及变量的并发访问" class="headerlink" title="第二章 对象及变量的并发访问"></a>第二章 对象及变量的并发访问</h1><h2 id="synchronized-同步方法"><a href="#synchronized-同步方法" class="headerlink" title="synchronized 同步方法"></a>synchronized 同步方法</h2><p>（1）方法内的变量线程安全，而 <strong>实例变量</strong> 非线程安全。</p><p>（2）多个对象多个锁</p><p>关键字 synchronized 取得的锁都是对象锁，而不是把方法或者代码段当作锁。</p><pre><code class="Java">class HasSelfPrivateNum {    public void addI(String username) {        try {            int num = 0;            if (username.equals(&quot;a&quot;)) {                num = 100;                System.out.println(&quot;a set over!&quot;);                Thread.sleep(2000);            } else {                num = 200;                System.out.println(&quot;b set over!&quot;);            }            System.out.println(username + &quot; num=&quot; + num);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}class ThreadA extends Thread {    private HasSelfPrivateNum numRef;    public ThreadA(HasSelfPrivateNum numRef) {        super();        this.numRef = numRef;    }    @Override    public void run() {        super.run();        numRef.addI(&quot;a&quot;);    }}class ThreadB extends Thread {    private HasSelfPrivateNum numRef;    public ThreadB(HasSelfPrivateNum numRef) {        super();        this.numRef = numRef;    }    @Override    public void run() {        super.run();        numRef.addI(&quot;b&quot;);    }}class Main {    public static void main(String[] args) {        HasSelfPrivateNum numRef = new HasSelfPrivateNum();        ThreadA athread = new ThreadA(numRef);        athread.start();        ThreadB bthread = new ThreadB(numRef);        bthread.start();    }}/* * a set over! * b set over! * b num=200 * a num=100 */</code></pre><p>对于多个对象实例，会有多个对象锁，所以还是异步的、互不影响。</p><p>（3）synchronized 方法与对象锁</p><p>调用 synchronized 声明的方法是排队同步执行的。</p><p>把 HasSelfPrivateNum 类的 addI() 方法添加 synchronized 关键字，输出就变为：</p><pre><code class="java">class HasSelfPrivateNum {    synchronized public void addI(String username) {        try {            int num = 0;            if (username.equals(&quot;a&quot;)) {                num = 100;                System.out.println(&quot;a set over!&quot;);                Thread.sleep(2000);            } else {                num = 200;                System.out.println(&quot;b set over!&quot;);            }            System.out.println(username + &quot; num=&quot; + num);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}/* * a set over! * a num=100 * b set over! * b num=200 */</code></pre><p>上面多个线程调用同一方法，下面再看调用 <strong>不同方法</strong> 的情况。</p><pre><code class="java">class MyObject {    synchronized public void methodA() {        try {            System.out.println(&quot;begin methodA threadName=&quot;                    + Thread.currentThread().getName());            Thread.sleep(5000);            System.out.println(&quot;end endTime=&quot; + System.currentTimeMillis());        } catch (InterruptedException e) {            e.printStackTrace();        }    }    synchronized public void methodB() {        try {            System.out.println(&quot;begin methodB threadName=&quot;                    + Thread.currentThread().getName() + &quot; begin time=&quot;                    + System.currentTimeMillis());            Thread.sleep(5000);            System.out.println(&quot;end&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}class ThreadA extends Thread {    private MyObject object;    public ThreadA(MyObject object) {        super();        this.object = object;    }    @Override    public void run() {        super.run();        object.methodA();    }}class ThreadB extends Thread {    private MyObject object;    public ThreadB(MyObject object) {        super();        this.object = object;    }    @Override    public void run() {        super.run();        object.methodB();    }}public class Main {    public static void main(String[] args) {        MyObject object = new MyObject();        ThreadA a = new ThreadA(object);        a.setName(&quot;A&quot;);        ThreadB b = new ThreadB(object);        b.setName(&quot;B&quot;);        a.start();        b.start();    }}/* * begin methodA threadName=A * end endTime=1526043906998 * begin methodB threadName=B begin time=1526043906998 * end */</code></pre><p>修改下 methodB() 方法，去除 synchronized 关键字。</p><pre><code class="Java">class MyObject {    synchronized public void methodA() {        try {            System.out.println(&quot;begin methodA threadName=&quot;                    + Thread.currentThread().getName());            Thread.sleep(5000);            System.out.println(&quot;end endTime=&quot; + System.currentTimeMillis());        } catch (InterruptedException e) {            e.printStackTrace();        }    }    public void methodB() {        try {            System.out.println(&quot;begin methodB threadName=&quot;                    + Thread.currentThread().getName() + &quot; begin time=&quot;                    + System.currentTimeMillis());            Thread.sleep(5000);            System.out.println(&quot;end&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}/* * begin methodA threadName=A * begin methodB threadName=B begin time=1526044084533 * end * end endTime=1526044089534 */</code></pre><p>由此可见：</p><p>A 线程先持有 object 对象锁，B 线程可以以异步方式调用 object 对象中的 <strong>非 synchronized 类型</strong> 的方法。<br>A 线程先持有 object 对象锁，B 线程如果在这时调用 object 对中的 <strong>synchronized 类型</strong> 的方法则需等待，也就是同步。</p><p>（4）脏读</p><p>脏读（dirtyRead）即赋值时进行了同步，但在取值时已经被其他线程修改过了。</p><p>跟上例类似，在方法上加 synchronized 关键字可以解决脏读问题。</p><p>（5）synchronized 锁重入</p><p>synchronized 具有锁重入功能，也就说当一个线程获得对象锁之后，再次请求此对象锁可以再次得到该对象的锁。</p><pre><code class="Java">public class Service {    synchronized public void service1() {        System.out.println(&quot;service1&quot;);        service2();    }    synchronized public void service2() {        System.out.println(&quot;service2&quot;);        service3();    }    synchronized public void service3() {        System.out.println(&quot;service3&quot;);    }}</code></pre><p>可重入锁的概念：自己可以再次获取自己的内部锁。假如说不可锁重入的话，线程一直等待释放对象锁，而对象锁自己拥有，就会造成死锁。</p><p><strong>可重入锁</strong> 也支持在父子类继承的环境中，即子类可以通过重入锁调用父类的同步方法。</p><p>（6）当线程执行的代码出现异常时，其所持有的锁会自动释放。</p><p>（7）同步不可以继承。</p><pre><code class="Java">class Super {    synchronized public void serviceMethod() {        try {            System.out.println(&quot;int main 下一步 sleep begin threadName=&quot;                    + Thread.currentThread().getName() + &quot; time=&quot;                    + System.currentTimeMillis());            Thread.sleep(5000);            System.out.println(&quot;int main 下一步 sleep   end threadName=&quot;                    + Thread.currentThread().getName() + &quot; time=&quot;                    + System.currentTimeMillis());        } catch (InterruptedException e) {            e.printStackTrace();        }    }}class Sub extends Super {    @Override    public void serviceMethod() {        try {            System.out.println(&quot;int sub 下一步 sleep begin threadName=&quot;                    + Thread.currentThread().getName() + &quot; time=&quot;                    + System.currentTimeMillis());            Thread.sleep(5000);            System.out.println(&quot;int sub 下一步 sleep   end threadName=&quot;                    + Thread.currentThread().getName() + &quot; time=&quot;                    + System.currentTimeMillis());            super.serviceMethod();        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}class MyThreadA extends Thread {    private Sub sub;    public MyThreadA(Sub sub) {        super();        this.sub = sub;    }    @Override    public void run() {        sub.serviceMethod();    }}class MyThreadB extends Thread {    private Sub sub;    public MyThreadB(Sub sub) {        super();        this.sub = sub;    }    @Override    public void run() {        sub.serviceMethod();    }}public class Main {    public static void main(String[] args) {        Sub subRef = new Sub();        MyThreadA a = new MyThreadA(subRef);        a.setName(&quot;A&quot;);        a.start();        MyThreadB b = new MyThreadB(subRef);        b.setName(&quot;B&quot;);        b.start();    }}/* * int sub 下一步 sleep begin threadName=A time=1526046246540 * int sub 下一步 sleep begin threadName=B time=1526046246540 * int sub 下一步 sleep   end threadName=A time=1526046251541 * int sub 下一步 sleep   end threadName=B time=1526046251541 * int main 下一步 sleep begin threadName=A time=1526046251541 * int main 下一步 sleep   end threadName=A time=1526046256541 * int main 下一步 sleep begin threadName=B time=1526046256541 * int main 下一步 sleep   end threadName=B time=1526046261542 */</code></pre><p>子类方法添加 synchronized 关键字。</p><pre><code class="Java">class Sub extends Super {    @Override    synchronized public void serviceMethod() {        try {            System.out.println(&quot;int sub 下一步 sleep begin threadName=&quot;                    + Thread.currentThread().getName() + &quot; time=&quot;                    + System.currentTimeMillis());            Thread.sleep(5000);            System.out.println(&quot;int sub 下一步 sleep   end threadName=&quot;                    + Thread.currentThread().getName() + &quot; time=&quot;                    + System.currentTimeMillis());            super.serviceMethod();        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}/* * int sub 下一步 sleep begin threadName=A time=1526046197787 * int sub 下一步 sleep   end threadName=A time=1526046202787 * int main 下一步 sleep begin threadName=A time=1526046202787 * int main 下一步 sleep   end threadName=A time=1526046207788 * int sub 下一步 sleep begin threadName=B time=1526046207788 * int sub 下一步 sleep   end threadName=B time=1526046212789 * int main 下一步 sleep begin threadName=B time=1526046212789 * int main 下一步 sleep   end threadName=B time=1526046217790 */</code></pre><p>由此可见：重写父类的同步方法并不能同步，还是要加 synchronized 关键字才行。</p><h2 id="synchronized-同步语句块"><a href="#synchronized-同步语句块" class="headerlink" title="synchronized 同步语句块"></a>synchronized 同步语句块</h2><p>（1）synchronized 同步语句块的使用</p><p>当两个线程同时访问同一对象 object 中的 synchronized (this) 同步代码块时，一段时间内只能有一个线程被执行，另一个线程要等这个线程执行完以后才能执行。</p><p>（2）用同步代码块解决同步方法的弊端</p><p>同步方法的弊端是有时候执行时间会比较长。</p><pre><code class="Java">// 使用同步方法public class Task {    private String getData1;    private String getData2;    public synchronized void doLongTimeTask() {        try {            System.out.println(&quot;begin task&quot;);            Thread.sleep(3000);            getData1 = &quot;长时间处理任务后从远程返回的值1 threadName=&quot;                    + Thread.currentThread().getName();            getData2 = &quot;长时间处理任务后从远程返回的值2 threadName=&quot;                    + Thread.currentThread().getName();            System.out.println(getData1);            System.out.println(getData2);            System.out.println(&quot;end task&quot;);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}// 使用同步代码块public class Task {    private String getData1;    private String getData2;    public void doLongTimeTask() {        try {            System.out.println(&quot;begin task&quot;);            Thread.sleep(3000);            String privateGetData1 = &quot;长时间处理任务后从远程返回的值1 threadName=&quot;                    + Thread.currentThread().getName();            String privateGetData2 = &quot;长时间处理任务后从远程返回的值2 threadName=&quot;                    + Thread.currentThread().getName();            synchronized (this) {                getData1 = privateGetData1;                getData2 = privateGetData2;            }            System.out.println(getData1);            System.out.println(getData2);            System.out.println(&quot;end task&quot;);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><p>其实也就是在耗时部分是异步执行的，从而缩短了代码的执行时长。</p><p>当一个线程访问 同步代码块 时，另一个线程仍然可以访问该对象的非同步代码块。即在 synchronized 块中就是同步执行，不在 synchronized 块中时异步执行。</p><p>（3）synchronized 代码块之间的同步性</p><p>在使用 synchronized (this) 代码块时，当线程访问 object 的一个 synchronized (this) 代码块时，其他线程对同一 object 中所有 synchronized (this) 同步代码块的访问将阻塞。</p><p>和 synchronized 方法一样，synchronized (this) 代码块也是锁定 <strong>当前对象</strong> 的。其他对象访问同一 object 中的 synchronized 方法也会阻塞。</p><p>（4）将任意对象作为对象监视器</p><p>多个线程调用同一个对象中的不同名称的 synchronized 同步方法或 synchronized(this) 同步代码块时，调用的效果就是按顺序执行，也就是 <strong>同步的，阻塞的</strong> 。</p><p>这说明 synchronized 同步方法或 synchronized(this) 同步代码块分别有 <strong>两种作用</strong> ：</p><ul><li>synchronized 同步 <strong>方法</strong><ul><li>对其他 synchronized 同步方法或 synchronized(this) 同步代码块呈阻塞状态。</li><li>同一时间只有一个线程可以执行 synchronized 同步方法中的代码。</li></ul></li><li>synchronized(this) 同步 <strong>代码块</strong><ul><li>对其他 synchronized 同步方法或 synchronized(this) 同步代码块呈阻塞状态。</li><li>同一时间只有一个线程可以执行 synchronized(this) 同步代码块中的代码。</li></ul></li></ul><p>类似，对于 synchronized(非this对象) 同步代码块：</p><p>当多个线程持有 “对象监视器” 为同一个对象的前提下，同一时间只有一个线程可以执行 synchronized(非this对象x) 同步代码块中的代码。</p><pre><code class="java">public class Service {    private String usernameParam;    private String passwordParam;    public void setUsernamePassword(String username, String password) {        try {            String anyString = new String();            synchronized (anyString) {                System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                        + &quot;在&quot; + System.currentTimeMillis() + &quot;进入同步块&quot;);                usernameParam = username;                Thread.sleep(3000);                passwordParam = password;                System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                        + &quot;在&quot; + System.currentTimeMillis() + &quot;离开同步块&quot;);            }        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><p>而多个线程持有的 “对象监视器” 不是同一对象时，还是异步执行的。</p><pre><code class="Java">public class Service {    private String anyString = new String();    public void a() {        try {            synchronized (anyString) {                System.out.println(&quot;a begin&quot;);                Thread.sleep(3000);                System.out.println(&quot;a   end&quot;);            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }    synchronized public void b() {        System.out.println(&quot;b begin&quot;);        System.out.println(&quot;b   end&quot;);    }}</code></pre><p>站在多个线程角度，多个线程调用同一方法先后顺序是随机的，只是对于单个线程而言，在同步方法/代码块内部是同步的。</p><p>（5）静态 synchronized 方法与 synchronized(class) 代码块</p><p>对于静态的 synchronized 方法，是对当前 Class 类进行封锁。<br>对于非静态 synchronized 方法，是对当前 对象 的封锁。</p><p>二者是不同的锁，但是 Class 锁可以对所有对象实例起作用。</p><pre><code class="Java">package com.wshunli.thread.sync5;class Service {    synchronized public static void printA() {        try {            System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                    + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printA&quot;);            Thread.sleep(3000);            System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                    + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printA&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    synchronized public static void printB() {        System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot;                + System.currentTimeMillis() + &quot;进入printB&quot;);        System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot;                + System.currentTimeMillis() + &quot;离开printB&quot;);    }}class ThreadA extends Thread {    private Service service;    public ThreadA(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.printA();    }}class ThreadB extends Thread {    private Service service;    public ThreadB(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.printB();    }}public class Main {    public static void main(String[] args) {        Service service1 = new Service();        Service service2 = new Service();        ThreadA a = new ThreadA(service1);        a.setName(&quot;A&quot;);        a.start();        ThreadB b = new ThreadB(service2);        b.setName(&quot;B&quot;);        b.start();    }}/* * 线程名称为：A在1526136864655进入printA * 线程名称为：A在1526136867656离开printA * 线程名称为：B在1526136867656进入printB * 线程名称为：B在1526136867656离开printB */</code></pre><p>同步 synchronized(class) 代码块的作用其实和 synchronized static 方法的作用一样。</p><pre><code class="Java">class Service {    public static void printA() {        synchronized (Service.class) {            try {                System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                        + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printA&quot;);                Thread.sleep(3000);                System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                        + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printA&quot;);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void printB() {        synchronized (Service.class) {            System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                    + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printB&quot;);            System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName()                    + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printB&quot;);        }    }}/* * 线程名称为：A在1526137124491进入printA * 线程名称为：A在1526137127492离开printA * 线程名称为：B在1526137127492进入printB * 线程名称为：B在1526137127492离开printB */</code></pre><p>（6）数据类型 String 的常量池特性</p><p>对于 synchronized(<strong>string</strong>) 同步块，string 值为相同 String 常量时，两个线程持有相同的锁。</p><p>所以在大多数情况下，synchronized 代码块不使用 String 作为锁对象。</p><p>（7）多线程的死锁</p><p>不同的线程都在等待根本不可能释放的锁，从而导致所有任务都无法继续完成。</p><p>线程互相持有对方的锁，然后等待对方释放锁就有可能出现死锁。</p><p>（8）内置类与静态内置类</p><p>对于内置类中有两个同步方法，只要是使用不同的锁，多线程还是异步的。</p><p>对于两个内置类 class1 class2 ，class1 中使用 synchronized(<strong>class2</strong>) 同步代码块时，其他线程只能以同步方式调用 class2 中的 synchronized 同步方法</p><p>（9）锁对象的改变</p><p>再将任何数据作为同步锁时，只需判断多线程是否同时持有相同的锁对象即可。</p><pre><code class="Java">class MyService {    private String lock = &quot;123&quot;;    public void testMethod() {        try {            synchronized (lock) {                System.out.println(Thread.currentThread().getName() + &quot; begin &quot;                        + System.currentTimeMillis());                lock = &quot;456&quot;;                Thread.sleep(2000);                System.out.println(Thread.currentThread().getName() + &quot;   end &quot;                        + System.currentTimeMillis());            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}class ThreadA extends Thread {    private MyService service;    public ThreadA(MyService service) {        super();        this.service = service;    }    @Override    public void run() {        service.testMethod();    }}class ThreadB extends Thread {    private MyService service;    public ThreadB(MyService service) {        super();        this.service = service;    }    @Override    public void run() {        service.testMethod();    }}public class Main {    public static void main(String[] args) throws InterruptedException {        MyService service = new MyService();        ThreadA a = new ThreadA(service);        a.setName(&quot;A&quot;);        ThreadB b = new ThreadB(service);        b.setName(&quot;B&quot;);        a.start();        Thread.sleep(50);        b.start();    }}/* * A begin 1526217990101 * B begin 1526217990151 * A   end 1526217992101 * B   end 1526217992151 */</code></pre><p>运行到线程 B 时，对象锁已经改变，所以是异步。</p><p>但是对于对象而言，只是改变对象的属性时不行的，运行结果还是同步的。</p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>关键字 volatile 的主要作用是使变量在多个线程间可见。</p><p>（1）关键字 volatile 与死循环</p><pre><code class="Java">class PrintString {    private boolean isContinuePrint = true;    public boolean isContinuePrint() {        return isContinuePrint;    }    public void setContinuePrint(boolean isContinuePrint) {        this.isContinuePrint = isContinuePrint;    }    public void printStringMethod() {        try {            while (isContinuePrint == true) {                System.out.println(&quot;run printStringMethod threadName=&quot;                        + Thread.currentThread().getName());                Thread.sleep(1000);            }        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}public class Run {    public static void main(String[] args) {        PrintString printStringService = new PrintString();        printStringService.printStringMethod();        System.out.println(&quot;我要停止它！ stopThread=&quot;                + Thread.currentThread().getName());        printStringService.setContinuePrint(false);    }}</code></pre><p>这个程序停不下来，主要原因是 main 线程一直在处理 while() 循环，导致程序不能继续执行。</p><p>我们可以使用多线程技术解决这个问题，在子线程中执行 while() 循环，这样主线程就能继续执行了。</p><pre><code class="Java">class PrintString implements Runnable {    private boolean isContinuePrint = true;    public boolean isContinuePrint() {        return isContinuePrint;    }    public void setContinuePrint(boolean isContinuePrint) {        this.isContinuePrint = isContinuePrint;    }    public void printStringMethod() {        try {            while (isContinuePrint == true) {                System.out.println(&quot;run printStringMethod threadName=&quot;                        + Thread.currentThread().getName());                Thread.sleep(1000);            }        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    @Override    public void run() {        printStringMethod();    }}public class Run {    public static void main(String[] args) {        PrintString printStringService = new PrintString();        new Thread(printStringService).start();        System.out.println(&quot;我要停止它！ stopThread=&quot;                + Thread.currentThread().getName());        printStringService.setContinuePrint(false);    }}</code></pre><p>但是这种在 <code>-server</code> 服务器模式下，还是会出现死循环。<br>主要是因为在服务器模式下，为了提高线程运行的效率，线程一致在私有堆栈中取得 <code>isContinuePrint</code> 的值为 true 。</p><p><img src="https://img.wshunli.com/Java/Java多线程编程核心技术/内存结构.png" alt="内存结构"></p><p>volatile 关键字增加了实例变量在多个线程之间的可见性，但不支持原子性。</p><p>也就是说同步私有堆栈中的值和公共堆栈中的值，强制从公共堆栈中进行取值，或者强制将值写入公共堆栈。</p><p><strong>synchronized 和 volatile 的比较</strong>：</p><p>1、关键字 volatile 是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 要好，并且 volatile 只能修饰变量，而 synchronized 可以修饰方法和代码块。目前在开发中使用 synchronized 关键字的比率还是比较大的。<br>2、多线程访问 volatile 不会发生阻塞，而 synchronized 会出现阻塞。<br>3、volatile 能保证数据的可见性，但是不能保证原子性；而 synchronized 可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公有内存中的数据同步。<br>4、volatile 关键字是解决变量在多个线程之间的可见性；而 synchronized 关键字是解决多个线程之间访问资源同步性的。</p><p>所谓的线程安全包含 <strong>原子性和可见性</strong> 两个方面，Java 的同步机制都是围绕这两个方面量保证线程安全的。</p><p>volatile和synchronized的区别 - CSDN博客:<br><a href="https://blog.csdn.net/suifeng3051/article/details/52611233" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/suifeng3051/article/details/52611233</a></p><p>（2）volatile 关键字的非原子性</p><p>（3）原子类</p><p>原子操作是不可分割的整体，没有其他线程能够中断或检查正在原子操作中的变量。</p><pre><code class="Java">import java.util.concurrent.atomic.AtomicInteger;public class AddCountThread extends Thread {    private AtomicInteger count = new AtomicInteger(0);    @Override    public void run() {        for (int i = 0; i &lt; 10000; i++) {            System.out.println(count.incrementAndGet());        }    }}</code></pre><p>一个原子（atomic）类型就是一个原子操作可用的类型，它可以在没有锁的情况下做到线程安全（thread-safe）。</p><p>注意方法之间的调用不是原子操作。</p><p>（4）synchronized 代码块具有 volatile 同步功能。</p><p>关键字 synchronized 可以使多个线程访问统一资源具有同步性，而且它还具有将线程内存中的私有变量与公共内存中的变量同步的功能。</p><h1 id="第三章-线程间通信"><a href="#第三章-线程间通信" class="headerlink" title="第三章 线程间通信"></a>第三章 线程间通信</h1><p>进程间通信使系统之间的交互性更强大，在大大提高 CPU 利用率的同时，还可以对个线程任务在处理的过程中进行有效的把控和监督。</p><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>（1）使用 wait/notify 实现进程间通信</p><p>java中等待通知机制（wait/notify） - CSDN博客：<br><a href="https://blog.csdn.net/joenqc/article/details/54981532" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/joenqc/article/details/54981532</a></p><p>wait() 和 notify() 需要在同步方法或者同步代码块中调用。</p><p>wait() 会使线程停止运行，而 notify() 使停止的线程继续运行。</p><pre><code class="Java">import java.util.ArrayList;import java.util.List;class MyList {    private static List list = new ArrayList();    public static void add() {        list.add(&quot;anyString&quot;);    }    public static int size() {        return list.size();    }}class ThreadA extends Thread {    private Object lock;    public ThreadA(Object lock) {        super();        this.lock = lock;    }    @Override    public void run() {        try {            synchronized (lock) {                if (MyList.size() != 5) {                    System.out.println(&quot;wait begin &quot;                            + System.currentTimeMillis());                    lock.wait();                    System.out.println(&quot;wait end  &quot;                            + System.currentTimeMillis());                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}class ThreadB extends Thread {    private Object lock;    public ThreadB(Object lock) {        super();        this.lock = lock;    }    @Override    public void run() {        try {            synchronized (lock) {                for (int i = 0; i &lt; 10; i++) {                    MyList.add();                    if (MyList.size() == 5) {                        lock.notify();                        System.out.println(&quot;已发出通知！&quot;);                    }                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);                    Thread.sleep(1000);                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}public class Main {    public static void main(String[] args){        try {            Object lock = new Object();            ThreadA a = new ThreadA(lock);            a.start();            Thread.sleep(50);            ThreadB b = new ThreadB(lock);            b.start();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}/* * wait begin 1526377675223 * 添加了1个元素! * 添加了2个元素! * 添加了3个元素! * 添加了4个元素! * 已发出通知！ * 添加了5个元素! * 添加了6个元素! * 添加了7个元素! * 添加了8个元素! * 添加了9个元素! * 添加了10个元素! * wait end  1526377685276 */</code></pre><p>方法 wait() 被执行后，锁会自动释放；执行完 notify() 方法后，锁不会自动释放，只有同步方法或者代码块执行完后才会释放。</p><p>（2）Thread 中关于线程状态的 API</p><p><img src="https://img.wshunli.com/Java/Java多线程编程核心技术/线程状态切换.png" alt="线程状态切换"></p><p>Java 线程一共有 6 个状态，分别是新建（New），RUNNABLE [ 就绪（Ready to run）、运行中（Running）]，睡眠（Sleeping），阻塞（Blocked），等待（Waiting），死亡（Dead/Terminate）。</p><p>java线程状态切换 - 简书：<br><a href="https://www.jianshu.com/p/531310753a64" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/531310753a64</a></p><p>每个锁对象都有两个队列：就绪队列、阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。</p><p>当一个线程被唤醒 (notify) 后，才会进入到就绪队列，等待 CPU 的调度，反之，当一个线程被等待 (wait) 后，就会进入阻塞队列，等待下一次被唤醒。</p><p>（3）wait() 方法的使用</p><p>wait() 方法会使线程进入等待状态。</p><p>wait(long) 方法是线程等待一段时间内是否被唤醒，超时则自动唤醒。</p><p>当线程在 wait() 状态时，调用线程的 interrupt() 方法会出现 InterruptedException 异常。</p><p>在以下情况下，持有锁的线程会释放锁：<br>1、执行完同步代码块。<br>2、在执行同步代码块的过程中，遇到异常而导致线程终止。<br>3、在执行同步代码块的过程中，执行了锁所属对象的 wait() 方法，这个线程会释放锁，进行对象的等待池。</p><p>（4）通知一个线程和唤醒所有线程</p><p>notify() 仅 <strong>随机</strong> 唤醒一个线程，多次调用也会随机将等待 wait 状态的线程进行唤醒。</p><p>notifyAll() 方法可以唤醒所有线程。</p><p>但是通知 notify() 方法在 wait() 方法之前调用，后面 wait 线程收不到通知就会一直处于等待状态。</p><p>注意线程在等待结束后其外部条件数据值可能发生改变。</p><p>（5）生产者/消费者模式</p><p>1、一生产者一消费者:</p><pre><code class="Java">class MyStack {    private List list = new ArrayList();    synchronized public void push() {        try {            if (list.size() == 1) {                this.wait();            }            list.add(&quot;anyString=&quot; + Math.random());            this.notify();            System.out.println(&quot;push=&quot; + list.size());        } catch (InterruptedException e) {            e.printStackTrace();        }    }    synchronized public String pop() {        String returnValue = &quot;&quot;;        try {            if (list.size() == 0) {                System.out.println(&quot;pop操作中的：&quot;                        + Thread.currentThread().getName() + &quot; 线程呈wait状态&quot;);                this.wait();            }            returnValue = &quot;&quot; + list.get(0);            list.remove(0);            this.notify();            System.out.println(&quot;pop=&quot; + list.size());        } catch (InterruptedException e) {            e.printStackTrace();        }        return returnValue;    }}class P {    private MyStack myStack;    public P(MyStack myStack) {        super();        this.myStack = myStack;    }    public void pushService() {        myStack.push();    }}class C {    private MyStack myStack;    public C(MyStack myStack) {        super();        this.myStack = myStack;    }    public void popService() {        System.out.println(&quot;pop=&quot; + myStack.pop());    }}class P_Thread extends Thread {    private P p;    public P_Thread(P p) {        super();        this.p = p;    }    @Override    public void run() {        while (true) {            p.pushService();        }    }}class C_Thread extends Thread {    private C r;    public C_Thread(C r) {        super();        this.r = r;    }    @Override    public void run() {        while (true) {            r.popService();        }    }}public class Main {    public static void main(String[] args) {        MyStack myStack = new MyStack();        P p = new P(myStack);        C r = new C(myStack);        P_Thread pThread = new P_Thread(p);        C_Thread rThread = new C_Thread(r);        pThread.start();        rThread.start();    }}</code></pre><p>2、一生产者多消费者：</p><pre><code class="Java">class MyStack {    private List list = new ArrayList();    synchronized public void push() {        try {            while (list.size() == 1) {                this.wait();            }            list.add(&quot;anyString=&quot; + Math.random());            this.notify();            System.out.println(&quot;push=&quot; + list.size());        } catch (InterruptedException e) {            e.printStackTrace();        }    }    synchronized public String pop() {        String returnValue = &quot;&quot;;        try {            while (list.size() == 0) {                System.out.println(&quot;pop操作中的：&quot;                        + Thread.currentThread().getName() + &quot; 线程呈wait状态&quot;);                this.wait();            }            returnValue = &quot;&quot; + list.get(0);            list.remove(0);            this.notify();            System.out.println(&quot;pop=&quot; + list.size());        } catch (InterruptedException e) {            e.printStackTrace();        }        return returnValue;    }}</code></pre><p>3、多生产者一消费者。</p><p>4、多生产者多消费者。</p><p>可能产生假死的情况，使用 notifyAll() 方法通知其他线程即可。</p><p>（6）通过管道进行进程间通信</p><p>在 Java 语言中提供了各种各样的输入/输出流，其中管道流 pipeStream 可用于不同线程间之间传送数据。</p><p>一个线程发送数据到输出管道，另一个线程从输入管道中读取数据。</p><pre><code class="Java">class WriteData {    public void writeMethod(PipedOutputStream out) {        try {            System.out.println(&quot;write :&quot;);            for (int i = 0; i &lt; 300; i++) {                String outData = &quot;&quot; + (i + 1);                out.write(outData.getBytes());                System.out.print(outData);            }            System.out.println();            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}class ReadData {    public void readMethod(PipedInputStream input) {        try {            System.out.println(&quot;read  :&quot;);            byte[] byteArray = new byte[20]; // 字节流            // char[] byteArray = new char[20]; //字符流            int readLength = input.read(byteArray);            while (readLength != -1) {                String newData = new String(byteArray, 0, readLength);                System.out.print(newData);                readLength = input.read(byteArray);            }            System.out.println();            input.close();        } catch (IOException e) {            e.printStackTrace();        }    }}class ThreadWrite extends Thread {    private WriteData write;    private PipedOutputStream out;    public ThreadWrite(WriteData write, PipedOutputStream out) {        super();        this.write = write;        this.out = out;    }    @Override    public void run() {        write.writeMethod(out);    }}class ThreadRead extends Thread {    private ReadData read;    private PipedInputStream input;    public ThreadRead(ReadData read, PipedInputStream input) {        super();        this.read = read;        this.input = input;    }    @Override    public void run() {        read.readMethod(input);    }}public class Main {    public static void main(String[] args) {        try {            WriteData writeData = new WriteData();            ReadData readData = new ReadData();            PipedInputStream inputStream = new PipedInputStream();            PipedOutputStream outputStream = new PipedOutputStream();            // inputStream.connect(outputStream);            outputStream.connect(inputStream);            ThreadRead threadRead = new ThreadRead(readData, inputStream);            threadRead.start();            Thread.sleep(2000);            ThreadWrite threadWrite = new ThreadWrite(writeData, outputStream);            threadWrite.start();        } catch (IOException e) {            e.printStackTrace();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>通过管道进行进程间通信可以传递，字节流和字符流。</p><h2 id="方法-join-的使用"><a href="#方法-join-的使用" class="headerlink" title="方法 join 的使用"></a>方法 join 的使用</h2><p>join() 方法具有使线程排队运行的作用，使所属线程 x 正常执行 run() 方法，而使当前线程 z 进行无限期阻塞，等待线程 x 销毁后继续执行线程 z 后面的代码。</p><pre><code class="Java">class MyThread extends Thread {    @Override    public void run() {        try {            int secondValue = (int) (Math.random() * 10000);            System.out.println(secondValue);            Thread.sleep(secondValue);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}public class Test {    public static void main(String[] args) {        try {            MyThread threadTest = new MyThread();            threadTest.start();            threadTest.join();            System.out.println(&quot;我想当threadTest对象执行完毕后我再执行，我做到了&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>join 方法有点类似与同步的效果。</p><p>但是 join() 方法内部是由 wait() 方法进行等待，而 sychronized 关键字是使用 <strong>对象监视器</strong> 原理作为同步。</p><p>在 join 过程中，如果当前线程对象被终端，则当前线程出现异常，而 join 的线程正常执行。</p><p>方法 join(long) 中参数是设定等待时间。</p><p>long 是最长的等待时间，如果子线程提前结束，主线程也会结束等待。</p><pre><code class="Java">public final synchronized void join(long millis)throws InterruptedException {    long base = System.currentTimeMillis();    long now = 0;    if (millis &lt; 0) {        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);    }    if (millis == 0) {        while (isAlive()) {            wait(0);        }    } else {        while (isAlive()) {            long delay = millis - now;            if (delay &lt;= 0) {                break;            }            wait(delay);            now = System.currentTimeMillis() - base;        }    }}</code></pre><p>方法 join() 内部由 wait() 方法实现会立即释放对象锁，而 Thread.sleep() 方法不会释放对象锁。</p><h2 id="类-ThreadLocal-的使用"><a href="#类-ThreadLocal-的使用" class="headerlink" title="类 ThreadLocal 的使用"></a>类 ThreadLocal 的使用</h2><p>类 <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/ThreadLocal.html" rel="external nofollow noopener noreferrer" target="_blank">ThreadLocal</a> 是保证线程之间变量的隔离性。</p><pre><code class="Java">class Tools {    public static ThreadLocal tl = new ThreadLocal();}class ThreadA extends Thread {    @Override    public void run() {        try {            for (int i = 0; i &lt; 100; i++) {                if (Tools.tl.get() == null) {                    Tools.tl.set(&quot;ThreadA&quot; + (i + 1));                } else {                    System.out.println(&quot;ThreadA get Value=&quot; + Tools.tl.get());                }                Thread.sleep(200);            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}class ThreadB extends Thread {    @Override    public void run() {        try {            for (int i = 0; i &lt; 100; i++) {                if (Tools.tl.get() == null) {                    Tools.tl.set(&quot;ThreadB&quot; + (i + 1));                } else {                    System.out.println(&quot;ThreadB get Value=&quot; + Tools.tl.get());                }                Thread.sleep(200);            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}public class Run {    public static void main(String[] args) {        try {            ThreadA a = new ThreadA();            ThreadB b = new ThreadB();            a.start();            b.start();            for (int i = 0; i &lt; 100; i++) {                if (Tools.tl.get() == null) {                    Tools.tl.set(&quot;Main&quot; + (i + 1));                } else {                    System.out.println(&quot;Main get Value=&quot; + Tools.tl.get());                }                Thread.sleep(200);            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h2 id="类-InheritableThreadLocal-的使用"><a href="#类-InheritableThreadLocal-的使用" class="headerlink" title="类 InheritableThreadLocal 的使用"></a>类 InheritableThreadLocal 的使用</h2><p>类 <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html" rel="external nofollow noopener noreferrer" target="_blank">InheritableThreadLocal</a> 可以再子线程中取得父线程继承下来的值。</p><pre><code class="Java">class InheritableThreadLocalExt extends InheritableThreadLocal {    @Override    protected Object initialValue() {        return new Date().getTime();    }    @Override    protected Object childValue(Object parentValue) {        return parentValue + &quot; 我在子线程加的~!&quot;;    }}class Tools {    public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt();}class ThreadA extends Thread {    @Override    public void run() {        try {            for (int i = 0; i &lt; 10; i++) {                System.out.println(&quot;在ThreadA线程中取值=&quot; + Tools.tl.get());                Thread.sleep(100);            }        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}public class Run {    public static void main(String[] args) {        try {            for (int i = 0; i &lt; 10; i++) {                System.out.println(&quot;       在Main线程中取值=&quot; + Tools.tl.get());                Thread.sleep(100);            }            Thread.sleep(5000);            ThreadA a = new ThreadA();            a.start();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>在继承的同时可以对值进行进一步的处理。</p><p>但在子线程取得值的同时，主线程将 InheritableThreadLocal 中的值进行更改，子线程取得的值还是旧值。</p><h1 id="第四章-Lock-的使用"><a href="#第四章-Lock-的使用" class="headerlink" title="第四章 Lock 的使用"></a>第四章 Lock 的使用</h1><h2 id="ReentrantLock-类"><a href="#ReentrantLock-类" class="headerlink" title="ReentrantLock 类"></a>ReentrantLock 类</h2><p>（1）ReentrantLock 实现同步</p><pre><code class="Java">ReentrantLock reentrantLock = new ReentrantLock();reentrantLock.lock();// Do somethingreentrantLock.unlock();</code></pre><p>（2）使用 Condition 实现等待/通知</p><pre><code class="Java">class MyService {    private Lock lock = new ReentrantLock();    public Condition condition = lock.newCondition();    public void await() {        try {            lock.lock();            System.out.println(&quot; await时间为&quot; + System.currentTimeMillis());            condition.await();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void signal() {        try {            lock.lock();            System.out.println(&quot;signal时间为&quot; + System.currentTimeMillis());            condition.signal();        } finally {            lock.unlock();        }    }}class ThreadA extends Thread {    private MyService service;    public ThreadA(MyService service) {        super();        this.service = service;    }    @Override    public void run() {        service.await();    }}public class Run {    public static void main(String[] args) throws InterruptedException {        MyService service = new MyService();        ThreadA a = new ThreadA(service);        a.start();        Thread.sleep(3000);        service.signal();    }}</code></pre><p>这样就实现了 Condition 的通知/等待功能。</p><p>对于多个 Condition 实现通知部分线程，可多次调用 lock.newCondition() 方法。</p><p>（3）公平锁和非公平锁</p><p>锁 Lock 分为公平锁和非公平锁：</p><p>公平锁表示线程获取锁的顺序是按照线程 <strong>加锁的顺序</strong> 来分配的。而非公平锁是抢占机制，是随机获取获取锁的。</p><p>ReentrantLock 可使用构造函数实例化公平锁和非公平锁。</p><p>（4）ReentrantLock 中的常用方法</p><p>getHoldCount() 当前线程保持锁定的个数，也就是调用 lock() 方法的次数。</p><p>getQueueLength() 返回等待获得锁定的线程的估计数。</p><p>getWaitQueueLength​(Condition condition) 返回等待与此锁定相关的给定条件 condition 的线程估计数。</p><p>hasQueuedThread​(Thread thread) 查询指定线程 thread 是否在等待获得此锁定；hasQueuedThreads() 查询是否有线程在等待次锁。</p><p>hasWaiters​(Condition condition) 查询是否有线程正在等待与此线程有关的 condition 条件。</p><p>isFair() 是不是公平锁。</p><p>isHeldByCurrentThread() 当前线程是否保持此锁。</p><p>isLocked() 查询此锁定是否由任意线程锁定。</p><p>lockInterruptibly() 如果当前线程未中断，则获得此锁；否则出现异常。</p><p>tryLock() 调用时未被另外一个线程保持的情况下，才获得此锁定；tryLock​(long timeout, TimeUnit unit) 在给定时间内。</p><h2 id="ReentrantReadWriteLock-类"><a href="#ReentrantReadWriteLock-类" class="headerlink" title="ReentrantReadWriteLock 类"></a>ReentrantReadWriteLock 类</h2><p>读写锁 <a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" rel="external nofollow noopener noreferrer" target="_blank">ReentrantReadWriteLock</a> 表示也有两个锁，一个是与读有关的锁，也成为共享锁；另一个是与写有关的锁，也叫排他锁。</p><p>多个读锁之间不互斥，读锁和写锁互斥，写锁和写锁互斥。</p><p>（1）读读共享</p><pre><code class="java">import java.util.concurrent.locks.ReentrantReadWriteLock;class Service {    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    public void read() {        try {            try {                lock.readLock().lock();                System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName()                        + &quot; &quot; + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.readLock().unlock();            }        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}class ThreadA extends Thread {    private Service service;    public ThreadA(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.read();    }}class ThreadB extends Thread {    private Service service;    public ThreadB(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.read();    }}public class Main {    public static void main(String[] args) {        Service service = new Service();        ThreadA a = new ThreadA(service);        a.setName(&quot;A&quot;);        ThreadB b = new ThreadB(service);        b.setName(&quot;B&quot;);        a.start();        b.start();    }}/* * 获得读锁B 1526483245955 * 获得读锁A 1526483245955 */</code></pre><p>（2）写写互斥</p><pre><code class="Java">class Service {    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    public void write() {        try {            try {                lock.writeLock().lock();                System.out.println(&quot;获得写锁&quot; + Thread.currentThread().getName()                        + &quot; &quot; + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.writeLock().unlock();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}/* * 获得写锁B 1526483357433 * 获得写锁A 1526483367434 */</code></pre><p>（3）读写互斥、写读互斥</p><pre><code class="Java">class Service {    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    public void read() {        try {            try {                lock.readLock().lock();                System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName()                        + &quot; &quot; + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.readLock().unlock();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }    public void write() {        try {            try {                lock.writeLock().lock();                System.out.println(&quot;获得写锁&quot; + Thread.currentThread().getName()                        + &quot; &quot; + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.writeLock().unlock();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}/* * 获得读锁A 1526483561390 * 获得写锁B 1526483571390 *//* * 获得写锁B 1526483608487 * 获得读锁A 1526483618487 */</code></pre><h1 id="第五章-定时器-Timer"><a href="#第五章-定时器-Timer" class="headerlink" title="第五章 定时器 Timer"></a>第五章 定时器 Timer</h1><p>（1）Timer 的概念</p><p>类 <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Timer.html" rel="external nofollow noopener noreferrer" target="_blank">Timer</a> 主要负责计划任务的功能，也就是在指定时间开始执行某一个任务。Timer 的封装类是 <a href="https://docs.oracle.com/javase/10/docs/api/java/util/TimerTask.html" rel="external nofollow noopener noreferrer" target="_blank">TimerTask</a> 。</p><p>（2）Timer 的常用方法</p><p>1、schedule​(TimerTask task, Date time) 在指定日期执行一次某一任务。</p><pre><code class="Java">public class Run {    private static Timer timer = new Timer();    // 守护线程方式，任务执行后自行销毁    // private static Timer timer = new Timer(true);    static public class MyTask extends TimerTask {        @Override        public void run() {            System.out.println(&quot;运行了！时间为：&quot; + new Date());        }    }    public static void main(String[] args) {        try {            MyTask task = new MyTask();            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);            String dateString = &quot;2014-10-12 11:55:00&quot;;            Date dateRef = sdf.parse(dateString);            System.out.println(&quot;字符串时间：&quot; + dateRef.toLocaleString() + &quot; 当前时间：&quot;                    + new Date().toLocaleString());            timer.schedule(task, dateRef);        } catch (ParseException e) {            e.printStackTrace();        }    }}</code></pre><p>如果 time 晚于当前时间，则按照计划执行；若早于当前时间，则立即执行。</p><p>TimerTask 是以任务队列的方式按照顺序知心话，如果前面的任务执行时间较长，后面的任务也会延迟。</p><p>2、schedule​(TimerTask task, Date firstTime, long period) 在指定日期后，按照指定时间间隔周期性无限循环地执行某一任务。</p><p>3、schedule​(TimerTask task, long delay) 以当前时间为参考，延迟指定地毫秒数之后执行一次 TimerTask 任务。</p><p>4、schedule​(TimerTask task, long delay, long period) 以当前时间为参考，延迟指定地毫秒数之后，再以指定时间间隔周期性无限循环地执行某一任务。</p><p>5、scheduleAtFixedRate​() 方法</p><p>主要有两个方法：</p><p>scheduleAtFixedRate​(TimerTask task, Date firstTime, long period)</p><p>scheduleAtFixedRate​(TimerTask task, long delay, long period)</p><p>方法 schedule 和 scheduleAtFixedRate​ 区别和联系：</p><p>1) 方法 schedule 和 scheduleAtFixedRate 都会顺序序执行，所以不要考虑非线程安全的情况。<br>2) 方法 schedule 和 scheduleAtFixedRate 主要的区别只在于不延时的情况。</p><ul><li>使用 schedule 方法:如果执行任务的时间没有被延时，那么下一次任务的执行时间参考的是上一次任务的“开始”时的时间来计算。</li><li>使用 scheduleAtFixedRate 方法:如果执行任务的时间没有被延时，那么下一次任务的执行时间参考的是上一次任务的“结束”时的时间来计算。</li></ul><p>3) 延时的情况则没有区别，也就是使用 schedule 或 scheduleAtFixedRate 方法都是如果执行任务的时间被延时，那么下一次任务的执行时间参考的是上一次任务“结束”时的时间来计算。<br>4) schedule 方法没有具有任务追赶执行性，而 scheduleAtFixedRate 是有的。</p><p><strong>不延时</strong> 是指 TimerTask 任务执行的时间比 period 周期要短，不会对下次任务执行造成延迟。<br><strong>追赶执行性</strong> 是指 任务执行时间 比当前时间早的情况下，过去时间段内的任务从现在开始执行。</p><h1 id="第六章-单例模式与多线程"><a href="#第六章-单例模式与多线程" class="headerlink" title="第六章 单例模式与多线程"></a>第六章 单例模式与多线程</h1><p>（1）单例模式概述</p><p>单例模式可分为两种：</p><p>1、立即执行/“饿汉模式”：使用类的时候已经将对象创建完毕。</p><pre><code class="Java">public class MyObject {    // 立即加载方式==饿汉模式    private static MyObject myObject = new MyObject();    private MyObject() {    }    public static MyObject getInstance() {        // 此代码版本为立即加载        // 此版本代码的缺点是不能有其它实例变量        // 因为getInstance()方法没有同步        // 所以有可能出现非线程安全问题        return myObject;    }}</code></pre><p>2、延迟加载/“懒汉模式”：在使用类的时候实例才被创建。</p><p>DCL 双检查锁机制。</p><pre><code class="Java">public class MyObject {    private volatile static MyObject myObject;    private MyObject() {    }    // 使用双检测机制来解决问题    // 即保证了不需要同步代码的异步    // 又保证了单例的效果    public static MyObject getInstance() {        try {            if (myObject != null) {            } else {                // 模拟在创建对象之前做一些准备性的工作                Thread.sleep(3000);                synchronized (MyObject.class) {                    if (myObject == null) {                        myObject = new MyObject();                    }                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }        return myObject;    }    // 此版本的代码称为：    // 双重检查Double-Check Locking}</code></pre><p>（2）单例模式的实现方式</p><p>单例模式还可以由静态内置类、static 代码块、enum 枚举数据类实现。</p><h1 id="第七章-拾遗增补"><a href="#第七章-拾遗增补" class="headerlink" title="第七章 拾遗增补"></a>第七章 拾遗增补</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程在不同运行时期有不同的状态，状态信息存储在 <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.State.html" rel="external nofollow noopener noreferrer" target="_blank">State</a> 枚举类中。</p><p><img src="https://img.wshunli.com/Java/Java多线程编程核心技术/java_thread_state.png" alt="java_thread_state"></p><p>A thread can be in one of the following states:</p><ul><li>NEW ：A thread that has not yet started.</li><li>RUNNABLE ：A thread executing in the Java virtual machine.</li><li>BLOCKED ：A thread that is blocked waiting for a monitor lock.</li><li>WAITING ：A thread that is waiting indefinitely for another thread to perform a particular action.</li><li>TIMED_WAITING ：A thread that is waiting for another thread to perform an action for up to a specified waiting time.</li><li>TERMINATED ：A thread that has exited.</li></ul><p>A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states.</p><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>线程组中可以包含线程对象和线程组，对其进行批量管理和有效组织。</p><p>（1）线程组的关联</p><p>1 级关联，即没有子孙对象。</p><pre><code class="Java">ThreadA aRunnable = new ThreadA();ThreadB bRunnable = new ThreadB();ThreadGroup group = new ThreadGroup(&quot;线程组&quot;);Thread aThread = new Thread(group, aRunnable);Thread bThread = new Thread(group, bRunnable);aThread.start();bThread.start();</code></pre><p>多级关联，存在子孙对象。</p><pre><code class="Java">// 在main组中添加一个线程组A，然后在这个A组中添加线程对象ZThreadGroup mainGroup = Thread.currentThread().getThreadGroup();ThreadGroup group = new ThreadGroup(mainGroup, &quot;A&quot;);Runnable runnable = new Runnable() {    @Override    public void run() {        try {            System.out.println(&quot;runMethod!&quot;);            Thread.sleep(10000);// 线程必须在运行状态才可以受组管理        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }};Thread newThread = new Thread(group, runnable);newThread.setName(&quot;Z&quot;);newThread.start();// 线程必须启动然后才归到组A中</code></pre><p>（2）线程组自动归属特性</p><p>自动归属就是在实例化一个 ThreadGroup 线程组 x 时，如果不指定所属的线程组，则 x 线程组会自动归到当前线程对象所属的线程组中。</p><p>（3）线程组的操作</p><p>获取父线程组，ThreadGroup 的 getParent() 方法获取父线程组。</p><pre><code class="Java">Thread.currentThread().getThreadGroup().getParent()</code></pre><p>线程组内的线程批量停止，ThreadGroup 的 interrupt() 方法。</p><h2 id="SimpleDateFormat-非线程安全"><a href="#SimpleDateFormat-非线程安全" class="headerlink" title="SimpleDateFormat 非线程安全"></a>SimpleDateFormat 非线程安全</h2><p>类 SimpleDateFormat 主要负责日期的转化和格式化，但在多线程环境下，非常容易造成数据转换和处理的不准确，SimpleDateFormat 不是线程安全的。</p><h2 id="多线程出现异常的处理"><a href="#多线程出现异常的处理" class="headerlink" title="多线程出现异常的处理"></a>多线程出现异常的处理</h2><p>（1）线程中出现异常的处理</p><pre><code class="Java">// 指定线程对象设置异常处理类MyThread t1 = new MyThread();t1.setName(&quot;线程t1&quot;);t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {    @Override    public void uncaughtException(Thread t, Throwable e) {        System.out.println(&quot;线程:&quot; + t.getName() + &quot; 出现了异常：&quot;);        e.printStackTrace();    }});t1.start();// 指定线程类的所有对象设置默认异常处理类MyThread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {    @Override    public void uncaughtException(Thread t, Throwable e) {        System.out.println(&quot;线程:&quot; + t.getName() + &quot; 出现了异常：&quot;);        e.printStackTrace();    }});</code></pre><p>（2）线程组中出现异常的处理</p><pre><code class="Java">public class MyThreadGroup extends ThreadGroup {    public MyThreadGroup(String name) {        super(name);    }    @Override    public void uncaughtException(Thread t, Throwable e) {        super.uncaughtException(t, e);        this.interrupt();    }}</code></pre><p>注意线程组中的线程对象 run() 方法内部不要有 catch 语句，否则 uncaughtException 不执行。</p><p>（3）线程组异常处理的传递</p><pre><code class="Java">package com.wshunli.thread.sync71;class MyThread extends Thread {    private String num = &quot;a&quot;;    public MyThread() {        super();    }    public MyThread(ThreadGroup group, String name) {        super(group, name);    }    @Override    public void run() {        int numInt = Integer.parseInt(num);        System.out.println(&quot;在线程中打印：&quot; + (numInt + 1));    }}class MyThreadGroup extends ThreadGroup {    public MyThreadGroup(String name) {        super(name);    }    @Override    public void uncaughtException(Thread t, Throwable e) {        super.uncaughtException(t, e);        System.out.println(&quot;线程组的异常处理&quot;);        e.printStackTrace();    }}class ObjectUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {    @Override    public void uncaughtException(Thread t, Throwable e) {        System.out.println(&quot;对象的异常处理&quot;);        e.printStackTrace();    }}class StateUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {    @Override    public void uncaughtException(Thread t, Throwable e) {        System.out.println(&quot;静态的异常处理&quot;);        e.printStackTrace();    }}public class Main {    public static void main(String[] args) {        MyThread myThread = new MyThread();        // 对象        myThread.setUncaughtExceptionHandler(new ObjectUncaughtExceptionHandler());        // 类        // MyThread.setDefaultUncaughtExceptionHandler(new StateUncaughtExceptionHandler());        myThread.start();    }}/* * 对象的异常处理 * java.lang.NumberFormatException: For input string: &quot;a&quot; *     at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) *     at java.lang.Integer.parseInt(Integer.java:580) *     at java.lang.Integer.parseInt(Integer.java:615) *     at com.wshunli.thread.sync71.MyThread.run(Main.java:17) */public class Main {    public static void main(String[] args) {        MyThread myThread = new MyThread();        // 对象        // myThread.setUncaughtExceptionHandler(new ObjectUncaughtExceptionHandler());        // 类        MyThread.setDefaultUncaughtExceptionHandler(new StateUncaughtExceptionHandler());        myThread.start();    }}/* * 静态的异常处理 * java.lang.NumberFormatException: For input string: &quot;a&quot; *     at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) *     at java.lang.Integer.parseInt(Integer.java:580) *     at java.lang.Integer.parseInt(Integer.java:615) *     at com.wshunli.thread.sync71.MyThread.run(Main.java:17) */</code></pre><p>对于线程组而言：</p><pre><code class="Java">public class Main {    public static void main(String[] args) {        MyThreadGroup group = new MyThreadGroup(&quot;我的线程组&quot;);        MyThread myThread = new MyThread(group, &quot;我的线程&quot;);        // 对象        myThread.setUncaughtExceptionHandler(new ObjectUncaughtExceptionHandler());        // 类        // MyThread.setDefaultUncaughtExceptionHandler(new StateUncaughtExceptionHandler());        myThread.start();    }}/* * 对象的异常处理 * java.lang.NumberFormatException: For input string: &quot;a&quot; *     at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) *     at java.lang.Integer.parseInt(Integer.java:580) *     at java.lang.Integer.parseInt(Integer.java:615) *     at com.wshunli.thread.sync71.MyThread.run(Main.java:17) */public class Main {    public static void main(String[] args) {        MyThreadGroup group = new MyThreadGroup(&quot;我的线程组&quot;);        MyThread myThread = new MyThread(group, &quot;我的线程&quot;);        // 对象        // myThread.setUncaughtExceptionHandler(new ObjectUncaughtExceptionHandler());        // 类        MyThread.setDefaultUncaughtExceptionHandler(new StateUncaughtExceptionHandler());        myThread.start();    }}/* * 静态的异常处理 * java.lang.NumberFormatException: For input string: &quot;a&quot; * 线程组的异常处理 *     at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) *     at java.lang.Integer.parseInt(Integer.java:580) *     at java.lang.Integer.parseInt(Integer.java:615) *     at com.wshunli.thread.sync71.MyThread.run(Main.java:17) * java.lang.NumberFormatException: For input string: &quot;a&quot; *     at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) *     at java.lang.Integer.parseInt(Integer.java:580) *     at java.lang.Integer.parseInt(Integer.java:615) *     at com.wshunli.thread.sync71.MyThread.run(Main.java:17) */</code></pre><blockquote><p>本书是阅读完了，也只是一些多线程的基础，距离实战还是有差距，后面再深入学习 《Java并发编程的艺术》、《Java并发编程实战》等书籍逐步提高。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面面试什么的多线程部分问的比较多，需要加强下，这里记录总结 《Java多线程编程核心技术》 读书情况。&lt;/p&gt;&lt;h1 id=&quot;第一章-Java-多线程技能&quot;&gt;&lt;a href=&quot;#第一章-Java-多线程技能&quot; class=&quot;headerlink&quot; title=&quot;第一章 J
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java多线程编程核心技术》" scheme="https://www.wshunli.com/tags/%E3%80%8AJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Cesium Hello World ！</title>
    <link href="https://www.wshunli.com/posts/a4e3e5ad.html"/>
    <id>https://www.wshunli.com/posts/a4e3e5ad.html</id>
    <published>2018-05-03T09:22:54.000Z</published>
    <updated>2018-06-05T09:20:28.117Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Cesium 的环境搭建及 Hello World Demo 。</p><p>Cesium 是一个基于 JavaScript 的开源框架，可用于在浏览器中绘制 3D 的地球，并在其上绘制地图（支持多种格式的瓦片服务），该框架不需要任何插件支持，但是浏览器必须支持 WebGL。</p><p>Cesium 支持多种数据可视化方式，可以绘制各种几何图形、导入图片，甚至 3D 模型。同时，Cesium还支持基于时间轴的动态数据展示，例如，我们可以用它绘制卫星运行轨迹。</p><p>从官方仓库或者官网下载 CesiumJS</p><p>官方仓库：<a href="https://github.com/AnalyticalGraphicsInc/cesium" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/cesium</a><br>官网下载：<a href="https://cesiumjs.org/downloads/" rel="external nofollow noopener noreferrer" target="_blank">https://cesiumjs.org/downloads/</a></p><p>首先官方推荐使用 Nodejs 作为 Web 服务器，安装很简单就不多介绍了。</p><p>下载好之后解压即可，在项目根目录，命令行中依次输入以下命令</p><pre><code class="NPM">npm installnode server.js</code></pre><p>然后在浏览器中打开 <a href="http://localhost:8080/Apps/HelloWorld.html" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/Apps/HelloWorld.html</a> 即可。</p><p>我们来看 <code>HelloWorld.html</code> 源码也比较简单。</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;!-- Use correct character set. --&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;!-- Tell IE to use the latest, best version. --&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;!-- Make the application on mobile take up the full browser screen and disable user scaling. --&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;  &lt;title&gt;Hello World!&lt;/title&gt;  &lt;script src=&quot;../Build/Cesium/Cesium.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;      @import url(../Build/Cesium/Widgets/widgets.css);      html, body, #cesiumContainer {          width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;      }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;cesiumContainer&quot;&gt;&lt;/div&gt;  &lt;script&gt;    var viewer = new Cesium.Viewer(&#39;cesiumContainer&#39;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在 <a href="http://localhost:8080/Apps/Sandcastle/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/Apps/Sandcastle/index.html</a> 中有一些示例代码，很不错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Cesium 的环境搭建及 Hello World Demo 。&lt;/p&gt;&lt;p&gt;Cesium 是一个基于 JavaScript 的开源框架，可用于在浏览器中绘制 3D 的地球，并在其上绘制地图（支持多种格式的瓦片服务），该框架不需要任何插件支持，但是浏览器必须支持 
      
    
    </summary>
    
      <category term="三维技术" scheme="https://www.wshunli.com/categories/%E4%B8%89%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Cesium" scheme="https://www.wshunli.com/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>大数据量 3dsMax 精细模型处理及可视化方法</title>
    <link href="https://www.wshunli.com/posts/4cbab315.html"/>
    <id>https://www.wshunli.com/posts/4cbab315.html</id>
    <published>2018-05-03T07:46:46.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，本文为较新研究成果，暂不公开. " /> <label for="pass"> 欢迎您访问我的博客，本文为较新研究成果，暂不公开. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/KNBHoVY9CdKP6o57CxBQfyKhprAk4TKX9+hUWGm0L/BBsA/dGml+u7BhS4+eyMUkemZis2WQWmZ46aQGf8V1qZujwOEaxU723EgfQf5AhKsrxdcWt+5te8/gThnEOztMdYHTWLgRQkeMjY61liIzCwJuO3+sEpyWdh3RS4tKSYDWUFHWKWTmhPYLYsiSsaTzf0vIUijtKSIquA/fiafBv+fN2igwmpj/a788CQOc0zpNzPHcZ61QAu+M/2hkZez9t+H9kNRR/FYPpOGKPrtn1lcZBpfnppRf28GpXDt97wKAcV4td5E+bzZHgySlesVLa7KSBILNtAkq/iVsruCLoGYsId56dmcmV4XPVnwHDsJZp+jx8qPdlfbw5te5h+QB35iDYbzIejjmqp9GphAt43fqVOyVCYo70J07rQMmPmdblvB8FPV9yaekrOs7gtVMZtfID32HJ5ndd4Emb4DkaVrdH06sD2JRUkNWwPPmo8eIqnYyqXfVwlddgk5gTW/5nAYjaCGSLmN4mgZbrnHMgbLtnjzy3FCtRD4zZWSPkgeSC9oZ2bxh6SgOIZpG1sbMFUYmw3d9/PUg2gB053oc61K44ucf+JVJxePgO1iBpu496egWFT9BPy73P2oBEIaEniQ37kCsi84uQxS+GB2TGPodNvOQwFj+Ow5+qAr4EHg1MePRDAS2nWaHicoptmACAmmycyV/nqIjyHMrSD2tvUBIBRAtxWaeTf/Obz4b/hu+92l1B5h4p3qjFuL/GXmIypEQKrE5aDC/r1grqs5mzn2qsnZ39KWWadUZtj/9ELRMHzkwy+sIxB354GpyDObpBrobjVBKeW+4qJQZ3DHxFP1EAuhRZyt+OCjGKRoJ3Z1pgL4IcBEuEf85ZS8tkLH5jIBc84QVcQrI9R2mRY5wcJxFoO1gl5p4hawa4nO3zXWbYsFpe2TevmCh+MWK+MJYuZqNJuM/dkih0NxzvT6l3MgIS3W1Z4EYXUp+WOUlYkrwIDiuJnNo0gJAT4FBDXKcC8cizHua9wW+IaCAAfCPPSqQU/XF3FZVAJbgce8P++v29X/RFDqzdgX56hrDpt1+B3evMgyePEBHbi6OjWtOsmF6WBCC633tyo8O3T7URe3C6RkNBXqCDIH9bDqkWknXBGyOTk8BXv+wtUaN78oYBTJeqd+Q/tnA3voZ9wCnWf0/MN9jP2uiQLT9CgJyVY4bOeJcBOjw9O0+yJbJEg5rhrtMqcqshBef7E4aSUXEIIpIStwLbdhw4RLncZWfQJYGFUsvcOZ4FOybkHso9eM5+0z4s+goTkvgkVjKIdzCOk783mC2ztl9TpHGQP10jdw9o4/SE74Yw6+BQ3w8zW5yWDTnIorBx9eQQ0Wz1MnYqo7FyUeSFNwoUOgXyg+FHw4HA3bu2rpWW+LOhn87YPr8qe1ZVGIKFjalcD7pFZmu4hyyDEVZfrzdsPgjuVY73Pu/06Ttg9gzH0/qwIamw7FZNzR/rCgjgLpUecoOByTteYSPO0cn8FEz8xYGAoywpKdk3+edBU+HhN4/jcwcO4ToTU6V7rXg7r3iq02S2YCOKV5a1skMLBKAIal994vRh1dzHtRY5xThOPuvsuBrtpV5V1BZDqXrBfnPV8N5XqRgr6ywaewMzmTLllzzRxyBw/YyBorjNOSV2i6TmVmBY75Lk2T8s782sC/0xBFPjZOzrNc3g8LlMzbZ/bLDz8efjJAkdeyXndn++esfsV9oMQmgl7zkRr7vpTutXRdRo7lKol2E/mLxBPSEr9sgwT5tmIuaB2jzwBUH+K5TDilv5W0Jl238O7GEB0AkZstJZFK70DlNquBNt2O8tXvqcPIn1UiC+VtNLENcWswZvgmIuFd6sTstgoRbQekOUhtqmqxBzd4jRom/x6oq9ZMmjcNIEjyod/+pcjgdvOcip9CytFt7JGxFFsX/ihmwmvRABoSCJBg5R7kqpFeqa0g4ckk6SU0XKWjgsKevRJ2XqHIkkcsuQZz14M9Vlk7eydQN5tC08Cjlch6QzDLrvyKvXinh5rry2rET5ys9OsB7aaz4ygc0E1OzTsJD+LwpjfLlpesnhn01B5jP9DvEuuqFk54aS7+rzofy5gCYiqyrX7uWLip7Jv0HuxyZWNmXgAONBuFOx1ONRGDiKPZmR02Pibj12R6rAoDTZBHT20rJH/vYoElY/z3vkn5gembzgHa2AaF8Lpx55RyKdGCeHncix5O5ozqHLppT6091emDF2DtFP01wYCLQiC7ujiwiB/ESTGnCefDfKq8rwCaWcSu5XXU4huDlZ6Wb0LLonB4UhH373LqVbWLnZjyecE/NJak4NkYWA23UUTnuoMgDAqoWWkO3iE+2W8DZyOE/nkp9OROBEcWEx64AthpeGcuoBSAHofYHnRfFomFEu/BKxsLqxARI0eBT40CJ7W/MuvaFBGidZtpJKgOUvDvZO1JN0VFuqp6naqCIp2fid2HaK5tbY0faYxMZ2fXn/K6/X3EwNmHa7bUdOG7qvZxVRogw1oMaEkQl7kfqLjQASU8ZCM2Vbalm6Iau9G35KP2klc0/iW5tn0CJZF0TafmbsSy6dFuJcjsuHNwH+DTRzXYxS9/EcIESXkB1+osQwq1Ohkg6SHaW/S82O4FCpVNlxaY73it1mP9fhQ+EJqTsRfyb3zVizXgRe5GP+y/P0/Gi5sGimx8E1w3KL5xieRuJLlpwu6ccum0iInl5Kon76NhRWRE03QQ0XYlfP7pMdWGrF1TC/w+ScrBdUtR9XbHDr/zMje6kcxGIAgfckD7aNjSMM83/FPtv7qGq9i6qQfZhtsKtgTiw7+s2Ru9wE+o1E5bXx7aSUgt9T/XBhDO4MQtXM/fclfi/pFocbm4xgyDp+RN+Y3p3cvsinRPIoLmW+tdUdRAl8B6aNwaUt4PwaOSjcDo9kmGycRUxeVOYUZf75zs1egwtwjaE3+F7BbtthgBu/7gvJQNSyMT4doXyaou38w70Ig4dDvgs3Sbt5yJYKzdDQ/9idnb9mhFC7TI7VcH2GZoB5INbtwdqgHRYa+Kv2d92sbPFuBwJcREm2KhtEy7WoTvojCK+9xhrOaz1RejEdCHLU5hFPJseL9X84eSCgJVXiLasXxOjI5J6e/X0vY37GsZVTQ6q0gDSgR3NZVThkU4FnI5MpBu+9ZgAdWkHyDjFiUJ96dSrvpZkCDisPqdUkhs9VvNNKnRE2vemn55a9VyuUidzZ5Zqv6ucRPQfSvR4/jyN/tbeuom2JJHIkoPij6YJ8NoVu81R3Yh5UGA05oiDGmvWrs8q8Im/YYcUrvUU19UrCmWAuWWeRDS7Ixo3yPBHBrCoug7+a9UyARevEDSwN4IPWHzA9FRDsCDAO4Wu+EtBtP0LgjrOj02oORvNH1YKRZmOprIaezbkTFTALLMlYJt3cxdflpb/Vg3PjnBOoHmdmkmHxh3vHdn6xCNhZ1VlhhreE0qSGHt+08sxuBLWCIL63Fc2lEXsyY66eb/aRV8hz+/QsJYeU5rsgJV0AWSdMhApOeAANVKUpcdef9jND9qTVPXEgS3x1KJiqyhQ+EiZL/5VSeWPF7via3kAYgTHrPZBRF8hKstgJ8ENQeJz9G+JEZ2hlo9OeycdTIke4HjHMjA5UwtCFPcPJL4oLUjvOEuVp2f8zYRmzNhoGl9EratsS5qJgKeCqgpbCDn2uQKs6157lSHL8ONCTf5MfqQXCmDVGHfov6tdSkqJPmaEQGAXsb+rOwgAhy16uPnoJexX55mFV/8rb9bBnbVQdgB982f7fSOtWeD1yZpVBwdx2RO4UDiKwTFTyRTz6PPxFKDqmz1/nCYWVpY0/ZSUr0rV8+DwLWJ5Cpp3A2B4nGI7VmMBvhYTlH8uFQvlhtdzYW0K2tpIRVWOP8LOM5BAMe9NZvHaNr2RGi8FMW5bwk1/6D0ShvjNXxOWnFlIDDsQz1ZzFkG4J9iagJq8HphNwb1ZsWuX3MgFPLzS1EwyCGb0AsFduhvQf/Ye5vGcy/X9sTFHJuv0mya4oFlbTlnqyJeNXesuQU03CYNhFQQdK3g75/Rr1jtHdM++6W1OQCH09junbbvmexzZYbHmcc8yYv1QVlIT/vd2NbO2CxaVmQTV3FQ5oyiZhGUf8PoioRqay7qAa1lcQHge4TTyf8Cgnlntblrsg9+NxIc+2SYvA+oWWIO6A2TcOf4SKd3qdB+rtbw4ak90cSv6XTmIcWljf1iyO0rzyuC32luLGwowC0OxqebD19VKsUX8BcgfFl10M9AjZzkAEJvyIrxYJAF9VHX2KdQpEm5oaZjnCx80IubKt4U0I3iVp11VkaRaGNvWofjOrkgXuViZ0LAaND3V5UFlYViXp3BIBJNSR2uzrEhLZOYSb8tnstIuKScR5qGAMpEDQv+kNsidt48lG8N3H7KhfBaoJjcGjF6WexaaLvHigX5J9LWTw20ExcXl9Vvfgs8FiA+iLtyXEodMEkNjzK28Q29Ybi9rCwgIRpAC1Oe9KjxwpeGqAylRUZX4vmZcAzjpWz9Vkgkg4x2Hu4ach8Ac0tiqsT89NY6cEeMlJ49P5dX6ULiRgyHRdlNpgr+pHo1LCvnoldXWtySmnIqwoGGZ9kVFwt1tNn04q1whM8z4iUdXiEODJbO6VTqD44LWu406pwXXgrVqRod3ViZ2LOxJDz9uvuixlwtdSVLz8CdLnSnbDLYwwu8frZlWCA48EB5R39DEEPeij88titBrcLa/UNzjaFF+x5bFC4cIY6u8zTiuLWT8dXKU5gZKU0vYjrWCQQ8OWrrwVXuM6qm8MM68cTFzCnHLMAuzBdhyGSfwFozfmhGz/u6mp3S4rez8kA/a3d/kL/BCwUHYIseHRE9iGUpJ4t8afuWjc8R7ng2iRckBy4U5rj7Stg+JOeQtcUeqNCxbOCSfns/XtPRr6Dv0TWJKB0kZTfG3NI9Hdrxb7j2B+tzXaOQgCeo9wbIAuOcLLAtvH777ZkdBNPYcYJff3ciCVzC5u7tOByaTcknJbrg0sXaqtbv6uj/oQaBGv5NdLfr83rtP0E2dazGNVj3nyQGDojylcRZ/DD8KdKewJZoUf+3PYWslK88ekjlbm5YQZx15zDoSrzFnBpqeoEQrsOn7eDkFIDl3IOszKNcd5N52Dd71Sweu/VWh/CvCLKs/iFYhEjVW0ql68jqTE7bcbBOYHVKBckJlNM1aT0dKQaCSzE2W8coIIhbxdlDMy6oRL+pa1jYSzW1V7+B156tNdIKZH6Ip+Bfdt31CzP+h5qAqzDdpaI4QE/AXVqymIfhpryIo/SH8SYEJRjBFEctvIlTB8xeNjDFq/yYXQe/fzGJ7XbBxgE6Oseia2xvnbhxz7AcH3er6Mw2JVKGAk0nAWGokPHJ50HDxPSHqIlPvQKhWaRnPN02r190nn4EOdu5bBufDaeH+TQyxj5yLvcRtOQTHgdhNQq5IKONBhRXsC3yQpvWehmo7ixlgW0FbWUQK8iZ/kVkQsB98W0AebQrPcymZObERAnBgExiuVz5VdHy0HgDyWlauAf8g+GWPKsVfxj13hPUyyVzGvLAwQsOLBZusPXc4NlTTaq25M3dKtPCKCgbWEaW5qmgpJF0X9RDVDCmMp0Pl1QQdt2IB12aK5gtH7D94ScC14QNuRneWN8l+YQ0ddjFz9C/kGGKHAGN+AYu4kQZ9nb9prewfA5F/eqBBnrTDVhj2rIy96YaCCwNsNpkQyWATl0e1PulBdOmqc1uB5JYcm+2j3wP5Mq2ZtfWSDAg/sE2ewS9KtJTXBSx6Q7SxzTxrP30iKr8wrJKNDjtFNxcL+26aRb756lZHkrl7apVRuA1SgLbDWalgodkAs+Y6WDz0v+yftycaoZV+JccwreRqxRXpFATdcjNdmWWQq7I+EiVoYfb7lxXr2Do8Ufg/FwAh5dlZUFq6bFiT5tM8/HepZHAYYcqcvXi0URStme/tSLn2tbiEzezfDDgZP/XUSmZfCvZza+GhkUT2TeEvLMnmc85aExhhFt9ijz8OnhgOHumbPwNxyuvtVat4RWNeE4SnRRVYBeG9KLGPo4APqEOCZsrl/CsUsrX3c/9Z82N3//epNLcZ9peG4hdRudnO1l2ydqnNggnre0praDgo3YH6jiZPRKXpYbQX3UApptCzGRxhoZvkO5CtZaT4yz6IPZNlSGVSxbjXFAd7uLeYJPHPKKfLO7OIjU1sZIt1aiK2LfxWQJSFNOzit4ZJaQcKpg4w0fWd7rduTpPAPMTsH50xU17AUw12haeHIaNLpdk+taUzSEtb7TqEqKLfPHdOZXcx/sgg1Oia2MJXhS1enP3JFSuqlwm8Y/+QUftZp+qAElgM3DkKoyYkNcG37MbMlMAXfMukM473AFXEQH+SsYfSZqKTqbYuwtZ4j2lB33lwAr7BvsRRVGyrRJJQWfWbCqrICMj+8tf0HK3bqdFPElGq32ByesBgqMT/20gedHbbLeLd0L5gNcNkuXiy4ddlnSmYDrtDQfW67xY/ra1OxZIEjApuNtgBemJOcrCiNdEApTojEAS4r8dippKc7QLKnw2vxCJh42ggH6WJTbp/CdCWEnKWd2ysdItYu+x5bGT7RRYH3jreGddSNF1NohQMCEoXzF7fRrBRikuxjIKe9FH1woVtRMcDmqJs00DKhR/0e4wvpYs0BUQNh97pH/bdPqeI8o3Yb/ktF87vpM2dOIB4A7o1GQ72zHmKnyWrQvfg5nv0fZ0ptV8J+UhjojpDgvroVgEGAZGqI6NpVK0ljQFc+NzxoIiowb/nCOMiykpq90+kgPFEwAEFQkaSZyg4mRswG9BPzbGIBia5EVTVko/N4HGWrbKVeUPIGj2sc2dixA74TCZ5yNhyEPuN2Q6kySFmhJkP+a5xbB2+aKcZjk+1tBuzLbKN+2koUHJjkQmJ1a0TJNL61lWEqDiNI7fqBxryHHFcML6SG/S0sRh7XaDN7Q25gUjjJG/2cSDlvExl80EUWSig4XvxLSoGASqcT3fiYazc+O6RofKRoNYiIkE0PIc+J5mxB4EjwFZv6GxgYXSL4+Jh9rOn0gBBYQndxv6SF95RFb1IaE7m7GRQr1KTliDiUZu7Mhg0Xut1HiytoNXonXXrG7TZzgatMta1hgvSUcAJpmWKETliC7Dxt2uwRx5Hh6WL90jvD6r4EUtI1Y8ckCEYZuW+O50Ye8i91X9yFzFiogCFmsXe5xzjcLx3KbRwlIeKf5I1J5O5dXkZHby+MN8jhA5NMGw/DuWRehLs+yvgOwB6vMAEdKeZ40+YKrOBCDkGlHqXHsHU96vNiVCmoz6RFidcEwc3Rt4LM+TU4anmWEudh/5b775OR6mS19/IxUPFD5Ar+3QaY3FySQWcYgBy7G86whHwYh+41h9/Gj56ysk6ZZ/WOP/QmfwKAInOasyXnJDAJ9mwXQe7mp8Azy0f8GD6o2LMc+7gw09W7jfWhvpin1zVNR/WrF7fOxlrYpTlpCz1LG1MDcOSI5V4PNQN9v+tipVf8gckVaCb0EcDU2lFvCNdr0XfI+XIoZjJrINGF0qzRDRcM7Q02ym2wxaFFAeR09xiM157ESDItveE7t1+N0mLFzXHdoEEMlS30lkYISnyVEZeoBLSdgClL87LmB6wICUBGVo09UFeBCu5RAiXZVj4YymKFRDtPpObOxzr9esAJHG8P5A1V6h0GR67cQWKDFA4y+TAfjgi9TiGJgHh0wrTTxGrLzWN1YzsLn0m943jNDIslVQtxHVr23z8VCthq3s2H3mhLl88lxUb+MQGpUuWgMlv86Q9/LJNHxr6we9xD+2tQRz/vc+AceKsES8nkh+795pKBzybM1zDI9v8guNvgyqMjHi1A9QQxVH7RUj0Vs1YDlOjcICQJuzvbvlQoH7L6i6Cn6oQ0x1+S30/iRCJhtqSO2Nql+OdF5jvqiRQ5CrufYJyXYpS9fCrt4d2aJUTeiT7BZbzEVo00g6PLQDWV1jNDKX2nMefTor1BD92/SgLmfI3JoDVs/qWEw2imSWZkjhMnZ/5zCdgeM4qzykNYePRspHrr9afgUKY8pfKqfKdsFn0IErS0dD0QTOZHvcpdHp4ME+xGF80buoTmkyb3pdctjl1MLKb5cdAO2SNTbOX2iLEOH5w7tMsIyTAAbp4QwjeGEx2NinlUqOGsmPX8zhEcYytj7ko1LfBp+ZsSMuZXznirgDcRgAJlc94UPv4XoAQwJadWBvsqli7BP3y/m/mm2rjs4b5naZsmYIhXBdMRLKJni+39BwwAW3TG2c5q32b4kK5ZlguIEafFYsJTLE6Qt/dcJ+DRN76vQivewRjkiee9LyjkDZsBw3+Dm3JNN6+MVSYVHLsQmu38aCH23D4NT4Q3w1YpEbuSyYEnXLGiV2D0M7b9OXEmvz5Bi9QtiKD+6Q3nOWMd6M3QL08gvFcvrX+/eyVed5WJLUaSY5qC8useiTw+z9H8Ux45skle45A0JBLlC/lI3b59kxrWmmgLvGSgj0M5X0fOedXTQAX3jrknKFWgx7KKj9ozLmc4kDf8YgLEfe+u6UKKJE/7zA37K1+tu2pBI1EGcN7G6p210EAo0Gndssj68oYPOjosoKTmtkfyelk161Ulr3bKavUtLTNTW8IC1euKBLei+PwpWb7jusXpb/46gYjzR4QJJUML4veiXEXpkDGYlHYjCGFcVrdw1tQBX0fu1z74k3KQuNEXbPMoDP8DdZyqDifjB9qYjj23ZVtgpnO4Kzcc6ABbsKWjN+GEcY5g1T9Q2EbW/JgiUu6IXUTp+GJnB50ao8bXDRrUZkaG0+E3ekfkRUuUoDB14uRIh3qUsbKCiwH1+S8MAD5+gliQOw0EVf7srhMW8DT+j7yEZyAESK7vEL7zzTUInI6YfkWA82qhIYi5NZyL/5c36yxdXcH1NX6gVyZjf/6ajlox4N8QfXbff3TuGnYE8mNcnupa6BGmolWd9Tu3seTPQ9gahDwxIWI7yCGm1QA6Eb3qonZAD36tAGcFvLDMltxo6ogOdxR40q/65r6f/6BXtIDyGDiWPup+Ohk55SAq9t5T3LrXWgMWD3D461g1cDCwmnKucjSus+3TvQkC44hi2odf6de3B07ou4W0UCSb6mXR4pywOnDHzPjZC7SiI9qRZ2hxYFNaMmEseSZkv/pgeS7TQvuyN1HXT3h3rOxVy6yPYzdmMW9CuWQsSaEpfVFRZ7POgxXspjOcZCpZgKZrz7c4bFoD3weWltC9AxNDsWSRv6YNdbcywW+Z8p6ZTtW5YdbnNh15egUY4qoHARUXZ2q+I1IVQUwt89mXVkqwpXKhyzX7PN0hPVO/T+tv/1jt+pNeoTurPOMf9IC2iteT2h6LR0qxUjS+xszHCFot0F/KfV+LmC8O4zlXkHIyqF7KsaLft5OmlRNzkoJSPScR3FYyrMbyZ8AXTwCYF+TcPKGkmkmtBKh1p1PmALW5mJ6M9swEdpOjjrh+UesSRIjtNKjlXdMmeMlMfdeggA6EL5VxnPIMPzZTKx0F/kUfhtVGyEQoXGzCkiFssesS5CYbw3T1UZ4IAhvsXZkhdRYDGtI+YJVFuNGqXKdc9iB3TUqAIjkdE+5jNca4Z7YgKZpFW9kXQ427apGm/MkV6jJG4+11tAgANkhfsEb4boR9Y5R9aHcXQksNuj9WQc6wDGo6XseqIEBJyk5iEjoVSnpARGzaNbk5Q4AvPUHGz0GyWGSmrLJsAMiG79Fr6MGBtoYUa/ur41jnrohdLb5UF3p/cOfnZGgWtT8zvclUjg+3AoprVdZLgwnpojIlB8zajjdD9vToNnVVCG/vPmb0dpMWmNrXTIWeJIeHGbzgyEWR4zMeCpkv+ra2hqolvLwyrOcNf6XgzWgPla/TfPXmrUIl+sUvlcyJwZXzQ29uFVmJ9icGgy71qeR+Jo6AQuHo5Ks9Csqrz4Fer52PIrXweI5te0gaFY2CAnVdUdPv4yvUTWk634Uj75UXWerWIT4dsgaZfTpeN3eVK91yqZ1RehSYLcsMJrddPksanzM7a2/WZMFHnixugFIfNgOwylKCHOdu9kFNcaV/qvmFmN0KE+pFsDO7tSDyOisXfavV4WTsJ+iQ0pucvsvIGMZ4hy8RrWPyHJHQVC+3WcYFE4sTriPKyWj8obv3oOccgOs7IYNSDd2fnEFFd7u6rPpBQHsSF8URSx9ubh5NSi3GIpxc8oErSnjXIeWaLlQcyqou1IWP8NbQ2h6yDiiL1k5WEH+H4WVNaE6oy5701hcmazGPwdOHxD19e/xhovKWpcjnNRiaC78r17/wpOezBYdayVJRJNJ+8cD/HcaqI5GN4S6p16p0uuF7+zPthq0Ms1J7Xr2o6nmanEgo2SBNT4qtIFdc34b627GMCBhEmSQQYp0l0s01G+cy1SH/b8rSuca1tgUy5oZBiY4M0/ZCYpiVnTZUX3F0LzwDoFA+ydA+KCjhTAJMk1L8frFvrv5zCklgsAz1EKomFktTi4/UTFSrxsuPY0Gfew4ZTf/MzZFwAfq0XTLc07P0MPy+Xf8nwcq/tDWjXXg24lgO8UjUEh1rm79u3Z0rMVcNz+TYsWzO9koEyCwl7DdKNranwRbciByw7zsf6CywiFiAOprwQBHuKSTYAfY8jwiZNUYWgjDf4n+p2x9vMXIyJ47n/NylFdiTVZQb4ZVMfQUiJp5QKIw4DYJMexjbTNj2liDvnDC0BQ1Jp8bY6Id5DriBPs9cQcXXXIIH2lRj5LMJ/cmIqi6a7d05nDxKksAzzm25yNKCmRj/jnjXy03X8aCuAyU8/GC8cswkwRg+6k/gq/q897/JuQtMYapcZrEtObJxuV2UmtTWoZx5kX7nFIzR5IRYZ/IFVeSbJXRencJJkIZ29Uh0ZTdJxNkYLUOdJAYCuz/cQT6sHpb3wpeHclgCfTFnQV1id7gDad9lHuwjMPUuNiaPf6aOkPvnMk305Tt1bjTZANx3FZ0nB0ESoWtLfrfh4ktKcC8UDJPgq5IWkl+Eyvss0nDDHTHOCO7aKuPaxRoVIP4WrJbKAjhHJhsCHA15hlqrN4vCpg1SM6d00TMFQR5uBxrDwhJ9024fs/HauADelgfSH2maEUHt5Xwwbg9LfoTI761AxL9+Co+5mrK4F/8K0yNPjFha3RZmmDEtLMFo9QvPZMPQhMF5ap8SjD4l25NZmA2LhZ4SC4seV8W9rnyX+VUB3LjuB4OoPYg9Hee0zDJ3rScdVPLaD2sAWdgVkj+9Gru1MbLDi2NBPNkLcf6ioAHDrI6gY25HMQkcKLQG7uz0KnkHpe8hZgxQXUCAEmMMRWXo/stzW1Z0a82Gi2DumfZbOKWbJnXbbbUWx7UEz3qnPCAMEXKxEMmJGfJdmzE8hI+ua3DsJDE7QKAkb1CmZh0GFfc3Eqpv95E7ZNs1k7YOwB6yofXc4vnaI3r1OPKDeVaDAgE++FKVVQjeAt8cHNCOumuDa/5J5aoC9TDzZ+puSjimh2XQlCyXmBeX5qPDYk/EMBzcCojGvRPYwTB8o1AqxnaxvidZFNg+8qVP6vJrqXoDb2COItDN/lypmK/Mvu99DX/gYplz5FUevXeP27IqqstHfpBDcDqYP7vnocsAUAd143CgtgckxzwnwqTM0ofC58omaeX3rYoIb2kj6Q9uxqMERChesxuzxunPOUcUXVGEXm6BzkmtUMhmE0u72YkudJQRlp60xXfgdKFFbCqRmSDyIuKPwLvgFopdx7Vmgzt4PK3tVcE4QaIWevbonDuxafJVYDtKuzI8chNdT3gblNcQJ3d1aUK/j5/LBmwkVbkZMw7lXjEvBdIy1Hxb+32dc5DtQd4xzWo2VP4SafY+sjDPNiQGgoewnlSrH/nP5BSXUu6JEVYPGGl+OCgVKfawLwWd+g8EGflEhFeipFxig6kruEaXrYkvnDM7pz5l/PAo07hUTVkV4dvkumUJYCqXfLqTQicIjRf3gw+kC0IodiFtM5yxAmb1/VQ0rgHq6gDWdAF2qP/5lLg8oEq0fukPRacePdoGMfiRF3vqaA/tnVPnf+wieWLp2FcS/11vLC1K0HpijD4TTZ6FXSV1NbqvnFHOmpxNXX445VYXfQzodCO6eUsxYSd5oJilvuGgR/AAS4ATOAZZeR3DoGd9jgc55g4NN1uaXvGoebzIjmvMbZRYijLOg/kePGSMr95uMdiRzi9Mt2NqaC2OBEDPbt6EO+j8cLTnVTKy/dCse6hK18kvIY6HpRNQvyaWrgqKUCEetXtFxBExIiWQz9WPdz8EXZpF/QweFJkVIJz1HKY/CNFt2XKGVdXkTyNqr8xsksvevAT41JFej4aLTA9o5wJtfU5AaZPOqnfOiz3NbixJ2w4cI+O1GtQqav6CFrcbEeVqiRMwE48hH3IJot10PddqQhuTOl9FG0E7zYBT83WQrtDhbOxrvxCgug4DsXGcRjuKu2A9jCLQ7UrASIQ6fgzi2TeUxpWEjn5+q345Wa+V7xwldkH8dgPuNkJ5OCwOnA7umouyBxzg7KUJJzdbTvx8xYVXK94145WFPr0sJ8PzHbG8yqIgdPSH4bYDbq8BIdEMaYhkkh2yCZymfqDE6gbsNxT8k6pwiPQgPi1ej9ljeWIYo7nFPn1hyVvhtowrrj5kcq/coOPAsAZ3O/CcjpqRHAjk88VrMhipFUZdVh/HmenxjAa9RCgpM6IoE+vq7nWypFcsqKt/Xwb5DPa8NOlPoBfPgRuqiJ1qpXjjG54+J630xXvFQ5z2zSnbqIo9010khhm+ppWSB6/dR3nzk0LeL2kgsEyf1FM6idbTLoMhszX5GEMaEFyEd07t3ULk0enWxScNABBw7a6+32AGUSjsOpOTlMw6ITTKiLTmTFJrJbeHTu8jpij9GTOerFWCF+B6zKjXhEctHRMGqOhURxaV1m+HrHvOoJ38skj7Ro5/VYJSkIi1KQp9U/x/sWzpxWGFauPdP4X1OBRqIcRoUSnZseSkCR451PrqAyDL/Xq3aNI9Is4PPPpiyWIMKYNsGeB87u8egehjCOi4huoyGKZwr68LSMnS0HPP6WIICUkS1I9APdQBb5mYhFWY9jAEvQahpDkVQWZNDiS1rUQFgrq4JhwAbwPob2ZEBXwAFB1vXE3bEcR1F2eDE+VcYQn0lsqttdz/spaWV7NFd4tJBMSf+qU+p0tOlN5JWCuZyRBk8Jn0qXDEY3bggF8SlHM9de7+xzczuFmsTY2NJRGZOcuZ9lrNR+uF9RdDaGegKWsuZTmNv3cSFQJXKYFvlGhDtOViFY5joBBfbMaiYGbEqmSFsTF2pzYWBsinOCetvm3/GBiNbZy2AMI5CvPB2M4ezao+uHoeBQi4XN1H76CPHHu6z/KqnMJ5FRF0E7hnd69ryqBLbbD+xoomM8WtBwFvCT5y9Ds9E4q5W0IN2ZgPzERFehYLvNtMpQ6e/2o2Ke8rqy27JVKwnP7ems2OiaRxTqs1DdJClrpSMnUQ0OEDKOLqF4ahC5qu+P3HgZfi3Uj+9QV94n+GCLRMP6L0/LQ2Wa6XJMTM+JyDorQWhR1aHdN6vIHj5ELRnL6VxtPJF4cKCLB5lojGwYeF3m3RjNB0PqTHQdQJ6DUj9CraaKZiEbsrJDeytkuf+Tely2lkvRcTNy/UgkiWsiaeIfB8d2C+YGj0McwO2eDkjhZI3Cxg8sEh7z0Y8EHClPAqcjtoKBO+/ydBDFlqSUFduBFf84R9iSOG5cUiO0S6K2+iw9w566bjcQXEQbC544tCQTAVYWcZ1ymum8dlTijgXKMXpYEHHTra5zB4DW4RY4bV7mZsKtw7FVgyJEVhLgexCIFAAP1Y63r2edZGFfwnrM244VAsbMGa04dQGjJVQ2IK6fqjtuFh/zeXe4L+790ehHXWwyNZDP4+XccuUiUlQM1AQ+PHmc9IXJQsfMljHwcO8Yj68IF8jCDUzGzg32EtJFM07dpvr3/C1kchP3fkq/PeWoD0L9yXOtAW+XA8/L9juANP/ghhEb+hZ6nmsiWm5m6B54ObMBmho2VDai9vzTeRZ9tTBiPcai3yI4cYFSKhZSNfNADo67q1ibLrDfwOEVwFK9SFx9W2umKRD7dUd0mMeldvkIxhW7JVnoS7CHA2iMxi7C3XCcsHiqpTOmyVT5JI1vvk73K/Q9BJoRfNevN91efeRxv6GwvfJJSF7vrH/2rSqNSzgW76VmX9zV97n0agLXo1oDQ/820NcDmnRu/ikUre8Q33FagiAUjRrMVe0liSgb7IYhUepr/HS+mErl6nJqh4/9s9NABUVWlMZlieqTVdxXPF3URdW34C3MOyfPxXM2T6YLngaoGuIi1PPEUUYmaZTaB7hTRwG+7JumypIZTR+87uK91dQUDlaBOjZ0scPLm4MfbHmqdypqg+eMJY96SEb7ujO/idCHBA0EzSFWKkIsFwGRFrFF3yBkmEavpPdgdEiu7HPhsOnPGrv3USdZbmlg1HTPhrUsMNVusAp1al9+REdFhYdH7HtecmbGTwezB/zBBGxYXzifn+uJkR5N1hwIi86ElsD3FisAeOXXKrsIeTuxcRG4sAavkU886n+4s80QNyPu2VbByKzMopFEVBVooJtNlMFH4pqWM18XNWre3KOg40c6C5EylxjwYPkQxvj3pF1P+nU63S2qi9OaGcNk/aAItUKYo84i3lsEnhfQFIHiUdTw9Kn4yTyzpizkjbPFHs8H1unizmDs3SjCmPXKRzEIxIMXYaf9OEpKWvhoaM73uzOi7xbUQ39QS9p7qYVTAEWpM80L8O4C2kze8YOulQe/sfzyan/7EYKUpFqblWo8tbiYoxdJH318Q+aGpJFhqBsouBM1CCEzvkqNegNaizj7/TJioIiFU9L5uqTtTjD5rTaOTNZgAPqXF5TmKu4iNjhgbSwGA9M9uRND/9ZOUPTfvYbbGp8Vb+8qurMk3/3sYu2FnKHzZHsyYxvZ7EGM97wCW3SrWEc6GGzV7xnF9BfrlfSoCr32CF2K86TdMtegMDGH2jBvSlezQ7eJDoaVEKck6DuAMZMAFzieYz29BROmo= </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【暂不公开】记录大数据量 3dsMax 精细模型处理及可视化方法。
    
    </summary>
    
      <category term="三维技术" scheme="https://www.wshunli.com/categories/%E4%B8%89%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Cesium" scheme="https://www.wshunli.com/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（八）</title>
    <link href="https://www.wshunli.com/posts/b96eb139.html"/>
    <id>https://www.wshunli.com/posts/b96eb139.html</id>
    <published>2018-04-28T06:47:46.000Z</published>
    <updated>2018-06-05T09:20:28.125Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】面试官们不错，脸上总是笑嘻嘻
    
    </summary>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="https://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年春季阿里云实习生面试</title>
    <link href="https://www.wshunli.com/posts/b3a8426.html"/>
    <id>https://www.wshunli.com/posts/b3a8426.html</id>
    <published>2018-04-28T03:03:38.000Z</published>
    <updated>2018-06-05T09:20:28.129Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码（aliyun）查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码（aliyun）查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【密码公开】记录2018年春阿里巴巴●阿里云暑期实习生面试（技术岗）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
