<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2018-01-24T15:17:45.131Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机基础-计算机操作系统（一）</title>
    <link href="http://www.wshunli.com/posts/b4e3c990.html"/>
    <id>http://www.wshunli.com/posts/b4e3c990.html</id>
    <published>2018-01-22T05:13:26.000Z</published>
    <updated>2018-01-24T15:17:45.131Z</updated>
    
    <content type="html"><![CDATA[<p>还要几天才能回家，就先看看计算机操作系统的内容<a id="more"></a> ，继续朝着目标前进。</p><p><strong>具备扎实的数据结构和计算机系统基础，编码功底扎实</strong>。</p><p>这次选择的课本是《计算机操作系统》（第三版），主编是汤小丹老师。</p><h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><p>计算机系统由硬件和软件两部分组成。<br>操作系统(OS，Operating System)是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。</p><p>从一般用户的观点，可把 OS 看做是用户与计算机硬件系统之间的接口；<br>从资源管理的观点看，则可把 OS 视为计算机系统资源的管理者。<br>另外，OS 实现了对计算机资源的抽象，隐藏了对硬件操作的细节，使用户能更方便地使用机器。</p><p>未完待续。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还要几天才能回家，就先看看计算机操作系统的内容
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="《计算机操作系统》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（六）</title>
    <link href="http://www.wshunli.com/posts/9c05eee5.html"/>
    <id>http://www.wshunli.com/posts/9c05eee5.html</id>
    <published>2018-01-22T02:44:25.000Z</published>
    <updated>2018-01-24T15:17:45.131Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】生活是一条路，走走停停，停停走走
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK 开发入门</title>
    <link href="http://www.wshunli.com/posts/3eae2406.html"/>
    <id>http://www.wshunli.com/posts/3eae2406.html</id>
    <published>2018-01-19T13:00:14.000Z</published>
    <updated>2018-01-24T15:17:45.123Z</updated>
    
    <content type="html"><![CDATA[<p>Android NDK 是一套允许您使用原生代码语言（例如 C 和 C++）实现部分应用的工具集。<a id="more"></a>在开发某些类型应用时，这有助于您重复使用以这些语言编写的代码库。</p><p>那我们为什么要使用 NDK 呢?</p><ul><li>代码的保护。由于 apk 的 Java 层代码很容易被反编译，而 C/C++ 库反汇难度较大。</li><li>可以方便地使用现存的开源库。大部分现存的开源库都是 用C/C++ 代码编写的。</li><li>提高程序的执行效率。将要求高性能的应用逻辑使用 C 开发，从而提高应用程序的执行效率。</li><li>便于移植。用 C/C++ 写得库可以方便在其他的嵌入式平台上再次使用。</li></ul><p>上述文字致谢 <a href="http://www.cnblogs.com/devinzhang/archive/2012/02/29/2373729.html" rel="external nofollow noopener noreferrer" target="_blank">Devin Zhang</a> 提供理论支持</p><p>本文默认已配置好 Android 开发环境，<br>关于 Android 开发环境配置可参考：<a href="http://www.wshunli.com/posts/f6977dbb.html">http://www.wshunli.com/posts/f6977dbb.html</a></p><h1 id="NDK-环境配置"><a href="#NDK-环境配置" class="headerlink" title="NDK 环境配置"></a>NDK 环境配置</h1><p>1、首先应该下载 NDK</p><p>官方指定的下载地址：<a href="https://developer.android.google.cn/ndk/downloads/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.google.cn/ndk/downloads/index.html</a></p><p>可能因为网络原因打不开，而且我们也不要那么新的。</p><p>本文以 Android NDK r10e 版本为例：</p><p>下载地址：<a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" rel="external nofollow noopener noreferrer" target="_blank">https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip</a></p><p>下载好之后，解压即可，我们解压到：<code>D:\Android\android-ndk-r10e</code></p><p>2、和配置 Android 环境类似，配置 NDK 环境</p><p>新建变量：<code>ANDROID_NDK</code></p><pre><code class="TXT">D:\Android\android-ndk-r10e</code></pre><p>在 <code>Path</code> 中添加</p><pre><code class="TXT">%ANDROID_NDK%</code></pre><p>3、验证 NDK 环境</p><p>在 命令控制符 中输入 <code>ndk-build -version</code> 存在输出即可。</p><h1 id="第一个-Android-NDK-项目"><a href="#第一个-Android-NDK-项目" class="headerlink" title="第一个 Android NDK 项目"></a>第一个 Android NDK 项目</h1><p>在 Android Studio 中新建 Android NDK 项目特别简单，</p><p>只需在新建项目时，勾选 <code>include C++ support</code> 即可：</p><p><img src="https://img.wshunli.com/Android/NDK/1.新建NDK项目.png" alt="1.新建NDK项目.png"></p><p>点击运行即可看到效果：</p><p><img src="https://img.wshunli.com/Android/NDK/1.Screenshot_1516414188.png-hexo.png" alt="1.Screenshot_1516414188.png"></p><h1 id="向现有项目添加-C-C-代码"><a href="#向现有项目添加-C-C-代码" class="headerlink" title="向现有项目添加 C/C++ 代码"></a>向现有项目添加 C/C++ 代码</h1><p>如果您希望向现有项目添加原生代码，请执行以下步骤：</p><p>1、<a href="#创建新的原生源文件">创建新的原生源文件</a>并将其添加到您的 Android Studio 项目中。</p><p>如果您已经拥有原生代码或想要导入预构建的原生库，则可以跳过此步骤。</p><p>2、<a href="#创建CMake构建脚本">创建 CMake 构建脚本</a>，将您的原生源代码构建到库中。如果导入和关联预构建库或平台库，您也需要此构建脚本。</p><p>如果您的现有原生库已经拥有 <code>CMakeLists.txt</code> 构建脚本或者使用 ndk-build 并包含 Android.mk 构建脚本，则可以跳过此步骤。</p><p>3、提供一个指向您的 CMake 或 ndk-build 脚本文件的路径，<a href="#将Gradle关联到您的原生库">将 Gradle 关联到您的原生库</a>。Gradle 使用构建脚本将源代码导入您的 Android Studio 项目并将原生库（SO 文件）打包到 APK 中。</p><h2 id="创建新的原生源文件"><a href="#创建新的原生源文件" class="headerlink" title="创建新的原生源文件"></a>创建新的原生源文件</h2><p>1、选择 Project 视图，在 main 目录下，新建 cpp 文件夹；</p><p>2、在 cpp 文件夹下新建 C/C++ Source File ，本文以 <code>native-lib</code> 为例。</p><p><img src="https://img.wshunli.com/Android/NDK/1.创建新的原生源文件.png" alt="1.创建新的原生源文件.png"></p><h2 id="创建CMake构建脚本"><a href="#创建CMake构建脚本" class="headerlink" title="创建CMake构建脚本"></a>创建CMake构建脚本</h2><p>CMake 构建脚本是一个纯文本文件，您必须将其命名为 CMakeLists.txt。</p><p>在 Android 视图下，在 app 模块下右键，新建 File，文件名为 <code>CMakeLists.txt</code>。</p><p>文件内容如下：</p><pre><code class="TXT"># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)# 指示 CMake 从原生源代码创建一个原生库add_library( # Sets the name of the library.             native-lib             # Sets the library as a shared library.             SHARED             # Provides a relative path to your source file(s).             src/main/cpp/native-lib.cpp )# 添加引用 NDK 库find_library( # Sets the name of the path variable.              log-lib              # Specifies the name of the NDK library that              # you want CMake to locate.              log )# 关联 NDK 库target_link_libraries( # Specifies the target library.                       native-lib                       # Links the target library to the log library                       # included in the NDK.                       ${log-lib} )</code></pre><h2 id="将Gradle关联到您的原生库"><a href="#将Gradle关联到您的原生库" class="headerlink" title="将Gradle关联到您的原生库"></a>将Gradle关联到您的原生库</h2><p>在 Android 视图下，右键点击您想要关联到原生库的模块（例如 app 模块），并从菜单中选择 <code>Link C++ Project with Gradle</code>。</p><p><img src="https://img.wshunli.com/Android/NDK/1.将Gradle关联到您的原生库.png" alt="1.将Gradle关联到您的原生库.png"></p><p>或者手动配置：</p><pre><code class="Gradle">android {  ...  defaultConfig {...}  buildTypes {...}  // Encapsulates your external native build configurations.  externalNativeBuild {    // Encapsulates your CMake build configurations.    cmake {      // Provides a relative path to your CMake build script.      path &quot;CMakeLists.txt&quot;    }  }}</code></pre><p>可选配置，可以包裹一些特定的示例代码：</p><pre><code class="Gradle">android {    compileSdkVersion 26    defaultConfig {        ···        externalNativeBuild {            cmake {                cppFlags &quot;-frtti -fexceptions&quot;            }        }        ndk {            // Specifies the ABI configurations of your native            // libraries Gradle should build and package with your APK.            abiFilters &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi&#39;, &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;        }    }</code></pre><p>最后运行即可，效果是一样的。</p><h1 id="添加-native-方法流程"><a href="#添加-native-方法流程" class="headerlink" title="添加 native 方法流程"></a>添加 native 方法流程</h1><p>在 <code>MainActivity</code> 中添加 native 方法：</p><pre><code class="Java">    public native void printLog();</code></pre><p>在 <code>native-lib.cpp</code> 中添加头文件及宏定义</p><pre><code class="C">#include &lt;android/log.h&gt;#define TAG &quot;native-lib&quot;#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, TAG, __VA_ARGS__)</code></pre><p>实现 native 方法，我们这里打印个日志：</p><pre><code class="C">extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_wshunli_android_ndk_demo_MainActivity_printLog(JNIEnv *env, jobject instance) {    LOGV(&quot;log from native&quot;);}</code></pre><p>这个方法可以自动生成，在 native 方法下 <code>Alt + Enter</code> 即可。</p><p>本文源码：<a href="https://github.com/wshunli/android-ndk-demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/android-ndk-demo</a></p><blockquote><p>参考资料<br>1、Android NDK | Android Developers<br><a href="https://developer.android.com/ndk/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/ndk/index.html</a><br>2、Android-NDK入门-慕课网<br><a href="https://www.imooc.com/learn/411" rel="external nofollow noopener noreferrer" target="_blank">https://www.imooc.com/learn/411</a><br>3、Android-NDK进阶-慕课网<br><a href="https://www.imooc.com/learn/918" rel="external nofollow noopener noreferrer" target="_blank">https://www.imooc.com/learn/918</a><br>4、Android NDK开发(一) 入门 - 简书<br><a href="https://www.jianshu.com/p/0261e6cceb3e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0261e6cceb3e</a><br>5、向您的项目添加 C 和 C++ 代码 | Android Studio<br><a href="https://developer.android.com/studio/projects/add-native-code.html?hl=zh-cn" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/studio/projects/add-native-code.html?hl=zh-cn</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android NDK 是一套允许您使用原生代码语言（例如 C 和 C++）实现部分应用的工具集。
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="NDK" scheme="http://www.wshunli.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android图片加载框架Glide简单使用</title>
    <link href="http://www.wshunli.com/posts/d82d8606.html"/>
    <id>http://www.wshunli.com/posts/d82d8606.html</id>
    <published>2018-01-19T12:14:17.000Z</published>
    <updated>2018-01-24T15:17:45.123Z</updated>
    
    <content type="html"><![CDATA[<p>Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。<a id="more"></a>Glide 提供了易用的 API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p><h1 id="Glide-介绍"><a href="#Glide-介绍" class="headerlink" title="Glide 介绍"></a>Glide 介绍</h1><p>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</p><p>虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。</p><h1 id="Glide-简单使用"><a href="#Glide-简单使用" class="headerlink" title="Glide 简单使用"></a>Glide 简单使用</h1><p>0、添加 Glide 依赖</p><pre><code class="gradle">dependencies {  implementation &#39;com.github.bumptech.glide:glide:4.5.0&#39;  annotationProcessor &#39;com.github.bumptech.glide:compiler:4.5.0&#39;}</code></pre><p>1、准备图片容器</p><p>我们在布局文件中添加 ImageView 控件：</p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;vertical&quot;    android:background=&quot;#8f8f8f&quot;    tools:context=&quot;com.wshunli.glidedemo.MainActivity&quot;&gt;    &lt;Button        android:id=&quot;@+id/bt&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;@string/app_name&quot; /&gt;    &lt;ImageView        android:id=&quot;@+id/img&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>2、加载图片</p><p>我们以加载 <a href="https://img.wshunli.com/Android/Glide/Glide.min.png" rel="external nofollow noopener noreferrer" target="_blank">https://img.wshunli.com/Android/Glide/Glide.min.png</a> 为例。</p><pre><code class="Java">Glide.with(MainActivity.this)        .load(&quot;https://img.wshunli.com/Android/Glide/Glide.min.png&quot;)        .into(img);</code></pre><p>真的超级简单。</p><p>MainActivity 完整代码如下：</p><pre><code class="Java">package com.wshunli.glidedemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.ImageView;import com.bumptech.glide.Glide;public class MainActivity extends AppCompatActivity {    private ImageView img;    private Button bt;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        img = findViewById(R.id.img);        bt = findViewById(R.id.bt);        bt.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Glide.with(MainActivity.this)                        .load(&quot;https://img.wshunli.com/Android/Glide/Glide.min.png&quot;)                        .into(img);            }        });    }}</code></pre><p>注意别忘了声明权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></pre><p>3、取消加载图片</p><pre><code class="Java">Glide.with(MainActivity.this).clear(img);</code></pre><p>取消加载也超级简单。</p><p>4、最终加载效果</p><p><img src="https://img.wshunli.com/Android/Glide/Screenshot_1516366180.png-hexo.png" alt="Glide加载图图片"></p><h1 id="ProGuard-混淆规则"><a href="#ProGuard-混淆规则" class="headerlink" title="ProGuard 混淆规则"></a>ProGuard 混淆规则</h1><pre><code class="gradle">-keep public class * implements com.bumptech.glide.module.GlideModule-keep public class * extends com.bumptech.glide.module.AppGlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {  **[] $VALUES;  public *;}# for DexGuard only-keepresourcexmlelements manifest/application/meta-data@value=GlideModule</code></pre><blockquote><p>参考资料<br>1、bumptech/glide: An image loading and caching library for Android focused on smooth scrolling<br><a href="https://github.com/bumptech/glide" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/bumptech/glide</a><br>2、Android图片加载框架最全解析（一），Glide的基本用法 - 郭霖的专栏 - CSDN博客<br><a href="http://blog.csdn.net/guolin_blog/article/details/53759439" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/guolin_blog/article/details/53759439</a><br>3、Glide v4 : 快速高效的Android图片加载库<br><a href="https://muyangmin.github.io/glide-docs-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://muyangmin.github.io/glide-docs-cn/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="Glide" scheme="http://www.wshunli.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Android注入框架Butter Knife使用入门</title>
    <link href="http://www.wshunli.com/posts/896cb4b5.html"/>
    <id>http://www.wshunli.com/posts/896cb4b5.html</id>
    <published>2018-01-18T04:54:15.000Z</published>
    <updated>2018-01-24T15:17:45.123Z</updated>
    
    <content type="html"><![CDATA[<p>Butter Knife 是一个专注于 Android 系统的 View 注入框架<a id="more"></a>，可以减少大量的 findViewById 以及 setOnClickListener 代码，可视化一键生成。</p><h1 id="Butter-Knife-概述"><a href="#Butter-Knife-概述" class="headerlink" title="Butter Knife 概述"></a>Butter Knife 概述</h1><p>1.强大的View绑定和Click事件处理功能，简化代码，提升开发效率<br>2.方便的处理Adapter里的ViewHolder绑定问题<br>3.运行时不会影响APP效率，使用配置方便<br>4.代码清晰，可读性强</p><h1 id="Butter-Knife-上手使用"><a href="#Butter-Knife-上手使用" class="headerlink" title="Butter Knife 上手使用"></a>Butter Knife 上手使用</h1><p>0、首先为项目添加 Butter Knife 依赖：</p><pre><code class="gradle">dependencies {  compile &#39;com.jakewharton:butterknife:8.8.1&#39;  annotationProcessor &#39;com.jakewharton:butterknife-compiler:8.8.1&#39;}</code></pre><p>1、简单使用示例:</p><p>首先在 onCreate 绑定 Activity 实例。</p><pre><code class="Java">package com.wshunli.butterknifedemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.Button;import android.widget.Toast;import butterknife.BindString;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;public class MainActivity extends AppCompatActivity {    @BindView(R.id.button)    Button button;    @BindString(R.string.app_name)    String appName;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ButterKnife.bind(this);    }    @OnClick(R.id.button)    void clickButton() {        Toast.makeText(this, appName, Toast.LENGTH_LONG).show();    }}</code></pre><p>其中：<code>@BindView</code> 根据控件 id 绑定；<code>@BindString</code> 绑定资源中的字符串；<code>@OnClick</code> 绑定按钮的单击事件。</p><p>3、最终效果：</p><p>点击按钮，显示app名称。</p><p><img src="https://img.wshunli.com/Android/ButterKnife/Screenshot_1516251143.png-hexo.png" alt="最终效果"></p><h1 id="Butter-Knife-方法详解"><a href="#Butter-Knife-方法详解" class="headerlink" title="Butter Knife 方法详解"></a>Butter Knife 方法详解</h1><p>1、绑定 Activity 和 Fragment</p><p>在 onCreate 中绑定 Activity</p><pre><code class="Java">@Override public void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.simple_activity);    ButterKnife.bind(this);    // TODO Use fields...  }</code></pre><p>在 onCreateView 中绑定 Fragment</p><pre><code class="Java"> @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {    View view = inflater.inflate(R.layout.fancy_fragment, container, false);    ButterKnife.bind(this, view);    // TODO Use fields...    return view;  }</code></pre><p>2、绑定布局中的 View</p><pre><code class="Java">  @BindView(R.id.title) TextView title;  @BindView(R.id.subtitle) TextView subtitle;  @BindView(R.id.footer) TextView footer;</code></pre><p>3、在 Adapter ViewHolder 中绑定 View</p><pre><code class="Java">  static class ViewHolder {    @BindView(R.id.title) TextView name;    @BindView(R.id.job_title) TextView jobTitle;    public ViewHolder(View view) {      ButterKnife.bind(this, view);    }  }</code></pre><p>4、绑定资源</p><pre><code class="Java">  @BindString(R.string.title) String title;  @BindDrawable(R.drawable.graphic) Drawable graphic;  @BindColor(R.color.red) int red; // int or ColorStateList field  @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field  // ...</code></pre><p>5、绑定方法</p><pre><code class="Java">@OnClick(R.id.submit)public void submit() {  // TODO submit data to server...}</code></pre><p>或者</p><pre><code class="Java">@OnClick(R.id.submit)public void submit(View view) {  // TODO submit data to server...}</code></pre><p>甚至自动类型转换：</p><pre><code class="Java">@OnClick(R.id.submit)public void sayHi(Button button) {  button.setText(&quot;Hello!&quot;);}</code></pre><p>多个 View 绑定同一个事件：</p><pre><code class="Java">@OnClick({ R.id.door1, R.id.door2, R.id.door3 })public void pickDoor(DoorView door) {  if (door.hasPrizeBehind()) {    Toast.makeText(this, &quot;You win!&quot;, LENGTH_SHORT).show();  } else {    Toast.makeText(this, &quot;Try again&quot;, LENGTH_SHORT).show();  }}</code></pre><p>本文内容基于 Butter Knife 8.8.1 ，时间原因部分方法可能过时，最新版可参考 <a href="http://jakewharton.github.io/butterknife/" rel="external nofollow noopener noreferrer" target="_blank">http://jakewharton.github.io/butterknife/</a></p><blockquote><p>参考资料<br>1、JakeWharton/butterknife: Bind Android views and callbacks to fields and methods.<br><a href="https://github.com/JakeWharton/butterknife" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/JakeWharton/butterknife</a><br>2、ButterKnife使用详解 - ITjianghuxiaoxiong的专栏 - CSDN博客<br><a href="http://blog.csdn.net/itjianghuxiaoxiong/article/details/50177549" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/itjianghuxiaoxiong/article/details/50177549</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Butter Knife 是一个专注于 Android 系统的 View 注入框架
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="ButterKnife" scheme="http://www.wshunli.com/tags/ButterKnife/"/>
    
  </entry>
  
  <entry>
    <title>Android事件总线EventBus使用总结</title>
    <link href="http://www.wshunli.com/posts/6a115a99.html"/>
    <id>http://www.wshunli.com/posts/6a115a99.html</id>
    <published>2018-01-17T04:36:06.000Z</published>
    <updated>2018-01-24T15:17:45.123Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus是一款针对Android优化的<strong>发布/订阅</strong>事件总线<a id="more"></a>，简化了应用程序内各组件间、组件与后台线程间的通信。</p><p><img src="https://img.wshunli.com/Android/EventBus/EventBus-Publish-Subscribe.min.png" alt="EventBus 发布订阅模式"></p><p>主要是替代 handler BroadCast 在 Fragment 、Activity 、Service 线程之间传递消息。</p><h1 id="EventBus-概述"><a href="#EventBus-概述" class="headerlink" title="EventBus 概述"></a>EventBus 概述</h1><p>1、EventBus 有三个主要的元素：</p><ul><li>Event：事件，可以是任意类型的对象。</li><li>Subscriber：事件订阅者，<del>在EventBus3.0之前消息处理的方法只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，他们分别代表四种线程模型</del>。而在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING），四种线程模型下面会讲到。</li><li>Publisher：事件发布者，可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法。可以自己实例化EventBus对象，但一般使用EventBus.getDefault()就好了，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</li></ul><p>2、EventBus3.0有以下四种ThreadMode（线程模型）：</p><ul><li>POSTING（默认）：<strong>发布事件和接收事件在同一个线程</strong>，也就是说该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行。</li><li>MAIN: 事件的处理<strong>总是在UI线程</strong>中执行。</li><li>ASYNC：无论事件在哪个线程发布，该事件处理函数<strong>总是在新建的子线程</strong>中执行，同样，此事件处理函数中禁止进行UI更新操作。</li><li>BACKGROUND：如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。</li></ul><h1 id="EventBus-快速入门"><a href="#EventBus-快速入门" class="headerlink" title="EventBus 快速入门"></a>EventBus 快速入门</h1><p>0、首先为项目添加 EventBus 依赖：</p><pre><code class="gradle">compile &#39;org.greenrobot:eventbus:3.1.1&#39;</code></pre><p>1、定义事件类:</p><pre><code class="java">public static class MessageEvent { /* Additional fields if needed */ }</code></pre><p>2、准备订阅者:</p><pre><code class="java">@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(MessageEvent event) {/* Do something */};</code></pre><p>3、发送事件:</p><pre><code class="java">EventBus.getDefault().post(new MessageEvent());</code></pre><h1 id="EventBus-实际应用"><a href="#EventBus-实际应用" class="headerlink" title="EventBus 实际应用"></a>EventBus 实际应用</h1><p>这里举例子具体介绍 EventBus 的用法，实现Activity之间传值。</p><p>1、定义消息事件类</p><pre><code class="java">package com.wshunli.eventbusdemo;public class MessageEvent {    private String message;    public MessageEvent(String message) {        this.message = message;    }    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }    @Override    public String toString() {        return &quot;MessageEvent{&quot; +                &quot;message=&#39;&quot; + message + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>2、注册和取消订阅事件</p><p>根据组件的声明周期，在 MainActivity.java 中注册/取消订阅事件。</p><pre><code class="java">package com.wshunli.eventbusdemo;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;import android.widget.Toast;import org.greenrobot.eventbus.EventBus;import org.greenrobot.eventbus.Subscribe;import org.greenrobot.eventbus.ThreadMode;public class MainActivity extends AppCompatActivity {    private TextView textView;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        // 注册订阅事件        EventBus.getDefault().register(this);        // 跳转到 SecondActivity        findViewById(R.id.bt).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                startActivity(new Intent(MainActivity.this, SecondActivity.class));            }        });        textView = findViewById(R.id.text);    }    @Override    protected void onDestroy() {        super.onDestroy();        // 取消订阅事件        EventBus.getDefault().unregister(this);    }}</code></pre><p>3、添加消息处理函数</p><p>在 MainActivity.java 中添加事件的处理函数：</p><pre><code class="java">    @Subscribe(threadMode = ThreadMode.MAIN)    public void onMessageEvent(MessageEvent event) {        textView.setText(String.format(&quot;接收到发送的事件：%s&quot;, event.getMessage()));    }</code></pre><p>我们选择 <code>threadMode = ThreadMode.MAIN</code> 表示总是在 <strong>主线程</strong> 中执行。</p><p>4、发布事件</p><p>在 SecondActivity 中发布事件：</p><pre><code class="java">package com.wshunli.eventbusdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import org.greenrobot.eventbus.EventBus;public class SecondActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_second);        findViewById(R.id.bt).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                EventBus.getDefault().post(new MessageEvent(&quot;来自SecondActivity的消息&quot;));                finish();            }        });    }}</code></pre><p>5、接收到消息</p><p>在 MainActivity 接受到来自 SecondActivity 中发送的消息：</p><p><img src="https://img.wshunli.com/Android/EventBus/Screenshot_1516247350.png-hexo.png" alt="EventBus消息"></p><h1 id="ProGuard-混淆规则"><a href="#ProGuard-混淆规则" class="headerlink" title="ProGuard 混淆规则"></a>ProGuard 混淆规则</h1><pre><code class="gradle">-keepattributes *Annotation*-keepclassmembers class ** {    @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;}-keep enum org.greenrobot.eventbus.ThreadMode { *; }# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {    &lt;init&gt;(java.lang.Throwable);}</code></pre><blockquote><p>参考资料<br>1、greenrobot/EventBus: Event bus for Android and Java that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality.<br><a href="https://github.com/greenrobot/EventBus" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/greenrobot/EventBus</a><br>2、Android事件总线（一）EventBus3.0用法全解析 - 刘望舒的专栏 - CSDN博客<br><a href="http://blog.csdn.net/itachi85/article/details/52205464" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/itachi85/article/details/52205464</a><br>3、EventBus 3.0的用法详解（一） - neu - SegmentFault<br><a href="https://segmentfault.com/a/1190000004279679" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000004279679</a><br>4、Android事件分发库的使用-慕课网<br><a href="https://www.imooc.com/learn/871" rel="external nofollow noopener noreferrer" target="_blank">https://www.imooc.com/learn/871</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus是一款针对Android优化的&lt;strong&gt;发布/订阅&lt;/strong&gt;事件总线
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="EventBus" scheme="http://www.wshunli.com/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>ClassNotFoundException</title>
    <link href="http://www.wshunli.com/posts/774f73e1.html"/>
    <id>http://www.wshunli.com/posts/774f73e1.html</id>
    <published>2018-01-10T12:23:30.000Z</published>
    <updated>2018-01-24T15:17:45.123Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ClassNotFoundException</strong> 是 java.lang.ClassNotFoundException 的简称<a id="more"></a>，是 Java 语言中的一个异常类，位于 java.lang 包中，父类是 java.lang.ReflectiveOperationException ，该异常指找不到指定的 Class。</p><p>常见的场景就是：</p><p>1 调用class的forName方法时，找不到指定的类。<br>2 ClassLoader 中的 findSystemClass() 方法时，找不到指定的类。<br>3 ClassLoader 中的 loadClass() 方法时，找不到指定的类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ClassNotFoundException&lt;/strong&gt; 是 java.lang.ClassNotFoundException 的简称
    
    </summary>
    
      <category term="技术分享" scheme="http://www.wshunli.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="ClassNotFoundException" scheme="http://www.wshunli.com/tags/ClassNotFoundException/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 从入门到放弃：Hello Spring Boot !</title>
    <link href="http://www.wshunli.com/posts/b93d59e.html"/>
    <id>http://www.wshunli.com/posts/b93d59e.html</id>
    <published>2018-01-05T03:19:35.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 入门 Hello Spring Boot !</p><a id="more"></a><p>前面在师兄的带领下，基于 nodejs 写了机房管理系统后端，也根据需要实现了简单三维重建的后端服务。<br>但是总感觉怪怪的，前者基于 Eggjs 后端框架，后者基于 Express 后端框架，好像跟 Java 没啥关系啊。</p><p>这几天刻意学习下 Spring Boot 后端框架，并把三维重建服务后端重写了。下面记录下学习过程。</p><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><p>Spring Boot 可以使用 Maven 或 Gradle 这样的构建系统，本文是基于 Maven（现在用得比较多，其实我更熟悉Gradle）。</p><h2 id="Spring-Boot-特性"><a href="#Spring-Boot-特性" class="headerlink" title="Spring Boot 特性"></a>Spring Boot 特性</h2><p>Spring将很多魔法带入了 Spring 应用程序的开发之中，其中最重要的是以下四个核心。</p><ul><li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置。</li><li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li><li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。</li><li>Actuator：让你能够深入运行中的Spring Boot应用程序，一探究竟。</li></ul><h2 id="Spring-Boot-环境"><a href="#Spring-Boot-环境" class="headerlink" title="Spring Boot 环境"></a>Spring Boot 环境</h2><p>首先 Spring Boot 需要 java 环境，需要使用 Gradle 2.3+ 或者 Maven 3.0+ 构建。</p><p>本文环境是 Java 1.8，Spring Boot (v1.5.9.RELEASE) 以及 Maven3.3.9 构建。开发工具使用 IntelliJ IDEA。</p><h1 id="初始化Spring-Boot项目"><a href="#初始化Spring-Boot项目" class="headerlink" title="初始化Spring Boot项目"></a>初始化Spring Boot项目</h1><p>本文使用 Spring Initializr 初始化 Spring Boot项目。</p><h2 id="通过-Spring-官网"><a href="#通过-Spring-官网" class="headerlink" title="通过 Spring 官网"></a>通过 Spring 官网</h2><p>1、打开 <a href="http://start.spring.io/" rel="external nofollow noopener noreferrer" target="_blank">http://start.spring.io/</a></p><p>2、选择构建工具 Maven Project、Spring Boot版本1.5.9 以及一些依赖，输入 Web 即可，如下图所示：</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/1.png" alt="初始化Spring Boot项目"></p><p>3、点击 <code>Generate Project</code> 即可下载项目压缩包</p><h2 id="通过IntelliJ-IDEA"><a href="#通过IntelliJ-IDEA" class="headerlink" title="通过IntelliJ IDEA"></a>通过IntelliJ IDEA</h2><p>1、在 IntelliJ IDEA 中新建项目，选择 Spring Initializr ，如下图所示：</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/2.png" alt="初始化Spring Boot项目2"></p><p>2、配置项目的基本信息</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/3.png" alt="初始化Spring Boot项目3"></p><p>3、配置项目的依赖，这里选择添加 Web 模块</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/4.png" alt="初始化Spring Boot项目4"></p><p>4、设置项目存储位置</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/5_1.png" alt="初始化Spring Boot项目5"></p><p>初始化Spring Boot项目完成</p><h2 id="Spring-Boot-项目结构"><a href="#Spring-Boot-项目结构" class="headerlink" title="Spring Boot 项目结构"></a>Spring Boot 项目结构</h2><p>Spring Boot 项目 初始化完成后，项目如下图所示：</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/6.png" alt="Spring Boot 项目结构"></p><p>SpringBootDemoApplication 是 Spring Boot 的程序的入口。</p><p>我们添加 <code>@RestController</code> 注解，及 <code>home()</code> 方法</p><pre><code class="Java">package com.wshunli.spring.boot.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class SpringBootDemoApplication {    @RequestMapping(&quot;/&quot;)    String home() {        return &quot;Hello Spring Boot !&quot;;    }    public static void main(String[] args) {        SpringApplication.run(SpringBootDemoApplication.class, args);    }}</code></pre><h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><p>1、可以在 IntelliJ IDEA 中点击 run 按钮启动应用。</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/7.png" alt="Spring Boot 项目启动"></p><p>2、也可以在项目根目录使用 <code>mvnw spring-boot:run</code> 命令。</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/8.png" alt="Spring Boot 项目启动"></p><p>如果提示无法识别 <code>mvnw</code> 命令，可改为 <code>.\mvnw spring-boot:run</code></p><p>3、使用 <code>mvnw clean package</code> 命令打包后启动</p><p><img src="https://cdn.wshunli.com/SpringBoot/1HelloSpringBoot/9.png" alt="Spring Boot 项目启动"></p><p>再执行一下命令启动：</p><pre><code class="bash">java -jar  target/demo-0.0.1-SNAPSHOT.jar</code></pre><p>其中 <code>demo-0.0.1-SNAPSHOT.jar</code> 替换为自己的 jar 包名字。</p><p>最后 打开 <a href="http://127.0.0.1:8080/" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/</a> 即可看到 <code>Hello Spring Boot !</code></p><p>本文源码：<a href="https://github.com/wshunli/spring-boot-demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/spring-boot-demo</a></p><blockquote><p>参考资料<br>1、Getting Started · Building an Application with Spring Boot<br><a href="https://spring.io/guides/gs/spring-boot/" rel="external nofollow noopener noreferrer" target="_blank">https://spring.io/guides/gs/spring-boot/</a><br>2、Spring Boot干货系列：（一）优雅的入门篇 | 嘟嘟独立博客<br><a href="http://tengj.top/2017/02/26/springboot1/" rel="external nofollow noopener noreferrer" target="_blank">http://tengj.top/2017/02/26/springboot1/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot 入门 Hello Spring Boot !&lt;/p&gt;
    
    </summary>
    
      <category term="后端技术" scheme="http://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.wshunli.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.wshunli.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>2017年终总结，我这一年的点点滴滴</title>
    <link href="http://www.wshunli.com/posts/33b6fcdd.html"/>
    <id>http://www.wshunli.com/posts/33b6fcdd.html</id>
    <published>2017-12-30T13:37:12.000Z</published>
    <updated>2018-01-24T15:17:45.123Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】 深自缄默，如云漂泊
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="年终总结" scheme="http://www.wshunli.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/fba26489.html"/>
    <id>http://www.wshunli.com/posts/fba26489.html</id>
    <published>2017-12-27T07:05:30.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver</p><a id="more"></a><h1 id="第5章-全局大喇叭"><a href="#第5章-全局大喇叭" class="headerlink" title="第5章 全局大喇叭"></a>第5章 全局大喇叭</h1><p>BroadcastReceiver，广播接收者，它是一个系统全局的监听器，用于监听系统全局的Broadcast消息，所以它可以很方便的进行系统组件之间的通信。</p><p>BroadcastReceiver属于系统级的监听器，它拥有自己的进程，只要存在与之匹配的Broadcast被以Intent的形式发送出来，BroadcastReceiver就会被激活。</p><p>第7章 跨程序共享数据</p><p>第10章 后台默默的劳动者</p><p>未完待续。。</p><blockquote><p>参考资料<br>1、Broadcasts | Android Developers<br><a href="https://developer.android.com/guide/components/broadcasts.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/broadcasts.html</a><br>2、Android之BroadcastReceiver | 吴小龙同學<br><a href="http://wuxiaolong.me/2015/11/03/BroadcastReceiver/" rel="external nofollow noopener noreferrer" target="_blank">http://wuxiaolong.me/2015/11/03/BroadcastReceiver/</a><br>3、Android BroadcastReceiver使用详解 - 简书<br><a href="https://www.jianshu.com/p/f348f6d7fe59" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f348f6d7fe59</a><br>4、Android深入四大组件（四）广播的注册、发送和接收过程 | 刘望舒的博客<br><a href="http://liuwangshu.cn/framework/component/4-broadcastreceiver.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/framework/component/4-broadcastreceiver.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统下搭建Android开发环境</title>
    <link href="http://www.wshunli.com/posts/80d94eb7.html"/>
    <id>http://www.wshunli.com/posts/80d94eb7.html</id>
    <published>2017-12-26T05:25:55.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu 16.04 LTS 系统下搭建 Android 开发环境</p><a id="more"></a><p>昨天圣诞节在机房装了台 Ubuntu ，主要是想试下管理系统的部署，<br>原来在虚拟机下部署的没问题，在真机上部署基本上也没有什么问题。</p><p>有台 Ubuntu 还是很有必要的，后面编译软件会方便很多。<br>现在先学习搭建下 Android 开发环境。</p><h1 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a>Java 环境</h1><p>在比较新的版本 Android Studio 里面已经有 OpenJDK 了，但是 Oracle Java 更好点，我们直接使用命令安装。</p><pre><code class="bash">sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install java-common oracle-java8-installer</code></pre><p>在安装的过程会询问是否同意许可，选择同意即可。</p><p>配置 Java 环境变量，依次执行以下命令：</p><pre><code class="bash">sudo apt-get install oracle-java8-set-defaultsource /etc/profile</code></pre><p>默认安装路径在 <code>/usr/lib/jvm/java-8-oracle</code> .</p><h1 id="Android-环境"><a href="#Android-环境" class="headerlink" title="Android 环境"></a>Android 环境</h1><p>安装 Android Studio 和 安装 JDK 类似，执行一下命令：</p><pre><code class="bash">sudo add-apt-repository ppa:maarten-fonville/android-studiosudo apt updatesudo apt install android-studio`</code></pre><p>JDK 默认安装路径在 <code>/opt/android-studio</code> .</p><h2 id="配置-Android-环境变量："><a href="#配置-Android-环境变量：" class="headerlink" title="配置 Android 环境变量："></a>配置 Android 环境变量：</h2><pre><code class="bash">gedit ~/.bashrc</code></pre><p>在文件的末尾添加如下代码并保存</p><pre><code class="bash">export ANDROID_HOME=/home/wshunli/Android/Sdkexport PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH</code></pre><p>其中 <code>/home/wshunli/Android/Sdk</code> 替换为自己 SDK 的安装位置，一般在 <code>android-studio</code> 同级目录下。</p><p>应用环境变量：</p><pre><code class="bash">source ~/.bashrc</code></pre><p>测试下查看原来设置的目录：</p><pre><code class="bash">echo $ANDROID_HOME</code></pre><p>返回 SDK 所在目录，配置正确。</p><p>接下来就可以启动 Android Studio 了。</p><h2 id="NDK-安装及环境配置（可选）："><a href="#NDK-安装及环境配置（可选）：" class="headerlink" title="NDK 安装及环境配置（可选）："></a>NDK 安装及环境配置（可选）：</h2><p>可以在 Android Studio 中下载，也执行以下命令下载并解压</p><pre><code class="bash">wget -c https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zipunzip android-ndk-r10e-linux-x86_64.zip</code></pre><p>配置 NDK 环境变量，和 SDK 类似：</p><pre><code class="bash">gedit ~/.bashrc</code></pre><p>在文件的末尾添加如下代码并保存</p><pre><code class="bash">export ANDROID_NDK=/home/wshunli/Android/android-ndk-r10eexport PATH=$ANDROID_NDK:$PATH</code></pre><p>其中 <code>/home/wshunli/Android/android-ndk-r10e</code> 替换为自己 NDK 的安装位置</p><p>应用环境变量：</p><pre><code class="bash">source ~/.bashrc</code></pre><p>测试下查看原来设置的目录：</p><pre><code class="bash">echo $ANDROID_NDK</code></pre><p>Android Studio 中文社区(官网)下载所需开发工具。<br><a href="http://www.android-studio.org/" rel="external nofollow noopener noreferrer" target="_blank">http://www.android-studio.org/</a></p><blockquote><p>参考资料<br>1、2 Ways to Install Android Studio in Ubuntu 16.04 and Ubuntu 17.04 - LinuxBabe.Com<br><a href="https://www.linuxbabe.com/ubuntu/install-android-studio-ubuntu-16-04" rel="external nofollow noopener noreferrer" target="_blank">https://www.linuxbabe.com/ubuntu/install-android-studio-ubuntu-16-04</a><br>2、Ubuntu系统下配置Android开发环境 - 简书<br><a href="https://www.jianshu.com/p/949a5a2ddceb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/949a5a2ddceb</a><br>3、Ubuntu 16.04 搭建Android开发环境 - Droi - 博客园<br><a href="http://www.cnblogs.com/droi/p/5399975.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/droi/p/5399975.html</a><br>4、Ubuntu下安装Android NDK - 简书<br><a href="https://www.jianshu.com/p/b12d714435bc" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b12d714435bc</a><br>5、NDK:Linux下NDK安装和配置 - 简书<br><a href="https://www.jianshu.com/p/abdad7fd1367" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/abdad7fd1367</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu 16.04 LTS 系统下搭建 Android 开发环境&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="Ubuntu" scheme="http://www.wshunli.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（五）</title>
    <link href="http://www.wshunli.com/posts/f90ba53c.html"/>
    <id>http://www.wshunli.com/posts/f90ba53c.html</id>
    <published>2017-12-20T12:59:34.000Z</published>
    <updated>2018-01-24T15:17:45.131Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】今天又没找到对象
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/b6bcc7db.html"/>
    <id>http://www.wshunli.com/posts/b6bcc7db.html</id>
    <published>2017-12-06T07:35:48.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 Activity</p><a id="more"></a><p>Android 应用的四大组件 Activity，Service，Broadcast Receiver， Content Provider 最为核心。</p><h1 id="第2章-先从看得到的入手"><a href="#第2章-先从看得到的入手" class="headerlink" title="第2章 先从看得到的入手"></a>第2章 先从看得到的入手</h1><p>Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片或查看地图等操作。</p><h2 id="Activity-创建、启动及销毁"><a href="#Activity-创建、启动及销毁" class="headerlink" title="Activity 创建、启动及销毁"></a>Activity 创建、启动及销毁</h2><p>要创建 Activity，必须创建 <a href="https://developer.android.com/reference/android/app/Activity.html" rel="external nofollow noopener noreferrer" target="_blank">Activity</a> 的子类（或使用其现有子类）。</p><h3 id="实现用户界面"><a href="#实现用户界面" class="headerlink" title="实现用户界面"></a>实现用户界面</h3><p>Activity 的用户界面是由层级式视图 — 衍生自 View 类的对象 — 提供的，也可以利用 Android 提供的现成视图设计和组织布局。</p><p>利用视图定义布局的最常见方法是借助保存在您的应用资源内的 XML 布局文件。</p><pre><code class="Java">setContentView(R.layout.activity_main);</code></pre><p>不过，也可以在 Activity 代码中创建新 View，并通过将新 View 插入 ViewGroup 来创建视图层次，然后通过将根 ViewGroup 传递到 setContentView() 来使用该布局。</p><h3 id="声明-Activity"><a href="#声明-Activity" class="headerlink" title="声明 Activity"></a>声明 Activity</h3><p>Activity 需要在 清单文件 中声明。</p><pre><code class="XML">&lt;manifest ... &gt;  &lt;application ... &gt;    &lt;activity android:name=&quot;.MainActivity&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    ...  &lt;/application ... &gt;  ...&lt;/manifest &gt;</code></pre><p><code>&lt;action&gt;</code> 元素指定这是应用的“主”入口点。<br><code>&lt;category&gt;</code> 元素指定此 Activity 应列入系统的应用启动器内（以便用户启动该 Activity）。</p><h3 id="启动-Activity"><a href="#启动-Activity" class="headerlink" title="启动 Activity"></a>启动 Activity</h3><p>可以通过调用 startActivity()，并将其传递给描述想启动的 Activity 的 Intent 来启动另一个 Activity。</p><pre><code class="Java">Intent intent = new Intent(Intent.ACTION_SEND);intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);startActivity(intent);</code></pre><p>启动 Activity 推荐写法：</p><pre><code class="Java">public class SecondActivity extends FirstActivity {    public static void actionStart(Context context, String data1, String data2) {        Intent intent = new Intent(context, SecondActivity.class);        intent.putExtra(&quot;param1&quot;, data1);        intent.putExtra(&quot;param2&quot;, data2);        context.startActivity(intent);    }    ···}</code></pre><p>可以通过调用 startActivityForResult() 方法启动 Activity 并实现 onActivityResult() 回调方法得到启动 Activity 的结果。</p><pre><code class="Java">private void pickContact() {    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);    startActivityForResult(intent, PICK_CONTACT_REQUEST);}@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST    if (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {        // Perform a query to the contact&#39;s content provider for the contact&#39;s name        Cursor cursor = getContentResolver().query(data.getData(),        new String[] {Contacts.DISPLAY_NAME}, null, null, null);        if (cursor.moveToFirst()) { // True if the cursor is not empty            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);            String name = cursor.getString(columnIndex);            // Do something with the selected contact&#39;s name...        }    }}</code></pre><p>处理 Activity 结果时应该在 onActivityResult() 方法中使用的基本逻辑。</p><p>检查请求是否成功以及requestCode 与随 startActivityForResult() 发送的第二个参数是否匹配。<br>代码通过查询 Intent 中返回的数据（data 参数）从该处开始处理 Activity 结果。</p><h3 id="结束-Activity"><a href="#结束-Activity" class="headerlink" title="结束 Activity"></a>结束 Activity</h3><p>通过调用 Activity 的 finish() 方法来结束该 Activity。也可以通过调用 finishActivity() 结束之前启动的另一个 Activity。</p><h2 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h2><h3 id="Activity-状态"><a href="#Activity-状态" class="headerlink" title="Activity 状态"></a>Activity 状态</h3><p>Activity 在其生命周期中最多有4种状态：</p><ul><li>运行状态：Activity 位于屏幕前台并具有用户焦点。</li><li>暂停状态：另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。</li><li>停止状态：该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。</li><li>销毁状态：系统结束 Activity （调用其 finish() 方法）或直接终止其进程，将其从内存中删除。</li></ul><h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>当一个 Activity 转入和转出上述不同状态时，系统会通过各种回调方法向其发出通知。</p><pre><code class="Java">public class ExampleActivity extends Activity {    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // The activity is being created.    }    @Override    protected void onStart() {        super.onStart();        // The activity is about to become visible.    }    @Override    protected void onResume() {        super.onResume();        // The activity has become visible (it is now &quot;resumed&quot;).    }    @Override    protected void onPause() {        super.onPause();        // Another activity is taking focus (this activity is about to be &quot;paused&quot;).    }    @Override    protected void onStop() {        super.onStop();        // The activity is no longer visible (it is now &quot;stopped&quot;)    }    @Override    protected void onDestroy() {        super.onDestroy();        // The activity is about to be destroyed.    }}</code></pre><p>这些方法共同定义 Activity 的整个生命周期。可以通过实现这些方法监控 Activity 生命周期中的三个嵌套循环：</p><ul><li><strong>完整生命周期</strong> 发生在 onCreate() 与 onDestroy() 之间，就是完整的生存期。</li><li><strong>可见生命周期</strong> 发生在 onStart() 与 onStop() 之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。</li><li><strong>前台生命周期</strong> 发生在 onResume() 与 onPause() 之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。</li></ul><center><img src="https://img.wshunli.com/Android/第一行代码/2.activity_lifecycle.png" alt="activity_lifecycle"></center><p>Activity 生命周期回调方法汇总表。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.activity_lifecycle_method.png" alt="activity_lifecycle"></p><p>名为“是否能事后终止？”的列表示系统是否能在不执行另一行 Activity 代码的情况下，在方法返回后随时终止承载 Activity 的进程。</p><h3 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h3><p>在 Activity 暂停或者停止时，Activity 的状态会得到保留。<br>但是当系统为了回复内存而销毁 Activity 时，Activity 对象也会被销毁，<br>我们可以使用 onSaveInstanceState() 方法保存 Acitivity 状态信息，使用 onRestoreInstanceState() 方法 恢复保存的状态信息。</p><center><img src="https://img.wshunli.com/Android/第一行代码/2.restore_instance.png" alt="restore_instance"></center><p>当 Activity A 启动 Activity B 时一系列操作的发生顺序：</p><ol><li>Activity A 的 onPause() 方法执行。</li><li>Activity B 的 onCreate()、onStart() 和 onResume() 方法依次执行。（Activity B 现在具有用户焦点。）</li><li>然后，如果 Activity A 在屏幕上不再可见，则其 onStop() 方法执行。</li></ol><h2 id="Intent-和-Intent-过滤器"><a href="#Intent-和-Intent-过滤器" class="headerlink" title="Intent 和 Intent 过滤器"></a>Intent 和 Intent 过滤器</h2><p>Intent 是一个消息传递对象，可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p><p><strong>启动 Activity</strong>：Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。</p><p>如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，您的 Activity 将结果作为单独的 Intent 对象接收。</p><p><strong>启动服务</strong>：Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。</p><p>如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。</p><p><strong>传递广播</strong>：广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。</p><h3 id="显示Intent和隐式Intent"><a href="#显示Intent和隐式Intent" class="headerlink" title="显示Intent和隐式Intent"></a>显示Intent和隐式Intent</h3><p>显式 Intent 按名称（完全限定类名）指定要启动的组件。</p><pre><code class="Java">startActivity(new Intent(this, SecondActivity.class));</code></pre><p>隐式 Intent 不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。</p><p>创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.intent-filters.png-hexo.png" alt="intent-filters"></p><p>隐式 Intent 如何通过系统传递以启动其他 Activity 的图解：<br>[1] Activity A 创建包含操作描述的 Intent，并将其传递给 startActivity()。<br>[2] Android 系统搜索所有应用中与 Intent 匹配的 Intent 过滤器。 找到匹配项之后，<br>[3] 该系统通过调用匹配 Activity（Activity B）的 onCreate() 方法并将其传递给 Intent，以此启动匹配 Activity。</p><h3 id="构建-Intent"><a href="#构建-Intent" class="headerlink" title="构建 Intent"></a>构建 Intent</h3><p>Intent 对象携带了 Android 系统用来确定要启动哪个组件的信息，以及收件人组件为了正确执行操作而使用的信息。</p><p>Intent 中包含的主要信息如下：</p><ul><li>组件名称(Component name)：要启动的组件名称。</li><li>操作(Action)：指定要执行的通用操作的字符串。如 ACTION_VIEW 、ACTION_SEND。</li><li>数据(Data)：引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。</li><li>类别(Category)：一个包含应处理 Intent 组件类型的附加信息的字符串。如 CATEGORY_BROWSABLE、CATEGORY_LAUNCHER。</li><li>Extra：携带完成请求操作所需的附加信息的键值对。</li><li>标志(Flags)：在 Intent 类中定义的、充当 Intent 元数据的标志。</li></ul><p>隐式创建 Intent 示例：</p><pre><code class="Java">// Create the text message with a stringIntent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);sendIntent.setType(&quot;text/plain&quot;);// Verify that the intent will resolve to an activityif (sendIntent.resolveActivity(getPackageManager()) != null) {    startActivity(sendIntent);}</code></pre><p>使用<strong>应用选择器</strong></p><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。</p><p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()。</p><pre><code class="Java">Intent sendIntent = new Intent(Intent.ACTION_SEND);...String title = getResources().getString(R.string.chooser_title);// Create intent to show the chooser dialogIntent chooser = Intent.createChooser(sendIntent, title);if (sendIntent.resolveActivity(getPackageManager()) != null) {    startActivity(chooser);}</code></pre><h3 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，需要在清单文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent 过滤器。</p><p>在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p><p><code>&lt;action&gt;</code> 在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。<br><code>&lt;data&gt;</code> 使用一个或多个指定数据 URI 各个方面（scheme、host、port、path 等）和 MIME 类型的属性，声明接受的数据类型。<br><code>&lt;category&gt;</code> 在 name 属性中，声明接受的 Intent 类别。该值必须是操作的文本字符串值，而不是类常量。</p><pre><code class="XML">&lt;activity android:name=&quot;ShareActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><h3 id="使用待定-Intent"><a href="#使用待定-Intent" class="headerlink" title="使用待定 Intent"></a>使用待定 Intent</h3><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p><p>待定 Intent 的主要用例包括：</p><ul><li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li><li>声明用户使用您的 应用小部件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li><li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li></ul><h3 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h3><p>当系统收到隐式 Intent 以启动 Activity 时，它根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p><ul><li>Intent 操作</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.EDIT&quot; /&gt;    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;    ...&lt;/intent-filter&gt;</code></pre><ul><li>Intent 数据（URI 和数据类型）</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;    ...&lt;/intent-filter&gt;</code></pre><ul><li>Intent 类别</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;data android:mimeType=&quot;video/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt;    &lt;data android:mimeType=&quot;audio/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt;    ...&lt;/intent-filter&gt;</code></pre><h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent 过滤器匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。<br>例如，主页应用通过使用指定 ACTION_MAIN 操作和 CATEGORY_LAUNCHER 类别的 Intent 过滤器查找所有 Activity，以此填充应用启动器。</p><p>PackageManager 提供了一整套 query…() 方法来返回所有能够接受特定 Intent 的组件，resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities()、queryIntentServices()、queryBroadcastReceivers()将返回能够执行那些作为参数传递的 Intent 的所有 组件 列表，但方法均不会激活组件，而只是列出能够响应的组件。</p><h3 id="通用-Intent"><a href="#通用-Intent" class="headerlink" title="通用 Intent"></a>通用 Intent</h3><p>主要是调用系统提供的一些服务，如闹钟、相机等等。</p><p><a href="https://developer.android.com/guide/components/intents-common.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/intents-common.html</a></p><h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><h3 id="任务和返回栈"><a href="#任务和返回栈" class="headerlink" title="任务和返回栈"></a>任务和返回栈</h3><p>任务是指在执行特定作业时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈（即返回栈）中。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.diagram_backstack.png" alt="diagram_backstack"></p><p>当前 Activity 启动另一个 Activity 时，新 Activity 会被推到栈顶，并获得焦点。当用户按返回按钮时，当前 Activity 会从栈顶弹出并销毁。</p><p>当用户直接按 Home 键回到主屏幕时，尽管该任务中的所有 Activity 全部停止，但是任务的返回栈仍然不变。</p><p>即使来自其他任务，Activity 也可以多次实例化。</p><h3 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h3><p>通过使用 <code>&lt;activity&gt;</code> 清单文件元素中的属性</p><ul><li>taskAffinity</li><li>launchMode</li><li>allowTaskReparenting</li><li>clearTaskOnLaunch</li><li>alwaysRetainTaskState</li><li>finishOnTaskLaunch</li></ul><p>以及传递给 <code>startActivity()</code> 的 Intent 中的标志</p><ul><li>FLAG_ACTIVITY_NEW_TASK</li><li>FLAG_ACTIVITY_CLEAR_TOP</li><li>FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>管理 Activity 如何与任务关联或者如何存在于返回栈中。</p><h3 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h3><p><strong>使用清单文件</strong>：</p><p>在清单文件中声明 Activity 时，您可以使用 <code>&lt;activity&gt;</code> 元素的 launchMode 属性指定 Activity 应该如何与任务关联。</p><p>launchMode 属性的启动模式共有四种：</p><p><strong>“standard”</strong>（默认模式）每次启动 Activity 系统都会在任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</p><p><strong>“singleTop”</strong> 如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的 Activity 并不是 Activity 的现有实例）。</p><p><strong>“singleTask”</strong> 系统创建新任务并实例化位于新任务底部的 Activity。但是如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。一次只能存在 Activity 的一个实例。</p><p><strong>“singleInstance”</strong> 与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。</p><p><strong>使用 Intent 标志</strong>：</p><p>启动 Activity 时，您可以通过在传递给 startActivity() 的 Intent 中加入相应的标志，修改 Activity 与其任务的默认关联方式。可用于修改默认行为的标志包括：</p><p><strong>FLAG_ACTIVITY_NEW_TASK</strong> 在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 onNewIntent() 中收到新 Intent。这会产生与 “singleTask” launchMode 值相同的行为。</p><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong> 如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 onNewIntent() 的调用，而不是创建 Activity 的新实例。这会产生与 “singleTop” launchMode 值相同的行为。</p><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong> 如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。产生这种行为的 launchMode 属性没有值。</p><h3 id="处理关联"><a href="#处理关联" class="headerlink" title="处理关联"></a>处理关联</h3><p>“关联”指示 Activity 优先属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此关联。</p><p>可以使用 <code>&lt;activity&gt;</code> 元素的 taskAffinity 属性修改任何给定 Activity 的关联。</p><p>taskAffinity 属性取字符串值，该值必须不同于在 <code>&lt;manifest&gt;</code> 元素中声明的默认软件包名称，因为系统使用该名称标识应用的默认任务关联。</p><p>在两种情况下，关联会起作用：</p><ul><li>启动 Activity 的 Intent 包含 FLAG_ACTIVITY_NEW_TASK 标志。</li><li>Activity 将其 allowTaskReparenting 属性设置为 “true”。</li></ul><h3 id="清理返回栈"><a href="#清理返回栈" class="headerlink" title="清理返回栈"></a>清理返回栈</h3><p>如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。<br>当用户再次返回到任务时，仅恢复根 Activity。</p><p><strong>alwaysRetainTaskState</strong> 如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。</p><p><strong>clearTaskOnLaunch</strong> 如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。</p><p><strong>finishOnTaskLaunch</strong> 此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。</p><h1 id="第4章-手机平板要兼容"><a href="#第4章-手机平板要兼容" class="headerlink" title="第4章 手机平板要兼容"></a>第4章 手机平板要兼容</h1><p>Fragment 表示 Activity 中的行为或部分用户界面。Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.fragments.png" alt="fragments"></p><h2 id="创建-Fragment"><a href="#创建-Fragment" class="headerlink" title="创建 Fragment"></a>创建 Fragment</h2><p>要想创建 Fragment，必须创建 Fragment 的子类（或已有其子类）。</p><center><img src="https://img.wshunli.com/Android/第一行代码/2.fragment_lifecycle.png" alt="fragment_lifecycle"></center><p>其他 Fragment 子类，DialogFragment、ListFragment、PreferenceFragment 。</p><h3 id="构造-Fragment-界面"><a href="#构造-Fragment-界面" class="headerlink" title="构造 Fragment 界面"></a>构造 Fragment 界面</h3><p>实现 onCreateView() 回调方法，Android 系统会在 Fragment 需要绘制其布局时调用该方法。</p><pre><code class="Java">public static class ExampleFragment extends Fragment {    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        return inflater.inflate(R.layout.example_fragment, container, false);    }}</code></pre><p>inflater 利用 XML 中定义的布局资源来拓展 Fragment 布局。</p><h3 id="向-Activity-添加-Fragment"><a href="#向-Activity-添加-Fragment" class="headerlink" title="向 Activity 添加 Fragment"></a>向 Activity 添加 Fragment</h3><p>可以通过两种方式向 Activity 布局添加 Fragment ：</p><p><strong>在 Activity 的布局文件内声明 Fragment</strong>：</p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleListFragment&quot;            android:id=&quot;@+id/list&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleReaderFragment&quot;            android:id=&quot;@+id/viewer&quot;            android:layout_weight=&quot;2&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>当系统创建此 Activity 布局时，会实例化在布局中指定的每个Fragment，并为每个Fragment调用 onCreateView() 方法，以检索每个Fragment的布局。系统会直接插入Fragment返回的 View 来替代 <code>&lt;fragment&gt;</code> 元素。</p><p><strong>或者通过编程方式将 Fragment 添加到某个现有 ViewGroup</strong>:</p><p>用 FragmentTransaction 添加、移除或替换 Fragment 。</p><pre><code class="Java">FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();// 使用 add() 方法添加一个 FragmentExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);fragmentTransaction.commit();</code></pre><p>添加没有 UI 的 Fragment ：</p><p>使用 add(Fragment, String) 方法在 Activity 添加 Fragment，可以使用 Fragment 为 Activity 提供后台行为，而不显示额外 UI。</p><h2 id="管理-Fragment"><a href="#管理-Fragment" class="headerlink" title="管理 Fragment"></a>管理 Fragment</h2><p>在 Activity 调用 getFragmentManager() 方法得到 FragmentManager 对象可以管理 Activity 中的 Fragment。</p><p>FragmentManager 执行的操作包括：</p><ul><li>findFragmentById()（对于在 Activity 布局中提供 UI 的 Fragment ）或 findFragmentByTag()（对于提供或不提供 UI 的 Fragment）获取 Activity 中存在的 Fragment。</li><li>popBackStack()（模拟用户发出的返回命令）将 Fragment 从返回栈中弹出。</li><li>addOnBackStackChangedListener() 注册一个侦听返回栈变化的侦听器。</li></ul><h2 id="执行-Fragment-事务"><a href="#执行-Fragment-事务" class="headerlink" title="执行 Fragment 事务"></a>执行 Fragment 事务</h2><p>从 FragmentManager 获取 FragmentTransaction 实例，使用 add()、remove() 和 replace() 等方法动态管理 Fragment。</p><pre><code class="Java">// Create new fragment and transactionFragment newFragment = new ExampleFragment();FragmentTransaction transaction = getFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,// and add the transaction to the back stacktransaction.replace(R.id.fragment_container, newFragment);transaction.addToBackStack(null);// Commit the transactiontransaction.commit();</code></pre><p>通过调用 addToBackStack() 可将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一 Fragment 。</p><h2 id="Fragment-与-Activity-通信"><a href="#Fragment-与-Activity-通信" class="headerlink" title="Fragment 与 Activity 通信"></a>Fragment 与 Activity 通信</h2><p>尽管 Fragment 是作为独立于 Activity 的对象实现，并且可在多个 Activity 内使用，但 Fragment 的特定实例会直接绑定到包含它的 Activity。</p><p>Fragment 可以通过 getActivity() 访问 Activity 实例，并轻松地执行在 Activity 布局中查找视图等任务。</p><pre><code class="Java">View listView = getActivity().findViewById(R.id.list);</code></pre><p>同样地，Activity 也可以使用 findFragmentById() 或 findFragmentByTag()，通过从 FragmentManager 获取对 Fragment 的引用来调用Fragment中的方法。例如：</p><pre><code class="Java">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</code></pre><h2 id="处理-Fragment-生命周期"><a href="#处理-Fragment-生命周期" class="headerlink" title="处理 Fragment 生命周期"></a>处理 Fragment 生命周期</h2><p>管理Fragment生命周期与管理 Activity 生命周期很相似。和 Activity 一样，Fragment也以三种状态存在：</p><p><strong>Resumed</strong> Fragment在运行中的 Activity 中可见。<br><strong>Paused</strong> 另一个 Activity 位于前台并具有焦点，但此Fragment所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。<br><strong>Stopped</strong> Fragment不可见。宿主 Activity 已停止，或Fragment已从 Activity 中移除，但已添加到返回栈。 停止Fragment仍然处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。</p><p>Activity 生命周期与 Fragment 生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。</p><p>默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈；<br>不过，仅当您在移除 Fragment 的事务执行期间通过调用 addToBackStack() 显式请求保存实例时，系统才会将 Fragment 放入由宿主 Activity 管理的返回栈。</p><h3 id="与-Activity-生命周期协调一致"><a href="#与-Activity-生命周期协调一致" class="headerlink" title="与 Activity 生命周期协调一致"></a>与 Activity 生命周期协调一致</h3><p>Fragment所在的 Activity 的生命周期会直接影响Fragment的生命周期，其表现为，Activity 的每次生命周期回调都会引发每个Fragment的类似回调。<br>例如，当 Activity 收到 onPause() 时，Activity 中的每个Fragment也会收到 onPause()。</p><p>不过，Fragment 还有几个额外的生命周期回调:</p><ul><li>onAttach() 在片段已与 Activity 关联时调用（Activity 传递到此方法内）。</li><li>onCreateView() 调用它可创建与片段关联的视图层次结构。</li><li>onActivityCreated() 在 Activity 的 onCreate() 方法已返回时调用。</li><li>onDestroyView() 在移除与片段关联的视图层次结构时调用。</li><li>onDetach() 在取消片段与 Activity 的关联时调用。</li></ul><center><img src="https://img.wshunli.com/Android/第一行代码/2.activity_fragment_lifecycle.png" alt="activity_fragment_lifecycle"></center><p>图示说明了受其宿主 Activity 影响的片段生命周期流。</p><blockquote><p>参考资料<br>1、Activity | Android Developers<br><a href="https://developer.android.com/guide/components/activities.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/activities.html</a><br>2、Activity/Service 生命周期 · 笔试面试知识整理<br><a href="https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html" rel="external nofollow noopener noreferrer" target="_blank">https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html</a><br>3、Intent 和 Intent 过滤器<br><a href="https://developer.android.com/guide/components/intents-filters.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/intents-filters.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 Activity&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/df51fd76.html"/>
    <id>http://www.wshunli.com/posts/df51fd76.html</id>
    <published>2017-12-06T03:33:44.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 平台架构</p><a id="more"></a><p>我最开始学习 Android 是在 2014 年下半年，看的是《疯狂Android讲义》。</p><p>在 2015 年参加 ESRI 中国组织的 GIS 开发大赛，也是主要在暑假学习了不少 Android 入门知识。</p><p>后面在较长一段时间，感觉停滞在 Android 入门的水平不前。也有尝试在项目中使用一些优秀的框架或者类库，但是感觉自身的水平并没有多大的提高。</p><p>所以有意在前面学习计算机基础、Java 语言基础，后面打算深入之后学习下数据结构及算法。也为明年找工作做准备。</p><p>其实这本书 《第一行代码》 在考研结束以后已经看过一遍了，这次再复习一遍，毕竟有一段时间没有具体做 Android 开发了，再者希望能记忆一些常用的知识点。</p><h1 id="第1章-开启启程"><a href="#第1章-开启启程" class="headerlink" title="第1章 开启启程"></a>第1章 开启启程</h1><h2 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h2><p>总的来说，Android的系统体系结构分为四层，自顶向下分别是：</p><ul><li>应用程序(Applications)</li><li>应用程序框架(Application Frameworks)</li><li>系统运行库与 Android 运行环境(Libraris &amp; Android Runtime)</li><li>Linux 核心层</li></ul><p><img src="https://img.wshunli.com/Android/第一行代码/1.Android系统架构.png" alt="1.Android系统架构"></p><h3 id="Linux核心层"><a href="#Linux核心层" class="headerlink" title="Linux核心层"></a>Linux核心层</h3><p><strong>Linux 内核</strong>(Linux Kernel)<br>Android 平台的基础是 Linux 内核，Linux 内核直接和硬件打交道。硬件驱动、进程管理、内存管理、网络管理的功能在这里实现。</p><p><strong>硬件抽象层</strong>(Hardware Abstraction Layer)<br>硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。<br>HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。</p><h3 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h3><p><strong>Android 运行环境</strong>(Android Runtime)<br>每个应用都在其自己的进程中运行，有其自己的 Android Runtime (ART) 实例（Android 5.0 之前是 Dalvik）。<br>并且 Android 还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能。</p><p><strong>原生C/C++ 库</strong>(Native C/C++ Libraries)<br>许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。<br>Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。</p><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><p><strong>Java API 框架</strong>(Java API Framework)</p><p>提供构建应用的各种 API 。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器。</li><li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件。</li><li>通知管理器，可让所有应用在状态栏中显示自定义提醒。</li><li>Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈。</li><li>内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据。</li></ul><p>开发者可以完全访问 Android 系统应用使用的框架 API。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>系统应用</strong>(System Apps)</p><p>所有安装在手机上的应用程序都属于应用层，包括系统自带的软件和自己开发的软件。</p><h2 id="搭建-Android-开发环境"><a href="#搭建-Android-开发环境" class="headerlink" title="搭建 Android 开发环境"></a>搭建 Android 开发环境</h2><p>前面已经写过了，不再重复。<br>《ArcGIS Runtime SDK for Android学习笔记》-1、Android开发环境搭建 | CirGIS<br><a href="https://www.wshunli.com/posts/f6977dbb.html">https://www.wshunli.com/posts/f6977dbb.html</a></p><blockquote><p>参考资料<br>1、平台架构 | Android Developers<br><a href="https://developer.android.com/guide/platform/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/platform/index.html</a><br>2、Android系统架构简介 - 简书<br><a href="http://www.jianshu.com/p/69f0d25c727a" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/69f0d25c727a</a><br>3、Android系统架构介绍 - LCore的专栏 - CSDN博客<br><a href="http://blog.csdn.net/lcore/article/details/20993367" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/lcore/article/details/20993367</a><br>4、android系统体系结构 - CSDN博客<br><a href="http://blog.csdn.net/spy19881201/article/details/5775484" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/spy19881201/article/details/5775484</a><br>5、Android系统开篇 - Gityuan博客 | 袁辉辉博客<br><a href="http://gityuan.com/android/" rel="external nofollow noopener noreferrer" target="_blank">http://gityuan.com/android/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 平台架构&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（九）</title>
    <link href="http://www.wshunli.com/posts/8c5a6523.html"/>
    <id>http://www.wshunli.com/posts/8c5a6523.html</id>
    <published>2017-12-05T09:51:24.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— Java I/O 系统。</p><a id="more"></a><p>第18章 <strong>Java I/O 系统</strong></p><h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h1><p>File 类不仅仅可以代表一个特定文件的名称，还可以代表一个目录下的一组文件的名称。</p><p>未完待续。。</p><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><blockquote><p>参考资料<br>1、Java 编程思想（六）Java I/O - Invoker’s Tower - CSDN博客<br><a href="http://blog.csdn.net/kingcat666/article/details/78027078" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/kingcat666/article/details/78027078</a><br>2、java基础学习总结——流 - 孤傲苍狼 - 博客园<br><a href="http://www.cnblogs.com/xdp-gacl/p/3634409.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/xdp-gacl/p/3634409.html</a><br>3、《Java编程思想》学习笔记11——Java I/O - CSDN博客<br><a href="http://blog.csdn.net/chjttony/article/details/6966246" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/chjttony/article/details/6966246</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— Java I/O 系统。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（八）</title>
    <link href="http://www.wshunli.com/posts/f697447c.html"/>
    <id>http://www.wshunli.com/posts/f697447c.html</id>
    <published>2017-12-05T09:46:52.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 容器深入研究。</p><a id="more"></a><p>第17章 <strong>容器深入研究</strong></p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java容器1.png" alt="Java容器"></p><p>未完待续。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 容器深入研究。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（七）</title>
    <link href="http://www.wshunli.com/posts/1fc6c3f.html"/>
    <id>http://www.wshunli.com/posts/1fc6c3f.html</id>
    <published>2017-12-04T13:54:10.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类型信息及泛型。</p><a id="more"></a><h1 id="第14章-类型信息"><a href="#第14章-类型信息" class="headerlink" title="第14章 类型信息"></a>第14章 类型信息</h1><p>RTTI (Run-Time Type Identification, 运行时类型识别) 是 Java 中非常有用的机制。</p><pre><code class="Java">abstract class Shape {  void draw() { System.out.println(this + &quot;.draw()&quot;); }  abstract public String toString();}class Circle extends Shape {  public String toString() { return &quot;Circle&quot;; }}class Square extends Shape {  public String toString() { return &quot;Square&quot;; }}public class Shapes {  public static void main(String[] args) {    List&lt;Shape&gt; shapeList = Arrays.asList(      new Circle(), new Square()    );    for(Shape shape : shapeList) shape.draw();  }}/* Output:Circle.draw()Square.draw()*/</code></pre><p>在Java运行时，RTTI 维护类的相关信息，识别一个对象的类型。</p><p>1.Class 对象</p><p>类是程序的一部分，每个类都有一个Class对象。</p><pre><code class="Java">interface HasBatteries {}interface Waterproof {}interface Shoots {}class Toy {  // Comment out the following default constructor  // to see NoSuchMethodError from (*1*)  Toy() {}  Toy(int i) {}}class FancyToy extends Toyimplements HasBatteries, Waterproof, Shoots {  FancyToy() { super(1); }}public class ToyTest {  static void printInfo(Class cc) {    print(&quot;Class name: &quot; + cc.getName() + // 全限定的类型      &quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;); // Class 对象是否表示某接口    print(&quot;Simple name: &quot; + cc.getSimpleName()); // 不含包名的类名    print(&quot;Canonical name : &quot; + cc.getCanonicalName()); // 含包名的类名  }  public static void main(String[] args) {    Class c = null;    try {      c = Class.forName(&quot;typeinfo.toys.FancyToy&quot;); // 获取 Class 对象的引用    } catch(ClassNotFoundException e) {      print(&quot;Can&#39;t find FancyToy&quot;);      System.exit(1);    }    printInfo(c);    for(Class face : c.getInterfaces()) // 获取 Class 对象中包含的接口      printInfo(face);    Class up = c.getSuperclass(); // 获取 Class 对象的直接基类    Object obj = null;    try {      // Requires default constructor:      obj = up.newInstance(); // 实现虚拟构造器    } catch(InstantiationException e) {      print(&quot;Cannot instantiate&quot;);      System.exit(1);    } catch(IllegalAccessException e) {      print(&quot;Cannot access&quot;);      System.exit(1);    }    printInfo(obj.getClass());  }} /* Output:Class name: typeinfo.toys.FancyToy is interface? [false]Simple name: FancyToyCanonical name : typeinfo.toys.FancyToyClass name: typeinfo.toys.HasBatteries is interface? [true]Simple name: HasBatteriesCanonical name : typeinfo.toys.HasBatteriesClass name: typeinfo.toys.Waterproof is interface? [true]Simple name: WaterproofCanonical name : typeinfo.toys.WaterproofClass name: typeinfo.toys.Shoots is interface? [true]Simple name: ShootsCanonical name : typeinfo.toys.ShootsClass name: typeinfo.toys.Toy is interface? [false]Simple name: ToyCanonical name : typeinfo.toys.Toy*/</code></pre><p>2.类加载器是通过判断这个类包含的Class对象是否已经加载来判断它是否已经加载过这个类。为使用类而做的准备工作实际上包括三个步骤：</p><p>1 加载。这个由类加载器去完成。查找相关的字节码，并从这些字节码中创建一个Class对象。<br>2 链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且必须的话将解析这个类创建的对其他类的引用。<br>3 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了静态方法或者静态域进行首次引用时才执行。</p><pre><code class="Java">class Initable {  static final int staticFinal = 47;  static final int staticFinal2 =    ClassInitialization.rand.nextInt(1000);  static {    System.out.println(&quot;Initializing Initable&quot;);  }}class Initable2 {  static int staticNonFinal = 147;  static {    System.out.println(&quot;Initializing Initable2&quot;);  }}class Initable3 {  static int staticNonFinal = 74;  static {    System.out.println(&quot;Initializing Initable3&quot;);  }}public class ClassInitialization {  public static Random rand = new Random(47);  public static void main(String[] args) throws Exception {    Class initable = Initable.class;    System.out.println(&quot;After creating Initable ref&quot;);    // Does not trigger initialization:    System.out.println(Initable.staticFinal);    // Does trigger initialization:    System.out.println(Initable.staticFinal2);    // Does trigger initialization:    System.out.println(Initable2.staticNonFinal);    Class initable3 = Class.forName(&quot;Initable3&quot;);    System.out.println(&quot;After creating Initable3 ref&quot;);    System.out.println(Initable3.staticNonFinal);  }} /* Output:After creating Initable ref47Initializing Initable258Initializing Initable2147Initializing Initable3After creating Initable3 ref74*/</code></pre><p>3.instanceof</p><p>返回一个布尔值，判断对象是不是某个特定类型的实例。</p><pre><code class="Java">x instanceof Boy</code></pre><p>4.反射：运行时的类信息</p><p>反射机制是在运行状态中，<br>对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取的信息以及动态调用对象的方法的功能称为反射。</p><p>5.动态代理</p><p>代理是一本基本的设计模式；代理通常充当着中间人的角色。</p><h1 id="第15章-泛型"><a href="#第15章-泛型" class="headerlink" title="第15章 泛型"></a>第15章 泛型</h1><p>Java SE5 泛型实现了参数化类型的概念，使代码可以应用于多种类型。</p><p>泛型的出现，最引人注目的原因是为了创造容器类</p><p>一个只能持有单个对象的类：</p><pre><code class="Java">public class Holder {  private Automobile a;  public Holder(Automobile a) { this.a = a; }  Automobile get() { return a; }}</code></pre><p>显然，Holder 类的重用性很差，只能持有 Automobile 类对象。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><pre><code class="Java">public class Holder3&lt;T&gt; {  private T a;  public Holder3(T a) { this.a = a; }  public void set(T a) { this.a = a; }  public T get() { return a; }  public static void main(String[] args) {    Holder3&lt;Automobile&gt; h3 =      new Holder3&lt;Automobile&gt;(new Automobile());    Automobile a = h3.get(); // No cast needed    // h3.set(&quot;Not an Automobile&quot;); // Error    // h3.set(1); // Error  }}</code></pre><p>告诉编译器使用什么类型，然后编译器帮你处理一切细节。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口；例如生成器，这是一种专门负责创建对象的类。</p><p>生成器接口定义如下：</p><pre><code class="Java">public interface Generator&lt;T&gt; { T next(); }</code></pre><p>实现生成器接口</p><pre><code class="Java">public class CoffeeGeneratorimplements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt; {  private Class[] types = { Latte.class, Mocha.class,    Cappuccino.class, Americano.class, Breve.class, };  private static Random rand = new Random(47);  public CoffeeGenerator() {}  // For iteration:  private int size = 0;  public CoffeeGenerator(int sz) { size = sz; }  public Coffee next() {    try {      return (Coffee)        types[rand.nextInt(types.length)].newInstance();      // Report programmer errors at run time:    } catch(Exception e) {      throw new RuntimeException(e);    }  }  class CoffeeIterator implements Iterator&lt;Coffee&gt; {    int count = size;    public boolean hasNext() { return count &gt; 0; }    public Coffee next() {      count--;      return CoffeeGenerator.this.next();    }    public void remove() { // Not implemented      throw new UnsupportedOperationException();    }  };  public Iterator&lt;Coffee&gt; iterator() {    return new CoffeeIterator();  }  public static void main(String[] args) {    CoffeeGenerator gen = new CoffeeGenerator();    for(int i = 0; i &lt; 5; i++)      System.out.println(gen.next());    for(Coffee c : new CoffeeGenerator(5))      System.out.println(c);  }} /* Output:Americano 0Latte 1Americano 2Mocha 3Mocha 4Breve 5Americano 6Latte 7Cappuccino 8Cappuccino 9*/</code></pre><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一个基本指导原则：无论何时，只要你能做到，你就应该使用泛型方法。</p><pre><code class="Java">public class GenericMethods {  public &lt;T&gt; void f(T x) {    System.out.println(x.getClass().getName());  }  public static void main(String[] args) {    GenericMethods gm = new GenericMethods();    gm.f(&quot;&quot;);    gm.f(1);    gm.f(1.0);    gm.f(1.0F);    gm.f(&#39;c&#39;);    gm.f(gm);  }} /* Output:java.lang.Stringjava.lang.Integerjava.lang.Doublejava.lang.Floatjava.lang.CharacterGenericMethods*/</code></pre><p>泛型方法与可变参数列表能够很好地共存:</p><pre><code class="Java">public class GenericVarargs {  public static &lt;T&gt; List&lt;T&gt; makeList(T... args) {    List&lt;T&gt; result = new ArrayList&lt;T&gt;();    for(T item : args)      result.add(item);    return result;  }  public static void main(String[] args) {    List&lt;String&gt; ls = makeList(&quot;A&quot;);    System.out.println(ls);    ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);    System.out.println(ls);    ls = makeList(&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;));    System.out.println(ls);  }} /* Output:[A][A, B, C][, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]*/</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十四章 01 类型信息<br><a href="https://zhuanlan.zhihu.com/p/26081790" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/26081790</a><br>2、《java编程思想》14章类型信息 读书笔记 - CSDN博客<br><a href="http://blog.csdn.net/L2HL2H/article/details/51120480" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/L2HL2H/article/details/51120480</a><br>3、《Java编程思想》读书笔记 第十四章 02 反射<br><a href="https://zhuanlan.zhihu.com/p/26190300" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/26190300</a><br>4、Java泛型详解 | ZiWenXie<br><a href="https://www.ziwenxie.site/2017/03/01/java-generic/" rel="external nofollow noopener noreferrer" target="_blank">https://www.ziwenxie.site/2017/03/01/java-generic/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类型信息及泛型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/d3fc1ba0.html"/>
    <id>http://www.wshunli.com/posts/d3fc1ba0.html</id>
    <published>2017-12-04T12:22:17.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。</p><a id="more"></a><h1 id="第13章-字符串"><a href="#第13章-字符串" class="headerlink" title="第13章 字符串"></a>第13章 字符串</h1><p>1.不可变的 String<br>String 对象是不可变的，每当修改 String 对象的时候，实际上都是创建了一个新的 String 对象，最初的 String 对象丝毫未动。</p><p>2.重载“+”与 StringBuilder<br>String 对象的不可变性带来一定的效率问题，例如为 String 对象重载的“+”操作符。（用于String的“+”、“+=”是 Java 中仅有的两个重载过的操作符，而 Java 并不允许程序员重载任何操作符）。</p><pre><code class="Java">public class WhitherStringBuilder {  public String implicit(String[] fields) {    String result = &quot;&quot;;    for(int i = 0; i &lt; fields.length; i++)      result += fields[i];    return result;  }  public String explicit(String[] fields) {    StringBuilder result = new StringBuilder();    for(int i = 0; i &lt; fields.length; i++)      result.append(fields[i]);    return result.toString();  }}</code></pre><p>StringBuilder 提供了丰富而全面的方法，包括 append(),toString(),delete(),insert(),replace(),substring() 甚至 reverse()。</p><p>3.String 上的操作</p><p><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">Java 字符串常用操作（String类）</a></p><p>String 是固定不变的，而 StringBuffer 和 StringBuilder 可以改变它们的值。<br>二者唯一的区别是 StringBuilder 是非同步的而 StringBuffer 是同步的。</p><p>4.格式化输出</p><p>Java SE5 推出了类似 C语言中 printf() 风格的格式化输出这一功能。</p><pre><code class="Java">public class SimpleFormat {  public static void main(String[] args) {    int x = 5;    double y = 5.332542;    // The old way:    System.out.println(&quot;Row 1: [&quot; + x + &quot; &quot; + y + &quot;]&quot;);    // The new way:    System.out.format(&quot;Row 1: [%d %f]\n&quot;, x, y);    // or    System.out.printf(&quot;Row 1: [%d %f]\n&quot;, x, y);  }}/* Output:Row 1: [5 5.332542]Row 1: [5 5.332542]Row 1: [5 5.332542]*/</code></pre><p>format() 和 printf() 是等价的。</p><p><strong>Formatter</strong> 看一看成一个翻译器，劲格式化字符串与数据翻译成需要的结果。</p><pre><code class="Java">private Formatter f = new Formatter(System.out);f.format(&quot;%s The Turtle is at (%d,%d)\n&quot;, name, x, y);</code></pre><p>5.正则表达式</p><p>6.扫描输入</p><p>Java SE5 新增了 Scanner 类接受任意类型的输入对象。</p><h1 id="第16章-数组"><a href="#第16章-数组" class="headerlink" title="第16章 数组"></a>第16章 数组</h1><h1 id="第19章-枚举类型"><a href="#第19章-枚举类型" class="headerlink" title="第19章 枚举类型"></a>第19章 枚举类型</h1><p>未完待续。。</p><blockquote><p>参考资料<br>1、读书笔记 JAVA编程思想 第13章 字符串 - CSDN博客<br><a href="http://blog.csdn.net/imaginedranges/article/details/73335553" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/imaginedranges/article/details/73335553</a><br>2、Java 字符串常用操作（String类） - 薛遗山 - 博客园<br><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/b6f25079.html"/>
    <id>http://www.wshunli.com/posts/b6f25079.html</id>
    <published>2017-12-04T09:04:23.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 异常处理。</p><a id="more"></a><p>第12章 <strong>通过异常处理错误</strong></p><p>Java的基本理念是“结构不佳的代码不能运行”。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java异常.png" alt="Java异常"></p><p>Java 中的异常处理都是围绕着 try-catch-finally, throw, throws 这几个展开的，也就是：</p><p>try-catch-finally：捕获异常并处理。<br>throw：遇到错误的时候抛出一个异常。<br>throws：声明一个方法可能抛出的异常（所有可能抛出的异常都需要声明）。</p><pre><code class="Java">class ThreeException extends Exception {}public class FinallyWorks {  static int count = 0;  public static void main(String[] args) {    while(true) {      try {        // Post-increment is zero first time:        if(count++ == 0) throw new ThreeException();        System.out.println(&quot;No exception&quot;);      } catch(ThreeException e) {        System.out.println(&quot;ThreeException&quot;);      } finally {        System.out.println(&quot;In finally clause&quot;);        if(count == 2) break; // out of &quot;while&quot;      }    }  }}/* Output:ThreeExceptionIn finally clauseNo exceptionIn finally clause*/</code></pre><p>throw 与 throws 的差别</p><p>throw 是语句抛出一个 Throwable 类型的异常，总是出现在函数体中；程序会在 throw 语句之后立即终止。</p><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用 throws 子句来声明抛出异常；<br>throws 语句用在方法定义时声明该方法要抛出的异常类型，多个异常可使用逗号分割。</p><pre><code class="Java">f() throws Exception1, Exception2, Exception3, ... {    ...}</code></pre><p>例如：</p><pre><code class="Java">import java.lang.Exception;public class TestException {    public int div(int x, int y) throws MyException {        if (y == 0) {            throw new MyException(&quot;除数不能为0&quot;);        }        return (int)(x/y);    }    public static void main(String[] args) {        int x = 1;        int y = 0;        try {            int result = div(x, y);        } catch (MyException e) {            System.out.println(e.getMessage());        }    }}//自定义异常类class MyException extends Exception {    String message;    public MyException(String ErrorMessage) {        message = ErrorMessage;    }    public String getMessage() {        return message;    }}</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十二章 通过异常处理<br><a href="https://zhuanlan.zhihu.com/p/25935822" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25935822</a><br>2、Java编程思想第四版读书笔记——第十二章 通过异常处理错误 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/51780879" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/51780879</a><br>3、Java 异常处理<br><a href="https://zhuanlan.zhihu.com/p/24043941" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/24043941</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 异常处理。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/d96c953e.html"/>
    <id>http://www.wshunli.com/posts/d96c953e.html</id>
    <published>2017-12-03T11:07:09.000Z</published>
    <updated>2018-01-24T15:17:45.127Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 集合。</p><a id="more"></a><p>这部分只是还是挺重要的，面试题里面有好多。</p><p>第11章 <strong>持有对象</strong></p><p>Java 容器类提供了完善的方法保存对象，并经其划分为 <strong>Collection</strong> 和 <strong>Map</strong> 两个不同的概念。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java容器.png" alt="Java容器"></p><p><strong>Collection</strong> 一个独立的元素序列；<strong>Map</strong> 一组成对的“键值对”对象。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>1.<strong>Collection</strong> 一个独立的元素序列，这些元素服从一条或者多条规则。</p><p>List 必须按照插入的顺序保存元素，而 Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序。</p><pre><code class="java">public class SimpleCollection {  public static void main(String[] args) {    Collection&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;();    for(int i = 0; i &lt; 10; i++)      c.add(i); // Autoboxing    for(Integer i : c)      System.out.print(i + &quot;, &quot;);  }}/* Output:0, 1, 2, 3, 4, 5, 6, 7, 8, 9,*/</code></pre><p>2.Arrays 和 Collections 类有很多实用的方法，可以在 Collection 中添加一组元素。</p><pre><code class="Java">public class AddingGroups {  public static void main(String[] args) {    Collection&lt;Integer&gt; collection =      new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5));    Integer[] moreInts = { 6, 7, 8, 9, 10 };    collection.addAll(Arrays.asList(moreInts));    // Runs significantly faster, but you can&#39;t    // construct a Collection this way:    Collections.addAll(collection, 11, 12, 13, 14, 15);    Collections.addAll(collection, moreInts);    // Produces a list &quot;backed by&quot; an array:    List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20);    list.set(1, 99); // OK -- modify an element    // list.add(21); // Runtime error because the                     // underlying array cannot be resized.  }}</code></pre><p>Arrays.asList() 接受一个数组或者可变参数列表，并将之转换为 List 对象。<br>需要注意的是，此种方式获得的 List 对象，由于底层实现仍然是数组，在添加或者删除元素时会出现 UnsupportedOperationException 异常。</p><p>Collections.addAll() 接收一个 Collection 对象、一个数组或者是可变参数列表作为参数，得到新的 Collection 对象。</p><p>3.容器的打印</p><pre><code class="Java">public class PrintingContainers {  static Collection fill(Collection&lt;String&gt; collection) {    collection.add(&quot;rat&quot;);    collection.add(&quot;cat&quot;);    collection.add(&quot;dog&quot;);    collection.add(&quot;dog&quot;);    return collection;  }  static Map fill(Map&lt;String,String&gt; map) {    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);    map.put(&quot;cat&quot;, &quot;Rags&quot;);    map.put(&quot;dog&quot;, &quot;Bosco&quot;);    map.put(&quot;dog&quot;, &quot;Spot&quot;);    return map;  }      public static void main(String[] args) {    print(fill(new ArrayList&lt;String&gt;()));    print(fill(new LinkedList&lt;String&gt;()));    print(fill(new HashSet&lt;String&gt;()));    print(fill(new TreeSet&lt;String&gt;()));    print(fill(new LinkedHashSet&lt;String&gt;()));    print(fill(new HashMap&lt;String,String&gt;()));    print(fill(new TreeMap&lt;String,String&gt;()));    print(fill(new LinkedHashMap&lt;String,String&gt;()));  }}/* Output:[rat, cat, dog, dog][rat, cat, dog, dog][dog, cat, rat][cat, dog, rat][rat, cat, dog]{dog=Spot, cat=Rags, rat=Fuzzy}{cat=Rags, dog=Spot, rat=Fuzzy}{rat=Fuzzy, cat=Rags, dog=Spot}*/</code></pre><p>Collection 打印出来的内容用 [ ] 括住，Map 打印出来的内容用 { } 括住。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口在 Collection 基础上添加了大量的方法。可分为 ArrayList 和 LinkedList 两种。</p><p><strong>ArrayList</strong> 数据结构采用的是线性表，优势是访问和查询十分方便，但添加和删除的时候效率很低。<br><strong>LinkedList</strong> 数据结构采用的是链表，优势是删除和添加的效率很高，但随机访问元素时效率较 ArrayList 类低。</p><p>List 重要价值在于提供了一种可修改的序列。</p><p>contains(Object o) 确定某个对象是否在列表中。<br>remove(int index) 移除指定位置上的元素。<br>indexOf() 返回列表中首次出现指定元素的索引，如果不包含该元素，返回-1。</p><p>LikedList 增加了可以使其用作栈、队列或双端队列的方法。</p><pre><code class="Java">public class Stack&lt;T&gt; {    private LinkedList&lt;T&gt; storage = new LinkedList&lt;&gt;();    public void push(T v){        storage.addFirst(v);    }    public T peek(){        return storage.getFirst();    }    public T pop(){        return storage.removeFirst();    }    public boolean empty(){        return storage.isEmpty();    }    public String toString(){        return storage.toString();    }}</code></pre><p>LikedList 具有直接实现栈（LIFO）的所有功能的方法。</p><p>addFirst(E e)/addLast(E e)：将元素添加到列表的开头/结尾<br>getFirst()/element()：返回列表的第一个元素<br>peek()/peekFirst()：获取但不移除列表的第一个元素<br>offer(E e)/offerLast(E e)：将元素插入到列表末尾</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列是典型的先进先出（FIFO）的容器。</p><pre><code class="Java">public class QueueDemo {    public static void printQ(Queue queue) {  while(queue.peek() != null)      System.out.print(queue.remove() + &quot; &quot;);  System.out.println();    }    public static void main(String[] args) {  Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();  Random random = new Random(47);  for(int i = 0; i &lt; 10; i++)      queue.offer(random.nextInt(i+10));  printQ(queue);  Queue&lt;Character&gt; qCharacters = new LinkedList&lt;Character&gt;();  for(char c : &quot;Brontosaurus&quot;.toCharArray())      qCharacters.offer(c);  printQ(qCharacters);    }}/* Output: 8 1 1 1 5 14 3 1 0 1 B r o n t o s a u r u s*/</code></pre><p>LinkedList 提供了方法以支持队列的行为，并且它实现了 Queue 接口，<br>因此 LinkedList 可以用作 Queue 的一种实现，也可以将 LinkedList 向上转型为 Queue 。</p><p><strong>PriorityQueue</strong> 优先级队列声明下一个弹出的元素是最需要的元素(具有最高的优先级)，可以确保当调用 peek()、poll() 和 remove() 方法时，获取的元素将是队列中优先级最高的元素。</p><pre><code class="java">PriorityQueue priorityQueue = new PriorityQueue&lt;Integer&gt;(  inis.size(),Collections.reverseOrder());</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 具有与 Collection 完全一样的接口，实际上就是 Collection ，只是行为不同。</p><p><strong>HashSet</strong> 数据结构采用的是散列表，主要是设计用来做高性能集运算的，例如对两个集合求交集、并集、差集等。<br>集合中包含一组不重复出现且无特性顺序的元素，其值是不可重复与无序的。</p><p>LinkedHashSet 的核心概念相对于 HashSet 来说就是一个可以保持顺序的Set集合。</p><p><strong>TreeSet</strong> 数据结构使用的是红黑树，性能上低于HashSet，用于排序。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map：一组成对的“键值对”对象，允许使用键来查找值；<br>映射表允许我们使用另一个对象来查找某个对象，它被称为“关联数组”，因为它将某些对象与另外一些对象关联在了一起，或者被称为“字典”</p><pre><code class="Java">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</code></pre><p>get(Object o)：返回指定键所映射的值，如果不包含该键的映射关系，返回 null 。<br>put(K key, V value)：将指定的值与此映射中的指定键关联，如果已经存在映射关系，更新值。<br>hashCode()：返回此映射的哈希码值。</p><h2 id="Map-的三种实现"><a href="#Map-的三种实现" class="headerlink" title="Map 的三种实现"></a>Map 的三种实现</h2><p>HashMap：基于“拉链法”实现的散列表，一般用于单线程中，不是线程安全的。<br>HashTable：基于“拉链法”实现的散列表，一般用于多线程中，是线程安全的。<br>TreeMap：有序的散列表，通过红黑树实现的，一般用于单线程中存储有序的映射。</p><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>迭代器，用于遍历容器，JDK源码如下：</p><pre><code class="Java">package java.util;import java.util.function.Consumer;public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}</code></pre><p>Java 的 Iterator 只能单向移动：</p><pre><code class="Java">public class SimpleIteration {  public static void main(String[] args) {    List&lt;Pet&gt; pets = Pets.arrayList(12);    Iterator&lt;Pet&gt; it = pets.iterator();    while(it.hasNext()) {      Pet p = it.next();      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    }    System.out.println();    // A simpler approach, when possible:    for(Pet p : pets)      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    System.out.println();        // An Iterator can also remove elements:    it = pets.iterator();    for(int i = 0; i &lt; 6; i++) {      it.next();      it.remove();    }    System.out.println(pets);  }}/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]*/</code></pre><p>Iterator() 要求容器返回一个Iterator。Iterator 准备好返回序列的第一个元素。<br>next() 获得序列中的下一个元素。<br>hasNext() 检查序列中是否还有元素。<br>remove() 将迭代器新近返回的元素删除。</p><h2 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h2><p>ListIterator 是 Iterator 的一个子类，只能用于各种List的访问。<br>ListIterator 可以双向移动，可以产生当前位置的前一个和后一个元素的索引，并且可以使用 set() 方法，将最近访问过的元素进行替换。<br>此外，还可以通过 listIterator(int index) 的方法，获得一个一开始就指向 index 位置的 ListIterator。</p><h1 id="Foreach-与迭代器"><a href="#Foreach-与迭代器" class="headerlink" title="Foreach 与迭代器"></a>Foreach 与迭代器</h1><p>foreach 语法主要用于数组，同样可以用于 Collection 对象。</p><pre><code class="Java">public class ForEachCollections {  public static void main(String[] args) {    Collection&lt;String&gt; cs = new LinkedList&lt;String&gt;();    Collections.addAll(cs,      &quot;Take the long way home&quot;.split(&quot; &quot;));    for(String s : cs)      System.out.print(&quot;&#39;&quot; + s + &quot;&#39; &quot;);  }}/* Output:&#39;Take&#39; &#39;the&#39; &#39;long&#39; &#39;way&#39; &#39;home&#39;*/</code></pre><p>因为 java SE5 引入了 Iterable 接口，该接口包含产生 Iterator 的 iterator 方法，<br>并且 Iterable 接口被 foreach 用来造序列中移动。</p><blockquote><p>参考资料<br>1、Java 容器知识整理 - FullStackDeveloper - SegmentFault<br><a href="https://segmentfault.com/a/1190000002903035" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002903035</a><br>2、Java编程思想读书笔记——持有对象 - CSDN博客<br><a href="http://blog.csdn.net/baidu_21088863/article/details/78175347" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/baidu_21088863/article/details/78175347</a><br>3、Java编程思想第四版读书笔记——第十一章 持有对象 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/49491441" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/49491441</a><br>4、深入Java源码解析容器类List、Set、Map - 简书<br><a href="http://www.jianshu.com/p/047e33fdefd2" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/047e33fdefd2</a><br>5、《Java编程思想》读书笔记 第十一章 持有对象 02 Map<br><a href="https://zhuanlan.zhihu.com/p/25816448" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25816448</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 集合。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
</feed>
