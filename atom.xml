<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2017-12-02T14:48:31.458Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Hexo 中插入全景图片</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-panoview.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-panoview.html</id>
    <published>2017-11-30T09:14:59.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>一款基于 Three.js 全景显示的 Hexo 插件。</p><a id="more"></a><h1 id="Threejs-介绍"><a href="#Threejs-介绍" class="headerlink" title="Threejs 介绍"></a>Threejs 介绍</h1><p><a href="https://threejs.org/" rel="external nofollow noopener noreferrer" target="_blank">three.js</a> The aim of the project is to create an easy to use, lightweight, 3D library. The library provides <code>&lt;canvas&gt;</code>, <code>&lt;svg&gt;</code>, CSS3D and WebGL renderers.</p><div id="panoview10" style="margin:0 auto"></div><script src="https://unpkg.com/three@0.88.0/build/three.min.js"></script><script>function init(){var e,n;(e=document.getElementById("panoview10")).style.width;(camera=new THREE.PerspectiveCamera(75,2,1,1e3)).target=new THREE.Vector3(0,0,0),scene=new THREE.Scene;var t=new THREE.SphereBufferGeometry(500,60,40);t.scale(-1,1,1);var o=new THREE.MeshBasicMaterial({map:(new THREE.TextureLoader).load("https://img.wshunli.com/pano/pano2.jpg")});n=new THREE.Mesh(t,o),scene.add(n),(renderer=new THREE.WebGLRenderer).setPixelRatio(window.devicePixelRatio),renderer.setSize(window.innerWidth,window.innerHeight),renderer.domElement.style.width="800px",renderer.domElement.style.height="400px",e.appendChild(renderer.domElement),e.addEventListener("mousedown",onDocumentMouseDown,!1),e.addEventListener("mousemove",onDocumentMouseMove,!1),e.addEventListener("mouseup",onDocumentMouseUp,!1),e.addEventListener("dragover",function(e){e.preventDefault(),e.dataTransfer.dropEffect="copy"},!1),e.addEventListener("dragenter",function(e){document.body.style.opacity=.5},!1),e.addEventListener("dragleave",function(e){document.body.style.opacity=1},!1)}function onDocumentMouseDown(e){e.preventDefault(),isUserInteracting=!0,onMouseDownMouseX=e.clientX,onMouseDownMouseY=e.clientY,onMouseDownLon=lon,onMouseDownLat=lat}function onDocumentMouseMove(e){!0===isUserInteracting&&(lon=.1*(onMouseDownMouseX-e.clientX)+onMouseDownLon,lat=.1*(e.clientY-onMouseDownMouseY)+onMouseDownLat)}function onDocumentMouseUp(e){isUserInteracting=!1}function onDocumentMouseWheel(e){var n=camera.fov+.05*e.deltaY;return camera.fov=THREE.Math.clamp(n,10,75),camera.updateProjectionMatrix(),!1}function animate(){requestAnimationFrame(animate),update()}function update(){!1===isUserInteracting&&(lon+=.1),lat=Math.max(-85,Math.min(85,lat)),phi=THREE.Math.degToRad(90-lat),theta=THREE.Math.degToRad(lon),camera.target.x=500*Math.sin(phi)*Math.cos(theta),camera.target.y=500*Math.cos(phi),camera.target.z=500*Math.sin(phi)*Math.sin(theta),camera.lookAt(camera.target),renderer.render(scene,camera)}var camera,scene,renderer,isUserInteracting=!1,onMouseDownMouseX=0,onMouseDownMouseY=0,lon=0,onMouseDownLon=0,lat=0,onMouseDownLat=0,phi=0,theta=0;init(),animate()</script><h1 id="Hexo-中插入全景图片"><a href="#Hexo-中插入全景图片" class="headerlink" title="Hexo 中插入全景图片"></a>Hexo 中插入全景图片</h1><p><a href="https://github.com/wshunli/hexo-tag-panoview" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-panoview</a> 是一款在 Hexo 中使用 AntV 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-panoview --save</code></pre><p>之后在文章内使用 <code>panoview</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% panoview "https://img.wshunli.com/pano/pano2.jpg" 400 800 %}{% endpanoview %}</code></pre><p>其中：<br><code>panoview</code> 和 <code>endpanoview</code> 是 Hexo 的标签，不需要修改；<br><code>https://img.wshunli.com/pano/pano2.jpg</code> 部分是全景照片，建议 1024*512 ；<br><code>400</code> 是指全景的高度；<br><code>800</code> 是指全景的宽度。</p><p>灵感来自 <a href="https://threejs.org/examples/?q=pano#webgl_panorama_equirectangular" rel="external nofollow noopener noreferrer" target="_blank">webgl_panorama_equirectangular</a><br>也是我发布的第二个 npm 组件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一款基于 Three.js 全景显示的 Hexo 插件。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="panoview" scheme="http://www.wshunli.com/tags/panoview/"/>
    
      <category term="hexo-tag-panoview" scheme="http://www.wshunli.com/tags/hexo-tag-panoview/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入 AntV 动态图表</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-antv.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-antv.html</id>
    <published>2017-11-30T02:53:24.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p><strong>让数据栩栩如生</strong><br><a id="more"></a></p><div id="antv3229"></div><script src="https://gw.alipayobjects.com/as/g/datavis/assets/1.0.5/g2/3.0.0/g2.min.js"></script><script type="text/javascript">var chart=new G2.Chart({container:"antv3229",height:300,forceFit:!0,data:[{genre:"Sports",sold:275},{genre:"Strategy",sold:115},{genre:"Action",sold:120},{genre:"Shooter",sold:350},{genre:"Other",sold:150}],options:{scales:{genre:{alias:"游戏种类"},sold:{alias:"销售量"}},geoms:[{type:"interval",position:"genre*sold",color:"genre"}]}});chart.render()</script><h1 id="AntV-介绍"><a href="#AntV-介绍" class="headerlink" title="AntV 介绍"></a>AntV 介绍</h1><p><a href="https://antv.alipay.com" rel="external nofollow noopener noreferrer" target="_blank">AntV</a> 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。</p><h1 id="Hexo-中使用-AntV"><a href="#Hexo-中使用-AntV" class="headerlink" title="Hexo 中使用 AntV"></a>Hexo 中使用 AntV</h1><p><a href="https://github.com/wshunli/hexo-tag-antv" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-antv</a> 是一款在 Hexo 中使用 AntV 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-antv --save</code></pre><p>之后在文章内使用 <code>antv</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% antv 300 %}data:[    // TODO antv data goes here],options: {    // TODO antv options goes here}{% endantv %}</code></pre><p>其中：<br><code>antv</code> 和 <code>endantv</code> 是 Hexo 的标签，不需要修改；<br><code>300</code> 是指图表的高度，图表宽度是自适应的；<br><code>data</code> 部分是图表的数据；<br><code>options</code> 部分是图表的配置。</p><pre><code class="JavaSript">const options = {  scales: {object}, // 列定义声明  coord: {object}, // 坐标系配置  axes: {object}, // 坐标轴配置  legends: {object}, // 图例配置  guides: {array}, // 图表辅助元素配置  filters: {object}, // 数据过滤配置  tooltip: {object}, // 提示信息配置  facet: {object}, // 分面配置  geoms: {array} // 图形语法相关配置}</code></pre><p>更详细配置可参考官方文档：<a href="https://antv.alipay.com/zh-cn/g2/3.x/api/options.html" rel="external nofollow noopener noreferrer" target="_blank">配置项声明方式</a></p><p>下面我们来看一个饼图的使用样例：</p><pre><code class="javaSript">{% antv %}data:[  { genre: 'Sports', sold: 275 },  { genre: 'Strategy', sold: 115 },  { genre: 'Action', sold: 120 },  { genre: 'Shooter', sold: 350 },  { genre: 'Other', sold: 150 }],options: {    scales: {      'genre': {        alias: '游戏种类'      },      'sold': {        alias: '销售量'      }    },    geoms: [      {        type: 'percent',        position: 'genre*sold',        color: 'genre'      }    ]  }{% endantv %}</code></pre><p>即开头的图表效果。</p><p>灵感来自 <a href="https://github.com/quentin-chen/hexo-tag-echarts3" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-echarts3</a>，AntV 也刚刚发布了 3.0 版本所以就想尝试下。<br>最主要目的还是尝试发布自己的 npm 组件，可能现在还不够实用，后面我会不断完善。</p><blockquote><p>参考资料<br>1、发布自己的module - 我的第一个npm组件！<br><a href="https://segmentfault.com/a/1190000006250554" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000006250554</a><br>2、在 Hexo 中插入 ECharts 动态图表<br><a href="http://kchen.cc/2016/11/05/echarts-in-hexo/" rel="external nofollow noopener noreferrer" target="_blank">http://kchen.cc/2016/11/05/echarts-in-hexo/</a><br>3、标签插件（Tag） | Hexo<br><a href="https://hexo.io/zh-cn/api/tag.html" rel="external nofollow noopener noreferrer" target="_blank">https://hexo.io/zh-cn/api/tag.html</a><br>4、Hexo高级教程之插件开发<br><a href="http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;让数据栩栩如生&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="AntV" scheme="http://www.wshunli.com/tags/AntV/"/>
    
      <category term="hexo-tag-antv" scheme="http://www.wshunli.com/tags/hexo-tag-antv/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/6e418c5b.html"/>
    <id>http://www.wshunli.com/posts/6e418c5b.html</id>
    <published>2017-11-28T13:15:08.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类与接口。</p><a id="more"></a><h1 id="第5章-初始化与清理"><a href="#第5章-初始化与清理" class="headerlink" title="第5章 初始化与清理"></a>第5章 初始化与清理</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类与接口。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/235f2f09.html"/>
    <id>http://www.wshunli.com/posts/235f2f09.html</id>
    <published>2017-11-28T12:47:30.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 基础知识部分。</p><a id="more"></a><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a>第3章 操作符</h1><p>Java 中的数据是通过使用操作符来操作的。</p><ul><li>赋值操作符</li><li>算术操作符</li><li>关系操作符</li><li>逻辑操作符</li><li>按位操作符</li><li>其他操作符</li></ul><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a>第4章 控制执行流程</h1><p>1.Java 中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p>2.Foreach 语法，用于数组或容器</p><pre><code class="Java">int [] numbers = {10, 20, 30, 40, 50};for(int x : numbers ){    System.out.print( x );    System.out.print(&quot;,&quot;);}// 10,20,30,40,50,</code></pre><p>3.return、break、continue</p><p>return：指定方法的返回值或者退出当前方法。</p><p>break：主要用于循环或者 switch 语句，退出整个语句块。<br>continue：跳转到下一次循环迭代。</p><p>4.Java 分支结构：swich 语句与 if 语句</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 基础知识部分。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/1349c3d1.html"/>
    <id>http://www.wshunli.com/posts/1349c3d1.html</id>
    <published>2017-11-28T02:58:36.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 一切皆对象。</p><a id="more"></a><h1 id="第1章-对象导论"><a href="#第1章-对象导论" class="headerlink" title="第1章 对象导论"></a>第1章 对象导论</h1><p>本章主要介绍 OOP 面向对象的思想以及抽象、封装、继承、多态的概念。</p><p>JAVA 是一种面向对象编程语言：</p><ul><li>万物皆对象，每一个对象都会存储数据，并且可以对自身执行操作。因此，每一个对象包含两部分：成员变量和成员方法。在成员方法中可以改变成员变量的值。</li><li>程序是对象的集合，他们通过发送消息来告知彼此所要做的事情，也就是调用相应的成员函数。</li><li>每一个对象都有自己的由其他对象所构成的存储，也就是说在创建新对象的时候可以在成员变量中使用已存在的对象。</li><li>每个对象都拥有其类型，每个对象都是某个类的一个实例，每一个类区别于其它类的特性就是可以向它发送什么类型的消息，也就是它定义了哪些成员函数。</li><li>某一个特定类型的所有对象都可以接受同样的消息。</li></ul><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a>第2章 一切都是对象</h1><p>1.Java 中一切都被视为对象，但是操作的标识符实际是对象的引用。</p><pre><code class="Java">String s;                         // s 为引用，并不是对象。String s = new String(&quot;wshunli&quot;); // s 与新的对象关联String s = &quot;wshunli&quot;;             // 等价</code></pre><p>2.数据存储位置可分为：寄存器、堆栈、堆、常量存储、非 RAM 存储。</p><ul><li>寄存器位于处理器内部，最快的存储区；</li><li>堆栈通常位于 RAM 中，存储对象引用；</li><li>堆通常也是位于 RAM 中，存储所有 Java 对象；</li><li>常量存储直接存放在代码内部；</li><li>非 RAM 存储的数据完全存活于程序之外，比如流对象和持久化对象。</li></ul><p>3.Java 基本数据类型：</p><ul><li>byte、short、int、long</li><li>float、double</li><li>boolean</li><li>char</li></ul><p>4.类：字段、方法组成。</p><p>5.HelloWorld：</p><pre><code class="Java">public class HelloWorld {    /* 第一个Java程序     * 它将打印字符串 Hello World     */    public static void main(String []args) {        System.out.println(&quot;Hello World&quot;); // 打印 Hello World    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 一切皆对象。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（四）</title>
    <link href="http://www.wshunli.com/posts/9695607b.html"/>
    <id>http://www.wshunli.com/posts/9695607b.html</id>
    <published>2017-11-19T06:34:43.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      看得更远，走得更远。
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《React Native开发指南》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/46b86b5e.html"/>
    <id>http://www.wshunli.com/posts/46b86b5e.html</id>
    <published>2017-11-18T04:23:39.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。<br><a id="more"></a></p><p>我选择的是先看 《React Native开发指南》 入门。</p><h1 id="第1章-初识-React-Native"><a href="#第1章-初识-React-Native" class="headerlink" title="第1章 初识 React Native"></a>第1章 初识 React Native</h1><p><a href="https://facebook.github.io/react-native/" rel="external nofollow noopener noreferrer" target="_blank">React Native</a> 是一款用来开发真正原生、可渲染 iOS 和 Android 移动应用的 JavaScript 框架。<br>React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。<br>在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。</p><h1 id="第2章-React-Native-工作原理"><a href="#第2章-React-Native-工作原理" class="headerlink" title="第2章 React Native 工作原理"></a>第2章 React Native 工作原理</h1><p>React Native 使用 Virtual DOM 作为中间层，介于开发者描述的视图与实际页面渲染的视图之间。<br>Virtual DOM 不仅能提升性能，而且提供了强大的抽象能力，在开发者代码和实际渲染之间加入一个抽象层。</p><p>React Native 调用 Objective-C 的 API 渲染 iOS 组件，调用 Java 接口渲染 Android 组件，而不是渲染到浏览器 DOM 上。</p><p>React Native 的渲染周期和 React 完全相同；组件也很类似，只是名称有差别，但是和原生的组件名字差不多；使用 JSX 以及 React 的内联样式。</p><p>React Native 同样可以调用宿主平台的接口，比如数据存储，操控硬件设备等等。</p><h1 id="第3章-构建你的第一个应用"><a href="#第3章-构建你的第一个应用" class="headerlink" title="第3章 构建你的第一个应用"></a>第3章 构建你的第一个应用</h1><p>类似 React ，使用 React Native 构建 Android 应用，可使用 <code>create-react-native-app</code> 脚手架工具。</p><pre><code class="JSX">npm install -g create-react-native-app</code></pre><p>安装完成后执行以下命令即可创建 React Native 项目：</p><pre><code class="JSX">create-react-native-app first-react-native-app// 打开项目目录cd first-react-native-appnpm start</code></pre><p>基本上就构建完成。</p><p>运行在 Andoroid 系统:</p><pre><code class="JSX">npm run android</code></pre><p>代码也比较容易理解：</p><pre><code class="JSX">import React from &#39;react&#39;;import { StyleSheet, Text, View } from &#39;react-native&#39;;export default class App extends React.Component {  render() {    return (      &lt;View style={styles.container}&gt;        &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt;        &lt;Text&gt;Changes you make will automatically reload.&lt;/Text&gt;        &lt;Text&gt;Shake your phone to open the developer menu.&lt;/Text&gt;      &lt;/View&gt;    );  }}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: &#39;#fff&#39;,    alignItems: &#39;center&#39;,    justifyContent: &#39;center&#39;,  },});</code></pre><p>感觉和 React.js 差不多，比较容易理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。&lt;br&gt;
    
    </summary>
    
      <category term="跨平台技术" scheme="http://www.wshunli.com/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React Native" scheme="http://www.wshunli.com/tags/React-Native/"/>
    
      <category term="《React Native开发指南》" scheme="http://www.wshunli.com/tags/%E3%80%8AReact-Native%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/86c8e45a.html"/>
    <id>http://www.wshunli.com/posts/86c8e45a.html</id>
    <published>2017-11-15T08:05:27.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习 《深入浅出React和Redux》<br><a id="more"></a></p><h1 id="第3章-从-Flux-到-Redux"><a href="#第3章-从-Flux-到-Redux" class="headerlink" title="第3章 从 Flux 到 Redux"></a>第3章 从 Flux 到 Redux</h1><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>Redux 是 Flux 单向数据流思想的另一种实现方式，先介绍 Flux 的优缺点。</p><h3 id="MVC-介绍"><a href="#MVC-介绍" class="headerlink" title="MVC 介绍"></a>MVC 介绍</h3><p>MVC 框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分为三个部分：<br><img src="https://img.wshunli.com/React/深入浅出React和Redux/MVC.png-hexo.png" alt="MVC"></p><ul><li>Model （模型）负责管理数据，大部分业务逻辑也应该放在Model 中；</li><li>View （视图）负责渲染用户界面，应该避免在View 中涉及业务逻辑；</li><li>Controller （控制器）负责接受用户输入根据用户输入调用对应的Model 部分逻辑，把产生的数据结果交给View 部分，让View 渲染出必要的输出。</li></ul><p>MVC 框架提出的数据流很理想，用户请求先到达 Controller ，由 Controller 调用 Model 获得数据，然后把数据交给 View，但是在实际框架实现中，总是允许 View 和 Model 可以直接通信，MVC 很快就变得非常复杂。</p><p>Flux 执行更严格的数据流控制。一个 Flux 应用包含四个部分：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/Flux.png-hexo.png" alt="Flux"></p><ul><li>Dispatcher ，处理动作分发，维持Store 之间的依赖关系；</li><li>Store ，负责存储数据和处理数据相关逻辑；</li><li>Action ，驱动 Dispatcher 的JavaScript 对象；</li><li>View ，视图部分，负责显示用户界面。</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Flux 的基本原则是“单向数据流”， Redux 在此基础上强调三个基本原则：</p><ul><li>唯一数据源（ Single Source of Truth);</li><li>保持状态只读（ State is read-only);</li><li>数据改变只能通过纯函数完成（ Changes are made with pure functions ）。</li></ul><blockquote><p>参考资料<br>1、Flux | Application Architecture for Building User Interfaces<br><a href="https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow" rel="external nofollow noopener noreferrer" target="_blank">https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow</a><br>2、Flux 架构入门教程 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2016/01/flux.html</a><br>3、</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习 《深入浅出React和Redux》&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>又拍云CDN全站加速</title>
    <link href="http://www.wshunli.com/posts/97fe98e3.html"/>
    <id>http://www.wshunli.com/posts/97fe98e3.html</id>
    <published>2017-11-11T11:44:24.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。</p><a id="more"></a><p>前几天使用 Travis CI 自动构建 Hexo 博客并且上传至 Github 和 Coding，就在想能不能同时上传至 <a href="https://console.upyun.com/register/?invite=H1_D-bC4W" rel="external nofollow noopener noreferrer" target="_blank">又拍云</a>。</p><p>今天晚上使用 ftp 上传至又拍云，网站实现全站 CDN 加速。</p><p>前面发现是有工具可以直接上传至又拍云：</p><p><a href="https://github.com/Menci/hexo-deployer-upyun" rel="external nofollow noopener noreferrer" target="_blank">hexo-deployer-upyun</a></p><p>但是这个工具在 Windows 系统下使用有问题，并且我已经使用 Travis CI 自动部署了，继续使用这个工具有<strong>令牌</strong>暴露的风险。</p><p>所以就想使用 ftp 上传至又拍云，然后就发现了这个工具：</p><p><a href="https://github.com/git-ftp/git-ftp" rel="external nofollow noopener noreferrer" target="_blank">Git-ftp</a> – uploads to FTP servers the Git way</p><p>在 linux 下的安装方法：</p><pre><code class="Shell">git clone https://github.com/git-ftp/git-ftp.gitcd git-ftp# choose the newest releasetag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;# checkout the latest taggit checkout &quot;$tag&quot;sudo make install</code></pre><p>配置 git-ftp ：</p><pre><code class="Shell">git config git-ftp.url &quot;ftp://ftp.example.net:21/public_html&quot;git config git-ftp.user &quot;ftp-user&quot;git config git-ftp.password &quot;secr3t&quot;</code></pre><p>第一次上传执行：</p><pre><code class="Shell">git ftp init</code></pre><p>后面上传执行，只会上传变化的部分：</p><pre><code class="Shell">git ftp push</code></pre><p>使用方法也很简单，下面就默认在原来 <a href="https://www.wshunli.com/posts/7dcaaf9e.html">Travis CI 自动部署</a> 的基础上:</p><p>在 <code>.travis.yml</code> 文件中修改：</p><pre><code class="Shell">install:  - npm install  - git clone https://github.com/git-ftp/git-ftp.git  - cd git-ftp  - tag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;  - git checkout &quot;$tag&quot;  - sudo make install  - cd ..</code></pre><p>在 <code>publish-to-gh-pages.sh</code> 中修改</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;git ftp init# git ftp push</code></pre><p>第一次上传之后，修改 <code>publish-to-gh-pages.sh</code> 文件</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;# git ftp initgit ftp push -v</code></pre><p>其中 UPYUN_USE 和 UPYUN_PSD 是在 Travis 中配置的 UPYUN ftp 用户名密码。<br>具体值可参考：<a href="https://docs.upyun.com/api/developer_tools/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.upyun.com/api/developer_tools/</a></p><p>其实有点弊端就是上传之后更新具有一定的延迟性，但是速度快很多。</p><blockquote><p>参考资料<br>1、travis-ci-deploy-ftp<br><a href="https://github.com/ansediao/travis-ci-deploy-ftp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ansediao/travis-ci-deploy-ftp</a><br>2、How to use git-ftp： 使用 git-ftp 管理你的 FTP<br><a href="https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9</a><br>3、使用 git-ftp 将 git 两次提交发生变化的文件上传到服务器<br><a href="http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server" rel="external nofollow noopener noreferrer" target="_blank">http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="Upyun" scheme="http://www.wshunli.com/tags/Upyun/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/d0f6201d.html"/>
    <id>http://www.wshunli.com/posts/d0f6201d.html</id>
    <published>2017-11-10T05:40:03.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。</p><a id="more"></a><p>之间就简单地使用 <a href="https://reactjs.org" rel="external nofollow noopener noreferrer" target="_blank">React</a> 搭建过一次 Demo ，借这次机会把 React 给搞定了，至少能写个简单的界面。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React技术栈.png-hexo.png" alt="React技术栈"></p><p>看着这 React技术栈 ，还是压力山大啊。</p><p>这次选了两本书 《深入浅出React和Redux》 和 《React全栈》。书都很新也很薄，这次先看一本入门。</p><h1 id="第1章-React-新的前端思维方式"><a href="#第1章-React-新的前端思维方式" class="headerlink" title="第1章 React 新的前端思维方式"></a>第1章 React 新的前端思维方式</h1><p>首先使用 <code>creat-react-app</code> 创建一个 React 应用。</p><p>在确认 Node.js 和 npm 安装好之后，在命令行执行以下命令安装 <code>creat-react-app</code> 工具。</p><pre><code class="Shell">npm install -g create-react-appcreate-react-app first-react-appnpm start</code></pre><p>浏览器会自动打开 <a href="http://localhost:3000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:3000/</a> 显示如下界面：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app.png-hexo.png" alt="first-react-app"></p><p>我们来看一下 first-react-app 的目录结构：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app2.png-hexo.png" alt="first-react-app"></p><p>在开发过程中，我们主要关注 src 目录的内容。</p><p>其中 <code>src/index.js</code> 文件是应用的入口文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import App from &#39;./App&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>这里的代码渲染了一个 App 组件，效果就是首页界面。<br>我们看下 App 组件是怎么定义的，在 <code>src/App.js</code> 文件中：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import logo from &#39;./logo.svg&#39;;import &#39;./App.css&#39;;class App extends Component {  render() {    return (      &lt;div className=&quot;App&quot;&gt;        &lt;header className=&quot;App-header&quot;&gt;          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;        &lt;/header&gt;        &lt;p className=&quot;App-intro&quot;&gt;          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.        &lt;/p&gt;      &lt;/div&gt;    );  }}export default App;</code></pre><p>React 应用实际上依赖很复杂的技术栈，我们使用 <code>creat-react-app</code> 避免一开始就浪费太多精力配置技术栈。</p><p>我们启动 React 的命令是 <code>npm start</code> ，在 <code>package.json</code> 中：</p><pre><code class="JS">  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  }</code></pre><p>npm build 可以创建生产环境优化代码；<br>npm teat 用于单元测试；<br>npm eject 把 react-scripts 技术栈配置都弹射到应用顶层，不可逆。</p><h2 id="添加-React-组件"><a href="#添加-React-组件" class="headerlink" title="添加 React 组件"></a>添加 React 组件</h2><p>仿照着增加一个新的 React 组件。同样在 src 目录新建文件 <code>ClickCounter.js</code> 写入如下代码：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;class ClickCounter extends Component {  constructor(props) {    super(props);    this.onClickButton = this.onClickButton.bind(this);    this.state = {      count: 0    }  }  onClickButton() {    this.setState({count: this.state.count + 1});  }  render() {    const counterStyle = {      margin: &#39;16px&#39;    }    return (      &lt;div style={counterStyle}&gt;        &lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;        &lt;div&gt;          Click Count: &lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    );  }}export default ClickCounter;</code></pre><p>修改 <code>src/index.js</code> 文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import ClickCounter from &#39;./ClickCounter&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;ClickCounter /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>其中在 index.js 中使用 import 导入 ClickCounter 组件，替代之前的 App 组件。</p><pre><code class="JSX">import ClickCounter from &#39;./ClickCounter&#39;;</code></pre><p>在 ClickCounter.js 的第一行我们以同样的方式引入 React 和 Component 。</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;</code></pre><p>Component 为所有组件的基类，提供很多组件共有的功能。</p><pre><code class="JSX">class ClickCounter extends Component {}</code></pre><p>React 没有在代码中直接使用，但在 JSX 使用的范围内必须有 React，因为 JSX 最终会被转译成依赖 React 的表达式。</p><p><strong>JSX</strong>：JSX 是 JavaScript 的一种扩展语法，使我们能够在 JavaScript 中编写类似 HTML 的代码。<br>JSX 的基本语法规则：遇到 HTML 标签（以&lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。</p><p>首先，在 JSX 中使用的元素不限于 HTML 元素，可以是 React 组件。而区分二者的方法是首字母是否大写。<br>其次，在 JSX 中可以通过 onClick 这样的方式为元素添加事件处理函数。</p><pre><code class="JSX">&lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;</code></pre><h2 id="React-的工作方式"><a href="#React-的工作方式" class="headerlink" title="React 的工作方式"></a>React 的工作方式</h2><p>React的理念归结为一个公式：UI=render(data) 。</p><p>用户看到的界面（UI）是一个函数（render）的执行结果，只接受数据（data）作为参数。这是一个纯函数，即输出只依赖于输入的函数，两次函数的调用如果输入相同，那么输出也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于data ，哪些属于render ，想要更新用户界面，要做的就是更新data ，用户界面自然会做出响应，所以React 实践的也是“响应式编程”（ Reactive Programming ）的思想。</p><p><strong>Virtual DOM</strong>：是对DOM树的抽象，它并不触及浏览器部分，只是存在于 JavaScript 空间的树形结构，每次在渲染 React 组件，React 会对前后两次产生的 Virtual DOM 进行比较，最后只有发生了改变的地方会被重新渲染。</p><blockquote><p>总而言之，React利用函数式编程的思维来解决用户界面渲染的问题，强制所有组件都以数据驱动渲染的模式进行开发。</p></blockquote><h1 id="第2章-设计高质量的-React-组件"><a href="#第2章-设计高质量的-React-组件" class="headerlink" title="第2章 设计高质量的 React 组件"></a>第2章 设计高质量的 React 组件</h1><p>作为软件设计的通则，组件的划分要满足高内聚（High Cohesion ）和低搞合（ Low Coupling）的原则。</p><h2 id="React-组件的数据"><a href="#React-组件的数据" class="headerlink" title="React 组件的数据"></a>React 组件的数据</h2><p>React 组件的数据分为两种， prop 和 state。</p><p>prop 是组件的对外接口， state 是组件的内部状态，对外用 prop ，内部用 state 。</p><h3 id="React-的-prop"><a href="#React-的-prop" class="headerlink" title="React 的 prop"></a>React 的 prop</h3><p>prop ( property 的简写）是外部传递给组件的数据， React 组件通过定义自己能够接受的 prop 就定义了自己的对外公共接口。</p><pre><code class="JSX">&lt;SampleButtonid= &quot;sample&quot; borderWidth={2} onClick={onButtonClick}style={{color :"red"}}/&gt;</code></pre><p>当 prop 的值不是字符串类型时，在 JSX 中必须用花括号 {} 包住，<br>所以 style 的值有两层花括号，外层花括号代表是 JSX 的语法，内层的花括号代表这是一个对象常量。</p><pre><code class="JSX">class ControlPanel extends Component {  render() {    console.log(&#39;enter ControlPanel render&#39;);    return (      &lt;div&gt;        &lt;Counter caption=&quot;First&quot; initValue={0}/&gt;        &lt;Counter caption=&quot;Second&quot; initValue={10} /&gt;        &lt;Counter caption=&quot;Third&quot; initValue={20} /&gt;      &lt;/div&gt;    );  }}</code></pre><p>上面是给 prop 赋值，下面读取 prop 的值：</p><pre><code class="JSX">class Counter extends Component {  constructor(props) {    console.log(&#39;enter constructor: &#39; + props.caption);    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue || 0    }  }  ···</code></pre><p>在构造函数中可以通过参数 props 获得传人 prop 值，在其他函数中则可以通过 <code>this.props</code> 访问传人 prop 的值。</p><pre><code class="JSX">  ··· render() {    console.log(&#39;enter render &#39; + this.props.caption);    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }</code></pre><p><strong>propTypes 检查</strong>：组件声明接口规范，即组件支持的 prop 及其格式。</p><pre><code class="JSX">Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number};</code></pre><p>建议在开发阶段使用，产品环境下去除。</p><h3 id="React-的-state"><a href="#React-的-state" class="headerlink" title="React 的 state"></a>React 的 state</h3><p>state 代表组件的内部状态。</p><p>1、初始化 state</p><p>通常在组件的构造函数结尾处初始化 state 。</p><pre><code class="JSX">constructor(props) {    ···    this.state = {      count: props.initValue || 0    }  }</code></pre><p>React 的 defaultProps 给 prop 默认初始值：</p><pre><code class="JSX">Counter.defaultProps = {  initValue: 0}// this.state 可省去判断this.state = {  count: props.initValue}</code></pre><p>2、读取更新 state</p><p>this.state 读取 state<br>this.setState 更新 state</p><pre><code class="JSX">onClickIncrementButton() {  this.setState({count: this.state.count + 1});}</code></pre><h3 id="prop-和state-的区别"><a href="#prop-和state-的区别" class="headerlink" title="prop 和state 的区别"></a>prop 和state 的区别</h3><ul><li>prop 用于定义外部接口， state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时， state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><p>组件是绝不应该去修改传人的 props 值，否则会影响其他组件。</p><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：</p><ul><li>装载过程（ Mount ），也就是把组件第一次在DOM 树中渲染的过程；</li><li>更新过程（ Update ），当组件被重新渲染的过程；</li><li>卸载过程（ Unmount ），组件从DOM 中删除的过程。</li></ul><p>三种不同的过程， React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React组件生命周期.png-hexo.png" alt="React组件生命周期"></p><p><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a></p><h3 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h3><p>当组件第一次渲染的时候，依次调用的函数如下：</p><ul><li>constructor()</li><li>getlnitialState()</li><li>getDefaultProps()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p>1、constructor()<br>ES6 中类的构造函数，主要是初始化 state 和绑定成员函数的 this 环境。</p><p>2、getlnitialState() 和 getDefaultProps()<br>getlnitialState() 返回值用来初始化组件的 this.state ，getDefaultProps() 返回值用来作为 prop 的初始值。<br>这两个方法只有用 React.createClass 方法创建组件类时才会生效。</p><pre><code class="JSX">const Sample = React.createClass({  getInitialState() {    console.log(&#39;enter getInitialState&#39;);  }  getDefaultProps() {    console.log(&#39;enter getDefaultProps&#39;);  }});</code></pre><p>而在 ES6 中使用 defaultProps 指定初试 prop 初始值。</p><pre><code class="JSX">const Sample extends React.Component({  constructor(props) {    super(props);    this.state = {foo: &quot;bar&quot;}  }}Sample.defaultProps = {  return {sampleProp: 0}};</code></pre><p>React.createClass 已经被 Facebook 官方逐渐废弃。</p><p>3、render()</p><p>render() 函数在 React 中必须实现，其他生命周期函数在 React.Component 中都有默认实现。</p><p>render() 并不做实际的渲染动作，只是返回 JSX 描述的结构，最终由 React 操作渲染过程。<br>不需要渲染界面可以返回 null 或者 false 。</p><p>4、componentWillMount() 和 componentDidMount()</p><p>在装载过程中，componentWillMount() 会在调用 render() 函数之前被调用， componentDidMount() 会在调用 render() 函数之后被调用。</p><p>componentWillMount() 是将要装载，虽然还没有渲染出来结果，但是修改组件状态已经晚了。<br>componentDidMount() 是 render() 函数返回的内容已经渲染好了，组件已经被装载在 DOM 树上了。</p><p>componentWilIMount() 和 componentDidMount() 这对兄弟函数还有一个区别：<br>componentWillMount() 可以在服务器端被调用，也可以在浏览器端被调用；<br>而componentDidMount() 只能在浏览器端被调用，在服务器端使用 React 的时候不会被调用。</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>当组件的 props 或者 state 被修改的时候，就会引发组件的更新过程。<br>更新过程会依次调用下面的生命周期函数：</p><ul><li>componentWillReceiveProps(nextProps)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><p>1、componentWillReceiveProps(nextProps)</p><p>只要是父组件的 render() 函数被调用，在 render() 函数里面被谊染的子组件就会经历更新过程，<br>不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps() 函数。</p><p>componentWillReceiveProps(nextProps) 适合根据新的 props 值（也就是参数 nextProps ）来计算出是不是要更新内部状态state 。</p><p>注意，更新组件内部状态的方法 this.setState() 方法触发的更新过程不会调用这个函数，否则会导致 componentWillReceiveProps 再次被调用，陷入死循环。</p><p>当组件的 props 发生改变：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当组件的 state 发生改变：</p><pre><code class="TXT">&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当父组件导致子组件重新渲染：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>2、shouldComponentUpdate(nextProps, nextState)</p><p>shouldComponentUpdate() 函数决定组件是否需要渲染，返回布尔值。</p><pre><code class="JSX">shouldComponentUpdate(nextProps, nextState) {  return (nextProps.caption !== this.props.caption) ||         (nextState.count !== this.state.count);}</code></pre><p>3、componentWillUpdate() 和 componentDidUpdate()</p><p>当组件的 shouldComponentUpdate() 函数返回 true ,React 接下来依次调用对应组件的 componentWillUpdate()、render() 和 componentDidUpdate() 函数。</p><p>和装载过程不同的是，当在服务器端使用 React 渲染时，二者都可以在服务端调用。</p><h3 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h3><p>componentWillUnmount() 表示组件要从 DOM 树上删除掉之前，比较适合做一些清理工作。</p><h2 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h2><p><code>ControlPanel.js</code></p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import Counter from &#39;./Counter.js&#39;;const style = {  margin: &#39;20px&#39;};class ControlPanel extends Component {  constructor(props) {    super(props);    this.onCounterUpdate = this.onCounterUpdate.bind(this);    this.initValues = [ 0, 10, 20];    const initSum = this.initValues.reduce((a, b) =&gt; a+b, 0);    this.state = {      sum: initSum    };  }  onCounterUpdate(newValue, previousValue) {    const valueChange = newValue - previousValue;    this.setState({ sum: this.state.sum + valueChange});  }  render() {    return (      &lt;div style={style}&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;First&quot; /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Second&quot; initValue={this.initValues[1]} /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Third&quot; initValue={this.initValues[2]} /&gt;        &lt;hr/&gt;        &lt;div&gt;Total Count: {this.state.sum}&lt;/div&gt;      &lt;/div&gt;    );  }}export default ControlPanel;</code></pre><p><code>Counter.js</code></p><pre><code class="JSX">import React, { Component, PropTypes } from &#39;react&#39;;const buttonStyle = {  margin: &#39;10px&#39;};class Counter extends Component {  constructor(props) {    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue    }  }  onClickIncrementButton() {    this.updateCount(true);  }  onClickDecrementButton() {    this.updateCount(false);  }  updateCount(isIncrement) {    const previousValue = this.state.count;    const newValue = isIncrement ? previousValue + 1 : previousValue - 1;    this.setState({count: newValue})    this.props.onUpdate(newValue, previousValue)  }  render() {    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }}Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number,  onUpdate: PropTypes.func};Counter.defaultProps = {  initValue: 0,  onUpdate: f =&gt; f //什么都不做的函数};export default Counter;</code></pre><blockquote><p>参考资料<br>1、React.Component - React<br><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a><br>2、React组件生命周期<br><a href="https://nsne.github.io/2017/02/15/react-component-lifecycle/" rel="external nofollow noopener noreferrer" target="_blank">https://nsne.github.io/2017/02/15/react-component-lifecycle/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署Hexo博客</title>
    <link href="http://www.wshunli.com/posts/7dcaaf9e.html"/>
    <id>http://www.wshunli.com/posts/7dcaaf9e.html</id>
    <published>2017-11-09T11:14:08.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。</p><a id="more"></a><p>我一般都是将博客的源文件保存到私有仓库中，虽然几个简单地命令就能部署，但是过程还是很繁琐。最近申请了 Github Student Developer Pack ，就想利用软件开发中的持续集成工具 Travis CI 来帮助完成 Hexo 博客的部署过程。这样就只需要把源代码 push 到仓库就能自动部署好了。</p><p>CI 是 Continuous Integration 的缩写，持续集成之意。持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><h1 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h1><p>关于 Hexo 博客的搭建请参考文章：<a href="https://www.wshunli.com/posts/9642fffa.html">https://www.wshunli.com/posts/9642fffa.html</a></p><h1 id="Travis-CI-配置"><a href="#Travis-CI-配置" class="headerlink" title="Travis CI 配置"></a>Travis CI 配置</h1><p>1.使用 GitHub 账户登录 <a href="https://travis-ci.org" rel="external nofollow noopener noreferrer" target="_blank">Travis CI</a> 官网，然后用 Github 账号登陆，就可以看到可以持续集成的仓库。</p><p>还有个地址 <a href="https://travis-ci.com" rel="external nofollow noopener noreferrer" target="_blank">https://travis-ci.com</a> 可以部署 Github 私有仓库。</p><p>选择要启用的项目，打开<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo1.png" alt=""></p><p>然后选择一些通用的设置<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo2.png" alt=""></p><p>2.登陆 GitHub –Settings -Developer Settings 选项，找到 Personal access tokens 页面。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo3.png" alt=""></p><p>点击右上角的 Generate new token 按钮会生成新的token，点击后提示输入密码后继续，然后来到如下界面。<br>取个名字，勾选相应权限，这里只需要 repo 下全部和 user 下的 user:email 即可。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo4.png" alt=""></p><p>生成完成后，将该token拷贝下来。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo5.png" alt=""></p><p><strong>如果需要将代码同时部署到 Coding 类似</strong>：<br>3.登陆 Coding ，账户 -访问令牌，新建访问令牌：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding1.png" alt=""></p><p>勾选相应权限：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding2.png" alt=""></p><p>4.将上面获取到的token添加到 Environment Variables 部分，值为该 token ，而名称为 GH_TOKEN、CD_TOKEN 。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo6.png" alt=""></p><h1 id="创建-travis-yml"><a href="#创建-travis-yml" class="headerlink" title="创建 .travis.yml"></a>创建 .travis.yml</h1><p>要想自动部署还需在博客源码新增加 <code>.travis.yml</code> 配置文件。</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - npm install -g hexo-cliinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:    - cd ./public    - git init    - git config user.name &quot;yourname&quot; # 修改name    - git config user.email &quot;youremail&quot; # 修改email    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master     # GH_TOKEN 是在 Travis 中配置 token 的名称branches:    only:        - master #只监测 master 分支，master是我的分支的名称，可根据自己情况设置env:    global:        - GH_REF: github.com/yourname/yourname.github.io.git         # 设置 GH_REF，注意更改 yourname</code></pre><h1 id="实现自动部署"><a href="#实现自动部署" class="headerlink" title="实现自动部署"></a>实现自动部署</h1><p>将原代码 push 到 Github 即可，如果配置没问题就该自动构建了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>虽然实现了基本的自动部署，还是有问题的。</p><h2 id="master-commit-树被清空"><a href="#master-commit-树被清空" class="headerlink" title="master commit 树被清空"></a>master commit 树被清空</h2><p>自动部署会把原来的 commit 清空，显然不是我们想要的结果。</p><p>为了解决这个问题，将配置文件改为了如下的内容：</p><pre><code class="TXT">after_script:    - git clone https://${GH_REF} .deploy_git    - cd .deploy_git    - git checkout master    - cd ../    - mv .deploy_git/.git/ ./public/    - cd ./public    - git config user.name &quot;yourname&quot;    - git config user.email &quot;your email&quot;    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master</code></pre><h2 id="添加-commit-时间戳"><a href="#添加-commit-时间戳" class="headerlink" title="添加 commit 时间戳"></a>添加 commit 时间戳</h2><p>commit 的描述一直是 <code>Travis CI Auto Builder</code> 。</p><pre><code class="TXT">Travis CI Auto BuilderTravis CI Auto BuilderTravis CI Auto Builder// 之前Site updated: 2017-11-07 22:05:16Site updated: 2017-11-07 17:19:32Site updated: 2017-11-06 18:04:53</code></pre><p>最终 <code>.travis.yml</code> 配置文件：</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - export TZ=&#39;Asia/Shanghai&#39;  - npm install -g hexo-cli  - chmod +x ./publish-to-gh-pages.shinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:  - ./publish-to-gh-pages.shenv:    global:        - GH_REF: github.com/yourname/yourname.github.io.git        # 设置GH_REF，注意更改成自己的仓库地址        - CD_REF: git.coding.net/yourname/repository.git        # 同时部署到 Coding，repository 为仓库名称</code></pre><p>其中 <code>publish-to-gh-pages.sh</code> 文件：</p><pre><code class="TXT">#!/bin/bashset -evgit clone https://${GH_REF} .deploy_gitcd .deploy_gitgit checkout mastercd ../mv .deploy_git/.git/ ./public/cd ./publicgit config user.name  &quot;yourname&quot;git config user.email &quot;youremail&quot;git add .git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot;git push --force --quiet &quot;https://${TravisCIToken}@${GH_REF}&quot; master:mastergit push --force --quiet &quot;https://yourname:${CD_TOKEN}@${CD_REF}&quot; master:master# 同时部署到 Coding，注意修改 yourname</code></pre><blockquote><p>参考资料<br>1、使用Travis CI自动部署Hexo博客<br><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" rel="external nofollow noopener noreferrer" target="_blank">http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a><br>2、使用 Travis CI 自动部署 Hexo<br><a href="http://www.jianshu.com/p/5e74046e7a0f" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/5e74046e7a0f</a><br>3、使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器<br><a href="https://segmentfault.com/a/1190000009054888" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000009054888</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="TravisCI" scheme="http://www.wshunli.com/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/2a9bf8cf.html"/>
    <id>http://www.wshunli.com/posts/2a9bf8cf.html</id>
    <published>2017-11-09T06:52:46.000Z</published>
    <updated>2017-12-02T14:48:31.454Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>这部分学习 ES6 中新增的数据类型。</p><h1 id="第10章-Symbol"><a href="#第10章-Symbol" class="headerlink" title="第10章 Symbol"></a>第10章 Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。</p><pre><code class="JavaScript">let s = Symbol();typeof s // &quot;symbol&quot;// 字符串参数let s1 = Symbol(&#39;foo&#39;);s1.toString() // &quot;Symbol(foo)&quot;// 对象参数-调用 toString 方法const obj = {  toString() {    return &#39;abc&#39;;  }};const sym = Symbol(obj);sym // Symbol(abc)</code></pre><p>Symbol 值不能与其他类型的值进行运算；可显式转为字符串或布尔值，但不能转为数值。</p><pre><code class="JavaScript">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym // TypeError: can&#39;t convert symbol to string// 字符串String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;// 布尔值let sym = Symbol();Boolean(sym) // true!sym  // false</code></pre><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>Symbol 值唯一，能保证对象不会出现同名的属性。</p><pre><code class="JavaScript">let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = &#39;Hello!&#39;;// 第二种写法let a = {  [mySymbol]: &#39;Hello!&#39;};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });// 以上写法都得到同样结果console.log(a[mySymbol]); // &quot;Hello!&quot;</code></pre><pre><code class="JavaScript"></code></pre><h1 id="第11章-Set-和-Map-数据结构"><a href="#第11章-Set-和-Map-数据结构" class="headerlink" title="第11章 Set 和 Map 数据结构"></a>第11章 Set 和 Map 数据结构</h1><h1 id="第12章-Proxy"><a href="#第12章-Proxy" class="headerlink" title="第12章 Proxy"></a>第12章 Proxy</h1><h1 id="第13章-Reflect"><a href="#第13章-Reflect" class="headerlink" title="第13章 Reflect"></a>第13章 Reflect</h1><h1 id="第14章-Promise-对象"><a href="#第14章-Promise-对象" class="headerlink" title="第14章 Promise 对象"></a>第14章 Promise 对象</h1><h1 id="第15章-Iterator-和-for…of-循环"><a href="#第15章-Iterator-和-for…of-循环" class="headerlink" title="第15章 Iterator 和 for…of 循环"></a>第15章 Iterator 和 for…of 循环</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/281a70b1.html"/>
    <id>http://www.wshunli.com/posts/281a70b1.html</id>
    <published>2017-11-09T06:44:01.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(六) 学习JavaScript的一些高级技巧及实践方案。</strong>(22-25章)</p><h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><p>这部分后面再看吧，现在那么水，估计还用不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/4d143b68.html"/>
    <id>http://www.wshunli.com/posts/4d143b68.html</id>
    <published>2017-11-08T13:12:48.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(五) 学习 JavaScript 对各数据载体的操作方法（如JSON、XML），学会 Ajax 的使用方法。</strong>(18-21章)</p><h1 id="第十八章-JavaScript-与-XML"><a href="#第十八章-JavaScript-与-XML" class="headerlink" title="第十八章 JavaScript 与 XML"></a>第十八章 JavaScript 与 XML</h1><h2 id="浏览器对-XML-DOM-的支持"><a href="#浏览器对-XML-DOM-的支持" class="headerlink" title="浏览器对 XML DOM 的支持"></a>浏览器对 XML DOM 的支持</h2><p>如何检测浏览器是否支持DOM2级XML：</p><pre><code class="JavaScript">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;,&quot;2.0&quot;);</code></pre><p>在支持DOM2级的浏览器中创建一个空白XML:</p><pre><code class="JavaScript">var xmldom = document.implemention.createDocument(namespaceUri,root,docype);</code></pre><p>通过 JavaScript 处理XML时，通常只使用参数root，这个参数指定的是XML DOM文档元素的标签名。</p><pre><code class="JavaScript">var xmldom = document.implementation.createDocument(&quot;&quot;,&quot;root&quot;,null);console.log(xmldom.documentElement.tagName);  //&quot;root&quot;var child = xmldom.createElement(&quot;child&quot;);xmldom.documentElement.appendChild(child);</code></pre><p><strong>DOMParser 类型</strong>：将 XML 解析为 DOM 文档。</p><p><strong>XMLSerializer 类型</strong>：将 DOM 文档序列化为 XML 字符串。</p><pre><code class="JavaScript">var parser = new DOMParser();var xmldom = parser.parseFromString(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;, &quot;text/xml&quot;);//convert back into XMLvar serializer = new XMLSerializer();var xml = serializer.serializeToString(xmldom);console.log(xml);</code></pre><h2 id="浏览器对XPath的支持"><a href="#浏览器对XPath的支持" class="headerlink" title="浏览器对XPath的支持"></a>浏览器对XPath的支持</h2><p>XPath 是设计用来在 DOM 文档中查找节点的一种手段。</p><h2 id="浏览器对XSLT的支持"><a href="#浏览器对XSLT的支持" class="headerlink" title="浏览器对XSLT的支持"></a>浏览器对XSLT的支持</h2><p>XSLT 是与 XML 相关的一种技术，它利用 XPath 将文档从一种表现形式转换成另一种表现形式。</p><h1 id="第十九章-E4X"><a href="#第十九章-E4X" class="headerlink" title="第十九章 E4X"></a>第十九章 E4X</h1><p>E4X 本身不是一门语言，它只是 ECMAScript 语言的可选扩展。<br>就其本身而言，E4X 为处理 XML 定义了新的语法，也定义了特定于 XML 的对象。</p><h1 id="第二十章-JSON"><a href="#第二十章-JSON" class="headerlink" title="第二十章 JSON"></a>第二十章 JSON</h1><p>JSON（Javascript Object Notaion，Javascript对象表示法）是一种数据格式。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON有3种类型的值：简单值、对象 和 数组。</p><ul><li>简单值：字符串、数值、布尔值、null（JSON不支持JavaScript的特殊值undefined）。</li><li>对象：一组无序键值对。值可为简单值，或对象和数组。</li><li>数组：一组有序值的列表。值可为简单值，或对象和数组。</li></ul><p>JSON不支持变量、函数 和 对象实例。</p><p><strong>简单值</strong>：最简单的 JSON 数据形式就是简单值。</p><pre><code class="JSON">6&quot;Hello World!&quot; //必须为双引号</code></pre><p>布尔值和 null 也是有效的 JSON 数据形式，但简单值往往是复杂数据结构的一部分。</p><p><strong>对象</strong>：</p><pre><code class="JSON">// JavaScript对象字面量：var object = {  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29};// JSON 表示方式如下：{  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29}</code></pre><p>JSON 对象 与 JavaScript 的对象字面量相比：首先，没有声明变量（JSON 中没有变量的概念）；其次，没有末尾的分号；JSON 对象的属性必须加双引号。</p><p><strong>数组</strong>：JSON 数组采用的就是 JavaScript 中的数组字面量形式。</p><pre><code class="JSON">// JavaScript 中的数组字面量：var values = [25, &quot;hi&quot;, true];// JSON 表示数组：[25, &quot;hi&quot;, true]</code></pre><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><p>ECMAScript5 对解析 JSON 进行了规范，定义了全局对象 JSON。</p><p>JSON 对象有两个方法：stringify() 和 parse()，分别用于把 JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。</p><pre><code class="JavaScript">var book = {        title: &quot;Professional JavaScript&quot;,        authors: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011    };var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);console.log(jsonText);// {&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011}var bookCopy =JSON.parse(jsonText);</code></pre><p><strong>序列化选项</strong>: JSON.stringify() 除了要序列化的 JavaScript 对象外，还可以接收另外两个参数指定以不同的方式序列化。<br>第一个参数是数据，第二个参数是个过滤器，可以是一个数组或函数；第三个参数是一个选项，表示是否在 JSON 字符串中保留缩进。</p><p>1.过滤结果：</p><p>如果过滤器参数是<strong>数组</strong>，那么 JSON.stringify()的结果中将只包含数组中列出的属性。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3}</code></pre><p>如果过滤器参数是<strong>函数</strong>，传入的函数接收两个参数，属性（键）名和属性值。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, function(key, value){   switch(key){       case &quot;authors&quot;:           return value.join(&quot;,&quot;)       case &quot;year&quot;:           return 5000;       case &quot;edition&quot;:           return undefined;       default:           return value;   }});//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000}</code></pre><p>2.字符串缩进</p><p>JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。<br>如果这个参数是一个<strong>数值</strong>，那它表示的是每个级别缩进的空格数。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, 4);</code></pre><p>结果：</p><pre><code class="JSON">{    &#39;title&#39;: &#39;Professional JavaScript&#39;,    &#39;authors&#39;: [        &#39;Nicholas C. Zakas&#39;    ],    &#39;edition&#39;: 3,    &#39;year&#39;: 2011}</code></pre><p>如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON 字符串中被用作缩进字符（不再使用空格）。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, &quot; - -&quot;);</code></pre><p>结果：</p><pre><code class="JSON">{ - -&#39;title&#39;: &#39;Professional JavaScript&#39;, - -&#39;authors&#39;: [ - - - -&#39;Nicholas C. Zakas&#39; - -], - -&#39;edition&#39;: 3, - -&#39;year&#39;: 2011}</code></pre><p>缩进字符串最长不能超过 10 个字符长。如果字符串长度超过了 10 个，结果中将只出现前 10 个字符。</p><p>3.toJSON()方法</p><p>给对象自定义 toJSON() 方法，返回其自身的 JSON 数据格式。</p><pre><code class="JavaScript">var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        toJSON: function(){            return this.title;        }    };var jsonText = JSON.stringify(book);console.log(jsonText);</code></pre><p>假设把一个对象传入 JSON.stringify()，序列化该对象的顺序如下：<br>(1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。<br>(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。<br>(3) 对第(2)步返回的每个值进行相应的序列化。<br>(4) 如果提供了第三个参数，执行相应的格式化。</p><p><strong>解析选项</strong>：JSON.parse() 方法也可以接收另一个参数，该参数是一个函数（还原函数），将在每个键值对儿上调用。<br>如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</p><pre><code class="JavaScript"> var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        releaseDate: new Date(2011, 11, 1)    };var jsonText = JSON.stringify(book);console.log(jsonText);var bookCopy = JSON.parse(jsonText, function(key, value){    if (key == &quot;releaseDate&quot;){        return undefined;    } else {        return value;    }});console.log(&quot;releaseDate&quot; in bookCopy);</code></pre><h1 id="第二十一章-Ajax-与-Comet"><a href="#第二十一章-Ajax-与-Comet" class="headerlink" title="第二十一章 Ajax 与 Comet"></a>第二十一章 Ajax 与 Comet</h1><p>Ajax(Asynchronous Javascript + XML)技术的核心是 XMLHttpRequest 对象，即: XHR。<br>它所指的仅仅是<strong>无须刷新页面即可从服务器端获取数据</strong>的技术，其通信与数据格式无关，并不一定是 XML 数据。</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p><strong>XHR的用法</strong>：</p><p>使用 XMLHttpRequest 构造函数来创建 XHR 对象。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();</code></pre><p>使用 XHR对象的时候，要调用的第一个方法是open()，它接受3个参数:</p><ol><li>要发送请求的类型，如: get/post</li><li>请求的 url</li><li>是否异步发送请求，这个参数是一个布尔值</li></ol><p>再调用 send() 方法，才会真正发起 ajax 请求。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.php&#39;, false)xhr.send(null);</code></pre><p>本例中的请求是同步的，Javascript 代码会等到服务器响应之后再执行。<br>收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性有:</p><ul><li>responseText: 作为响应主体被返回的文本。</li><li>responseXML: 如果响应的内容类型是 “text/xml” 或者 “application/xml”，那么这个属性中将保存着包含响应数据的 XML DOM 文档。</li><li>status: 响应的 HTTP 状态。</li><li>statusText: HTTP 状态的说明。</li></ul><p>发送异步请求：JavaScript 继续执行而不必等待。<br>此时，我们可以检测readyState属性，该属性表示请求/响应过程的当前活动阶段。它的可取值有如下几种：</p><ul><li>0: 未初始化。 尚未调用 open() 方法。</li><li>1: 启动。 已经调用open()方法，但，尚未调用send()方法。</li><li>2: 发送。 已经调用send()方法，但，尚未接收到响应。</li><li>3: 接收。 已经接收到部分响应数据。</li><li>4: 完成。 已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p>readyState 属性的每一次变化，都会触发一次 readyStateChange 事件，我们可以利用这个事件来检测 readyState 值。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    if(xhr.readyState == 4){        if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){            console.log(xhr.responseText);        }        else{            console.log(&#39;fail, &#39; + xhr.status);        }    }}xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.send(null);</code></pre><p>在接收到响应之前，可以调用 abort() 方法来取消异步请求。</p><pre><code class="JavaScript">xhr.abort();</code></pre><p><strong>HTTP 头部信息</strong>：XHR 对象提供了操作头部信息的方法，包括对请求头部和响应头部的操作。</p><p>默认情况下，发送XHR请求的同时，还会发送以下头部信息:</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language: 浏览器当前设置的语言</li><li>Connection: 浏览器与服务器之间的连接类型</li><li>Cookie: 当前页面的任何Cookie</li><li>Host: 发出请求的页面，所在的域</li><li>Referer: 发出请求的页面的URI</li><li>User-Agent: 浏览器的用户代理字符串</li></ul><p>setRequestHeader()：自定义的头部信息。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.setRequestHeader(&quot;MySite&quot;, &quot;wshunli.com&quot;);xhr.send(null);</code></pre><p>getResponseHeader()：获取响应头部信息。</p><pre><code class="JavaScript">var mySite = xhr.getResponseHeader(&#39;MySite&#39;); // wshunli.com</code></pre><p>getAllResponseHeaders()：在服务器端，也可以利用头部信息向浏览器发送额外的结构化数据。</p><pre><code class="JavaScript">var allHeaders = xhr.getAllResponseHeaders();// 返回内容Date: Sun, 14 Nov 2004 18:04:22 GMTServer: Apache/1.3.29 (Unix)Vary: AcceptX-Powerd-By: PHP/4.3.8Connection: closeContent-Type: text/html; charset=iso-8859-1</code></pre><p><strong>GET 请求</strong>：向服务器查询某些信息。</p><pre><code class="JavaScript">xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true);</code></pre><p><strong>POST 请求</strong>：向服务器发送应该被保存的数据。</p><pre><code class="JavaScript">xhr.open(&quot;post&quot;, &quot;post.php&quot;, true);xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);var form = document.getElementById(&quot;my-form&quot;);xhr.send(serialize(form));</code></pre><h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><p><strong>FormData</strong>：</p><p>XMLHttpRequest 2 级定义了 FormData 类型，来处理表单数据的序列化，以及创建与表单格式相同的数据。</p><pre><code class="JavaScript">var data = new FormData();// 添加键值对data.append(&#39;site&#39;, &#39;wshunli.com&#39;);// 直接传入表单元素var data = new FormData(document.forms[0]);</code></pre><p>创建 FromData 的实例后，就可以传给 XHR 的 send() 方法。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest(); ···var form = document.getElementById(&#39;site-info&#39;);xhr.send(new FormData(form));</code></pre><p>XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。</p><p><strong>超时设定</strong>：</p><p>XHR 对象添加了一个 timeout 属性，表示请求在等待多少毫秒之后就终止。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    try{        if(xhr.readyState == 4){            if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){                console.log(xhr.responseText);            }            else{                console.log(&#39;fail, &#39; + xhr.status);            }        }    }    catch(ex){    }}xhr.open(&#39;get&#39;, &#39;example.php&#39;, true);xhr.timeout = 1000; // 1秒超时，仅适用IE8+xhr.ontimeout = function(){    console.log(&#39;fail, timeout&#39;);}xhr.send(null);</code></pre><p>在给 timeout 设置一个数值后，如果在规定时间内浏览器没有接收到响应信息，就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。<br>如果在超时终止请求之后再访问 status 属性，就会导致错误。因此，将相关的代码封装到 try-catch 语句中。</p><p><strong>overrideMimeType() 方法</strong>：重写 XHR 响应的 MIME 类型。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.open(&#39;get&#39;, &#39;text.php&#39;, true);xhr.overrideMimeType(&#39;text/xml&#39;);xhr.send(null);</code></pre><h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><p>进度事件包括以下6个：</p><ul><li>loadstart: 在接收到响应数据的第一个字节时触发</li><li>progress: 在接收响应期间持续不断地触发</li><li>error: 在请求发生错误时触发</li><li>abort: 在因为调用 abort() 方法而终止连接时触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 在通信完成或者触发 error、abort 或 load 事件之后触发</li></ul><p>每个请求都从触发 loadstart 事件开始，接下来是一个或多个 progress 事件，然后触发 error、abort 或者 load 事件中的一个，最后以触发 loadend 事件结束。</p><p><strong>load 事件</strong>：响应接收完毕后将触发 load 事件，因此就没有必要再去检查 readyState 属性了。</p><p><strong>progress 事件</strong>：progress 事件会在浏览器接收新数据的过程中周期性地被触发。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.onload = function(){    if( (xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300) || xhr.status ==304 ){        console.log(xhr.responseText);    }    else{        console.log(&#39;fail, &#39; + xhr.status);    }}xhr.onprogress = function(event){    var statusDiv = document.getElementById(&#39;status&#39;);    if( event.lengthComputable ){        statusDiv.innerHTML = &#39;Received &#39; + event.position + &#39; of &#39; + event.totalSize + &#39; bytes&#39;;    }}xhr.open(&#39;get&#39;, &#39;progress.php&#39;, true);xhr.send(null);</code></pre><p>onprogress 事件处理程序，会接收到一个event对象，其 target 属性是 XHR 对象。<br>event 对象还包含了另外3个额外属性：lengthComputable、position、totalSize。</p><ul><li>lengthComputable 是一个布尔值，它表示进度信息是否可用；</li><li>position 表示已经接收的字节数；</li><li>totalSize 表示根据 Content-Length 响应头确定的预期字节数。</li></ul><h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）：使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。IE中要使用XDR对象实现，其他浏览器XHR对象原生支持。</p><pre><code class="JavaScript">// 发送请求附加 Origin 头部Origin: http://www.wshunli.com// 响应请求Access-Control-Allow-Origin: http://www.wshunli.com</code></pre><p><strong>图像 Ping</strong>：动态创建图像经常用于图像 Ping 。</p><pre><code class="JavaScript">var img = new Image();img.onload = img.onerror = function(){    console.log(&#39;Done&#39;);}img.src = &#39;http://www.wshunli.com/test?action=click&#39;;</code></pre><p>我们可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。</p><p><strong>JSOUP</strong>：(JSON with padding，填充式 JSON 或参数式 JSON) 它看起来与 JSON 非常相似，只不过是被包含在函数调用中的 JSON。</p><pre><code class="JavaScript">function handleResponse(response){    console.log(&quot;You&#39;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);}var script = document.createElement(&quot;script&quot;);script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);</code></pre><p><strong>Comet</strong>: 一种服务器向页面推送数据的技术。</p><p>实现Comet有 2 种方式: 长轮询和流。<br>1.长轮询是相对于传统轮询(短轮询)而言的，传统轮询即浏览器定时向服务器发送请求，查看是否有数据更新。<br>而长轮询则是，页面向服务器发起一个请求后，服务器一直保持连接打开，直到有数据可以发送。<br>发送完数据后，浏览器关闭连接，随即又向服务器发起一个新的请求。<br>这一过程在页面打开期间一直持续不断。<br>2.另外一种实现 Comet 的方式就是HTTP流。流的特点是，在页面的整个生命周期内只有使用一个HTTP连接。<br>也就是说，浏览器向服务器发送一个请求后，服务器保持连接打开，然后周期性地向浏览器发送数据</p><p><strong>服务器发送事件</strong>：SSE(Server-Sent Events)服务器发送事件，是围绕只读 Comet 交互推出的 API 或者模式。</p><p><strong>Web Sockets</strong>：Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。</p><p>创建 Web Sockets，可以先实例一个 WebSocket 对象并传入要连接 URL:</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);</code></pre><p>实例化 WebSocket 对象之后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket也有一个表示当前状态的 readyState 属性。</p><ul><li>WebSocket.OPENING (0) : 正在建立连接</li><li>WebSocket.OPEN (1): 已经建立连接</li><li>WebSocket.CLOSING (2): 正在关闭连接</li><li>WebSocket.CLOSE (3): 已经关闭连接</li></ul><p>WebSocket 没有 readystatechange 事件，readyState 的值永远从0开始。<br>要关闭 Web Socket 连接，可以在任何时候调用close()方法。<br>调用该方法后，readyState 的值立即变为2(正在关闭)，当成功关闭连接后变为3。</p><pre><code class="JavaScript">socket.close();</code></pre><p>发送和接收数据：Web Socket 打开之后就可以通过连接发送和接收数据。</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);socket.send(&quot;Hello World!&quot;);</code></pre><p>Web Socket 只能通过连接发送纯文本数据，对于复杂数据必须进行序列化。</p><pre><code class="JavaScript">socket.onmessage = function(event){    var data = event.data;}</code></pre><p>当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。</p><p>WebSocket 对象的其他事件：<br>WebSocket对象还有其他3个事件，在连接生命周期的不同阶段触发。</p><ul><li>open: 在成功建立连接时触发</li><li>error: 在发生错误时触发，连接不能持续</li><li>close: 在连接关闭时触发</li></ul><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/server.php&#39;);socket.onopen = function(){    console.log(&#39;WebSocket Opened.&#39;)}socket.onerror = function(){    console.log(&#39;WebSocket Error.&#39;)}socket.onclose = function(){    console.log(&#39;WebSocket Closed.&#39;)}</code></pre><p>其中只有 close 事件的event的对象有额外的信息。这个事件的事件对象有3个额外属性: wasClean、code 和 reason。<br>其中，wasClean 是一个布尔值，表示连接是否已经明确关闭；code 是服务器返回的数值状态码；而 reason 是一个字符串，包含服务器发回的信息。</p><pre><code class="JavaScript">socket.onclose = function(event){    console.log(event.wasClean + &#39;,&#39; + event.code + &#39;,&#39; + event.reason);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/228afe2f.html"/>
    <id>http://www.wshunli.com/posts/228afe2f.html</id>
    <published>2017-11-08T09:06:23.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(四) 学习在浏览器中进行实际开发时的错误调试技巧。</strong>(17章)</p><h1 id="第十七章-错误处理与调试"><a href="#第十七章-错误处理与调试" class="headerlink" title="第十七章 错误处理与调试"></a>第十七章 错误处理与调试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>try-catch 语句</strong>：</p><p>try-catch 语句 和 Java 很类似。</p><pre><code class="JavaScript">function testFinally(){    try {        return 2;    } catch (error){        return 1;    } finally {        return 0;    }}function testWithoutFinally(){    try {        return 2;    } catch (error){        return 1;    }}alert(testFinally());alert(testWithoutFinally());</code></pre><p>我们把可能会抛出错误的语句放到 try 语句中，处理错误的代码放到 catch 块中，finally 语句块无论如何都会执行。</p><p><strong>抛出错误</strong>：与 try-catch 语句相配的还有一个 throw 操作符，用于随时抛出自定义错误 。</p><p>在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时，代码才回继续执行。</p><pre><code class="JavaScript">if (!(values instanceof Array)){    throw new Error(&quot;process(): Argument must be an array.&quot;);}</code></pre><p>捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。</p><p><strong>常见的错误类型</strong>：类型转换错误、数据类型错误、通信错误。</p><h2 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h2><p><strong>将消息记录到控制台</strong>：通过 console 对象向 JavaScript 控制台中写入消息。</p><p>error(message): 将错误消息记录到控制台<br>info(message): 将信息性消息记录到控制台<br>log(message): 将一般消息记录到控制台<br>warn(message): 将警告消息记录到控制台</p><p><strong>将消息记录到当前页面</strong>：在页面中开辟一小块区域，用以显示消息。</p><p><strong>抛出错误</strong>：自定义 assert() 函数。<br>两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。</p><pre><code class="JavaScript">function assert(condition, message){    if (!condition){        throw new Error(message);    }}function divide(num1, num2){    assert(typeof num1 == &quot;number&quot; &amp;&amp; typeof num2 == &quot;number&quot;,            &quot;divide(): Both arguments must be numbers.&quot;);    return num1 / num2;}var result = divide(10, 23);result = divide(&quot;hi&quot;, 3);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/95a7e74a.html"/>
    <id>http://www.wshunli.com/posts/95a7e74a.html</id>
    <published>2017-11-07T14:07:10.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/demobox.css">《JavaScript高级程序设计》读书笔记<br><br><a id="more"></a><p><strong>学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。</strong>(15-16章)</p><h1 id="第十五章-使用-Canvas-绘图"><a href="#第十五章-使用-Canvas-绘图" class="headerlink" title="第十五章 使用 Canvas 绘图"></a>第十五章 使用 Canvas 绘图</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>使用 <code>&lt;canves&gt;</code> 元素；指定 width 和 height 属性。</p><pre><code class="JavaScript">&lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;Your browser doesn&#39;t support canvas&lt;/canvas&gt;</code></pre><p>要在画布上绘制，还需取得绘图上下文。</p><pre><code class="JavaScript">var drawing = document.getElementById(&quot;drawing&quot;),//make sure &lt;canvas&gt; is completely supportedif (drawing.getContext){    var context = drawing.getContext(&quot;2d&quot;);}</code></pre><h2 id="2D-上下文"><a href="#2D-上下文" class="headerlink" title="2D 上下文"></a>2D 上下文</h2><p><strong>填充和描边</strong>：2D 上下文的两种基本绘图操作。<br>fillStyle 属性（填充）：指定的样式（颜色、渐变或图像）填充图形；<br>strokeStyle 属性（描边）：只在图形边缘画线。</p><p><strong>绘制矩形</strong>：矩形是唯一一种可以直接在 2D上下文中绘制的形状。</p><p>与矩形有关的方法包括fillRect()、strokeRect和clearRect()。<br>这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形的宽度和矩形高度。</p><div class="demobox"><div class="demobox-result"><canvas id="drawing" width="200" height="100">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing");if(t.getContext){var e=t.getContext("2d");e.fillStyle="#ff0000",e.fillRect(10,10,50,50),e.strokeStyle="rgba(0,0,255,0.5)",e.strokeRect(30,30,50,50),e.clearRect(40,40,10,10)}}()</script></div><div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x77E9;&#x5F62;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.strokeStyle = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>;</span><br><span class="line">    context.strokeRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.clearRect(<span class="number">40</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>绘制路径</strong>：</p><p>首先调用 beginPath() 方法；<br>然后调用一下方法：<br>arc(x,y,radius,startAngle,endAngle,bool);<br>arcTo(x1,y1,x2,y2,radius);<br>lineTo(x,y);<br>moveTo(x,y);<br>rect(x,y,w,h);<br>最后调用 closePath() 方法。</p><p><strong>绘制文本</strong>：fillText(str, x, y, width);strokeText(str, x, y, width)。</p>    <div class="demobox">      <div class="demobox-result">  <canvas id="drawing2" width="200" height="200">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing2");if(t.getContext){var e=t.getContext("2d");e.beginPath(),e.arc(100,100,99,0,2*Math.PI,!1),e.moveTo(194,100),e.arc(100,100,94,0,2*Math.PI,!1),e.moveTo(100,100),e.lineTo(100,15),e.moveTo(100,100),e.lineTo(35,100),e.stroke(),e.strokeText?(e.font="bold 14px Arial",e.textAlign="center",e.textBaseline="middle",e.fillText("12",100,20),e.textAlign="start",e.fillText("12",100,40),e.textAlign="end",e.fillText("12",100,60)):console.log("Your browser doesn't support the canvas text API.")}}()</script></div>    <div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x8DEF;&#x5F84;&#x548C;&#x6587;&#x672C;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">194</span>, <span class="number">100</span>);</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">100</span>, <span class="number">15</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">35</span>, <span class="number">100</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line">    <span class="keyword">if</span> (context.strokeText){</span><br><span class="line">        context.font = <span class="string">&quot;bold 14px Arial&quot;</span>;</span><br><span class="line">        context.textAlign = <span class="string">&quot;center&quot;</span>;</span><br><span class="line">        context.textBaseline = <span class="string">&quot;middle&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Your browser doesn&apos;t support the canvas text API.&quot;</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>变换</strong>：<br>rotate(angle): 围绕原点旋转图像angle角度。<br>scale(scaleX, scaleY): 缩放图像。<br>translate(x,y)：将坐标原点移到（x,y）。</p><p><strong>阴影</strong>：<br>shadowColor()<br>shadowOffsetX:x方向的阴影偏移量。<br>shadowOffsetY:y方向的阴影偏移量。<br>shadowBlur:模糊的像素数，默认为0不模糊。</p><p><strong>渐变</strong>：渐变由 CanvasGradient 实例表示。</p><p>线性渐变：createLinearGradient(x1,y1,x2,y2);</p><pre><code class="JavaScript">var gradient = context.createLinearGradient(30,30,70,70);    gradient.addColorStop(0,&quot;orange&quot;);    gradient.addColorStop(1, &quot;blue&quot;);    context.fillStyle = gradient;    context.fillRect(30, 30,70,70);</code></pre><p>径向渐变：createRadialGradient(x1,y1,r1,x2,y2,r2);</p><pre><code class="JavaScript">var gra = context.createRadialGradient(55,55,10,55,55,30);    gra.addColorStop(0, &quot;blue&quot;);    gra.addColorStop(1, &quot;orange&quot;);    context.fillStyle = gra;    context.fillRect(30,30,50,50);</code></pre><p><strong>模式</strong>：模式就是重复的图像，可以用来填充或描边图形。</p><p>createPattern(img, str);<br>img： 表示一个 HTML 的 img 元素；<br>str： 可取值 “repeat”、“repeat-x”、“repeat-y”和“no-repeat”。</p><pre><code class="JavaScript">var img = document.images[0];var pattern = context.createPattern(img, &quot;repeat&quot;);context.fillStyle = pattern;context.fillRect(10,10,150,150);</code></pre><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p>WebGL 是针对 Canvas 的 3D 上下文。</p><h1 id="第十六章-HTML5-脚本编程"><a href="#第十六章-HTML5-脚本编程" class="headerlink" title="第十六章 HTML5 脚本编程"></a>第十六章 HTML5 脚本编程</h1><h2 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h2><p>跨文档消息传递，简称XDM，指的是来自不同域的页面间传递消息。</p><p>postMessage() 发送消息：</p><pre><code class="JavaScript">var iframeWindow = document.getElementById(&quot;myFrame&quot;).contentWindow;iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wshunli.com&quot;);</code></pre><p>接收消息，触发 window 对象的 message 事件，异步方式。</p><pre><code class="JavaScript">window.addEventListener(&quot;message&quot;,function(){    if(event.origin == &quot;http://www.wshunli.com&quot;){//发送消息的文档所在的域      processMessage(event.data); //处理接收的数据      event.source.postMessage(&quot;Received!&quot;, &quot;http://github.com&quot;); //可选：向来源窗口发送回执  }},false)</code></pre><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p>HTML5新增了 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 两个标签。</p><pre><code class="JavaScript">&lt;video src=&quot;conference.mpg&quot; id=&quot;muvideo&quot;&gt;video palyer not available&lt;/video&gt;&lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;audio player not available&lt;/audio&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/demobox.css&quot;&gt;《JavaScript高级程序设计》读书笔记&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章链接问题</title>
    <link href="http://www.wshunli.com/posts/261b7c4.html"/>
    <id>http://www.wshunli.com/posts/261b7c4.html</id>
    <published>2017-11-06T08:58:12.000Z</published>
    <updated>2017-12-02T14:48:31.454Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 文章链接问题<br><a id="more"></a></p><p>今天 <a href="https://www.google.com/search?safe=active&amp;q=site:wshunli.com" rel="external nofollow noopener noreferrer" target="_blank">搜索</a> 一下网站，发现有个很大的问题。</p><p>有很多链接 404，比如这个链接：</p><p><a href="http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/">http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/</a></p><p>搜索引擎跳转之后是：</p><p><a href="http://www.wshunli.com/2017/10/29/《javascript高级程序设计》读书笔记（一）/">http://www.wshunli.com/2017/10/29/《javascript高级程序设计》读书笔记（一）/</a></p><p>单单因为 <code>JavaScript</code> 大小写的问题，就找不到页面。</p><p>所以在 Hexo 官网找了一下固定链接的插件。</p><p>最终选择是： hexo-abbrlink ; Github ：<a href="https://github.com/rozbo/hexo-abbrlink" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/rozbo/hexo-abbrlink</a></p><p>安装插件：</p><pre><code class="TXT">npm install hexo-abbrlink --save</code></pre><p>在站点配置文件中修改 <code>permalink</code> ：</p><pre><code class="TXT">permalink: posts/:abbrlink.html</code></pre><p>站点配置文件中配置插件：</p><pre><code class="TXT"># abbrlink configabbrlink:  alg: crc32  #support crc16(default) and crc32  rep: hex    #support dec(default) and hex</code></pre><p>链接效果：</p><pre><code class="TXT">crc16 &amp; hexhttps://www.wshunli.com/posts/66c8.htmlcrc16 &amp; dechttps://www.wshunli.com/posts/65535.htmlcrc32 &amp; hexhttps://www.wshunli.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://www.wshunli.com/posts/1690090958.html</code></pre><p>更多内容参考：<a href="https://post.zz173.com/detail/hexo-abbrlink.html" rel="external nofollow noopener noreferrer" target="_blank">https://post.zz173.com/detail/hexo-abbrlink.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 文章链接问题&lt;br&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/67855b9d.html"/>
    <id>http://www.wshunli.com/posts/67855b9d.html</id>
    <published>2017-11-05T12:01:26.000Z</published>
    <updated>2017-12-02T14:48:31.454Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>ES6 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><h1 id="字符、数值、正则的扩展"><a href="#字符、数值、正则的扩展" class="headerlink" title="字符、数值、正则的扩展"></a>字符、数值、正则的扩展</h1><p>第4章 字符串的扩展：<a href="http://es6.ruanyifeng.com/#docs/string" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/string</a><br>第5章 数值的扩展：<a href="http://es6.ruanyifeng.com/#docs/array" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/array</a><br>第6章 正则的扩展：<a href="http://es6.ruanyifeng.com/#docs/regex" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/regex</a></p><h1 id="第7章-数组的扩展"><a href="#第7章-数组的扩展" class="headerlink" title="第7章 数组的扩展"></a>第7章 数组的扩展</h1><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符是三个点（<code>...</code>），将一个数组转为用逗号分隔的参数序列。</p><pre><code class="JavaScript">console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5function push(array, ...items) {  array.push(...items);}function add(x, y) {  return x + y;}const numbers = [4, 38];add(...numbers); // 42</code></pre><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><pre><code class="JavaScript">let arrayLike = {    &#39;0&#39;: &#39;a&#39;,    &#39;1&#39;: &#39;b&#39;,    &#39;2&#39;: &#39;c&#39;,    length: 3};// ES5的写法var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]// ES6的写法let arr2 = Array.from(arrayLike);    // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of 方法用于将一组值，转换为数组。</p><pre><code class="JavaScript">Array.of(3, 11, 8) // [3,11,8]</code></pre><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h2><p>数组实例的 copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</p><pre><code class="JavaScript">Array.prototype.copyWithin(target, start = 0, end = this.length)</code></pre><p>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p><pre><code class="JavaScript">[1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5]</code></pre><h2 id="find-amp-findIndex"><a href="#find-amp-findIndex" class="headerlink" title="find() &amp; findIndex()"></a>find() &amp; findIndex()</h2><p>数组实例的 find() 方法，用于找出第一个符合条件的数组成员。<br>它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。</p><pre><code class="JavaScript">[1, 5, 10, 15].find(function(value, index, arr) {  return value &gt; 9;}) // 10</code></pre><p>find() 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><pre><code class="JavaScript">[1, 5, 10, 15].findIndex(function(value, index, arr) {  return value &gt; 9;}) // 2</code></pre><p>findIndex() 方法的用法与 find() 方法非常类似，返回第一个符合条件的数组成员的位置</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p>数组实例的 fill() 方法使用给定值，填充一个数组。</p><pre><code class="JavaScript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7); // [7, 7, 7]new Array(3).fill(7); // [7, 7, 7]// 第二个和第三个参数，用于指定填充的起始位置和结束位置。[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2); // [&#39;a&#39;, 7, &#39;c&#39;]</code></pre><h2 id="entries-，keys-和-values"><a href="#entries-，keys-和-values" class="headerlink" title="entries()，keys() 和 values()"></a>entries()，keys() 和 values()</h2><p>ES6 提供三个新的方法 – entries()，keys() 和 values() – 用于遍历数组。<br>可以用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p><pre><code class="JavaScript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {  console.log(index);}// 0// 1for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {  console.log(elem);}// &#39;a&#39;// &#39;b&#39;for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {  console.log(index, elem);}// 0 &quot;a&quot;// 1 &quot;b&quot;</code></pre><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p><pre><code class="JavaScript">[1, 2, 3].includes(2)     // true[1, 2, 3].includes(4)     // false[1, 2, NaN].includes(NaN) // true// 第二个参数表示搜索的起始位置，默认为0[1, 2, 3].includes(3, 3);  // false</code></pre><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。</p><pre><code class="JavaScript">Array(3) // [, , ,]</code></pre><p>ES6 明确将空位转为 undefined。</p><pre><code class="JavaScript">Array.from([&#39;a&#39;,,&#39;b&#39;]); // [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p><h1 id="第8章-函数的扩展"><a href="#第8章-函数的扩展" class="headerlink" title="第8章 函数的扩展"></a>第8章 函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><pre><code class="JavaScript">function log(x, y = &#39;World&#39;) {  console.log(x, y);}log(&#39;Hello&#39;)          // Hello Worldlog(&#39;Hello&#39;, &#39;China&#39;) // Hello Chinalog(&#39;Hello&#39;, &#39;&#39;)      // Hello</code></pre><p>参数默认值是惰性求值的。</p><p><strong>与解构赋值默认值结合使用</strong>：</p><p>函数默认值生效：当前参数没有传值或传值为 undefined ；<br>解构赋值默认值生效：当前参数传值或没有传值而默认值与 undefined 严格相等。</p><pre><code class="JavaScript">// 写法一function m1({x = 0, y = 0} = {}) {  return [x, y];}// 写法二function m2({x, y} = { x: 0, y: 0 }) {  return [x, y];}m1()               // [0, 0]m2()               // [0, 0]m1( {x: 3, y: 8} ) // [3, 8]m2( {x: 3, y: 8} ) // [3, 8]m1( {x: 3} )       // [3, 0]m2( {x: 3} )       // [3, undefined]m1( {} )           // [0, 0];m2( {} )           // [undefined, undefined]m1( {z: 3} )       // [0, 0]m2( {z: 3} )       // [undefined, undefined]</code></pre><p>区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><p><strong>参数默认值的位置</strong>：</p><p>定义了默认值的参数应该是函数的尾参数，否则这个参数不能省略。</p><pre><code class="JavaScript">// 例一：默认值的参数在前function f(x = 1, y) {  console.log([x, y]);}f();             // [1, undefined]f(2);            // [2, undefined]f(, 1);          // 报错f(undefined, 1); // [1, 1]// 例二：默认值的参数在后function f(x , y= 1) {  console.log([x, y]);}f();             // [undefined, 1]f(2);            // [2, 1]f(2, );          // [2, 1]f(2, undefined); // [2, 1]</code></pre><p>undefined 能触发默认值，null 不能。</p><pre><code class="JavaScript">function foo(x = 5, y = 6) {  console.log(x, y);}foo(undefined, null); // 5 null</code></pre><p><strong>函数的 length 属性</strong>：没有指定默认值的参数个数。</p><p><strong>作用域</strong>：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。</p><pre><code class="JavaScript">var x = 1;function f(x, y = x) {  console.log(y);}f();  // undefinedf(2); // 2// x 没有定义，所以指向外部全局变量 xlet x = 1;function f(y = x) {  let x = 2;  console.log(y);}f();  // 1f(3); // 3</code></pre><p>更复杂的例子：</p><pre><code class="JavaScript">var x = 1; // 全局变量function foo(x, y = function() { x = 2; }) { //函数参数作用域  var x = 3; // 函数内部变量  y();  console.log(x);}foo();          // 3 - 第5行console.log(x); // 1</code></pre><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数。</p><pre><code class="JavaScript">function add(...values) {  let sum = 0;  for (var val of values) {    sum += val;  }  return sum;}add(2, 5, 3); // 10</code></pre><p>rest 参数搭配的变量为数组，arguments 为类似数组的对象。<br>rest 参数之后不能再有其他参数；函数的 length 属性，也不包括 rest 参数。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的 name 属性，返回该函数的函数名。</p><pre><code class="JavaScript">function foo() {}foo.name // &quot;foo&quot;var f = function () {};f.name // &quot;&quot; - ES5f.name // &quot;f&quot; - ES6</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><pre><code class="JavaScript">var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) {  return num1 + num2;};</code></pre><p>箭头函数有几个使用注意点：<br>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。<br>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p><pre><code class="JavaScript">function foo() {  setTimeout(() =&gt; {    console.log(&#39;id:&#39;, this.id);  }, 100);}var id = 21;foo.call({ id: 42 }); // id: 42</code></pre><p>箭头函数 this 指向定义时所在的对象。</p><pre><code class="JavaScript">function Timer() {  this.s1 = 0;  this.s2 = 0;  setInterval(() =&gt; this.s1++, 1000); // 箭头函数  setInterval(function () {           // 普通函数    this.s2++;  }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100); // s1: 3setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100); // s2: 0</code></pre><p>前者的 this 绑定定义时所在的作用域（即Timer函数），后者的 this 指向运行时所在的作用域（即全局对象）。</p><p>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。</p><pre><code class="JavaScript">// ES6function foo() {  setTimeout(() =&gt; {    console.log(&#39;id:&#39;, this.id);  }, 100);}// ES5function foo() {  var _this = this;  setTimeout(function () {    console.log(&#39;id:&#39;, _this.id);  }, 100);}</code></pre><p>由于没有 this，因而也不存在通过 bind()、call()、apply() 来改变 this 的指向。</p><p><strong>嵌套的箭头函数</strong>：箭头函数内部，还可以再使用箭头函数。</p><pre><code class="JavaScript">let insert = (value) =&gt; ({into: (array) =&gt; ({after: (afterValue) =&gt; {  array.splice(array.indexOf(afterValue) + 1, 0, value);  return array;}})});// 等价于function insert(value) {  return {into: function (array) {    return {after: function (afterValue) {      array.splice(array.indexOf(afterValue) + 1, 0, value);      return array;    }};  }};}// 结果相同insert(2).into([1, 3]).after(1); //[1, 2, 3]</code></pre><h2 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h2><p>函数绑定运算符是并排的两个冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><pre><code class="JavaScript">foo::bar;// 等同于bar.bind(foo);</code></pre><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><pre><code class="JavaScript">var method = obj::obj.foo;// 等同于var method = ::obj.foo;</code></pre><p>双冒号运算符的运算结果，还是一个对象，因此可以采用链式写法。</p><pre><code class="JavaScript">let { find, html } = jake;document.querySelectorAll(&quot;div.myClass&quot;)::find(&quot;p&quot;)::html(&quot;hahaha&quot;);</code></pre><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用（Tail Call）是指某个函数的最后一步是调用另一个函数。</p><pre><code class="JavaScript">function f(x) {  if (x &gt; 0) {    return m(x)  }  return n(x);}</code></pre><p><strong>尾调用优化</strong>：即只保留内层函数的调用帧。</p><p>函数调用会在内存形成一个调用记录即“调用帧”，如果函数 A 调用函数 B ，还会形成一个 B 的调用帧，依次类推形成一个调用栈。</p><p>如果函数存在尾调用，只保留最后的函数的调用帧即可，这将大大节省内存。</p><pre><code class="JavaScript">function f() {  let m = 1;  let n = 2;  return g(m + n);}f();// 等同于function f() {  return g(3);}f();// 等同于g(3);</code></pre><p>执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p><p>注意，只有不再用到外层函数的内部变量才能进行“尾调用优化”。<br>下面函数就不会进行“尾调用优化”。</p><pre><code class="JavaScript">function addOne(a){  var one = 1;  function inner(b){    return b + one;  }  return inner(a);}</code></pre><p><strong>尾递归</strong>：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><pre><code class="JavaScript">function factorial(n) {  if (n === 1) return 1;  return n * factorial(n - 1);}factorial(5) // 120// 改写成尾递归function factorial(n, total) {  if (n === 1) return total;  return factorial(n - 1, n * total);}facorial(5, 1) // 120</code></pre><h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><p>ES2017 允许函数的最后一个参数有尾逗号。</p><pre><code class="JavaScript">function clownsEverywhere(  param1,  param2,) { /* ... */ }clownsEverywhere(  &#39;foo&#39;,  &#39;bar&#39;,);</code></pre><h1 id="第9章-对象的扩展"><a href="#第9章-对象的扩展" class="headerlink" title="第9章 对象的扩展"></a>第9章 对象的扩展</h1><h2 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h2><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p><pre><code class="JavaScript">const foo = &#39;bar&#39;;const baz = {foo};// 等同于const baz = {foo: foo};</code></pre><p>除了属性简写，方法也可以简写。</p><pre><code class="JavaScript">const o = {  method() {    return &quot;Hello!&quot;;  }};// 等同于const o = {  method: function() {    return &quot;Hello!&quot;;  }};</code></pre><h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p><pre><code class="JavaScript">// 方法一obj.foo = true;// 方法二obj[&#39;a&#39; + &#39;bc&#39;] = 123;</code></pre><p>如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。<br>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名。</p><pre><code class="JavaScript">let lastWord = &#39;last word&#39;;const a = {  &#39;first word&#39;: &#39;hello&#39;,  [lastWord]: &#39;world&#39;};a[&#39;first word&#39;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#39;last word&#39;] // &quot;world&quot;</code></pre><p>表达式还可以用于定义方法名。</p><pre><code class="JavaScript">let obj = {  [&#39;h&#39; + &#39;ello&#39;]() {    return &#39;hi&#39;;  }};obj.hello(); // hi</code></pre><p>注意：属性名表达式与简洁表示法不能同时使用；属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 <code>[object Object]</code>。</p><h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p><pre><code class="JavaScript">const person = {  sayName() {    console.log(&#39;hello!&#39;);  },};person.sayName.name   // &quot;sayName&quot;</code></pre><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES6 提出“Same-value equality”（同值相等）算法，用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。。</p><pre><code class="JavaScript">Object.is(&#39;foo&#39;, &#39;foo&#39;); // trueObject.is({}, {});       // false</code></pre><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><pre><code class="JavaScript">+0 === -0           // trueNaN === NaN         // falseObject.is(+0, -0)   // falseObject.is(NaN, NaN) // true</code></pre><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign() 方法用于对象的合并，将源对象（source）的所有<strong>可枚举属性</strong>，复制到目标对象（target）。</p><pre><code class="JavaScript">const target = { a: 1 };const source1 = { b: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3}</code></pre><p>Object.assign() 方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>如果 undefined 或 null 作为第一个参数会报错，在之后则会跳过；<br>数值、布尔值可以被转换成包装对象，但依然会被忽略；<br>字符串转对象会被拆分成数组，除了原始值会被拷贝到<code>[[PrimitiveValue]]</code>属性中，每个字符都是可枚举的实义属性，因此是有效的。</p><pre><code class="JavaScript">const v1 = &#39;abc&#39;;const v2 = true;const v3 = 10;const obj = Object.assign({}, v1, v2, v3);console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</code></pre><p>Object.assign() 只拷贝对象的自有属性，属性名为 Symbol 的属性也会被拷贝，继承属性和不可枚举的属性不会被拷贝。<br>Object.assign() 执行的是浅拷贝，对于同名属性会直接覆盖而非合并。<br>Object.assign() 可以用于处理数组，但会把数组转换成属性名为 0、1、2…… 的对象，并依次替换。</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES2017 引入了 <code>Object.getOwnPropertyDescriptors()</code> ，返回指定对象所有自身属性（非继承属性）的描述对象。</p><h2 id="Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="Object.setPrototypeOf()，Object.getPrototypeOf()"></a>Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p><code>__proto__属性</code>:（前后各两个下划线），用来读取或设置当前对象的prototype对象。</p><p><strong>Object.setPrototypeOf()</strong>: 作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数对象本身。<br><strong>Object.getPrototypeOf()</strong>: 读取一个对象的原型对象。</p><h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><p>ES5 引入了 Object.keys() 来返回一个数组，其成员是参数对象的可枚举的自有属性的键名。<br>ES2017 跟着引入了 Object.values() 和 Object.entries() 用于返回属性对应的值，以及以键值对数组的形式返回。<br>可以配合 for…of 循环使用。</p><h2 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。</p><p><strong>可枚举性</strong>：描述对象的 enumerable 属性，如果该属性为false，就表示某些操作会忽略当前属性。</p><p>for…in 循环、Object.keys()、JSON.stringify()、Object.assign() 忽略 enumerable 为 false 的属性。</p><p>ES6 一共有5种方法可以遍历对象的属性。</p><ol><li><code>for...in</code>：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li><li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</li><li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</li><li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li><li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li></ol><p>以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。</p><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p>ES2017 将这个运算符引入了对象。</p><p><strong>解构赋值</strong>:对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。</p><pre><code class="JavaScript">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };x // 1y // 2z // { a: 3, b: 4 }</code></pre><p>解构赋值必须是最后一个参数，否则会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><p><strong>扩展运算符</strong>:</p><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre><code class="JavaScript">let z = { a: 3, b: 4 };let n = { ...z }; // { a: 3, b: 4 }</code></pre><p>扩展运算符可以用于合并两个对象。</p><pre><code class="JavaScript">let ab = { ...a, ...b };// 等同于let ab = Object.assign({}, a, b);</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre><code class="JavaScript">let newVersion = {  ...previousVersion,  name: &#39;New Name&#39; // Override the name property};</code></pre><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><pre><code class="JavaScript">let aWithDefaults = { x: 1, y: 2, ...a };// 等同于let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);</code></pre><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p><pre><code class="JavaScript">// 空对象没有任何效果{...{}, a: 1} // { a: 1 }// 忽略 null 和 undefinedlet emptyObject = { ...null, ...undefined }; // 不报错</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/ebc6af5b.html"/>
    <id>http://www.wshunli.com/posts/ebc6af5b.html</id>
    <published>2017-11-05T03:36:26.000Z</published>
    <updated>2017-12-02T14:48:31.454Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>《JavaScript高级程序设计》中学习了前八章，后面是一些 DOM 相关的知识，现在开始学习 ES6 语法。</p><p><a href="http://es6.ruanyifeng.com/" rel="external nofollow noopener noreferrer" target="_blank">《ECMAScript6入门》</a> 作者：阮一峰。</p><h1 id="第1章-ECMAScript6-简介"><a href="#第1章-ECMAScript6-简介" class="headerlink" title="第1章 ECMAScript6 简介"></a>第1章 ECMAScript6 简介</h1><p>ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等。</p><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码。<br>ESLint 用于静态检查代码的语法和风格；Mocha 则是一个测试框架。</p><h1 id="第2章-let-和-const-命令"><a href="#第2章-let-和-const-命令" class="headerlink" title="第2章 let 和 const 命令"></a>第2章 let 和 const 命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>let 命令只在其所在的代码块内有效。</p><pre><code class="JavaScript">{  let a = 10;  var b = 1;}console.log(a); // ReferenceError: a is not defined.console.log(b); // 1</code></pre><p>前面闭包中有说：闭包只能取得函数中任何变量的最后一个值。</p><pre><code class="JavaScript">var a = [];for (var i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 10</code></pre><p>使用 let 声明的变量仅在块级作用域内有效。</p><pre><code class="JavaScript">var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6</code></pre><p>其实 i 仅在当前循环有效。每循环一次就是一个新的变量。</p><p><strong>1.不存在变量提升</strong>：var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined；let 变量声明前使用会报错。</p><pre><code class="JavaScript">console.log(c); // ReferenceError: a is not defined.console.log(d); // undefinedlet c;var d;</code></pre><p><strong>2.暂时性死区</strong>：在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。</p><pre><code class="JavaScript">var tmp = 123;if (true) {  tmp = &#39;abc&#39;; // ReferenceError  let tmp;}</code></pre><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><p><strong>3.不允许重复声明</strong>：let 不允许在相同作用域内，重复声明同一个变量。也不能在函数内部重新声明参数。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>第一种场景，内层变量可能会覆盖外层变量；第二种场景，用来计数的循环变量泄露为全局变量。</p><p>let 实际上为 JavaScript 新增了块级作用域。</p><pre><code class="JavaScript">function f1() {  let n = 5;  if (true) {    let n = 10;  }  console.log(n); // 5}</code></pre><p>内部代码块可以定义外层作用域的同名变量；外层作用域无法读取内层作用域的变量，也不受内层代码块的影响。</p><p><strong>块级作用域与函数声明</strong>：ES6 允许在块级作用域之中声明函数，但函数在块级作用域之外不可引用。<br>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p>const声明一个只读的常量。一旦声明，就必须立即初始化，常量的值不能改变。</p><pre><code class="JavaScript">const PI = 3.1415;console.log(PI); // 3.1415PI = 3; // TypeError: Assignment to constant variable.const foo; // SyntaxError: Missing initializer in const declaration</code></pre><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。<br>const 命令声明的常量也是不提升；同样存在暂时性死区，只能在声明的位置后面使用；并且不可重复声明。</p><p><strong>本质</strong>：const 其实是变量指向的内存地址不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），等同于常量。但对于复合类型的数据（主要是对象和数组），变量保存的只是一个指针，const 只能保证这个指针是固定的。</p><pre><code class="JavaScript">const foo = {};// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = {}; // TypeError: &quot;foo&quot; is read-only</code></pre><p>如果真的想将对象冻结，应该使用 <code>Object.freeze</code> 方法。</p><pre><code class="JavaScript">const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;</code></pre><h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 中，顶层对象的属性与全局变量是等价的。</p><pre><code class="JavaScript">window.a = 1;console.log(a); // 1b = 2;console.log(window.b); // 2</code></pre><p>ES6 规定 let、const、class 命令声明的全局变量，不属于顶层对象的属性。</p><pre><code class="JavaScript">var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.aconsole.log(window.a) // 1let b = 1;console.log(window.b) // undefined</code></pre><h1 id="第3章-变量的解构赋值"><a href="#第3章-变量的解构赋值" class="headerlink" title="第3章 变量的解构赋值"></a>第3章 变量的解构赋值</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对 <strong>变量</strong> 进行赋值，这被称为解构。</p><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><pre><code class="JavaScript">let [a, b, c] = [1, 2, 3];</code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><pre><code class="JavaScript">// 右边比左边少，解构不成功，值为 undefinedlet [bar, foo] = [1]; // undefined,undefined// 右边比左边多，不完全解构let [x, y] = [1, 2, 3]; //1,2</code></pre><p><strong>默认值</strong>：解构赋值允许指定默认值。</p><pre><code class="JavaScript">let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // &#39;a&#39;,&#39;b&#39;let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // &#39;a&#39;,&#39;b&#39;// 只有数组成员 严格等于 undefined 时，默认值才会生效let [x = 1] = [null]; // null</code></pre><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class="JavaScript">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; //&quot;aaa&quot;,&quot;bbb&quot;let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // undefined</code></pre><p>对象的属性没有次序；变量必须与属性同名，才能取到正确的值。</p><p>变量名与属性名不一致:真正被赋值的是后者，而不是前者。</p><pre><code class="JavaScript">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };console.log(baz); // &quot;aaa&quot;</code></pre><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。</p><p>实际上，对象的解构时下面形式的简写：</p><pre><code class="JavaScript">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 完整形式let { foo     , bar      } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 简写形式</code></pre><p>嵌套赋值：</p><pre><code class="JavaScript">let obj = {};let arr = [];({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });console.log(obj); // {prop:123}console.log(arr); // [true]</code></pre><p>对象的解构也可以指定默认值。同样严格等于 undefined 才生效。</p><pre><code class="JavaScript">let {x = 3} = {};console.log(x); // 3let {x: y = 3} = {};console.log(y); // 3</code></pre><p>如果要将一个已经声明的变量用于解构赋值，必须用括号包裹，不能让花括号处于行首。</p><pre><code class="JavaScript">let x;{x} = {x: 1}; // 错误的写法({x} = {x: 1}); // 正确的写法</code></pre><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><pre><code class="JavaScript">// 字符串可以看做数组进行结构const [a, b, c, d, e] = &#39;hello&#39;;    // a:&quot;h&quot;, b:&quot;e&quot;, c:&quot;l&quot;, d:&quot;l&quot;, e:&quot;o&quot;,// 字符串作为类数组对象，拥有length属性。let {length : len} = &#39;hello&#39;;       // len:5</code></pre><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>数值和布尔值也能进行解构，两者会先转为对象，剩下的就是匹配对象中的方法</p><pre><code class="JavaScript">let {toString: s} = 123;s === Number.prototype.toString  // truelet {toString: s} = true;s === Boolean.prototype.toString // true// undefined和null不能转为对象，没有属性let { prop: x } = undefined;     // TypeErrorlet { prop: y } = null;          // TypeError</code></pre><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p><pre><code class="JavaScript">function add([x, y]){  return x + y;}add([1, 2]); // 3</code></pre><p>函数 add() 的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引。</p><p>函数参数的解构也可以使用默认值。</p><pre><code class="JavaScript">function move({x = 0, y = 0} = {}) {  return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3});       // [3, 0]move({});           // [0, 0]move();             // [0, 0]</code></pre><p>下面代码是为函数 move() 的参数指定默认值。</p><pre><code class="JavaScript">function move({x, y} = { x: 0, y: 0 }) {  return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3});       // [3, undefined]move({});           // [undefined, undefined]move();             // [0, 0] - 无参数，默认值生效</code></pre><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>ES6 规定，但凡有可能产生歧义，就不能使用圆括号。以下3种情况下不能用圆括号：</p><p>1.变量声明语句</p><pre><code class="JavaScript">let [(a)] = [1];let {x: (c)} = {};let { o: ({ p: p }) } = { o: { p: 2 } };</code></pre><p>2.函数参数</p><pre><code class="JavaScript">function f([(z)]) { return z; }function f([z,(x)]) { return x; }</code></pre><p>3.赋值语句的模式</p><pre><code class="JavaScript">[(b)] = [3]; // 正确，数组的解构赋值根据索引来，与括号无关({ p: (d) } = {}); // 正确，p 是模式，但 d 不是模式。</code></pre><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>1.<strong>交换变量的值</strong></p><pre><code class="javascript">let x = 1;let y = 2;[x, y] = [y, x];</code></pre><p>2.<strong>从函数返回多个值</strong></p><pre><code class="javascript">// 返回一个数组function example() {  return [1, 2, 3];}let [a, b, c] = example();// 返回一个对象function example() {  return {    foo: 1,    bar: 2  };}let { foo, bar } = example();</code></pre><p>3.<strong>函数参数的定义</strong></p><pre><code class="javascript">// 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1});</code></pre><p>4.<strong>提取JSON数据</strong></p><pre><code class="javascript">let jsonData = {  id: 42,  status: &quot;OK&quot;,  data: [867, 5309]};let { id, status, data: number } = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309]</code></pre><p>5.<strong>函数参数的默认值</strong></p><pre><code class="javascript">jQuery.ajax = function (url, {  async = true,  beforeSend = function () {},  cache = true,  complete = function () {},  crossDomain = false,  global = true,  // ... more config}) {  // ... do stuff};</code></pre><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p>6.<strong>遍历 Map 结构</strong></p><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><pre><code class="javascript">const map = new Map();map.set(&#39;first&#39;, &#39;hello&#39;);map.set(&#39;second&#39;, &#39;world&#39;);for (let [key, value] of map) {  console.log(key + &quot; is &quot; + value);}// first is hello// second is world// 如果只想获取键名或键值，可以写成下面这样。for (let [key] of map) { ... }// 获取键名for (let [,value] of map) { ...}// 获取键值</code></pre><p>7.<strong>输入模块的指定方法</strong></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><pre><code class="javascript">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/d8b94418.html"/>
    <id>http://www.wshunli.com/posts/d8b94418.html</id>
    <published>2017-11-05T03:18:50.000Z</published>
    <updated>2017-12-02T14:48:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。</strong>(8-14章)</p><h1 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p>BOM 的核心对象是 window，表示浏览器的实例。既是范文浏览器窗口的接口，又是 ECMAScript 规定的 Global 对象。</p><p><strong>全局作用域</strong>：全局作用域中声明的变量函数会变成 window 对象的属性和方法。</p><p><strong>窗口关系及框架</strong>：若页面中包含框架，则每个框架都有自己的 window 对象，并且保存在 frames 集合中。</p><p>top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。<br>parent 对象始终指向当前框架的直接上层框架。<br>self 对象始终指向 window。</p><p>所有这些对象都是 window 对象的属性。</p><p><strong>窗口位置</strong>：IE、Safari、Opera、Chrome 提供 screenLeft 和 screenTop 属性，FireFox 提供 screenX 和 screenY 属性，分别用于表示窗口相对于屏幕左边和上边的位置。</p><p><strong>窗口大小</strong>：innerWidth、innerHeight、outerWidth、outerHeight</p><p><strong>导航和打开窗口</strong>: window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。</p><p>接受 4 个参数：要加载的URL、窗口目标、一个特性字符串、一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。</p><p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p><p><strong>间歇调用和超时调用</strong>：JavaScript 是单线程语言，但允许通过设置超时时间和间歇时间调度代码在特定的时刻执行。</p><p>超时调用 setTimeout()：指定的时间过后执行代码。</p><pre><code class="JavaScript">var timeoutId=setTimeout(function(){    console.log(&quot;Hello world!&quot;);},1000);//取消超时调用clearTimeout(timeoutId);</code></pre><p>间歇调用 setInterval()：指定的时间间隔重复执行代码。</p><p><strong>系统对话框</strong>：alert()、confirm()、prompt()</p><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>location 对象不仅提供与当前窗口中加载的文档有关信息，还提供了一些导航功能。<br>即是 window 对象的属性，也是 document 对象的属性。</p><p>除直接修改 location 对象属性外 assign()、replace()、reload() 方法也可以改变当前加载页面。</p><pre><code class="JavaScript">location.assign(&quot;http://www.wshunli.com&quot;);// 等价于window.location=&quot;htttp://www.wshunli.com&quot;;location.href=&quot;htttp://www.wshunli.com&quot;;location.replace=&quot;htttp://www.wshunli.com&quot;;// 无法返回前一个页面location.reload();// 重新加载页面</code></pre><h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p>navigator 对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。</p><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><p>screen 对象用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息 ，如像素高度和宽度等。每个浏览器中的screen对象都包含着不同过的属性，支持也不同。</p><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此每个浏览器窗口、每个标签乃至每个框架，都有自己的history 对象与特定的 window 对象关联。</p><h1 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a>第九章 客户端检测</h1><p>客户端检测主要包括：<br>能力检测：浏览器的特定能力；<br>怪癖检测：浏览器实际中存在的 bug ；<br>用户代理检测：通过检测用户代理字符串识别浏览器。</p><p>尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案。</p><h1 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h1><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM 将任何HTML或XML文档描绘成一个由多层节点构成的树形结构。总共有 12 种节点，其中常用的有 4 种。</p><p>Node.ELEMENT_NODE(1) - 元素节点<br>Node.ATTRIBUTE_NODE(2) - 特性（属性）节点<br>Node.TEXT_NODE(3) - 文本节点<br>Node.COMMENT_NODE(8) - 注释节点</p><p>DOM 节点关系：</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/DOM节点关系.png" alt="DOM节点关系"></p><p><strong>Document 类型</strong>：JavaScript通过Document类型表示文档；浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面，且也是window对象的一个属性，因此可以将其作为全局对象来访问。</p><p>文档属性：<br>document.title：取得当前页面的标题，也可以修改标题。<br>document.URL：页面完整的URL；<br>document.domain：只包含页面的域名；<br>document.referrer：保存着链接到当前页面的那个页面的 URL。<br>文档方法：<br>document.getElementById()<br>document.getElementsByTagName()<br>document.getElementsByName()<br>特殊集合：<br>document.anchors：包含文档中所有带name特性的<code>&lt;a&gt;</code>元素；<br>document.forms：包含文档中所有<code>&lt;form&gt;</code>元素；<br>document.img：包含文档中所有<code>&lt;img&gt;</code>元素；<br>document.links：包含文档中所有带href特性的<code>&lt;a&gt;</code>元素。</p><p><strong>Element 类型</strong>：Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。</p><p>特性（属性）操作：getAttribute()、setAttribute()、removeAttribute()<br>创建元素：document.createElement()</p><p><strong>Text 类型</strong>：文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。</p><p>创建文本节点：document.createTextNode()</p><p>规范文本节点：父元素上调用 normalize()，其实就是将元素的相邻文本节点合并成一个节点。</p><pre><code class="JavaScript">var element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;var textNode = document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);var anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);console.log(element.childNodes.length);  //2element.normalize();console.log(element.childNodes.length);  //1console.log(element.firstChild.nodeValue);  //&quot;Hello World!Yippee!&quot;</code></pre><p>分割文本节点：spiltText()</p><pre><code class="JavaScript">var element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;var textNode=docuemnt.createTextNode(&quot;Hello World!&quot;);element.appendChild(textNode);document.body.appendChild(element);var newNode=element.firstChild.spiltText(5);console.log(element.firstChild.nodeValue); //&quot;Hello&quot;console.log(newNode.nodeValue);            //&quot; World&quot;console.log(element.childNodes.length);    //2</code></pre><p><strong>Attr 类型</strong>：元素的特性（属性）在 DOM 中以 Attr 类型来表示。<br>Attr对象有3个属性：name、value和specified。<br>其中，name是特性名称，value是特性的值，specified是一个布尔值，用以区别特性是在代码中指定的还是默认的。</p><p><strong>Comment 类型</strong>：注释在 DOM 中是通过 Comment 类型来表示的。</p><p><strong>其他节点类型</strong>：</p><p>Node.CDATA_SECTION_NODE(4)<br>Node.ENTITY_REFERENCE_NODE(5)<br>Node.ENTITY_NODE(6)<br>Node.PROCESSING_INSTRUCTION_NODE(7)<br>Node.DOCUMENT_NODE(9)<br>Node.DOCUMENT_TYPE_NODE(10)<br>Node.DOCUMENT_FRAGMENT_NODE(11)<br>Node.NOTATION_NODE(12)</p><h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><p>利用 JavaScript 代码、CSS 样式、表格修改 DOM 元素的结构、属性、内容的技术。</p><p>动态脚本：<code>&lt;script&gt;</code><br>动态样式：<code>&lt;link&gt;</code>,<code>&lt;style&gt;</code><br>操作表格：<code>&lt;table&gt;</code></p><h1 id="第十一章-DOM-扩展"><a href="#第十一章-DOM-扩展" class="headerlink" title="第十一章 DOM 扩展"></a>第十一章 DOM 扩展</h1><p>DOM扩展主要包含两方面：Selector API，HTML5</p><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><p>querySelector() ：接收一个 CSS 选择符，返回匹配的第一个元素；<br>querySelectorAll() ：返回 NodeList 对象。</p><pre><code class="JavaScript">// 取得ID为&quot;myDIV&quot;的元素var myDIV = document.querySelector(&quot;#myDiv&quot;);// 取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName(&quot;em&quot;))var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);</code></pre><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p>Element Traversal 规范为 DOM <strong>元素</strong>新定义了5个属性：<br>childElementCount：返回子元素的个数（不包括文本节点和注释）<br>firstElementChild：指向第一个子元素，firstChild元素版<br>lastElementChild：指向最后一个子元素，lastChild元素版<br>previousElementSibling：指向前一个同辈元素，previousSibling元素版<br>nextElementSibling：指向后一个同辈元素，nextSibling元素版</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p><strong>与类相关的扩展</strong>：</p><p>getElementsByClassName()：返回带有特定类的所有元素的 NodeList。<br>classList属性：HTML5为所有元素添加 classList属性。</p><p><strong>焦点管理</strong>：HTML5也添加了辅助管理DOM焦点的功能。<br>document.activeElement 属性，始终会引用 DOM 中当前获得焦点的元素。<br>document.hasFocus()方法，确定文档是否获得了焦点。</p><pre><code class="JavaScript">var button = document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement === button); // trueconsole.log(document.hasFocus()); // true</code></pre><p><strong>HTMLDocument 的变化</strong>：</p><p>readyState 属性：document.readyState 指示文档是否加载完成。<br>loading：正在加载文档；complete：已经加载完文档。</p><p>head 属性：document.head 属性可以获得<code>&lt;head&gt;</code>元素。</p><p><strong>字符集属性</strong>：</p><p>document.charset：表示文档中实际使用的字符集。<br>document.defaultCharset：当前文档的默认字符集。</p><p><strong>自定义数据属性</strong>：</p><p>HTML5规定可以为元素添加非标准的属性，以此为元素提供与渲染无关的信息。<br>每个自定义数据属性，都要为其添加前缀data-。可通过 dataset 属性访问自定义属性的值。</p><pre><code class="JavaScript">&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myName=&quot;nicholas&quot;&gt;&lt;/div&gt;// 访问上述div元素的自定义属性var div = document.getElementById(&quot;myDiv&quot;);// 访问自定义属性值时，属性名前不必加data-前缀var appId = div.dataset.appId;</code></pre><p><strong>插入标记</strong>：</p><p>innerHTML 属性：<br>在读模式下，innerHTML属性返回调用元素的所有子节点HTML标记。<br>在写模式下，innerHTML属性会根据指定的值创建新的DOM树，然后用新DOM树替换调用元素原先的所有子节点。</p><p>outerHTML 属性：<br>在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。<br>在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。</p><p>insertAdjacentHTML() 方法：<br>语法：insertAdjacentHTML(插入位置，要插入的HTML文本)<br>插入位置必须是下列四个值之一：</p><ul><li>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素</li><li>“afterend”，在当前元素之后插入一个紧邻的同辈元素</li><li>“afterbegin”，给当前元素插入第一个子元素（不管当前元素是否有无子元素）</li><li>“beforeend”，给当前元素插入最后一个子元素（不管当前元素是否有无子元素）</li></ul><p><strong>scrollIntoView() 方法</strong>：所有元素均可调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</p><h1 id="第十二章-DOM2-和-DOM3"><a href="#第十二章-DOM2-和-DOM3" class="headerlink" title="第十二章 DOM2 和 DOM3"></a>第十二章 DOM2 和 DOM3</h1><p>DOM1级主要定义的是HTML和XML文档的底层结构。DOM2 和DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。</p><h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p><p>事件冒泡（event bubbling）：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。<br>事件捕获（event capturing）:不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流.jpg" alt="事件-事件流"></p><p>事件流包括三个阶段：<br>事件捕获阶段：首先发生，为截获事件提供了机会。<br>处于目标阶段：实际的目标接收到事件。<br>事件冒泡阶段：在此阶段可以对事件做出响应。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流三个阶段.jpg" alt="事件-事件流三个阶段"></p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作（比如click、load、mouseover等）<br>事件处理程序（事件侦听器）是响应某个事件的函数。<br>事件处理程序的名字以“on”开头，如click事件的事件处理程序是onclick。</p><p><strong>HTML事件处理程序</strong>：</p><p>为元素添加一个与事件处理程序同名的属性，该属性的值是能够执行的JS代码或JS函数。</p><pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot;&gt;    function showMessage() {        console.log(&quot;Hello world&quot;);    }&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Clicke Me&quot; onclick=&quot;showMessage()&quot; /&gt;</code></pre><p><strong>DOM0级事件处理程序</strong>：</p><p>将一个函数赋值给一个事件处理程序属性。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);// 为按钮指定onclick事件处理程序btn.onclick = function(){    console.log(&quot;Clicked&quot;);}// 删除事件处理程序btn.onclick = null;</code></pre><p><strong>DOM2级事件处理程序</strong>：</p><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()、removeEventListener() 。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);//定义事件处理程序函数var handler = function(){    console.log(this.id);}btn.addEventListener(&quot;click&quot;, handler, false);btn.removeEventListener(&quot;click&quot;, handler, false);</code></pre><p>true：在捕获阶段调用事件处理程序；false：在冒泡阶段调用事件处理程序。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>触发DOM上的某个事件时，会产生一个event事件对象，该对象包含着所有与事件有关的信息。</p><p>兼容DOM（DOM0级和DOM2级）的浏览器将event对象传入到事件处理程序中。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event){    console.log(event.type);  //&quot;click&quot;};btn.addEventListener(&quot;click&quot;, function(event){    console.log(event.type);  //&quot;click&quot;}, false);</code></pre><p><strong>属性/方法</strong>：</p><p>currentTarget：正在处理事件的那个元素<br>target：事件的目标<br>type：事件类型<br>cancelable：可以阻止特定事件的默认行为<br>preventDefault()：阻止特定事件的默认行为<br>stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡<br>eventPhase：事件出于事件流的阶段 捕获阶段为1 处于目标对象为2 冒泡阶段为3</p><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件、合成事件、变动事件。</p><h1 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h1><p>在HTML中，表单是由 <code>&lt;form&gt;</code> 元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
</feed>
