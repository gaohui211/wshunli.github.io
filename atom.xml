<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS 博客</title>
  
  <subtitle>wshunli`s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2018-09-23T10:41:06.421Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Glide 图片加载框架源码解析</title>
    <link href="https://www.wshunli.com/posts/c47606cc.html"/>
    <id>https://www.wshunli.com/posts/c47606cc.html</id>
    <published>2018-09-17T05:18:23.000Z</published>
    <updated>2018-09-23T10:41:06.421Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。<strong>本文内容基于 Glide 4.7.1 版本</strong>。</p><p>Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、可扩展的图片解码管道，以及自动的资源池技术。<a href="https://muyangmin.github.io/glide-docs-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://muyangmin.github.io/glide-docs-cn/</a></p><p>Glide 支持拉取，解码和展示视频快照，图片，和 GIF 动画。Glide 的 API 是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide 使用的是一个定制化的基于 HttpUrlConnection 的栈，但同时也提供了与 Google Volley 和 Square OkHttp 快速集成的工具库。</p><h1 id="Glide-的简单使用"><a href="#Glide-的简单使用" class="headerlink" title="Glide 的简单使用"></a>Glide 的简单使用</h1><p>前面有比较详细的介绍，这里不再赘述。</p><p>Android 图片加载框架 Glide 简单使用 | CirGIS</p><p><a href="https://www.wshunli.com/posts/d82d8606.html">https://www.wshunli.com/posts/d82d8606.html</a></p><h1 id="Glide-的源码解析"><a href="#Glide-的源码解析" class="headerlink" title="Glide 的源码解析"></a>Glide 的源码解析</h1><p>1、我们先看 Glide 的 with() 方法</p><pre><code class="lang-Java">  @NonNull  public static RequestManager with(@NonNull Context context) {    return getRetriever(context).get(context);  }  @NonNull  public static RequestManager with(@NonNull Activity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull FragmentActivity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull Fragment fragment) {    return getRetriever(fragment.getActivity()).get(fragment);  }  @NonNull  public static RequestManager with(@NonNull View view) {    return getRetriever(view.getContext()).get(view);  }</code></pre><p>未完待续。。</p><blockquote><p>参考资料<br>1、Glide源码分析 | lightSky’Blog<br><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" rel="external nofollow noopener noreferrer" target="_blank">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br>2、Android Glide源码解析 - 简书<br><a href="https://www.jianshu.com/p/0c383eaa5675" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c383eaa5675</a><br>3、Android Glide源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/10/10/android-glide/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/10/10/android-glide/</a><br>4、Android源码分析：手把手带你分析 Glide的缓存功能 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/79256892" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/79256892</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Glide 4.7.1 版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Glide" scheme="https://www.wshunli.com/tags/Glide/"/>
    
      <category term="图片加载" scheme="https://www.wshunli.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/2bda06ba.html"/>
    <id>https://www.wshunli.com/posts/2bda06ba.html</id>
    <published>2018-09-16T01:38:40.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 Retrofit 2.4.0 版本</strong>。</p><p>Type-safe HTTP client for Android and Java by Square, Inc. <a href="http://square.github.io/retrofit/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/retrofit/</a></p><p>前面介绍过 OkHttp ，Retrofit 是对 OkHttp 网络请求框架的封装，前者专注于接口的封装，后者专注于真正的网络请求。</p><p><img src="https://img.wshunli.com/Android/Retrofit/Retrofit_OkHttp.png" alt="封装流程图"></p><p>应用程序通过 Retrofit 请求网络，实际上是由 Retrofit 接口层封装请求参数、Header、Url 等信息，由 OkHttp 完成实际的请求操作；在服务端返回数据后，OkHttp 将原始的结果交给 Retrofit，Retrofit 根据用户的需求对结果进行解析。</p><h1 id="Retrofit-的简单使用"><a href="#Retrofit-的简单使用" class="headerlink" title="Retrofit 的简单使用"></a>Retrofit 的简单使用</h1><p>参考官网的介绍：</p><p>1、创建 HTTP API 接口</p><pre><code class="lang-Java">public interface GitHubService {  @GET(&quot;users/{user}/repos&quot;)  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><p>2、创建 Retrofit 实例，并实现接口实例</p><pre><code class="lang-Java">Retrofit retrofit = new Retrofit.Builder()    .baseUrl(&quot;https://api.github.com/&quot;)    .build();GitHubService service = retrofit.create(GitHubService.class);</code></pre><p>3、创建请求实例</p><pre><code class="lang-Java">Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;wshunli&quot;);</code></pre><p>4、发送网络请求</p><pre><code class="lang-Java">// 同步请求call.execute();// 异步请求call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {    @Override    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) {    }    @Override    public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) {        Log.d(TAG, &quot;onFailure: &quot;);    }});</code></pre><p>和 OkHttp 流程差不多，特别是发送请求方法名字都没有变。</p><h1 id="Retrofit-的源码分析"><a href="#Retrofit-的源码分析" class="headerlink" title="Retrofit 的源码分析"></a>Retrofit 的源码分析</h1><p>Retrofit 网络请求完整的流程图如下：</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_full_process.min.png" alt="Retrofit 流程图"></p><p>下面详细介绍。</p><h2 id="创建-Retrofit-实例"><a href="#创建-Retrofit-实例" class="headerlink" title="创建 Retrofit 实例"></a>创建 Retrofit 实例</h2><p>Retrofit 实例化，也是使用的建造者模式。</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_builder.png" alt="retrofit_builder"></p><p>我们先看 Builder 成员变量的含义：</p><pre><code class="lang-Java">// Retrofit#Builderpublic static final class Builder {// 当前系统环境private final Platform platform;// 网络请求器的工厂private @Nullable okhttp3.Call.Factory callFactory;// 网络请求地址private HttpUrl baseUrl;// 数据转换器工厂集合private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();// 网络请求适配器工厂集合private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();// 回调方法执行器private @Nullable Executor callbackExecutor;// 标志位private boolean validateEagerly;</code></pre><p>1、首先构造函数中通过 <code>Platform.get()</code> 初始化了平台参数</p><pre><code class="lang-Java">Builder(Platform platform) {    this.platform = platform;}public Builder() {    this(Platform.get());}Builder(Retrofit retrofit) {    platform = Platform.get();    callFactory = retrofit.callFactory;    baseUrl = retrofit.baseUrl;    converterFactories.addAll(retrofit.converterFactories);    // Remove the default BuiltInConverters instance added by build().    converterFactories.remove(0);    callAdapterFactories.addAll(retrofit.callAdapterFactories);    // Remove the default, platform-aware call adapter added by build().    callAdapterFactories.remove(callAdapterFactories.size() - 1);    callbackExecutor = retrofit.callbackExecutor;    validateEagerly = retrofit.validateEagerly;}</code></pre><p>我们可以看下判断方法：</p><pre><code class="lang-Java">// Platformclass Platform {  private static final Platform PLATFORM = findPlatform();  static Platform get() {    return PLATFORM;  }  private static Platform findPlatform() {    try {      Class.forName(&quot;android.os.Build&quot;);      if (Build.VERSION.SDK_INT != 0) {        return new Android();      }    } catch (ClassNotFoundException ignored) {    }    try {      Class.forName(&quot;java.util.Optional&quot;);      return new Java8();    } catch (ClassNotFoundException ignored) {    }    return new Platform();  }  /* 省略部分无关代码 */}</code></pre><p>后面如果有需要，我们也可以直接拷贝。</p><p>2、然后设置 Retrofit 所需的参数即可</p><pre><code class="lang-Java">public Builder baseUrl(String baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    HttpUrl httpUrl = HttpUrl.parse(baseUrl);    if (httpUrl == null) {    throw new IllegalArgumentException(&quot;Illegal URL: &quot; + baseUrl);    }    return baseUrl(httpUrl);}public Builder baseUrl(HttpUrl baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    List&lt;String&gt; pathSegments = baseUrl.pathSegments();    if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) {    throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl);    }    this.baseUrl = baseUrl;    return this;}/** Add converter factory for serialization and deserialization of objects. */public Builder addConverterFactory(Converter.Factory factory) {    converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}public Builder addCallAdapterFactory(CallAdapter.Factory factory) {    callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}</code></pre><p>3、最后是 build() 方法</p><pre><code class="lang-Java">public Retrofit build() {    if (baseUrl == null) {    throw new IllegalStateException(&quot;Base URL required.&quot;);    }    okhttp3.Call.Factory callFactory = this.callFactory;    if (callFactory == null) {    callFactory = new OkHttpClient();    }    Executor callbackExecutor = this.callbackExecutor;    if (callbackExecutor == null) {    callbackExecutor = platform.defaultCallbackExecutor();    }    // Make a defensive copy of the adapters and add the default Call adapter.    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);    callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));    // Make a defensive copy of the converters.    List&lt;Converter.Factory&gt; converterFactories =        new ArrayList&lt;&gt;(1 + this.converterFactories.size());    // Add the built-in converter factory first. This prevents overriding its behavior but also    // ensures correct behavior when using converters that consume all types.    converterFactories.add(new BuiltInConverters());    converterFactories.addAll(this.converterFactories);    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);}</code></pre><h2 id="创建-API-实例"><a href="#创建-API-实例" class="headerlink" title="创建 API 实例"></a>创建 API 实例</h2><p>获取 API 实例使用 Retrofit 的 <code>create()</code> 方法</p><pre><code class="lang-Java">// Retrofit#create()public &lt;T&gt; T create(final Class&lt;T&gt; service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {        eagerlyValidateMethods(service);    }    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },        new InvocationHandler() {            private final Platform platform = Platform.get();            @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)                throws Throwable {            // If the method is a method from Object then defer to normal invocation.            if (method.getDeclaringClass() == Object.class) {                return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {                return platform.invokeDefaultMethod(method, service, proxy, args);            }            ServiceMethod&lt;Object, Object&gt; serviceMethod =                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);            return serviceMethod.adapt(okHttpCall);            }        });}</code></pre><p>创建 API 实例使用的是 <strong>动态代理</strong> 设计模式。</p><h2 id="创建请求实例"><a href="#创建请求实例" class="headerlink" title="创建请求实例"></a>创建请求实例</h2><p>创建请求实例，跟钱买你的动态代理有关。</p><pre><code class="lang-Java">// Retrofit#create()ServiceMethod&lt;Object, Object&gt; serviceMethod =    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.adapt(okHttpCall);</code></pre><p>1、<code>loadServiceMethod()</code> 方法</p><p>一个 <code>ServiceMethod</code> 对应于一个 API 接口的一个方法，<code>loadServiceMethod()</code> 方法负责加载 <code>ServiceMethod</code></p><pre><code class="lang-Java">// Retrofit#loadServiceMethod()ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) {    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) {        result = serviceMethodCache.get(method);        if (result == null) {        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();        serviceMethodCache.put(method, result);        }    }    return result;}</code></pre><p>2、<code>OkHttpCall</code> 类</p><p><code>OkHttpCall</code> 实现了 <code>retrofit2.Call</code> ，我们通常会使用它的 <code>execute()</code> 和 <code>enqueue()</code> 接口。</p><pre><code class="lang-Java">OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) {    this.serviceMethod = serviceMethod;    this.args = args;}</code></pre><p>构造方法也没有什么好看的。</p><h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>发送网络请求其实也就是 <code>OkHttpCall</code> 类中的方法。</p><p>1、<strong>同步请求</strong> 使用 <code>execute()</code> 方法</p><pre><code class="lang-Java">// OkHttpCall#execute()@Override public Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        if (creationFailure != null) {            if (creationFailure instanceof IOException) {                throw (IOException) creationFailure;            } else if (creationFailure instanceof RuntimeException) {                throw (RuntimeException) creationFailure;            } else {                throw (Error) creationFailure;            }        }        call = rawCall;        if (call == null) {            try {                call = rawCall = createRawCall();            } catch (IOException | RuntimeException | Error e) {                throwIfFatal(e); //  Do not assign a fatal error to creationFailure.                creationFailure = e;                throw e;            }        }    }    if (canceled) {        call.cancel();    }    return parseResponse(call.execute());}</code></pre><p>这里就是 Retrofit 和 OkHttp 交互的核心了，分为三步：</p><p>（1）创建 <code>okhttp3.Call</code> ，包括构造参数</p><pre><code class="lang-Java">private okhttp3.Call createRawCall() throws IOException {    okhttp3.Call call = serviceMethod.toCall(args);    if (call == null) {        throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    }    return call;}</code></pre><p>（2）执行网络请求，也就是 OkHttp 的同步网络请求</p><pre><code class="lang-Java">call.execute()</code></pre><p>（3）解析返回的结果</p><pre><code class="lang-Java">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {    ResponseBody rawBody = rawResponse.body();    // Remove the body&#39;s source (the only stateful object) so we can pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))        .build();    int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) {        try {        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);        } finally {        rawBody.close();        }    }    if (code == 204 || code == 205) {        rawBody.close();        return Response.success(null, rawResponse);    }    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);    try {        T body = serviceMethod.toResponse(catchingBody);        return Response.success(body, rawResponse);    } catch (RuntimeException e) {        // If the underlying source threw an exception, propagate that rather than indicating it was        // a runtime exception.        catchingBody.throwIfCaught();        throw e;    }}</code></pre><p>2、<strong>异步请求</strong> 使用 <code>enqueue()</code> 方法</p><pre><code class="lang-Java">@Override public void enqueue(final Callback&lt;T&gt; callback) {    checkNotNull(callback, &quot;callback == null&quot;);    okhttp3.Call call;    Throwable failure;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        call = rawCall;        failure = creationFailure;        if (call == null &amp;&amp; failure == null) {        try {            call = rawCall = createRawCall();        } catch (Throwable t) {            throwIfFatal(t);            failure = creationFailure = t;        }        }    }    if (failure != null) {        callback.onFailure(this, failure);        return;    }    if (canceled) {        call.cancel();    }    call.enqueue(new okhttp3.Callback() {        @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {        Response&lt;T&gt; response;        try {            response = parseResponse(rawResponse);        } catch (Throwable e) {            callFailure(e);            return;        }        try {            callback.onResponse(OkHttpCall.this, response);        } catch (Throwable t) {            t.printStackTrace();        }        }        @Override public void onFailure(okhttp3.Call call, IOException e) {        callFailure(e);        }        private void callFailure(Throwable e) {        try {            callback.onFailure(OkHttpCall.this, e);        } catch (Throwable t) {            t.printStackTrace();        }        }    });}</code></pre><p>我们可以看到和同步请求是一致的，实际请求交给了 <code>okhttp3.Call#enqueue(Callback responseCallback)</code> 来实现，并在它的 <code>callback</code> 中调用 <code>parseResponse()</code> 解析响应数据，并转发给传入的 <code>callback</code> 。</p><p>Retrofit 源码就先介绍到这里了，后面有机会再详细介绍。</p><blockquote><p>参考资料<br>1、Retrofit分析-漂亮的解耦套路 - 简书<br><a href="https://www.jianshu.com/p/45cb536be2f4" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/45cb536be2f4</a><br>2、Android：手把手带你 深入读懂 Retrofit 2.0 源码 - 简书<br><a href="https://www.jianshu.com/p/0c055ad46b6c" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c055ad46b6c</a><br>3、Retrofit源码分析（超详细） - 简书<br><a href="https://www.jianshu.com/p/097947afddaf" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/097947afddaf</a><br>4、拆轮子系列：拆 Retrofit - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/06/25/Understand-Retrofit/</a><br>5、Retrofit源码解析 | mundane的幻想空间<br><a href="https://mundane799699.github.io/2018/03/13/retrofit-analysis/" rel="external nofollow noopener noreferrer" target="_blank">https://mundane799699.github.io/2018/03/13/retrofit-analysis/</a><br>6、Retrofit源码解析 - 掘金<br><a href="https://juejin.im/post/5acee62c6fb9a028df22ffee" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5acee62c6fb9a028df22ffee</a><br>7、Retrofit源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="https://yuqirong.me/2017/08/03/Retrofit源码解析/" rel="external nofollow noopener noreferrer" target="_blank">https://yuqirong.me/2017/08/03/Retrofit源码解析/</a><br>8、android-cn/android-open-project-analysis<br><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit</a><br>9、【Android】Retrofit源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79933220" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79933220</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Retrofit 2.4.0 版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Type-safe HTTP client for Android and Java by Square, I
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Retrofit" scheme="https://www.wshunli.com/tags/Retrofit/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/5bd2f229.html"/>
    <id>https://www.wshunli.com/posts/5bd2f229.html</id>
    <published>2018-09-13T08:28:11.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 OkHttp 3.11.0 版本</strong>。</p><p>网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。</p><p>只是停留在应用层面，会使用一些框架是不行的，还需要深入源码、剖析结构。</p><p>An HTTP+HTTP/2 client for Android and Java applications. <a href="http://square.github.io/okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/okhttp/</a></p><blockquote><p>支持 HTTP/2 协议，允许连接到同一个主机地址的所有请求共享 Socket 。<br>在 HTTP/2 协议不可用的情况下，通过连接池减少请求的延迟。<br>支持 GZip 透明压缩，减少传输的数据包大小。<br>支持响应缓存，避免同一个重复的网络请求。</p></blockquote><h1 id="OkHttp-的简单使用"><a href="#OkHttp-的简单使用" class="headerlink" title="OkHttp 的简单使用"></a>OkHttp 的简单使用</h1><p>一般情况下，对于网络框架有两种常见的使用场景，同步请求和异步请求。</p><p><strong>同步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();Log.d(TAG, &quot;onCreate: &quot; + response.body().string());</code></pre><p><strong>异步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {        Log.d(TAG, &quot;onCreate: &quot; + response.body().string());    }});</code></pre><p>同步请求和异步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><h1 id="OkHttp-的源码分析"><a href="#OkHttp-的源码分析" class="headerlink" title="OkHttp 的源码分析"></a>OkHttp 的源码分析</h1><p>OkHttp 网络请求完整的流程图如下：</p><div align="center">     <img src="https://img.wshunli.com/Android/OkHttp/okhttp_full_process.min.png" title="OkHttp 流程图" alt="OkHttp 流程图"></div><p>下面详细介绍。</p><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步请求，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，最后执行 execute() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();</code></pre><h3 id="创建-OkHttpClient-对象"><a href="#创建-OkHttpClient-对象" class="headerlink" title="创建 OkHttpClient 对象"></a>创建 OkHttpClient 对象</h3><p>我们先看 OkHttp 的构造函数：</p><pre><code class="lang-Java">public OkHttpClient() {  this(new Builder());}</code></pre><p>这里是直接实例化，实质上是使用 <strong>建造者模式</strong> 构建 OkHttpClient 实例。 </p><p>下面是 OkHttpClient 内部类 Builder 的构造方法：</p><pre><code class="lang-Java">public Builder() {  dispatcher = new Dispatcher();  protocols = DEFAULT_PROTOCOLS;  connectionSpecs = DEFAULT_CONNECTION_SPECS;  eventListenerFactory = EventListener.factory(EventListener.NONE);  proxySelector = ProxySelector.getDefault();  cookieJar = CookieJar.NO_COOKIES;  socketFactory = SocketFactory.getDefault();  hostnameVerifier = OkHostnameVerifier.INSTANCE;  certificatePinner = CertificatePinner.DEFAULT;  proxyAuthenticator = Authenticator.NONE;  authenticator = Authenticator.NONE;  connectionPool = new ConnectionPool();  dns = Dns.SYSTEM;  followSslRedirects = true;  followRedirects = true;  retryOnConnectionFailure = true;  connectTimeout = 10_000;  readTimeout = 10_000;  writeTimeout = 10_000;  pingInterval = 0;}public OkHttpClient build() {  return new OkHttpClient(this);}</code></pre><p>这里 <code>OkHttpClient.Builder</code> 有很多参数，后面再介绍。</p><h3 id="创建-Request-对象"><a href="#创建-Request-对象" class="headerlink" title="创建 Request 对象"></a>创建 Request 对象</h3><p>和 OkHttpClient 类似，Request 也是是使用 <strong>建造者模式</strong> 创建实例。</p><pre><code class="lang-Java">public Builder() {  this.method = &quot;GET&quot;;  this.headers = new Headers.Builder();}public Request build() {  if (url == null) throw new IllegalStateException(&quot;url == null&quot;);  return new Request(this);}</code></pre><p>其中配置默认请求方法为 <code>GET</code> ，还有一些头部的默认参数。</p><h3 id="创建-Call-对象"><a href="#创建-Call-对象" class="headerlink" title="创建 Call 对象"></a>创建 Call 对象</h3><p>OkHttpClient 实现了 <code>Call.Factory</code> ，负责根据请求创建新的 Call 对象。</p><pre><code class="lang-Java">@Override public Call newCall(Request request) {  return RealCall.newRealCall(this, request, false /* for web socket */);}</code></pre><p>Call 只是个接口，实际是实例化的 RealCall 对象。</p><pre><code class="lang-Java">private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  this.client = client;  this.originalRequest = originalRequest;  this.forWebSocket = forWebSocket;  this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);}static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  // Safely publish the Call instance to the EventListener.  RealCall call = new RealCall(client, originalRequest, forWebSocket);  call.eventListener = client.eventListenerFactory().create(call);  return call;}</code></pre><h3 id="发送同步网络请求"><a href="#发送同步网络请求" class="headerlink" title="发送同步网络请求"></a>发送同步网络请求</h3><p>发送请求也是在 <code>RealCall</code> 的 <code>execute()</code> 方法中执行的。</p><pre><code class="lang-Java">// RealCall#execute()@Override public Response execute() throws IOException {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  try {    client.dispatcher().executed(this);    Response result = getResponseWithInterceptorChain();    if (result == null) throw new IOException(&quot;Canceled&quot;);    return result;  } catch (IOException e) {    eventListener.callFailed(this, e);    throw e;  } finally {    client.dispatcher().finished(this);  }}</code></pre><p>在这里主要做了四件事：</p><p>1、检查 Call 是否执行过，没有执行将 <code>executed</code> 赋值为 true ，保证每个请求只执行一次；<br>2、使用 <code>client.dispatcher().executed(this)</code> 来进行实际的请求；<br>3、调用 <code>getResponseWithInterceptorChain()</code> 方法，获取请求响应的结果；<br>4、最后 <code>dispatcher</code> 结束自己。</p><pre><code class="lang-Java">// Dispatcher#executed()/** Used by {@code Call#execute} to signal it is in-flight. */synchronized void executed(RealCall call) {  runningSyncCalls.add(call);}</code></pre><p>在同步请求中 <code>dispatcher</code> 只是负责判断请求执行的状态，在异步请求中参与内容过多。</p><p>下面我们来看 <code>getResponseWithInterceptorChain()</code> 方法：</p><pre><code class="lang-Java">Response getResponseWithInterceptorChain() throws IOException {  // Build a full stack of interceptors.  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();  interceptors.addAll(client.interceptors()); // 加入用户自定义的拦截器  interceptors.add(retryAndFollowUpInterceptor); // 重试和重定向拦截器  interceptors.add(new BridgeInterceptor(client.cookieJar())); // 加入转化请求响应的拦截器  interceptors.add(new CacheInterceptor(client.internalCache())); // 加入缓存拦截器  interceptors.add(new ConnectInterceptor(client)); // 加入连接拦截器  if (!forWebSocket) {      interceptors.addAll(client.networkInterceptors()); // 加入用户自定义的网络拦截器  }  interceptors.add(new CallServerInterceptor(forWebSocket)); // 加入请求响应的拦截器  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,          originalRequest, this, eventListener, client.readTimeoutMillis());  // 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象  return chain.proceed(originalRequest);}</code></pre><p>我们都知道，拦截器是 OkHttp 的精髓。</p><p>1、<code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；<br>2、<code>RetryAndFollowUpInterceptor</code> 是用来重试和重定向的拦截器，在下面我们会讲到；<br>3、<code>BridgeInterceptor</code> 是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；<br>4、<code>CacheInterceptor</code> 是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；<br>5、<code>ConnectInterceptor</code> 用来建立连接的拦截器；<br>6、<code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ；<br>7、<code>CallServerInterceptor</code>是真正向服务器发出请求且得到响应的拦截器；</p><p>最后在聚合了这些拦截器后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器，利用的就是 <strong>责任链模式</strong> 。</p><font font="" size="3" color="#FF0000"> 下面介绍 OkHttp 中的 拦截器 </font><p>拦截器 <code>Interceptor</code> 是 OkHttp 的核心，<strong>实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来</strong>，每一个功能都只是一个 <code>Interceptor</code>，它们再连接成一个 <code>Interceptor.Chain</code>，环环相扣，最终圆满完成一次网络请求。</p><div align="center">     <img src="https://img.wshunli.com/Android/OkHttp/okhttp_interceptors.jpg" title="OkHttp 拦截器" alt="OkHttp 拦截器"></div><p>1、<code>RealInterceptorChain</code> 拦截器链</p><p>拦截器链 <code>RealInterceptorChain</code> 是真正把这些拦截器串起来的一个角色，调用 <code>proceed()</code> 方法</p><pre><code class="lang-Java">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,    RealConnection connection) throws IOException {  if (index &gt;= interceptors.size()) throw new AssertionError();  calls++;  // If we already have a stream, confirm that the incoming request will use it.  if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must retain the same host and port&quot;);  }  // If we already have a stream, confirm that this is the only call to chain.proceed().  if (this.httpCodec != null &amp;&amp; calls &gt; 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must call proceed() exactly once&quot;);  }  // Call the next interceptor in the chain.  // 得到下一次对应的 RealInterceptorChain  RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,      connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,      writeTimeout);  // 当前次数的 interceptor  Interceptor interceptor = interceptors.get(index);  // 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法  Response response = interceptor.intercept(next);  // Confirm that the next interceptor made its required call to chain.proceed().  // 确认下一次的 interceptor 调用过 chain.proceed()  if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptor        + &quot; must call proceed() exactly once&quot;);  }  // Confirm that the intercepted response isn&#39;t null.  if (response == null) {    throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);  }  if (response.body() == null) {    throw new IllegalStateException(        &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);  }  return response;}</code></pre><p>在代码中是一次次链式调用拦截器。</p><p>2、<code>RetryAndFollowUpInterceptor</code> 重试和重定向的拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request request = chain.request();  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Call call = realChain.call();  EventListener eventListener = realChain.eventListener();  StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),      createAddress(request.url()), call, eventListener, callStackTrace);  this.streamAllocation = streamAllocation;  int followUpCount = 0;  Response priorResponse = null;  while (true) {    // 如果取消，就释放资源    if (canceled) {      streamAllocation.release();      throw new IOException(&quot;Canceled&quot;);    }    Response response;    boolean releaseConnection = true;    try {      // 调用下一个拦截器      response = realChain.proceed(request, streamAllocation, null, null);      releaseConnection = false;    } catch (RouteException e) {      // The attempt to connect via a route failed. The request will not have been sent.      // 路由连接失败，请求将不会被发送      if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {        throw e.getFirstConnectException();      }      releaseConnection = false;      continue;    } catch (IOException e) {      // An attempt to communicate with a server failed. The request may have been sent.      // 服务器连接失败，请求可能已被发送      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);      if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;      releaseConnection = false;      continue;    } finally {      // We&#39;re throwing an unchecked exception. Release any resources.      // 抛出未检查的异常，释放资源      if (releaseConnection) {        streamAllocation.streamFailed(null);        streamAllocation.release();      }    }    // Attach the prior response if it exists. Such responses never have a body.    if (priorResponse != null) {      response = response.newBuilder()          .priorResponse(priorResponse.newBuilder()                  .body(null)                  .build())          .build();    }    // 如果不需要重定向，那么 followUp 为空，会根据响应码判断    Request followUp;    try {      followUp = followUpRequest(response, streamAllocation.route());    } catch (IOException e) {      streamAllocation.release();      throw e;    }    // 释放资源，返回 response    if (followUp == null) {      if (!forWebSocket) {        streamAllocation.release();      }      return response;    }    // 关闭 response 的 body    closeQuietly(response.body());    if (++followUpCount &gt; MAX_FOLLOW_UPS) {      streamAllocation.release();      throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);    }    if (followUp.body() instanceof UnrepeatableRequestBody) {      streamAllocation.release();      throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());    }    // response 和 followUp 比较是否为同一个连接    // 若为重定向就销毁旧连接，创建新连接    if (!sameConnection(response, followUp.url())) {      streamAllocation.release();      streamAllocation = new StreamAllocation(client.connectionPool(),          createAddress(followUp.url()), call, eventListener, callStackTrace);      this.streamAllocation = streamAllocation;    } else if (streamAllocation.codec() != null) {      throw new IllegalStateException(&quot;Closing the body of &quot; + response          + &quot; didn&#39;t close its backing stream. Bad interceptor?&quot;);    }    // 将重定向操作得到的新请求设置给 request    request = followUp;    priorResponse = response;  }}</code></pre><p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p><p>3、<code>BridgeInterceptor</code> 桥街和适配拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request userRequest = chain.request();  Request.Builder requestBuilder = userRequest.newBuilder();  // 将用户友好的 request 构造为发送给服务器的 request  RequestBody body = userRequest.body();  // 若有请求体，则构造  if (body != null) {    MediaType contentType = body.contentType();    if (contentType != null) {      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());    }    long contentLength = body.contentLength();    if (contentLength != -1) {      requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);    } else {      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);      requestBuilder.removeHeader(&quot;Content-Length&quot;);    }  }  if (userRequest.header(&quot;Host&quot;) == null) {    requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));  }  if (userRequest.header(&quot;Connection&quot;) == null) {    requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);  }  // If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing  // the transfer stream.  // 使用 gzip 压缩  boolean transparentGzip = false;  if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {    transparentGzip = true;    requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);  }  // 设置 cookie  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());  if (!cookies.isEmpty()) {    requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));  }  // 设置 UA  if (userRequest.header(&quot;User-Agent&quot;) == null) {    requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());  }  // 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse  Response networkResponse = chain.proceed(requestBuilder.build());  // 保存 networkResponse 的 cookie  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());  // 将 networkResponse 构造为对用户友好的 response  Response.Builder responseBuilder = networkResponse.newBuilder()      .request(userRequest);  // 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体  if (transparentGzip      &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))      &amp;&amp; HttpHeaders.hasBody(networkResponse)) {    GzipSource responseBody = new GzipSource(networkResponse.body().source());    Headers strippedHeaders = networkResponse.headers().newBuilder()        .removeAll(&quot;Content-Encoding&quot;)        .removeAll(&quot;Content-Length&quot;)        .build();    responseBuilder.headers(strippedHeaders);    String contentType = networkResponse.header(&quot;Content-Type&quot;);    responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));  }  return responseBuilder.build();}</code></pre><p>在 <code>BridgeInterceptor</code> 这一步，先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</p><p>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</p><p>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</p><p>4、<code>CacheInterceptor</code> 缓存拦截器</p><p>分析 <code>CacheInterceptor</code> 拦截器 <code>intercept()</code> 方法的源代码</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {    // 得到 request 对应缓存中的 response    Response cacheCandidate = cache != null            ? cache.get(chain.request())            : null;    // 获取当前时间，会和之前缓存的时间进行比较    long now = System.currentTimeMillis();    // 得到缓存策略    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();    Request networkRequest = strategy.networkRequest;    Response cacheResponse = strategy.cacheResponse;    // 追踪缓存，其实就是计数    if (cache != null) {        cache.trackResponse(strategy);    }    // 缓存不适用，关闭    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&#39;t applicable. Close it.    }    // If we&#39;re forbidden from using the network and the cache is insufficient, fail.    // 禁止网络并且没有缓存的话，返回失败    if (networkRequest == null &amp;&amp; cacheResponse == null) {        return new Response.Builder()                .request(chain.request())                .protocol(Protocol.HTTP_1_1)                .code(504)                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)                .body(Util.EMPTY_RESPONSE)                .sentRequestAtMillis(-1L)                .receivedResponseAtMillis(System.currentTimeMillis())                .build();    }    // If we don&#39;t need the network, we&#39;re done.    // 不用网络请求，返回缓存    if (networkRequest == null) {        return cacheResponse.newBuilder()                .cacheResponse(stripBody(cacheResponse))                .build();    }    Response networkResponse = null;    try {        // 交给下一个拦截器，返回 networkResponse        networkResponse = chain.proceed(networkRequest);    } finally {        // If we&#39;re crashing on I/O or otherwise, don&#39;t leak the cache body.        if (networkResponse == null &amp;&amp; cacheCandidate != null) {            closeQuietly(cacheCandidate.body());        }    }    // 如果我们同时有缓存和 networkResponse ，根据情况使用    if (cacheResponse != null) {        if (networkResponse.code() == HTTP_NOT_MODIFIED) {            Response response = cacheResponse.newBuilder()                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())                    .cacheResponse(stripBody(cacheResponse))                    .networkResponse(stripBody(networkResponse))                    .build();            networkResponse.body().close();            // 更新原来的缓存至最新            // Update the cache after combining headers but before stripping the            // Content-Encoding header (as performed by initContentStream()).            cache.trackConditionalCacheHit();            cache.update(cacheResponse, response);            return response;        } else {            closeQuietly(cacheResponse.body());        }    }    Response response = networkResponse.newBuilder()            .cacheResponse(stripBody(cacheResponse))            .networkResponse(stripBody(networkResponse))            .build();    // 保存之前未缓存的缓存    if (cache != null) {        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {            // Offer this request to the cache.            CacheRequest cacheRequest = cache.put(response);            return cacheWritingResponse(cacheRequest, response);        }        if (HttpMethod.invalidatesCache(networkRequest.method())) {            try {                cache.remove(networkRequest);            } catch (IOException ignored) {                // The cache cannot be written.            }        }    }    return response;}</code></pre><p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p><p>5、<code>ConnectInterceptor</code> 拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Request request = realChain.request();  StreamAllocation streamAllocation = realChain.streamAllocation();  // We need the network to satisfy this request. Possibly for validating a conditional GET.  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);  HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);  RealConnection connection = streamAllocation.connection();  return realChain.proceed(request, streamAllocation, httpCodec, connection);}</code></pre><p>实际上建立连接就是创建了一个 <code>HttpCodec</code> 对象，它是对 <code>HTTP</code> 协议操作的抽象，有两个实现：<code>Http1Codec</code> 和 <code>Http2Codec</code>，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。</p><p>6、<code>CallServerInterceptor</code> 拦截器，发送和接收数据</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  HttpCodec httpCodec = realChain.httpStream();  StreamAllocation streamAllocation = realChain.streamAllocation();  RealConnection connection = (RealConnection) realChain.connection();  Request request = realChain.request();      long sentRequestMillis = System.currentTimeMillis();  // 整理请求头并写入  httpCodec.writeRequestHeaders(request);  Response.Builder responseBuilder = null;  // 检查是否为有 body 的请求方法  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {      // If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100      // Continue&quot; response before transmitting the request body. If we don&#39;t get that, return what      // we did get (such as a 4xx response) without ever transmitting the request body.      // 如果有 Expect: 100-continue 在请求头中，那么要等服务器的响应      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {          httpCodec.flushRequest();          responseBuilder = httpCodec.readResponseHeaders(true);      }      if (responseBuilder == null) {          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.          // 写入请求体          Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);          request.body().writeTo(bufferedRequestBody);          bufferedRequestBody.close();      } else if (!connection.isMultiplexed()) {          // If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP/1 connection from          // being reused. Otherwise we&#39;re still obligated to transmit the request body to leave the          // connection in a consistent state.          streamAllocation.noNewStreams();      }  }  httpCodec.finishRequest();  // 得到响应头  if (responseBuilder == null) {      responseBuilder = httpCodec.readResponseHeaders(false);  }  // 构造 response  Response response = responseBuilder          .request(request)          .handshake(streamAllocation.connection().handshake())          .sentRequestAtMillis(sentRequestMillis)          .receivedResponseAtMillis(System.currentTimeMillis())          .build();  int code = response.code();  // 如果为 web socket 且状态码是 101 ，那么 body 为空  if (forWebSocket &amp;&amp; code == 101) {      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.      response = response.newBuilder()              .body(Util.EMPTY_RESPONSE)              .build();  } else {      // 读取 body      response = response.newBuilder()              .body(httpCodec.openResponseBody(response))              .build();  }  // 如果请求头中有 close 那么断开连接  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))          || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {      streamAllocation.noNewStreams();  }  // 抛出协议异常  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {      throw new ProtocolException(              &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());  }  return response;}</code></pre><p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>和同步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {    }});</code></pre><p>异步请求在 <code>Callback</code> 回调中获取响应，有 <code>onResponse()</code> 、 <code>onFailure()</code> 两个方法。</p><h3 id="发送异步网络请求"><a href="#发送异步网络请求" class="headerlink" title="发送异步网络请求"></a>发送异步网络请求</h3><p>前面三个步骤完全一致，我们从发送异步网络请求开始，异步请求是调用 <code>RealCall</code> 实例的 <code>enqueue()</code> 方法。。</p><pre><code class="lang-Java">// RealCall#enqueue()@Override public void enqueue(Callback responseCallback) {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  client.dispatcher().enqueue(new AsyncCall(responseCallback));}</code></pre><p>这里使用 <code>Dispatcher</code> 分发器我来处理请求。</p><pre><code class="lang-Java">// Dispatcher#enqueue()synchronized void enqueue(AsyncCall call) {  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {    runningAsyncCalls.add(call);    executorService().execute(call);  } else {    readyAsyncCalls.add(call);  }}</code></pre><p>实质上异步网络请求是在 <code>Dispatcher</code> 中做到任务调度。</p><font font="" size="3" color="#FF0000">下面介绍 OkHttp 中的 任务调度</font><p>我们来看 <code>Dispatcher</code> 类的源代码。 </p><pre><code class="lang-Java">public final class Dispatcher {  private int maxRequests = 64;  private int maxRequestsPerHost = 5;  private @Nullable Runnable idleCallback;  /** Executes calls. Created lazily. */  // 线程池的实现  private @Nullable ExecutorService executorService;  /** Ready async calls in the order they&#39;ll be run. */  // 就绪等待网络请求的异步队列  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running asynchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的异步队列  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running synchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的同步队列  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();  public Dispatcher(ExecutorService executorService) {    this.executorService = executorService;  }  public Dispatcher() {  }  // 创建线程池  public synchronized ExecutorService executorService() {    if (executorService == null) {      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));    }    return executorService;  }  /* 省略部分无关代码*/  synchronized void enqueue(AsyncCall call) {    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {      runningAsyncCalls.add(call);      executorService().execute(call);    } else {      readyAsyncCalls.add(call);    }  }  /* 省略部分无关代码*/}</code></pre><p>异步请求是放在线程池中执行的，如果最大异步请求数小于 64 并且 单个 HOST 的异步请求数小于 5 ，将请求添加到 <code>runningAsyncCalls</code> 中，否则添加到 <code>readyAsyncCalls</code> 中。</p><p>我们来看添加进线程池的 <code>AsyncCall</code> 类，实际上 <code>AsyncCall</code> 是继承自 <code>NamedRunnable</code> 的 <code>RealCall</code> 内部类。<code>NamedRunnable</code> 是实现了 <code>Runnable</code> 接口的抽象类。</p><pre><code class="lang-Java">final class AsyncCall extends NamedRunnable {  private final Callback responseCallback;  AsyncCall(Callback responseCallback) {    super(&quot;OkHttp %s&quot;, redactedUrl());    this.responseCallback = responseCallback;  }  String host() {    return originalRequest.url().host();  }  Request request() {    return originalRequest;  }  RealCall get() {    return RealCall.this;  }  @Override protected void execute() {    boolean signalledCallback = false;    try {      // 和同步请求相同，调用拦截器，得到响应      Response response = getResponseWithInterceptorChain();      if (retryAndFollowUpInterceptor.isCanceled()) {        signalledCallback = true;        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));      } else {        signalledCallback = true;        responseCallback.onResponse(RealCall.this, response);      }    } catch (IOException e) {      if (signalledCallback) {        // Do not signal the callback twice!        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);      } else {        eventListener.callFailed(RealCall.this, e);        responseCallback.onFailure(RealCall.this, e);      }    } finally {      // 在 runningAsyncCalls 中移除      client.dispatcher().finished(this);    }  }}</code></pre><p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p><p>不同的是在得到 <code>Response</code> 后，进行结果的回调。</p><p>在 <code>AsyncCall</code> 的最后调用了 <code>Dispatcher</code> 的 <code>finished()</code> 方法。</p><pre><code class="lang-Java">// Dispatcher#finished()/** Used by {@code AsyncCall#run} to signal completion. */void finished(AsyncCall call) {  finished(runningAsyncCalls, call, true);}/** Used by {@code Call#execute} to signal completion. */void finished(RealCall call) {  finished(runningSyncCalls, call, false);}private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) {  int runningCallsCount;  Runnable idleCallback;  synchronized (this) {    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#39;t in-flight!&quot;);    // 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中    if (promoteCalls) promoteCalls();    runningCallsCount = runningCallsCount();    idleCallback = this.idleCallback;  }  if (runningCallsCount == 0 &amp;&amp; idleCallback != null) {    idleCallback.run();  }}</code></pre><p>这里所做的工作就是把执行过的 Call 移除，然后将 <code>readyAsyncCalls</code> 中的 Call 移动到 <code>runningAsyncCalls</code> 中并加入线程池中。</p><blockquote><p>基本上 OkHttp 的请求响应的流程就介绍完了，主要是关于 OkHttp 的 <strong>拦截器链</strong> 和 <strong>任务调度</strong> 原理。</p></blockquote><p>还有很多细节没有涉及，需要花费很大的精力，才能理解分析透彻，后面有机会再介绍。</p><blockquote><p>参考资料：<br>1、拆轮子系列：拆 OkHttp - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/07/11/Understand-OkHttp/</a><br>2、OkHttp源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="http://yuqirong.me/2017/07/25/OkHttp源码解析/" rel="external nofollow noopener noreferrer" target="_blank">http://yuqirong.me/2017/07/25/OkHttp源码解析/</a><br>3、OkHttp源码分析 - 掘金<br><a href="https://juejin.im/post/5af4482951882567286064e6" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5af4482951882567286064e6</a><br>4、okhttp源码分析（一）——基本流程（超详细） - 简书<br><a href="https://www.jianshu.com/p/37e26f4ea57b" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/37e26f4ea57b</a><br>5、OKHttp源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/03/12/android-okhttp/</a><br>6、OkHttp 源码解析（一）：基本流程 - Coding - SegmentFault 思否<br><a href="https://segmentfault.com/a/1190000012656606" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000012656606</a><br>7、【Android】OkHttp源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79175824" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79175824</a><br>8、深入浅出 OkHttp 源码 - DiyCode<br><a href="https://www.diycode.cc/topics/640" rel="external nofollow noopener noreferrer" target="_blank">https://www.diycode.cc/topics/640</a><br>9、Okhttp框架源码分析 - 简书<br><a href="https://www.jianshu.com/p/18a4861600d1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/18a4861600d1</a><br>10、OkHttp 3.7源码分析（一）——整体架构 - CSDN博客<br><a href="https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320</a><br>11、okhttp网络框架源码解析 - CSDN博客<br><a href="https://blog.csdn.net/fanguangjun123/article/details/78621585" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/fanguangjun123/article/details/78621585</a><br>12、OKHttp网络框架源码解析（一）okHttp框架同步异步请求流程和源码分析 - CSDN博客<br><a href="https://blog.csdn.net/qq_24675479/article/details/79483193" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_24675479/article/details/79483193</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 OkHttp 3.11.0 版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。&lt;/p&gt;
&lt;p&gt;只是停留在
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
      <category term="OkHttp" scheme="https://www.wshunli.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》编程题目 Java 实现（01-10）</title>
    <link href="https://www.wshunli.com/posts/25842bb5.html"/>
    <id>https://www.wshunli.com/posts/25842bb5.html</id>
    <published>2018-09-11T13:07:05.000Z</published>
    <updated>2018-09-23T10:41:06.429Z</updated>
    
    <content type="html"><![CDATA[<p>《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。</p><p>笔试中的重要性不必多说，面试官还总是喜欢让手写代码。</p><p>1、赋值运算函数</p><p>2、单例设计模式</p><p>在设计模式中有详细的介绍，这里不再赘述，请移步：</p><p><a href="https://www.wshunli.com/posts/d1c4534.html">https://www.wshunli.com/posts/d1c4534.html</a></p><p>3、二维数组中查找目标值</p><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>（1）直接暴力查找</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    for (int[] anArray : array) {        for (int anAnArray : anArray) {            if (anAnArray == target) return true;        }    }    return false;}</code></pre><p>（2）从右上角/左下角的元素出发</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    int row = array.length;    int col = array[0].length;    for (int i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0; ) {        int value = array[i][j];        if (value == target) return true;        if (value &lt; target) i++;        if (value &gt; target) j--;    }    return false;}</code></pre><p>4、替换字符串中的空格</p><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成 “%20” 。</p></blockquote><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;);}</code></pre><p>这个太偷懒了，不那么偷懒：</p><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    StringBuilder builder = new StringBuilder();    String string = str.toString();    for (int i = 0; i &lt; string.length(); i++) {        char charAt = string.charAt(i);        if (charAt == &#39; &#39;) {            builder.append(&quot;%20&quot;);        } else {            builder.append(charAt);        }    }    return builder.toString();}</code></pre><p>5、从尾到头打印链表</p><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList 。</p></blockquote><p>（1）借助堆栈的“后进先出”实现</p><pre><code class="lang-Java">/***    public class ListNode {*        int val;*        ListNode next = null;*        ListNode(int val) {*            this.val = val;*        }*    }*/public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    Stack&lt;Integer&gt; integers = new Stack&lt;&gt;();    while (listNode != null) {        integers.push(listNode.val);        listNode = listNode.next;    }    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (!integers.isEmpty()) {        arrayList.add(integers.pop());    }    return arrayList;}</code></pre><p>（2）借助递归实现</p><pre><code class="lang-Java">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    if (listNode != null) {        this.printListFromTailToHead(listNode.next);        arrayList.add(listNode.val);    }    return arrayList;}</code></pre><p>（3）使用 Collections 的 reverse 方法</p><pre><code class="lang-Java">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (listNode != null) {        arrayList.add(listNode.val);        listNode = listNode.next;    }    Collections.reverse(arrayList);    return arrayList;}</code></pre><p>6、由前序和中序遍历重建二叉树</p><p>7、用两个栈实现队列<br>8、求旋转数组的最小数字<br>9、斐波那契数列的第n项（青蛙跳台阶）<br>10、二进制中1的个数<br>11、数值的整数次方<br>12、打印1到最大的n位数<br>13、O(1)时间删除链表节点<br>14、使数组中的奇数位于偶数前面<br>15、找链表中倒数第K个节点<br>16、输出反转后的链表<br>17、合并两个有序链表<br>18、判断二叉树A中是否包含子树B<br>19、二叉树的镜像<br>20、顺时针打印矩阵<br>21、包含min函数的栈<br>22、判断一个栈是否是另一个栈的弹出序列<br>23、层序遍历二叉树<br>24、后序遍历二叉搜索树<br>25、二叉树中和为某值的路径<br>26、复杂链表的复制<br>27、二叉搜索树转换为双向链表<br>28、打印字符串中所有字符的排列<br>29、数组中出现次数超过一半的数字<br>30、找出最小的K个数<br>31、连续子数组的最大和<br>32、从1到整数n中1出现的次数<br>33、把数组中的数排成一个最小的数<br>34、求第N个丑数<br>35、第一个出现一次的字符<br>36、数组中逆序对的个数<br>37、两个链表的第一个公共节点<br>38、数字在排序数组中出现的次数<br>39、二叉树的深度<br>40、数组中只出现一次的两个数，而其他数都出现两次。<br>41、和为s的连续整数序列<br>42、翻转字符串<br>43、n个骰子的点数及出现的概率44. 扑克牌的顺子<br>44、圆圈中最后剩下的数<br>45、1+2+3+…+n的和<br>46、不用加减乘除做加法<br>47、不能被继承的类<br>48、字符串转换为整数<br>49、树中两个节点的最低公共祖先<br>50、找出重复的数<br>51、构建乘积数组<br>52、正则表达式匹配<br>53、表示数值的字符串<br>54、字符流中第一个不重复的字符<br>55、链表中环的入口节点<br>56、删除链表中重复的节点<br>57、二叉树的下一个节点<br>58、对称的二叉树<br>59、按之字形顺序打印二叉树<br>60、把二叉树打印成多行<br>61、序列化二叉树<br>62、二叉搜索树的第K个节点<br>63、数据流中的中位数<br>64、滑动窗口的最大值<br>65、矩阵中的路径<br>66、机器人的运动范围</p><blockquote><p>参考资料<br>1、剑指Offer<em>编程题</em>牛客网<br><a href="https://www.nowcoder.com/ta/coding-interviews" rel="external nofollow noopener noreferrer" target="_blank">https://www.nowcoder.com/ta/coding-interviews</a><br>2、【剑指offer】Java版代码（完整版） - CSDN博客<br><a href="https://blog.csdn.net/baiye_xing/article/details/78428561" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/baiye_xing/article/details/78428561</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。&lt;/p&gt;
&lt;p&gt;笔试中的重要性不必多说，面试官还总是喜欢让手写代码。&lt;/p&gt;
&lt;p&gt;1、赋值运算函数&lt;/p&gt;
&lt;p&gt;2、单例设计模式&lt;/p&gt;
&lt;p&gt;在设计模式中有详细的介绍，这里不再赘
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指Offer》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十四）观察者模式</title>
    <link href="https://www.wshunli.com/posts/58b1d741.html"/>
    <id>https://www.wshunli.com/posts/58b1d741.html</id>
    <published>2018-09-10T12:19:14.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/14.Observer.png" title="观察者模式" alt="观察者模式"></div><p>观察者模式所涉及的角色有：</p><p>(1) 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>(2) 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>(3) 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>(4) 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers(String newState) {        for (Observer observer : list) {            observer.update(newState);        }    }}</code></pre><p>2、具体主题角色类</p><pre><code class="lang-Java">public class ConcreteSubject extends Subject {    private String state;    public String getState() {        return state;    }    public void change(String newState) {        state = newState;        System.out.println(&quot;ConcreteSubject：&quot; + state);        this.nodifyObservers(state);//状态发生改变，通知各个观察者    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(String state);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    private String observerState;//观察者的状态    @Override    public void update(String state) {        /**         * 更新观察者的状态，使其与目标的状态保持一致         */        observerState = state;        System.out.println(&quot;ConcreteObserver：&quot; + observerState);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p>当主题对象的状态改变时，将通知所有观察者，观察者接收到主题对象的通知后，将可以进行其他操作，进行响应。</p><p><strong>推模型和拉模型</strong>：</p><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><p>（1）推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><p>（2）拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把 <strong>主题对象自身</strong> 通过 update() 方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><p>前面就是典型的推模型，下面介绍拉模型。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers() {        for (Observer observer : list) {            observer.update(this);        }    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(Subject subject);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    @Override    public void update(Subject subject) {        String state = ((ConcreteSubject) subject).getState();        System.out.println(&quot;ConcreteObserver：&quot; + state);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p><strong>两种模式的比较</strong>：</p><p>（1）推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</p><p>（2）推模型可能会使得观察者对象难以复用，因为观察者的 update() 方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的 update() 方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update() 方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p><p><strong>观察者模式的优缺点</strong>：</p><p>优点：观察者和被观察者是抽象耦合的；建立一套触发机制。<br>缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch14" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch14</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之观察者模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十三）享元模式</title>
    <link href="https://www.wshunli.com/posts/180f2df5.html"/>
    <id>https://www.wshunli.com/posts/180f2df5.html</id>
    <published>2018-09-10T10:43:03.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/13.Flyweight.png" title="享元模式" alt="享元模式"></div><p>享元模式所涉及到的角色如下：</p><p>(1) 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p><p>(2) 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p><p>(3) 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p><p>1、创建一个接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、创建实现接口的实体类</p><pre><code class="lang-Java">public class Circle implements Shape {    private String color;    private int x;    private int y;    private int radius;    public Circle(String color) {        this.color = color;    }    public void setX(int x) {        this.x = x;    }    public void setY(int y) {        this.y = y;    }    public void setRadius(int radius) {        this.radius = radius;    }    @Override    public void draw() {        System.out.println(&quot;Circle: Draw() [Color : &quot; + color                + &quot;, x : &quot; + x + &quot;, y :&quot; + y + &quot;, radius :&quot; + radius);    }}</code></pre><p>3、创建一个工厂，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();    public static Shape getCircle(String color) {        Circle circle = (Circle) circleMap.get(color);        if (circle == null) {            circle = new Circle(color);            circleMap.put(color, circle);            System.out.println(&quot;Creating circle of color : &quot; + color);        }        return circle;    }}</code></pre><p>4、享元模式的使用</p><pre><code class="lang-Java">public class FlyweightPatternMain {    private static final String colors[] =            {&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot;};    public static void main(String[] args) {        for (int i = 0; i &lt; 20; ++i) {            Circle circle =                    (Circle) ShapeFactory.getCircle(getRandomColor());            circle.setX(getRandomX());            circle.setY(getRandomY());            circle.setRadius(100);            circle.draw();        }    }    private static String getRandomColor() {        return colors[(int) (Math.random() * colors.length)];    }    private static int getRandomX() {        return (int) (Math.random() * 100);    }    private static int getRandomY() {        return (int) (Math.random() * 100);    }}</code></pre><p><strong>享元模式的优缺点</strong>：</p><p>优点：系统有大量相似对象；需要缓冲池的场景。<br>缺点：注意划分外部状态和内部状态，否则可能会引起线程安全问题，这些类必须有一个工厂对象加以控制。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch13" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch13</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之享元模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html</a><br>2、设计模式读书笔记——享元模式 - chenssy - 博客园<br><a href="https://www.cnblogs.com/chenssy/p/3330555.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chenssy/p/3330555.html</a><br>3、享元模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/flyweight-pattern.html</a><br>4、JAVA设计模式-享元模式（Flyweight） - 简书<br><a href="https://www.jianshu.com/p/f88b903a166a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f88b903a166a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;
&lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;h
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十二）桥接模式</title>
    <link href="https://www.wshunli.com/posts/f75ecf9a.html"/>
    <id>https://www.wshunli.com/posts/f75ecf9a.html</id>
    <published>2018-09-10T09:09:30.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/12.Bridge.png" title="桥接模式" alt="桥接模式"></div><p>桥接模式包含如下角色：</p><p>(1) Abstraction：抽象类，抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。Shape<br>(2) RefinedAbstraction：扩充抽象类，扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。Circle<br>(3) Implementor：实现类接口，定义实现部分的接口，这个接口不用和 Abstraction 里面的方法一致，通常是由 Implementor 接口提供基本的操作，而 Abstraction 里面定义的是基于这些基本操作的业务方法，也就是说 Abstraction 定义了基于这些基本操作的较高层次的操作。DrawAPI<br>(4) ConcreteImplementor：具体实现类，真正实现 Implementor 接口的对象。GreenCircle、RedCircle</p><p>1、创建桥接实现接口</p><pre><code class="lang-Java">public interface DrawAPI {    void drawCircle(int radius, int x, int y);}</code></pre><p>2、创建实现了 DrawAPI 接口的实体桥接实现类</p><pre><code class="lang-Java">public class GreenCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}public class RedCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}</code></pre><p>3、使用 DrawAPI 接口创建抽象类 Shape</p><pre><code class="lang-Java">public abstract class Shape {    protected DrawAPI drawAPI;    protected Shape(DrawAPI drawAPI) {        this.drawAPI = drawAPI;    }    public abstract void draw();}</code></pre><p>4、创建实现了 Shape 接口的实体类</p><pre><code class="lang-Java">public class Circle extends Shape {    private int x, y, radius;    public Circle(DrawAPI drawAPI, int x, int y, int radius) {        super(drawAPI);        this.x = x;        this.y = y;        this.radius = radius;    }    @Override    public void draw() {        drawAPI.drawCircle(radius, x, y);    }}</code></pre><p>5、使用 Shape 和 DrawAPI 类画出不同颜色的圆</p><pre><code class="lang-Java">public class BridgePatternMain {    public static void main(String[] args) {        Shape redCircle = new Circle(new RedCircle(), 100, 100, 10);        Shape greenCircle = new Circle(new GreenCircle(), 100, 100, 10);        redCircle.draw();        greenCircle.draw();    }}</code></pre><p><strong>桥接模式的优缺点</strong>：</p><p>优点：抽象和实现的分离；优秀的扩展能力；实现细节对客户透明。<br>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch12" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch12</a></p><blockquote><p>参考资料<br>1、Java设计模式之十五（桥接模式） - CSDN博客<br><a href="https://blog.csdn.net/shaopeng5211/article/details/8827507" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/shaopeng5211/article/details/8827507</a><br>2、JAVA设计模式之 桥接模式【Bridge Pattern】 - CSDN博客<br><a href="https://blog.csdn.net/janice0529/article/details/44102637" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/janice0529/article/details/44102637</a><br>3、java中的桥接模式 - 简书<br><a href="https://www.jianshu.com/p/c71562c98258" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c71562c98258</a><br>4、讲故事，学（Java）设计模式—桥接模式 - ImportNew<br><a href="http://www.importnew.com/6857.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.importnew.com/6857.html</a><br>5、桥接模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/bridge-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/bridge-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。&lt;/p&gt;
&lt;h1 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十一）组合模式</title>
    <link href="https://www.wshunli.com/posts/fb6e1df3.html"/>
    <id>https://www.wshunli.com/posts/fb6e1df3.html</id>
    <published>2018-09-10T08:40:17.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/11.Composite.png" title="组合模式" alt="组合模式"></div><p>组合模式的包含角色：</p><p>(1) Component 抽象构件角色，定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>(2) Leaf 叶子构件，叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>(3) Composite 树枝构件，树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</p><p>1、抽象构件角色</p><pre><code class="lang-Java">public abstract class Component {    public void operation() {        System.out.println(&quot;Component.operation()&quot;);    }}</code></pre><p>2、树枝构件</p><pre><code class="lang-Java">public class Composite extends Component {    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;&gt;();    public void add(Component component) {        componentArrayList.add(component);    }    public void remove(Component component) {        componentArrayList.remove(component);    }    public ArrayList&lt;Component&gt; getChildren() {        return this.componentArrayList;    }}</code></pre><p>3、树叶构件</p><pre><code class="lang-Java">public class Leaf extends Component {    @Override    public void operation() {        System.out.println(&quot;Leaf.operation()&quot;);    }}</code></pre><p>4、组合模式的使用</p><pre><code class="lang-Java">public class CompositeMain {    public static void main(String[] args) {        Composite root = new Composite();        root.operation();        Composite branch = new Composite();        root.add(branch);        Leaf leaf1 = new Leaf();        Leaf leaf2 = new Leaf();        branch.add(leaf1);        branch.add(leaf2);        display(root);    }    public static void display(Composite root) {        for (Component component : root.getChildren()) {            if (component instanceof Leaf) {                component.operation();            } else {                display((Composite) component);            }        }    }}</code></pre><p><strong>组合模式的优缺点</strong>：</p><p>优点：高层模块调用简单；节点自由增加。<br>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch11" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch11</a></p><blockquote><p>参考资料<br>1、JAVA设计模式十七—Composite(组合模式) - CSDN博客<br><a href="https://blog.csdn.net/hfmbook/article/details/7693069" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hfmbook/article/details/7693069</a><br>2、Java设计模式—组合模式 - CSDN博客<br><a href="https://blog.csdn.net/qq_25827845/article/details/52496522" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_25827845/article/details/52496522</a><br>3、组合模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/composite-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/composite-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。&lt;/p&gt;
&lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十）代理模式</title>
    <link href="https://www.wshunli.com/posts/b4b3761.html"/>
    <id>https://www.wshunli.com/posts/b4b3761.html</id>
    <published>2018-09-10T08:12:52.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p>代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/10.Proxy.png" title="代理模式" alt="代理模式"></div><p>代理模式一般涉及到的角色有：</p><p>(1) 抽象角色：声明真实对象和代理对象的共同接口；<br>(2) 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装；<br>(3) 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p><p>1、抽象对象角色</p><pre><code class="lang-Java">public abstract class AbstractObject {    public abstract void operation();}</code></pre><p>2、目标对象角色</p><pre><code class="lang-Java">public class RealObject extends AbstractObject {    @Override    public void operation() {        System.out.println(&quot;RealObject.operation()&quot;);    }}</code></pre><p>3、代理对象角色</p><pre><code class="lang-Java">public class ProxyObject extends AbstractObject {    RealObject realObject = new RealObject();    @Override    public void operation() {        //调用目标对象之前可以做相关操作        System.out.println(&quot;before&quot;);        realObject.operation();        //调用目标对象之后可以做相关操作        System.out.println(&quot;after&quot;);    }}</code></pre><p>4、代理模式的使用</p><pre><code class="lang-Java">public class ProxyMain {    public static void main(String[] args) {        AbstractObject object = new ProxyObject();        object.operation();    }}</code></pre><p><strong>代理模式的优缺点</strong>：</p><p>优点：给对象增加了本地化的扩展性，增加了存取操作控制。<br>缺点：会产生多余的代理类。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch10" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch10</a></p><blockquote><p>参考资料<br>1、Java设计模式之代理模式(Proxy) - CSDN博客<br><a href="https://blog.csdn.net/liangbinny/article/details/18656791" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/liangbinny/article/details/18656791</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。&lt;/p&gt;
&lt;p&gt;代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。&lt;/p&gt;
&lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（九）装饰者模式</title>
    <link href="https://www.wshunli.com/posts/d95b685e.html"/>
    <id>https://www.wshunli.com/posts/d95b685e.html</id>
    <published>2018-09-10T06:37:20.000Z</published>
    <updated>2018-09-23T10:41:06.421Z</updated>
    
    <content type="html"><![CDATA[<p>装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>动态的给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/9.Decorator.png" title="装饰者模式" alt="装饰者模式"></div><p>一般来说装饰者模式有下面几个参与者：</p><p>(1) Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为。<br>(2) ConcreteComponent：定义具体对象，即被装饰者。<br>(3) Decorator：抽象装饰者，继承自 Component ，从外类来扩展 ConcreteComponent 。对于 ConcreteComponent 来说，不需要知道 Decorator 的存在，Decorator 是一个接口或抽象类<br>(4) ConcreteDecorator：具体装饰者，用于扩展 ConcreteComponent 。</p><p>1、抽象构件角色 Component</p><pre><code class="lang-Java">public interface Component {    public void sampleOperation();}</code></pre><p>2、具体构件角色 ConcreteComponent</p><pre><code class="lang-Java">public class ConcreteComponent implements Component {    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteComponent.sampleOperation()&quot;);    }}</code></pre><p>3、装饰角色 Decorator</p><pre><code class="lang-Java">public class Decorator implements Component {    Component component;    public Decorator(Component component) {        this.component = component;    }    @Override    public void sampleOperation() {        // 委派给构件        component.sampleOperation();    }}</code></pre><p>4、具体装饰角色 ConcreteDecorator</p><pre><code class="lang-Java">public class ConcreteDecoratorA extends Decorator {    public ConcreteDecoratorA(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() end&quot;);    }}public class ConcreteDecoratorB extends Decorator {    public ConcreteDecoratorB(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() end&quot;);    }}</code></pre><p>5、装饰者模式的使用</p><pre><code class="lang-Java">public class DecoratorMain {    public static void main(String[] args) {        ConcreteComponent concreteComponent = new ConcreteComponent();        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);        concreteDecoratorA.sampleOperation();        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteComponent);        concreteDecoratorB.sampleOperation();    }}</code></pre><p><strong>装饰者模式的优缺点</strong>：</p><p>优点：装饰模式可以提供比继承更多的灵活性；通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>缺点：使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch09" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch09</a></p><blockquote><p>参考资料<br>1、学习、探究Java设计模式——装饰者模式 - CSDN博客<br><a href="https://blog.csdn.net/a553181867/article/details/52108423" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a553181867/article/details/52108423</a><br>2、Java设计模式之装饰者模式(Decorator pattern) - 简书<br><a href="https://www.jianshu.com/p/c26b9b4a9d9e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c26b9b4a9d9e</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;
&lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（八）外观模式</title>
    <link href="https://www.wshunli.com/posts/82583d16.html"/>
    <id>https://www.wshunli.com/posts/82583d16.html</id>
    <published>2018-09-10T06:10:36.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/8.Facade.png" title="外观模式" alt="外观模式"></div><p>外观模式包含如下两个角色：</p><p>(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p><p>(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p><p>1、创建子系统角色类</p><pre><code class="lang-Java">public class ModuleA {    public void testA() {        System.out.println(&quot;ModuleA.testA()&quot;);    }}public class ModuleB {    public void testB() {        System.out.println(&quot;ModuleB.testB()&quot;);    }}public class ModuleC {    public void testC() {        System.out.println(&quot;ModuleC.testC()&quot;);    }}</code></pre><p>2、创建外观角色类</p><pre><code class="lang-Java">public class Facade {    public void test() {        ModuleA a = new ModuleA();        a.testA();        ModuleB b = new ModuleB();        b.testB();        ModuleC c = new ModuleC();        c.testC();    }}</code></pre><p>3、外观模式使用</p><pre><code class="lang-Java">public class FacadeMain {    public static void main(String[] args) {        Facade facade = new Facade();        facade.test();    }}</code></pre><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</p><p><strong>外观模式的优缺点</strong>：</p><p>优点：客户代码将变得很简单，与之关联的对象也很少；降低了大型软件系统中的编译依赖性。<br>缺点：不能很好地限制客户使用子系统类；增加新的子系统可能需要修改外观类或客户端的源代码。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch08" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch08</a></p><blockquote><p>参考资料<br>1、深入浅出外观模式（一） · 设计模式Java版<br><a href="https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html" rel="external nofollow noopener noreferrer" target="_blank">https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html</a><br>2、浅谈JAVA设计模式之——外观模式(Facade) - CSDN博客<br><a href="https://blog.csdn.net/l1028386804/article/details/45568655" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/l1028386804/article/details/45568655</a><br>3、java中的外观模式（门面模式） - 简书<br><a href="https://www.jianshu.com/p/1424c90ca255" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/1424c90ca255</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。&lt;/p&gt;
&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（七）适配器模式</title>
    <link href="https://www.wshunli.com/posts/69ceed63.html"/>
    <id>https://www.wshunli.com/posts/69ceed63.html</id>
    <published>2018-09-10T01:13:31.000Z</published>
    <updated>2018-09-23T10:41:06.421Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</p><p>适配器模式有 <strong>类的适配器模式和对象的适配器模式</strong> 两种不同的形式。</p><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类的适配器模式把适配的类的 API 转换成为目标类的 API 。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ClassAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，提供一个中间环节，即类 Adapter ，把 Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是继承关系，这决定了这个适配器模式是类的。</p><p>模式所涉及的角色有：</p><p>(1)目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</p><p>(2)源(Adapee)角色：现在需要适配的接口。</p><p>(3)适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色 ClassAdapter 扩展了 Adaptee ,同时又实现了目标(Target)接口。</p><pre><code class="lang-Java">public class ClassAdapter extends Adaptee implements Target {    /**     * 由于源类Adaptee没有方法sampleOperation2()     * 因此适配器补充上这个方法     */    @Override    public void sampleOperation2() {        System.out.println(&quot;ClassAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的 API 转换成为目标类的 API。</p><p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用委派关系连接到 Adaptee 类。</p><div align="center">     <img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ObjectAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，需要提供一个包装(Wrapper)类 Adapter。这个包装类包装了一个 Adaptee 的实例，从而此包装类能够把Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是委派关系，这决定了适配器模式是对象的。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色</p><pre><code class="lang-Java">public class ObjectAdapter {    private Adaptee adaptee;    public ObjectAdapter(Adaptee adaptee) {        this.adaptee = adaptee;    }    /**     * 源类Adaptee有方法sampleOperation1     * 因此适配器类直接委派即可     */    public void sampleOperation1() {        this.adaptee.sampleOperation1();    }    /**     * 源类Adaptee没有方法sampleOperation2     * 因此由适配器类需要补充此方法     */    public void sampleOperation2() {        System.out.println(&quot;ObjectAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="类适配器和对象适配器的权衡"><a href="#类适配器和对象适配器的权衡" class="headerlink" title="类适配器和对象适配器的权衡"></a>类适配器和对象适配器的权衡</h2><p>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。</p><p>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><p>在 Android 开发过程中, ListView 的 Adapter 是我们最为常见的类型之一。</p><p><strong>适配器模式的优缺点</strong>：</p><p>优点：更好的复用性、更好的扩展性。<br>缺点：过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch07" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch07</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之适配器模式 - java_my_life - 博客园<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a><br>2、JAVA学习笔记—策略设计模式与适配器模式 - tongye - 博客园<br><a href="https://www.cnblogs.com/tongye/p/6676039.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/tongye/p/6676039.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;
&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（六）原型模式</title>
    <link href="https://www.wshunli.com/posts/b7ba42b9.html"/>
    <id>https://www.wshunli.com/posts/b7ba42b9.html</id>
    <published>2018-09-07T14:31:45.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/6.Prototype.png" alt="原型模式"></p><p>原型模式的参与角色:</p><p>(1) 客户角色：客户类提出创建对象的请求。</p><p>(2) 抽象原型角色：这是一个抽象角色，通常由一个java接口或抽象类实现，具体原型都需要实现该接口。</p><p>(3) 具体原型角色：客户端所需要的被复制的对象。</p><p>1、创建抽象原型角色</p><pre><code class="lang-Java">public class Prototype implements Cloneable {    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}</code></pre><p>2、创建具体原型角色</p><pre><code class="lang-Java">public class ConcretePrototype1 extends Prototype {    public static int classFlag = 1;    @Override    protected ConcretePrototype1 clone() throws CloneNotSupportedException {        return (ConcretePrototype1) super.clone();    }}public class ConcretePrototype2 extends Prototype {    public static int classFlag = 2;    @Override    protected ConcretePrototype2 clone() throws CloneNotSupportedException {        return (ConcretePrototype2) super.clone();    }}</code></pre><p>3、原型模式的使用</p><pre><code class="lang-Java">public class PrototypePatternMain {    public static void main(String[] args) throws CloneNotSupportedException {        Prototype prototype1 = new ConcretePrototype1();        ConcretePrototype1 concretePrototype1 = (ConcretePrototype1) prototype1.clone();        System.out.println(concretePrototype1.classFlag);        Prototype prototype2 = new ConcretePrototype2();        ConcretePrototype2 concretePrototype2 = (ConcretePrototype2) prototype2.clone();        System.out.println(concretePrototype2.classFlag);    }}</code></pre><p>优点：1、性能提高。2、逃避构造函数的约束。</p><p>缺点：1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。2、必须实现 Cloneable 接口。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch06" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch06</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之原型模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html</a><br>2、23种设计模式（5）：原型模式 - CSDN博客<br><a href="https://blog.csdn.net/zhengzhb/article/details/7393528" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhengzhb/article/details/7393528</a><br>3、java中的原型模式 - 简书<br><a href="https://www.jianshu.com/p/4e1f2d090f20" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4e1f2d090f20</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;h1 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（五）建造者模式</title>
    <link href="https://www.wshunli.com/posts/325f89c7.html"/>
    <id>https://www.wshunli.com/posts/325f89c7.html</id>
    <published>2018-09-07T10:07:47.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/5.Builder.png" alt="建造者模式"></p><p>建造者模式中的四个要素：</p><p>(1) 产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。</p><p>(2) 抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。</p><p>(3) 建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。</p><p>(4) 导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。</p><p>1、构造产品实例类</p><pre><code class="lang-Java">public class Product {    private String name;    private String type;    private String size;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public String getSize() {        return size;    }    public void setSize(String size) {        this.size = size;    }    @Override    public String toString() {        return &quot;Product{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, type=&#39;&quot; + type + &#39;\&#39;&#39; +                &quot;, size=&#39;&quot; + size + &#39;\&#39;&#39; +                &#39;}&#39;;    }    public void show() {        System.out.println(this.toString());    }}</code></pre><p>2、抽象建造者</p><pre><code class="lang-Java">public abstract class Builder {    public abstract void name(String name);    public abstract void type(String type);    public abstract void size(String size);    public abstract Product build();}</code></pre><p>3、建造者实例</p><pre><code class="lang-Java">public class ConcreteBuilder extends Builder {    private Product product = new Product();    @Override    public void name(String name) {        product.setName(name);    }    @Override    public void type(String type) {        product.setType(type);    }    @Override    public void size(String size) {        product.setSize(size);    }    public Product build() {        return product;    }}</code></pre><p>4、导演类</p><pre><code class="lang-Java">public class Director {    private Builder builder = new ConcreteBuilder();    public Product getAProduct() {        builder.name(&quot;Burger&quot;);        builder.type(&quot;Wrapper&quot;);        builder.size(&quot;big&quot;);        return builder.build();    }    public Product getBProduct() {        builder.name(&quot;Coke&quot;);        builder.type(&quot;Bottle&quot;);        builder.size(&quot;small&quot;);        return builder.build();    }}</code></pre><p>5、建造者模式的使用</p><pre><code class="lang-Java">public class BuilderPatternMain {    public static void main(String[] args) {        Director director = new Director();        Product aProduct = director.getAProduct();        aProduct.show();        Product bProduct = director.getBProduct();        bProduct.show();    }}</code></pre><p>优点：1、建造者独立，易扩展。2、便于控制细节风险。</p><p>缺点：1、产品必须有共同点，范围有限制。2、如内部变化复杂，会有很多的建造类。</p><p>使用场景：1、需要生成的对象具有复杂的内部结构。2、需要生成的对象内部属性本身相互依赖。</p><p>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch05" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch05</a></p><blockquote><p>参考资料<br>1、建造者模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/builder-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/builder-pattern.html</a><br>2、建造者模式（Builder Pattern）- 最易懂的设计模式解析 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/54910597" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/54910597</a><br>3、23种设计模式（4）：建造者模式 - CSDN博客<br><a href="https://blog.csdn.net/zhengzhb/article/details/7375966" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhengzhb/article/details/7375966</a><br>4、Java 设计模式 — 建造者模式 - 简书<br><a href="https://www.jianshu.com/p/7d16da4e61b8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/7d16da4e61b8</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;h1 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（四）抽象工厂模式</title>
    <link href="https://www.wshunli.com/posts/4e3be4ad.html"/>
    <id>https://www.wshunli.com/posts/4e3be4ad.html</id>
    <published>2018-09-07T07:45:07.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 </p><p>工厂模式可以分为三类： </p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory） </p><p>本文及主要介绍抽象工厂模式。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式 (Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，属于对象创建型模式。</p><p>抽象工厂模式中，一个工厂可以提供多个不同种类产品对象，而不是单一种类的产品对象。</p><p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p><p><strong>产品等级结构</strong>： 产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p><strong>产品族</strong>： 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</p><p>抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong>，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/4.AbstractFactory.png" alt="抽象工厂模式"></p><p>抽象工厂模式包含角色和工厂方法模式相同。</p><p>假设有一个移动终端工厂，可以制造苹果系列的移动产品和华为系列的移动产品。<br>这个工厂下有两个子厂，一个负责制造苹果系列的 Pad 和华为系列的 Pad ，另一个负责制造苹果系列的手机和华为系列的手机。这便是一个典型的抽象工厂的实例。</p><p>1、创建产品产品接口</p><pre><code class="lang-Java">// 苹果系列public interface Apple {    void AppleStyle();}// 华为系列public interface Huawei {    void HuaweiStyle();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">// 苹果系列产品public class iPhone implements Apple {    @Override    public void AppleStyle() {        System.out.println(&quot;Apple&#39;s style: iPhone!&quot;);    }}public class iPad implements Apple {    @Override    public void AppleStyle() {        System.out.println(&quot;Apple&#39;s style: iPad!&quot;);    }}// 华为系列产品public class Honor implements Huawei {    @Override    public void HuaweiStyle() {        System.out.println(&quot;Huawei&#39;s style: Honor!&quot;);    }}public class HuaweiPad implements Huawei {    @Override    public void HuaweiStyle() {        System.out.println(&quot;Huawei&#39;s style: HuaweiPad!&quot;);    }}</code></pre><p>3、创建抽象工厂接口</p><pre><code class="lang-Java">public interface Factory {    Apple createAppleProduct();    Huawei createHuaweiProduct();}</code></pre><p>4、实现具体工厂类，生成实例对象，和工厂方法模式的核心区别</p><pre><code class="lang-Java">// 手机工厂public class PhoneFactory implements Factory {    @Override    public Apple createAppleProduct() {        return new iPhone();    }    @Override    public Huawei createHuaweiProduct() {        return new Honor();    }}// 平板工厂public class PadFactory implements Factory {    @Override    public Apple createAppleProduct() {        return new iPad();    }    @Override    public Huawei createHuaweiProduct() {        return new HuaweiPad();    }}</code></pre><p>5、调用不同工厂的方法生成实例对象</p><pre><code class="lang-Java">public class AbstractFactoryMain {    public static void main(String[] args) {        Factory factory = new PhoneFactory();        Apple apple = factory.createAppleProduct();        apple.AppleStyle();        Huawei huawei = factory.createHuaweiProduct();        huawei.HuaweiStyle();        factory = new PadFactory();        apple = factory.createAppleProduct();        apple.AppleStyle();        huawei = factory.createHuaweiProduct();        huawei.HuaweiStyle();    }}</code></pre><p><strong>抽象工厂模式优缺点</strong>:</p><p>优点:<br>1、抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。<br>2、增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合“开闭原则”。</p><p>缺点：<br>1、在添加新的产品对象（不同于现有的产品等级结构）时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。<br>2、开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</p><p><strong>适用环境</strong>：</p><p>1、一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>2、系统中有多于一个的产品族，而每次只使用其中某一产品族。<strong>与工厂方法模式的区别</strong>。<br>3、属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>4、系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch04" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch04</a></p><blockquote><p>参考资料<br>1、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a><br>2、《JAVA与模式》之抽象工厂模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 &lt;/p&gt;
&lt;p&gt;工厂模式可以分为三类： &lt;/p&gt;
&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（三）工厂方法模式</title>
    <link href="https://www.wshunli.com/posts/4982f93c.html"/>
    <id>https://www.wshunli.com/posts/4982f93c.html</id>
    <published>2018-09-07T07:40:09.000Z</published>
    <updated>2018-09-23T10:41:06.421Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 </p><p>工厂模式可以分为三类： </p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory） </p><p>本文及主要介绍工厂方法模式。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式 (Factory Method Pattern) 又称为工厂模式，也叫虚拟构造器 (Virtual Constructor) 模式或者多态工厂( Polymorphic Factory) 模式，它属于类创建型模式。</p><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/3.FactoryMethod.png" alt="工厂方法模式"></p><p>工厂方法模式包含如下角色：</p><p>(1) Product：抽象产品，工厂方法模式所创建的对象的超类，也就是所有产品类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>(2) ConcreteProduct：具体产品，这个角色实现了抽象产品（Product）所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品的实例。</p><p>(3) Factory：抽象工厂，担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>(4) ConcreteFactory：具体工厂，担任这个角色的是实现了抽象工厂接口的具体 Java 类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建具体产品对象。</p><p>1、创建抽象产品接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">public class Point implements Shape {    @Override    public void draw() {        System.out.println(&quot;Point.draw()&quot;);    }}public class Line implements Shape {    @Override    public void draw() {        System.out.println(&quot;Line.draw()&quot;);    }}public class Plane implements Shape {    @Override    public void draw() {        System.out.println(&quot;Plane.draw()&quot;);    }}</code></pre><p>以上内容和简单工厂模式相同。</p><p>3、创建抽象工厂接口</p><pre><code class="lang-Java">public interface ICreator {    Shape getShape();}</code></pre><p>4、实现具体工厂类，生成实例对象</p><pre><code class="lang-Java">public class PointCreator implements ICreator {    @Override    public Shape getShape() {        return new Point();    }}public class LineCreator implements ICreator {    @Override    public Shape getShape() {        return new Line();    }}public class PlaneCreator implements ICreator {    @Override    public Shape getShape() {        return new Plane();    }}</code></pre><p>5、调用不同工厂的方法生成实例对象</p><pre><code class="lang-Java">public class FactoryMethodMain {    public static void main(String[] args) {        ICreator creator = new PointCreator();        Shape shape = creator.getShape();        shape.draw();        creator = new LineCreator();        shape = creator.getShape();        shape.draw();        creator = new PlaneCreator();        shape = creator.getShape();        shape.draw();    }}</code></pre><p><strong>工厂方法模式的优缺点</strong>:</p><p>优点：<br>1、在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。<br>2、基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。<br>3、使用工厂方法模式的另一个优点是在系统中加入新产品时，只要添加一个具体工厂和具体产品就可以了。</p><p>缺点：<br>1、在添加新产品时，需要编写新的具体产品类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度。<br>2、由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p><p><strong>适用场景</strong>：</p><p>1、一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。<br>2、一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>3、将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch03" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch03</a></p><blockquote><p>参考资料<br>1、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 &lt;/p&gt;
&lt;p&gt;工厂模式可以分为三类： &lt;/p&gt;
&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（二）简单工厂模式</title>
    <link href="https://www.wshunli.com/posts/6ae09785.html"/>
    <id>https://www.wshunli.com/posts/6ae09785.html</id>
    <published>2018-09-07T07:39:09.000Z</published>
    <updated>2018-09-23T10:41:06.421Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 </p><p>工厂模式可以分为三类： </p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory） </p><p>本文及主要介绍简单工厂模式。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>在简单工厂模式中，可以根据参数的不同返回不同类的实例。</p><p>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/2.SimpleFactory.png" alt="简单工厂模式"></p><p>简单工厂模式包含如下角色：</p><p>(1) Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑。</p><p>(2) Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的 <strong>公共接口</strong> 。</p><p>(3) ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p><p>1、创建抽象产品接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">public class Point implements Shape {    @Override    public void draw() {        System.out.println(&quot;Point.draw()&quot;);    }}public class Line implements Shape {    @Override    public void draw() {        System.out.println(&quot;Line.draw()&quot;);    }}public class Plane implements Shape {    @Override    public void draw() {        System.out.println(&quot;Plane.draw()&quot;);    }}</code></pre><p>3、工厂角色，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    // 使用 getShape 方法获取形状类型的对象    public Shape getShape(String shapeType) {        if (shapeType == null) {            return null;        }        if (shapeType.equalsIgnoreCase(&quot;POINT&quot;)) {            return new Point();        } else if (shapeType.equalsIgnoreCase(&quot;LINE&quot;)) {            return new Line();        } else if (shapeType.equalsIgnoreCase(&quot;PLANE&quot;)) {            return new Plane();        }        return null;    }}</code></pre><p>4、使用该工厂，通过传递类型信息来获取实体类的对象</p><pre><code class="lang-Java">public class SimpleFactoryMain {    public static void main(String[] args) {        ShapeFactory shapeFactory = new ShapeFactory();        //获取 Point 的对象，并调用它的 draw 方法        Shape shape1 = shapeFactory.getShape(&quot;POINT&quot;);        //调用 Point 的 draw 方法        shape1.draw();        //获取 Line 的对象，并调用它的 draw 方法        Shape shape2 = shapeFactory.getShape(&quot;LINE&quot;);        //调用 Line 的 draw 方法        shape2.draw();        //获取 Plane 的对象，并调用它的 draw 方法        Shape shape3 = shapeFactory.getShape(&quot;PLANE&quot;);        //调用 Plane 的 draw 方法        shape3.draw();    }}</code></pre><p><strong>简单工厂模式优缺点</strong>:</p><p>优点：<br>通过使用工厂类，外界不再需要关心如何创造各种具体的产品，只要提供一个产品的名称作为参数传给工厂，就可以直接得到一个想要的产品对象，并且可以按照接口规范来调用产品对象的所有功能（方法）。构造容易，逻辑简单。</p><p>缺点：<br>1、简单工厂模式中的 if else 判断非常多，当系统中的具体产品类不断增多时候，就要不断的修改工厂类，对系统的维护和扩展不利。<br>2、一个工厂类中集合了所有的类的实例创建逻辑，什么时候它不能工作了，整个系统都会受到影响。<br>3、简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p><p><strong>适用场景</strong>：</p><p>1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch02" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch02</a></p><blockquote><p>参考资料<br>1、工厂模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/factory-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/factory-pattern.html</a><br>2、JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式) - CSDN博客<br><a href="https://blog.csdn.net/jason0539/article/details/23020989" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/jason0539/article/details/23020989</a><br>3、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 &lt;/p&gt;
&lt;p&gt;工厂模式可以分为三类： &lt;/p&gt;
&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（一）单例模式</title>
    <link href="https://www.wshunli.com/posts/d1c4534.html"/>
    <id>https://www.wshunli.com/posts/d1c4534.html</id>
    <published>2018-09-05T11:51:25.000Z</published>
    <updated>2018-09-23T10:41:06.421Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p><strong>特点</strong>：<br>单例类只能有一个实例。<br>单例类必须自己创建自己的唯一实例。<br>单例类必须给所有其他对象提供这一实例。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的其他几种实现方式：</p><p>1、饿汉模式，线程安全</p><pre><code class="lang-Java">public class Singleton {    private static final Singleton instance = new Singleton();    private Singleton() {    }    public static Singleton getInstance() {        return instance;    }}</code></pre><p>饿汉模式单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance() 方法。</p><p>2、懒汉模式，线程不安全</p><pre><code class="lang-Java">public class Singleton {    private static Singleton instance;    private Singleton() {    }    public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><p>3、懒汉模式、线程安全：</p><pre><code class="lang-Java">public class Singleton {    private static Singleton instance;    private Singleton() {    }    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。</p><p>因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。</p><p>4、双检锁/双重校验锁（DCL，即 double-checked locking）</p><pre><code class="lang-Java">public class Singleton {    private volatile static Singleton instance;    private Singleton() {    }    public static Singleton getInstance() {        if (instance == null) {            synchronized (Singleton.class) {                if (instance == null) {                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><p>5、静态内部类</p><pre><code class="lang-Java">public class Singleton {      private static class SingletonHolder {          private static final Singleton INSTANCE = new Singleton();      }      private Singleton (){}      public static final Singleton getInstance() {          return SingletonHolder.INSTANCE;     }  }</code></pre><p>6、枚举</p><pre><code class="lang-Java">public enum Singleton{    INSTANCE;}</code></pre><p><strong>总结</strong>：</p><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。</p><p>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p><blockquote><p>参考资料<br>1、单例模式 | 菜鸟教程：<br><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/singleton-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式（Singleton Pattern）确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;br&gt;单例类只能有一个实例。&lt;br&gt;单例类必须自己创建自己的唯一实例。&lt;br&gt;单例类必须给所有其他对象提供
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（零）设计模式概述</title>
    <link href="https://www.wshunli.com/posts/af6d1ac0.html"/>
    <id>https://www.wshunli.com/posts/af6d1ac0.html</id>
    <published>2018-09-05T09:43:14.000Z</published>
    <updated>2018-09-23T10:41:06.425Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式也是比较欠缺的一方面，这次看的是 《设计模式之禅》 ，前面看了一点 《Head First 设计模式》感觉都是图片有点乱。</p><h1 id="第一部分-设计原则"><a href="#第一部分-设计原则" class="headerlink" title="第一部分 设计原则"></a>第一部分 设计原则</h1><p>单一职责原则：应该有且仅有一个原因引起类的变更，对于接口设计时要做到单一职责。</p><p>里氏替换原则：只要有父类出现的地方，替换为子类也不会产生任何问题或异常。<br>　　<br>依赖倒置原则：模块间的依赖关系是通过接口或抽象类产生的（面向接口编程）。</p><p>接口隔离原则：客户不应该依赖它不需要的接口；类间的依赖关系应建立在最小的接口上；尽量使用多个专门的接口。</p><p>迪米特法则：一个对象应对其他对象有最少的了解；只和直接朋友交流，朋友间也是有距离的；一个方法中尽量不引入类中不存在的对象；减少 public 方法和属性。</p><p>开闭原则：对扩展开放，对修改关闭；通过扩展来实现变化；不允许出现接口或抽象方法中不存在的 public 方法。</p><h1 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分 设计模式"></a>第二部分 设计模式</h1><p>设计模式根据目的可以分为三大类，分别是 <strong>创建型设计模式、行为型设计模式以及结构型设计模式</strong> 。</p><p>(一) <strong>创建型模式</strong> 涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解藕。 </p><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p><p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p><p>1、单例模式(Singleton) </p><p><a href="https://www.wshunli.com/posts/d1c4534.html">https://www.wshunli.com/posts/d1c4534.html</a></p><p>2、简单工厂模式(Simple Factory)</p><p><a href="https://www.wshunli.com/posts/6ae09785.html">https://www.wshunli.com/posts/6ae09785.html</a></p><p>3、工厂方法模式(Factory Method)</p><p><a href="https://www.wshunli.com/posts/4982f93c.html">https://www.wshunli.com/posts/4982f93c.html</a></p><p>4、抽象工厂模式(Abstract Factory)</p><p><a href="https://www.wshunli.com/posts/4e3be4ad.html">https://www.wshunli.com/posts/4e3be4ad.html</a></p><p>5、建造者模式(Builder)</p><p><a href="https://www.wshunli.com/posts/325f89c7.html">https://www.wshunli.com/posts/325f89c7.html</a></p><p>6、原型模式(Prototype)</p><p><a href="https://www.wshunli.com/posts/b7ba42b9.html">https://www.wshunli.com/posts/b7ba42b9.html</a></p><p>(二) <strong>结构型模式</strong> 可以让你把类或对象组合到更大的结构中。</p><p>结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。</p><p>结构型模式可以分为 <strong>类结构型模式和对象结构型</strong> 模式：<br>(1) 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承和实现关系。<br>(2) 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。</p><p>7、适配器模式(Adapter)</p><p><a href="https://www.wshunli.com/posts/69ceed63.html">https://www.wshunli.com/posts/69ceed63.html</a></p><p>8、外观模式(Facade)</p><p><a href="https://www.wshunli.com/posts/82583d16.html">https://www.wshunli.com/posts/82583d16.html</a></p><p>9、装饰者模式(Decorator)</p><p><a href="https://www.wshunli.com/posts/d95b685e.html">https://www.wshunli.com/posts/d95b685e.html</a></p><p>10、代理模式(Proxy)</p><p><a href="https://www.wshunli.com/posts/b4b3761.html">https://www.wshunli.com/posts/b4b3761.html</a></p><p>11、组合模式(Composite)</p><p><a href="https://www.wshunli.com/posts/fb6e1df3.html">https://www.wshunli.com/posts/fb6e1df3.html</a></p><p>12、桥接模式(Bridge)</p><p><a href="https://www.wshunli.com/posts/f75ecf9a.html">https://www.wshunli.com/posts/f75ecf9a.html</a></p><p>13、享元模式(Flyweight)</p><p><a href="https://www.wshunli.com/posts/180f2df5.html">https://www.wshunli.com/posts/180f2df5.html</a></p><p>(三) <strong>行为型模式</strong> 涉及到类和对象如何交互及分配职责。 </p><p>14、观察者模式(Observer)</p><p>15、策略模式(Strategy)</p><p>16、命令模式(Command)</p><p>17、迭代器模式(Iterator)</p><p>18、模板方法模式(Template Method)</p><p>19、状态模式(State)<br>20、责任链模式(Chain of Responsibility)<br>21、解释器模式(Interpreter)<br>22、备忘录模式(Memento)<br>23、访问者模式(Visitor)<br>24、中介者模式(Mediator)</p><blockquote><p>参考资料<br>1、图说设计模式 — Graphic Design Patterns<br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html#" rel="external nofollow noopener noreferrer" target="_blank">https://design-patterns.readthedocs.io/zh_CN/latest/index.html#</a><br>2、设计模式Java版<br><a href="https://quanke.gitbooks.io/design-pattern-java/" rel="external nofollow noopener noreferrer" target="_blank">https://quanke.gitbooks.io/design-pattern-java/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式也是比较欠缺的一方面，这次看的是 《设计模式之禅》 ，前面看了一点 《Head First 设计模式》感觉都是图片有点乱。&lt;/p&gt;
&lt;h1 id=&quot;第一部分-设计原则&quot;&gt;&lt;a href=&quot;#第一部分-设计原则&quot; class=&quot;headerlink&quot; title=&quot;第
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>图解数据结构-算法部分（Java语言实现）</title>
    <link href="https://www.wshunli.com/posts/444e2c0f.html"/>
    <id>https://www.wshunli.com/posts/444e2c0f.html</id>
    <published>2018-09-04T06:48:13.000Z</published>
    <updated>2018-09-23T10:41:06.429Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法一直是比较薄弱的地方，不仅在面试的时候会问相关问题、手写代码，而且在笔试的时候发挥重要作用。</p><p>前面一直学习的数据结构，下面排序、查找属于算法的范畴了。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>所谓 “排序” (Sorting) 就是指将一组数据，按特定规则调换位置，使数据具有某种顺序关系（递增或递减）。</p><p><strong>排序分类</strong>，可分为内部（内存中）和外部（外部存储器）排序两大类。</p><p>常见的内部排序法有：冒泡排序法、选择排序法、插入排序法、合并排序法、快速排序 法、堆积排序法、希尔排序法、基数排序法等。 至于比较常见的外部排序法有：直接合并排序法、K 路合并法、多相合并法等。 </p><p><strong>排序算法分析</strong>：算法是否稳定、时间复杂度、空间复杂度。</p><p>稳定的排序是指数据在经过排序后，两个相同键值的记录仍然保待原来的次序。</p><h2 id="内部排序法"><a href="#内部排序法" class="headerlink" title="内部排序法"></a>内部排序法</h2><p>内部排序法的时间复杂度及键值整理。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/内部排序法.png" alt="内部排序法"></p><p>1、<strong>冒泡排序法</strong></p><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/冒泡排序法.gif" alt="冒泡排序法"></p><p>实现算法：</p><pre><code class="lang-Java">int i, j, tmp;int data[] = {6, 5, 9, 7, 2, 8};    //原始数据for (i = 5; i &gt; 0; i--)             //扫描次数{    for (j = 0; j &lt; i; j++)         //比较、交换次数    {        // 比较相邻两数，如第一数较大则交换        if (data[j] &gt; data[j + 1]) {            tmp = data[j];            data[j] = data[j + 1];            data[j + 1] = tmp;        }    }}</code></pre><p>但是这样如论如何都会执行 $ n(n-1)/2 $ 次，我们可以加一个判断在没有可替换的数据时终止程序。</p><pre><code class="lang-Java">public void bubble() {    int i, j, tmp, flag;    for (i = 5; i &gt;= 0; i--) {        flag = 0;           //flag用来判断是否有执行交换的动作        for (j = 0; j &lt; i; j++) {            if (data[j + 1] &lt; data[j]) {                tmp = data[j];                data[j] = data[j + 1];                data[j + 1] = tmp;                flag++;    //如果有执行过交换，则flag不为0            }        }        //当执行完一次扫描就判断是否做过交换动作，如果没有交换过数据，        //表示此时数组已完成排序，故可直接跳出循环        if (flag == 0) {            break;        }    }</code></pre><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近 n²/2 次, 时间复杂度为 O(n²) . 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). </p><p>平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的 temp 变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><p>2、<strong>选择排序法</strong></p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。</p><p>算法描述：</p><p>(1) 从待排序序列中，找到关键字最小的元素；<br>(2) 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>(3) 从余下的 N - 1 个元素中，找出关键字最小的元素，重复 (1)、(2) 步，直到排序结束。</p><pre><code class="lang-Java">void select() {    int i, j, tmp;    for (i = 0; i &lt; 5; i++) {            //扫描 5 次        for (j = i + 1; j &lt; 6; j++) {    //由 i+1 比较起，比较 5 次            if (data[i] &gt; data[j]) {     //比较第 i 及第 j 个元素                tmp = data[i];                data[i] = data[j];                data[j] = tmp;            }        }    }}</code></pre><p>选择排序的简单和直观名副其实，这也造就了它 “出了名的慢性子” ，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近 n²/2 次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><p>3、<strong>插入排序法</strong></p><p>将数组中的所有元素依次跟前面已经排好的元素相比较，再将数组元素插入合适的位置。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/插入排序法.gif" alt="插入排序法"></p><p>实现算法：</p><pre><code class="lang-Java">void insert() {    int i;     // i 为扫描次数    int j;     // j 来定位比较的元素    int tmp;   // tmp 用来暂存数据    for (i = 1; i &lt; size; i++) {  // 扫描循环次数为 SIZE-1        tmp = data[i];        j = i - 1;        while (j &gt;= 0 &amp;&amp; tmp &lt; data[j]) {  // 如果第二元素小于第一元素            data[j + 1] = data[j]; // 就把所有元素往后推一个位置            j--;        }        data[j + 1] = tmp;       // 最小的元素放到第一个元素    }}</code></pre><p>Tips: 由于直接插入排序每次只移动一个元素的位，并不会改变值相同的元素之间的排序，因此它是一种稳定排序。</p><p>4、<strong>希尔排序法</strong></p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><p>实现算法：</p><pre><code class="lang-Java">void shell() {    int i;        // i 为扫描次数    int j;        // j 来定位比较的元素    int k = 1;    // k 打印计数    int tmp;      // tmp 用来暂存数据    int jmp;      // 设定间隔位移量    jmp = size / 2;    while (jmp != 0) {        for (i = jmp; i &lt; size; i++) {            tmp = data[i];            j = i - jmp;            while (j &gt;= 0 &amp;&amp; tmp &lt; data[j])  //插入排序法            {                data[j + jmp] = data[j];                j = j - jmp;            }            data[jmp + j] = tmp;        }        jmp = jmp / 2;    //控制循环数    }}</code></pre><p>5、<strong>合并排序法</strong></p><p>合并排序算法是将两个（或两个以上）有序表合并成一个新的有序表；<br>即把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序子序列合并为整体有序序列。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/合并排序法.gif" alt="合并排序法"></p><p>6、<strong>快速排序法</strong></p><p>快速排序法又称分割交换排序法，是目前公认最佳的排序法。</p><p>它的原理和冒泡排序法一样都是用交换的方式，不过它会先在数据中找到一个虚拟的中间值，把小于中间值的数据放在左边，而大于中间值的数据放在右边，再以同样的方式分别处理左右两边的数据，直到完成为止。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/快速排序法.gif" alt="快速排序法"></p><p>7、<strong>堆积排序法</strong></p><p>堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><p>8、<strong>基数排序法</strong></p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h2 id="外部排序法"><a href="#外部排序法" class="headerlink" title="外部排序法"></a>外部排序法</h2><p>直接合井排序法 (Direct Merge Sort) 是外部存储设备最常用的排序方法。</p><p>它可以分为两个步骤：<br>步骤1: 将要排序的文件分为几个大小可以加载到内存空间的小文件，再使用内部排序法将各文件内的数据排序。<br>步骤2: 将第一步所建立的小文件每两个合并成一个文件。两两合井后，把所有文件合并成一个文件后就可以完成排序了。</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>所谓查找，就是从数据文件中，寻找符合某特定条件的记录。而用来查找的条件就称为 “键值” 。</p><p>一般来说，如果数据在查找前经过排序，将可大幅减少查找的时间。至于查找技巧中比 较常见的方法有顺序法、二分查找法、斐波那契法、插值法、哈希法、m 路查找树、B-tree 等。</p><p>数据结构：<a href="https://www.wshunli.com/posts/850e5c53.html">https://www.wshunli.com/posts/850e5c53.html</a><br>算法：<a href="https://www.wshunli.com/posts/444e2c0f.html">https://www.wshunli.com/posts/444e2c0f.html</a></p><blockquote><p>参考资料<br>1、八大排序算法总结与java实现 | iTimeTraveler<br><a href="https://itimetraveler.github.io/2017/07/18/八大排序算法总结与java实现/" rel="external nofollow noopener noreferrer" target="_blank">https://itimetraveler.github.io/2017/07/18/八大排序算法总结与java实现/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据结构与算法一直是比较薄弱的地方，不仅在面试的时候会问相关问题、手写代码，而且在笔试的时候发挥重要作用。&lt;/p&gt;
&lt;p&gt;前面一直学习的数据结构，下面排序、查找属于算法的范畴了。&lt;/p&gt;
&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.wshunli.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="算法" scheme="https://www.wshunli.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://www.wshunli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
