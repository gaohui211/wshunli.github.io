<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2017-11-14T14:39:22.186Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>又拍云CDN全站加速</title>
    <link href="http://www.wshunli.com/posts/97fe98e3.html"/>
    <id>http://www.wshunli.com/posts/97fe98e3.html</id>
    <published>2017-11-11T11:44:24.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。</p><a id="more"></a><p>前几天使用 Travis CI 自动构建 Hexo 博客并且上传至 Github 和 Coding，就在想能不能同时上传至 <a href="https://console.upyun.com/register/?invite=H1_D-bC4W" rel="external nofollow noopener noreferrer" target="_blank">又拍云</a>。</p><p>今天晚上使用 ftp 上传至又拍云，网站实现全站 CDN 加速。</p><p>前面发现是有工具可以直接上传至又拍云：</p><p><a href="https://github.com/Menci/hexo-deployer-upyun" rel="external nofollow noopener noreferrer" target="_blank">hexo-deployer-upyun</a></p><p>但是这个工具在 Windows 系统下使用有问题，并且我已经使用 Travis CI 自动部署了，继续使用这个工具有<strong>令牌</strong>暴露的风险。</p><p>所以就想使用 ftp 上传至又拍云，然后就发现了这个工具：</p><p><a href="https://github.com/git-ftp/git-ftp" rel="external nofollow noopener noreferrer" target="_blank">Git-ftp</a> – uploads to FTP servers the Git way</p><p>在 linux 下的安装方法：</p><pre><code class="Shell">git clone https://github.com/git-ftp/git-ftp.gitcd git-ftp# choose the newest releasetag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;# checkout the latest taggit checkout &quot;$tag&quot;sudo make install</code></pre><p>配置 git-ftp ：</p><pre><code class="Shell">git config git-ftp.url &quot;ftp://ftp.example.net:21/public_html&quot;git config git-ftp.user &quot;ftp-user&quot;git config git-ftp.password &quot;secr3t&quot;</code></pre><p>第一次上传执行：</p><pre><code class="Shell">git ftp init</code></pre><p>后面上传执行，只会上传变化的部分：</p><pre><code class="Shell">git ftp push</code></pre><p>使用方法也很简单，下面就默认在原来 <a href="https://www.wshunli.com/posts/7dcaaf9e.html">Travis CI 自动部署</a> 的基础上:</p><p>在 <code>.travis.yml</code> 文件中修改：</p><pre><code class="Shell">install:  - npm install  - git clone https://github.com/git-ftp/git-ftp.git  - cd git-ftp  - tag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;  - git checkout &quot;$tag&quot;  - sudo make install  - cd ..</code></pre><p>在 <code>publish-to-gh-pages.sh</code> 中修改</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;git ftp init# git ftp push</code></pre><p>第一次上传之后，修改 <code>publish-to-gh-pages.sh</code> 文件</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;# git ftp initgit ftp push -v</code></pre><p>其中 UPYUN_USE 和 UPYUN_PSD 是在 Travis 中配置的 UPYUN ftp 用户名密码。<br>具体值可参考：<a href="https://docs.upyun.com/api/developer_tools/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.upyun.com/api/developer_tools/</a></p><p>其实有点弊端就是上传之后更新具有一定的延迟性，但是速度快很多。</p><blockquote><p>参考资料<br>1、travis-ci-deploy-ftp<br><a href="https://github.com/ansediao/travis-ci-deploy-ftp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ansediao/travis-ci-deploy-ftp</a><br>2、How to use git-ftp： 使用 git-ftp 管理你的 FTP<br><a href="https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9</a><br>3、使用 git-ftp 将 git 两次提交发生变化的文件上传到服务器<br><a href="http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server" rel="external nofollow noopener noreferrer" target="_blank">http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.wshunli.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="Upyun" scheme="http://www.wshunli.com/tags/Upyun/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/d0f6201d.html"/>
    <id>http://www.wshunli.com/posts/d0f6201d.html</id>
    <published>2017-11-10T05:40:03.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。</p><a id="more"></a><p>之间就简单地使用 <a href="https://reactjs.org" rel="external nofollow noopener noreferrer" target="_blank">React</a> 搭建过一次 Demo ，借这次机会把 React 给搞定了，至少能写个简单的界面。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React技术栈.png-hexo.png" alt="React技术栈"></p><p>看着这 React技术栈 ，还是压力山大啊。</p><p>这次选了两本书 《深入浅出React和Redux》 和 《React全栈》。书都很新也很薄，这次先看一本入门。</p><h1 id="第1章-React-新的前端思维方式"><a href="#第1章-React-新的前端思维方式" class="headerlink" title="第1章 React 新的前端思维方式"></a>第1章 React 新的前端思维方式</h1><p>首先使用 <code>creat-react-app</code> 创建一个 React 应用。</p><p>在确认 Node.js 和 npm 安装好之后，在命令行执行以下命令安装 <code>creat-react-app</code> 工具。</p><pre><code class="Shell">npm install -g create-react-appcreate-react-app first-react-appnpm start</code></pre><p>浏览器会自动打开 <a href="http://localhost:3000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:3000/</a> 显示如下界面：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app.png-hexo.png" alt="first-react-app"></p><p>我们来看一下 first-react-app 的目录结构：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app2.png-hexo.png" alt="first-react-app"></p><p>在开发过程中，我们主要关注 src 目录的内容。</p><p>其中 <code>src/index.js</code> 文件是应用的入口文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import App from &#39;./App&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>这里的代码渲染了一个 App 组件，效果就是首页界面。<br>我们看下 App 组件是怎么定义的，在 <code>src/App.js</code> 文件中：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import logo from &#39;./logo.svg&#39;;import &#39;./App.css&#39;;class App extends Component {  render() {    return (      &lt;div className=&quot;App&quot;&gt;        &lt;header className=&quot;App-header&quot;&gt;          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;        &lt;/header&gt;        &lt;p className=&quot;App-intro&quot;&gt;          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.        &lt;/p&gt;      &lt;/div&gt;    );  }}export default App;</code></pre><p>React 应用实际上依赖很复杂的技术栈，我们使用 <code>creat-react-app</code> 避免一开始就浪费太多精力配置技术栈。</p><p>我们启动 React 的命令是 <code>npm start</code> ，在 <code>package.json</code> 中：</p><pre><code class="JS">  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  }</code></pre><p>npm build 可以创建生产环境优化代码；<br>npm teat 用于单元测试；<br>npm eject 把 react-scripts 技术栈配置都弹射到应用顶层，不可逆。</p><h2 id="添加-React-组件"><a href="#添加-React-组件" class="headerlink" title="添加 React 组件"></a>添加 React 组件</h2><p>仿照着增加一个新的 React 组件。同样在 src 目录新建文件 <code>ClickCounter.js</code> 写入如下代码：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;class ClickCounter extends Component {  constructor(props) {    super(props);    this.onClickButton = this.onClickButton.bind(this);    this.state = {      count: 0    }  }  onClickButton() {    this.setState({count: this.state.count + 1});  }  render() {    const counterStyle = {      margin: &#39;16px&#39;    }    return (      &lt;div style={counterStyle}&gt;        &lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;        &lt;div&gt;          Click Count: &lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    );  }}export default ClickCounter;</code></pre><p>修改 <code>src/index.js</code> 文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import ClickCounter from &#39;./ClickCounter&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;ClickCounter /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>其中在 index.js 中使用 import 导入 ClickCounter 组件，替代之前的 App 组件。</p><pre><code class="JSX">import ClickCounter from &#39;./ClickCounter&#39;;</code></pre><p>在 ClickCounter.js 的第一行我们以同样的方式引入 React 和 Component 。</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;</code></pre><p>Component 为所有组件的基类，提供很多组件共有的功能。</p><pre><code class="JSX">class ClickCounter extends Component {}</code></pre><p>React 没有在代码中直接使用，但在 JSX 使用的范围内必须有 React，因为 JSX 最终会被转译成依赖 React 的表达式。</p><p><strong>JSX</strong>：JSX 是 JavaScript 的一种扩展语法，使我们能够在 JavaScript 中编写类似 HTML 的代码。<br>JSX 的基本语法规则：遇到 HTML 标签（以&lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。</p><p>首先，在 JSX 中使用的元素不限于 HTML 元素，可以是 React 组件。而区分二者的方法是首字母是否大写。<br>其次，在 JSX 中可以通过 onClick 这样的方式为元素添加事件处理函数。</p><pre><code class="JSX">&lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;</code></pre><h2 id="React-的工作方式"><a href="#React-的工作方式" class="headerlink" title="React 的工作方式"></a>React 的工作方式</h2><p>React的理念归结为一个公式：UI=render(data) 。</p><p>用户看到的界面（UI）是一个函数（render）的执行结果，只接受数据（data）作为参数。这是一个纯函数，即输出只依赖于输入的函数，两次函数的调用如果输入相同，那么输出也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于data ，哪些属于render ，想要更新用户界面，要做的就是更新data ，用户界面自然会做出响应，所以React 实践的也是“响应式编程”（ Reactive Programming ）的思想。</p><p><strong>Virtual DOM</strong>：是对DOM树的抽象，它并不触及浏览器部分，只是存在于 JavaScript 空间的树形结构，每次在渲染 React 组件，React 会对前后两次产生的 Virtual DOM 进行比较，最后只有发生了改变的地方会被重新渲染。</p><blockquote><p>总而言之，React利用函数式编程的思维来解决用户界面渲染的问题，强制所有组件都以数据驱动渲染的模式进行开发。</p></blockquote><h1 id="第2章-设计高质量的-React-组件"><a href="#第2章-设计高质量的-React-组件" class="headerlink" title="第2章 设计高质量的 React 组件"></a>第2章 设计高质量的 React 组件</h1><p>作为软件设计的通则，组件的划分要满足高内聚（High Cohesion ）和低搞合（ Low Coupling）的原则。</p><h2 id="React-组件的数据"><a href="#React-组件的数据" class="headerlink" title="React 组件的数据"></a>React 组件的数据</h2><p>React 组件的数据分为两种， prop 和 state。</p><p>prop 是组件的对外接口， state 是组件的内部状态，对外用 prop ，内部用 state 。</p><h3 id="React-的-prop"><a href="#React-的-prop" class="headerlink" title="React 的 prop"></a>React 的 prop</h3><p>prop ( property 的简写）是外部传递给组件的数据， React 组件通过定义自己能够接受的 prop 就定义了自己的对外公共接口。</p><pre><code class="JSX">&lt;SampleButtonid= &quot;sample&quot; borderWidth={2} onClick={onButtonClick}style={{color :"red"}}/&gt;</code></pre><p>当 prop 的值不是字符串类型时，在 JSX 中必须用花括号 {} 包住，<br>所以 style 的值有两层花括号，外层花括号代表是 JSX 的语法，内层的花括号代表这是一个对象常量。</p><pre><code class="JSX">class ControlPanel extends Component {  render() {    console.log(&#39;enter ControlPanel render&#39;);    return (      &lt;div&gt;        &lt;Counter caption=&quot;First&quot; initValue={0}/&gt;        &lt;Counter caption=&quot;Second&quot; initValue={10} /&gt;        &lt;Counter caption=&quot;Third&quot; initValue={20} /&gt;      &lt;/div&gt;    );  }}</code></pre><p>上面是给 prop 赋值，下面读取 prop 的值：</p><pre><code class="JSX">class Counter extends Component {  constructor(props) {    console.log(&#39;enter constructor: &#39; + props.caption);    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue || 0    }  }  ···</code></pre><p>在构造函数中可以通过参数 props 获得传人 prop 值，在其他函数中则可以通过 <code>this.props</code> 访问传人 prop 的值。</p><pre><code class="JSX">  ··· render() {    console.log(&#39;enter render &#39; + this.props.caption);    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }</code></pre><p><strong>propTypes 检查</strong>：组件声明接口规范，即组件支持的 prop 及其格式。</p><pre><code class="JSX">Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number};</code></pre><p>建议在开发阶段使用，产品环境下去除。</p><h3 id="React-的-state"><a href="#React-的-state" class="headerlink" title="React 的 state"></a>React 的 state</h3><p>state 代表组件的内部状态。</p><p>1、初始化 state</p><p>通常在组件的构造函数结尾处初始化 state 。</p><pre><code class="JSX">constructor(props) {    ···    this.state = {      count: props.initValue || 0    }  }</code></pre><p>React 的 defaultProps 给 prop 默认初始值：</p><pre><code class="JSX">Counter.defaultProps = {  initValue: 0}// this.state 可省去判断this.state = {  count: props.initValue}</code></pre><p>2、读取更新 state</p><p>this.state 读取 state<br>this.setState 更新 state</p><pre><code class="JSX">onClickIncrementButton() {  this.setState({count: this.state.count + 1});}</code></pre><h3 id="prop-和state-的区别"><a href="#prop-和state-的区别" class="headerlink" title="prop 和state 的区别"></a>prop 和state 的区别</h3><ul><li>prop 用于定义外部接口， state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时， state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><p>组件是绝不应该去修改传人的 props 值，否则会影响其他组件。</p><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：</p><ul><li>装载过程（ Mount ），也就是把组件第一次在DOM 树中渲染的过程；</li><li>更新过程（ Update ），当组件被重新渲染的过程；</li><li>卸载过程（ Unmount ），组件从DOM 中删除的过程。</li></ul><p>三种不同的过程， React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React组件生命周期.png-hexo.png" alt="React组件生命周期"></p><p><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a></p><h3 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h3><p>当组件第一次渲染的时候，依次调用的函数如下：</p><ul><li>constructor()</li><li>getlnitialState()</li><li>getDefaultProps()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p>1、constructor()<br>ES6 中类的构造函数，主要是初始化 state 和绑定成员函数的 this 环境。</p><p>2、getlnitialState() 和 getDefaultProps()<br>getlnitialState() 返回值用来初始化组件的 this.state ，getDefaultProps() 返回值用来作为 prop 的初始值。<br>这两个方法只有用 React.createClass 方法创建组件类时才会生效。</p><pre><code class="JSX">const Sample = React.createClass({  getInitialState() {    console.log(&#39;enter getInitialState&#39;);  }  getDefaultProps() {    console.log(&#39;enter getDefaultProps&#39;);  }});</code></pre><p>而在 ES6 中使用 defaultProps 指定初试 prop 初始值。</p><pre><code class="JSX">const Sample extends React.Component({  constructor(props) {    super(props);    this.state = {foo: &quot;bar&quot;}  }}Sample.defaultProps = {  return {sampleProp: 0}};</code></pre><p>React.createClass 已经被 Facebook 官方逐渐废弃。</p><p>3、render()</p><p>render() 函数在 React 中必须实现，其他生命周期函数在 React.Component 中都有默认实现。</p><p>render() 并不做实际的渲染动作，只是返回 JSX 描述的结构，最终由 React 操作渲染过程。<br>不需要渲染界面可以返回 null 或者 false 。</p><p>4、componentWillMount() 和 componentDidMount()</p><p>在装载过程中，componentWillMount() 会在调用 render() 函数之前被调用， componentDidMount() 会在调用 render() 函数之后被调用。</p><p>componentWillMount() 是将要装载，虽然还没有渲染出来结果，但是修改组件状态已经晚了。<br>componentDidMount() 是 render() 函数返回的内容已经渲染好了，组件已经被装载在 DOM 树上了。</p><p>componentWilIMount() 和 componentDidMount() 这对兄弟函数还有一个区别：<br>componentWillMount() 可以在服务器端被调用，也可以在浏览器端被调用；<br>而componentDidMount() 只能在浏览器端被调用，在服务器端使用 React 的时候不会被调用。</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>当组件的 props 或者 state 被修改的时候，就会引发组件的更新过程。<br>更新过程会依次调用下面的生命周期函数：</p><ul><li>componentWillReceiveProps(nextProps)</li><li>shouldComponentUpdate()</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><p>1、componentWillReceiveProps(nextProps)</p><p>只要是父组件的 render() 函数被调用，在 render() 函数里面被谊染的子组件就会经历更新过程，<br>不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps() 函数。</p><p>componentWillReceiveProps(nextProps) 适合根据新的 props 值（也就是参数 nextProps ）来计算出是不是要更新内部状态state 。</p><p>注意，更新组件内部状态的方法 this.setState() 方法触发的更新过程不会调用这个函数，否则会导致 componentWillReceiveProps 再次被调用，陷入死循环。</p><pre><code class="JSX"></code></pre><pre><code class="JSX"></code></pre><pre><code class="JSX">ReactDOM.render(  &lt;h1&gt;Hello, world!&lt;/h1&gt;,  document.getElementById(&#39;root&#39;));</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://www.wshunli.com/categories/React/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="深入浅出React和Redux" scheme="http://www.wshunli.com/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署Hexo博客</title>
    <link href="http://www.wshunli.com/posts/7dcaaf9e.html"/>
    <id>http://www.wshunli.com/posts/7dcaaf9e.html</id>
    <published>2017-11-09T11:14:08.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。</p><a id="more"></a><p>我一般都是将博客的源文件保存到私有仓库中，虽然几个简单地命令就能部署，但是过程还是很繁琐。最近申请了 Github Student Developer Pack ，就想利用软件开发中的持续集成工具 Travis CI 来帮助完成 Hexo 博客的部署过程。这样就只需要把源代码 push 到仓库就能自动部署好了。</p><p>CI 是 Continuous Integration 的缩写，持续集成之意。持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><h1 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h1><p>关于 Hexo 博客的搭建请参考文章：<a href="https://www.wshunli.com/posts/9642fffa.html">https://www.wshunli.com/posts/9642fffa.html</a></p><h1 id="Travis-CI-配置"><a href="#Travis-CI-配置" class="headerlink" title="Travis CI 配置"></a>Travis CI 配置</h1><p>1.使用 GitHub 账户登录 <a href="https://travis-ci.org" rel="external nofollow noopener noreferrer" target="_blank">Travis CI</a> 官网，然后用 Github 账号登陆，就可以看到可以持续集成的仓库。</p><p>还有个地址 <a href="https://travis-ci.com" rel="external nofollow noopener noreferrer" target="_blank">https://travis-ci.com</a> 可以部署 Github 私有仓库。</p><p>选择要启用的项目，打开<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo1.png" alt=""></p><p>然后选择一些通用的设置<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo2.png" alt=""></p><p>2.登陆 GitHub –Settings -Developer Settings 选项，找到 Personal access tokens 页面。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo3.png" alt=""></p><p>点击右上角的 Generate new token 按钮会生成新的token，点击后提示输入密码后继续，然后来到如下界面。<br>取个名字，勾选相应权限，这里只需要 repo 下全部和 user 下的 user:email 即可。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo4.png" alt=""></p><p>生成完成后，将该token拷贝下来。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo5.png" alt=""></p><p><strong>如果需要将代码同时部署到 Coding 类似</strong>：<br>3.登陆 Coding ，账户 -访问令牌，新建访问令牌：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding1.png" alt=""></p><p>勾选相应权限：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding2.png" alt=""></p><p>4.将上面获取到的token添加到 Environment Variables 部分，值为该 token ，而名称为 GH_TOKEN、CD_TOKEN 。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo6.png" alt=""></p><h1 id="创建-travis-yml"><a href="#创建-travis-yml" class="headerlink" title="创建 .travis.yml"></a>创建 .travis.yml</h1><p>要想自动部署还需在博客源码新增加 <code>.travis.yml</code> 配置文件。</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - npm install -g hexo-cliinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:    - cd ./public    - git init    - git config user.name &quot;yourname&quot; # 修改name    - git config user.email &quot;youremail&quot; # 修改email    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master     # GH_TOKEN 是在 Travis 中配置 token 的名称branches:    only:        - master #只监测 master 分支，master是我的分支的名称，可根据自己情况设置env:    global:        - GH_REF: github.com/yourname/yourname.github.io.git         # 设置 GH_REF，注意更改 yourname</code></pre><h1 id="实现自动部署"><a href="#实现自动部署" class="headerlink" title="实现自动部署"></a>实现自动部署</h1><p>将原代码 push 到 Github 即可，如果配置没问题就该自动构建了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>虽然实现了基本的自动部署，还是有问题的。</p><h2 id="master-commit-树被清空"><a href="#master-commit-树被清空" class="headerlink" title="master commit 树被清空"></a>master commit 树被清空</h2><p>自动部署会把原来的 commit 清空，显然不是我们想要的结果。</p><p>为了解决这个问题，将配置文件改为了如下的内容：</p><pre><code class="TXT">after_script:    - git clone https://${GH_REF} .deploy_git    - cd .deploy_git    - git checkout master    - cd ../    - mv .deploy_git/.git/ ./public/    - cd ./public    - git config user.name &quot;yourname&quot;    - git config user.email &quot;your email&quot;    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master</code></pre><h2 id="添加-commit-时间戳"><a href="#添加-commit-时间戳" class="headerlink" title="添加 commit 时间戳"></a>添加 commit 时间戳</h2><p>commit 的描述一直是 <code>Travis CI Auto Builder</code> 。</p><pre><code class="TXT">Travis CI Auto BuilderTravis CI Auto BuilderTravis CI Auto Builder// 之前Site updated: 2017-11-07 22:05:16Site updated: 2017-11-07 17:19:32Site updated: 2017-11-06 18:04:53</code></pre><p>最终 <code>.travis.yml</code> 配置文件：</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - export TZ=&#39;Asia/Shanghai&#39;  - npm install -g hexo-cli  - chmod +x ./publish-to-gh-pages.shinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:  - ./publish-to-gh-pages.shenv:    global:        - GH_REF: github.com/yourname/yourname.github.io.git        # 设置GH_REF，注意更改成自己的仓库地址        - CD_REF: git.coding.net/yourname/repository.git        # 同时部署到 Coding，repository 为仓库名称</code></pre><p>其中 <code>publish-to-gh-pages.sh</code> 文件：</p><pre><code class="TXT">#!/bin/bashset -evgit clone https://${GH_REF} .deploy_gitcd .deploy_gitgit checkout mastercd ../mv .deploy_git/.git/ ./public/cd ./publicgit config user.name  &quot;yourname&quot;git config user.email &quot;youremail&quot;git add .git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot;git push --force --quiet &quot;https://${TravisCIToken}@${GH_REF}&quot; master:mastergit push --force --quiet &quot;https://yourname:${CD_TOKEN}@${CD_REF}&quot; master:master# 同时部署到 Coding，注意修改 yourname</code></pre><blockquote><p>参考资料<br>1、使用Travis CI自动部署Hexo博客<br><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" rel="external nofollow noopener noreferrer" target="_blank">http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a><br>2、使用 Travis CI 自动部署 Hexo<br><a href="http://www.jianshu.com/p/5e74046e7a0f" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/5e74046e7a0f</a><br>3、使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器<br><a href="https://segmentfault.com/a/1190000009054888" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000009054888</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.wshunli.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="TravisCI" scheme="http://www.wshunli.com/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/2a9bf8cf.html"/>
    <id>http://www.wshunli.com/posts/2a9bf8cf.html</id>
    <published>2017-11-09T06:52:46.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>这部分学习 ES6 中新增的数据类型。</p><h1 id="第10章-Symbol"><a href="#第10章-Symbol" class="headerlink" title="第10章 Symbol"></a>第10章 Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。</p><pre><code class="JavaScript">let s = Symbol();typeof s // &quot;symbol&quot;// 字符串参数let s1 = Symbol(&#39;foo&#39;);s1.toString() // &quot;Symbol(foo)&quot;// 对象参数-调用 toString 方法const obj = {  toString() {    return &#39;abc&#39;;  }};const sym = Symbol(obj);sym // Symbol(abc)</code></pre><p>Symbol 值不能与其他类型的值进行运算；可显式转为字符串或布尔值，但不能转为数值。</p><pre><code class="JavaScript">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym // TypeError: can&#39;t convert symbol to string// 字符串String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;// 布尔值let sym = Symbol();Boolean(sym) // true!sym  // false</code></pre><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>Symbol 值唯一，能保证对象不会出现同名的属性。</p><pre><code class="JavaScript">let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = &#39;Hello!&#39;;// 第二种写法let a = {  [mySymbol]: &#39;Hello!&#39;};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });// 以上写法都得到同样结果console.log(a[mySymbol]); // &quot;Hello!&quot;</code></pre><pre><code class="JavaScript"></code></pre><h1 id="第11章-Set-和-Map-数据结构"><a href="#第11章-Set-和-Map-数据结构" class="headerlink" title="第11章 Set 和 Map 数据结构"></a>第11章 Set 和 Map 数据结构</h1><h1 id="第12章-Proxy"><a href="#第12章-Proxy" class="headerlink" title="第12章 Proxy"></a>第12章 Proxy</h1><h1 id="第13章-Reflect"><a href="#第13章-Reflect" class="headerlink" title="第13章 Reflect"></a>第13章 Reflect</h1><h1 id="第14章-Promise-对象"><a href="#第14章-Promise-对象" class="headerlink" title="第14章 Promise 对象"></a>第14章 Promise 对象</h1><h1 id="第15章-Iterator-和-for…of-循环"><a href="#第15章-Iterator-和-for…of-循环" class="headerlink" title="第15章 Iterator 和 for…of 循环"></a>第15章 Iterator 和 for…of 循环</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ECMAScript6入门" scheme="http://www.wshunli.com/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/281a70b1.html"/>
    <id>http://www.wshunli.com/posts/281a70b1.html</id>
    <published>2017-11-09T06:44:01.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(六) 学习JavaScript的一些高级技巧及实践方案。</strong>(22-25章)</p><h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><p>这部分后面再看吧，现在那么水，估计还用不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://www.wshunli.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/4d143b68.html"/>
    <id>http://www.wshunli.com/posts/4d143b68.html</id>
    <published>2017-11-08T13:12:48.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(五) 学习 JavaScript 对各数据载体的操作方法（如JSON、XML），学会 Ajax 的使用方法。</strong>(18-21章)</p><h1 id="第十八章-JavaScript-与-XML"><a href="#第十八章-JavaScript-与-XML" class="headerlink" title="第十八章 JavaScript 与 XML"></a>第十八章 JavaScript 与 XML</h1><h2 id="浏览器对-XML-DOM-的支持"><a href="#浏览器对-XML-DOM-的支持" class="headerlink" title="浏览器对 XML DOM 的支持"></a>浏览器对 XML DOM 的支持</h2><p>如何检测浏览器是否支持DOM2级XML：</p><pre><code class="JavaScript">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;,&quot;2.0&quot;);</code></pre><p>在支持DOM2级的浏览器中创建一个空白XML:</p><pre><code class="JavaScript">var xmldom = document.implemention.createDocument(namespaceUri,root,docype);</code></pre><p>通过 JavaScript 处理XML时，通常只使用参数root，这个参数指定的是XML DOM文档元素的标签名。</p><pre><code class="JavaScript">var xmldom = document.implementation.createDocument(&quot;&quot;,&quot;root&quot;,null);console.log(xmldom.documentElement.tagName);  //&quot;root&quot;var child = xmldom.createElement(&quot;child&quot;);xmldom.documentElement.appendChild(child);</code></pre><p><strong>DOMParser 类型</strong>：将 XML 解析为 DOM 文档。</p><p><strong>XMLSerializer 类型</strong>：将 DOM 文档序列化为 XML 字符串。</p><pre><code class="JavaScript">var parser = new DOMParser();var xmldom = parser.parseFromString(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;, &quot;text/xml&quot;);//convert back into XMLvar serializer = new XMLSerializer();var xml = serializer.serializeToString(xmldom);console.log(xml);</code></pre><h2 id="浏览器对XPath的支持"><a href="#浏览器对XPath的支持" class="headerlink" title="浏览器对XPath的支持"></a>浏览器对XPath的支持</h2><p>XPath 是设计用来在 DOM 文档中查找节点的一种手段。</p><h2 id="浏览器对XSLT的支持"><a href="#浏览器对XSLT的支持" class="headerlink" title="浏览器对XSLT的支持"></a>浏览器对XSLT的支持</h2><p>XSLT 是与 XML 相关的一种技术，它利用 XPath 将文档从一种表现形式转换成另一种表现形式。</p><h1 id="第十九章-E4X"><a href="#第十九章-E4X" class="headerlink" title="第十九章 E4X"></a>第十九章 E4X</h1><p>E4X 本身不是一门语言，它只是 ECMAScript 语言的可选扩展。<br>就其本身而言，E4X 为处理 XML 定义了新的语法，也定义了特定于 XML 的对象。</p><h1 id="第二十章-JSON"><a href="#第二十章-JSON" class="headerlink" title="第二十章 JSON"></a>第二十章 JSON</h1><p>JSON（Javascript Object Notaion，Javascript对象表示法）是一种数据格式。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON有3种类型的值：简单值、对象 和 数组。</p><ul><li>简单值：字符串、数值、布尔值、null（JSON不支持JavaScript的特殊值undefined）。</li><li>对象：一组无序键值对。值可为简单值，或对象和数组。</li><li>数组：一组有序值的列表。值可为简单值，或对象和数组。</li></ul><p>JSON不支持变量、函数 和 对象实例。</p><p><strong>简单值</strong>：最简单的 JSON 数据形式就是简单值。</p><pre><code class="JSON">6&quot;Hello World!&quot; //必须为双引号</code></pre><p>布尔值和 null 也是有效的 JSON 数据形式，但简单值往往是复杂数据结构的一部分。</p><p><strong>对象</strong>：</p><pre><code class="JSON">// JavaScript对象字面量：var object = {  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29};// JSON 表示方式如下：{  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29}</code></pre><p>JSON 对象 与 JavaScript 的对象字面量相比：首先，没有声明变量（JSON 中没有变量的概念）；其次，没有末尾的分号；JSON 对象的属性必须加双引号。</p><p><strong>数组</strong>：JSON 数组采用的就是 JavaScript 中的数组字面量形式。</p><pre><code class="JSON">// JavaScript 中的数组字面量：var values = [25, &quot;hi&quot;, true];// JSON 表示数组：[25, &quot;hi&quot;, true]</code></pre><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><p>ECMAScript5 对解析 JSON 进行了规范，定义了全局对象 JSON。</p><p>JSON 对象有两个方法：stringify() 和 parse()，分别用于把 JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。</p><pre><code class="JavaScript">var book = {        title: &quot;Professional JavaScript&quot;,        authors: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011    };var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);console.log(jsonText);// {&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011}var bookCopy =JSON.parse(jsonText);</code></pre><p><strong>序列化选项</strong>: JSON.stringify() 除了要序列化的 JavaScript 对象外，还可以接收另外两个参数指定以不同的方式序列化。<br>第一个参数是数据，第二个参数是个过滤器，可以是一个数组或函数；第三个参数是一个选项，表示是否在 JSON 字符串中保留缩进。</p><p>1.过滤结果：</p><p>如果过滤器参数是<strong>数组</strong>，那么 JSON.stringify()的结果中将只包含数组中列出的属性。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3}</code></pre><p>如果过滤器参数是<strong>函数</strong>，传入的函数接收两个参数，属性（键）名和属性值。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, function(key, value){   switch(key){       case &quot;authors&quot;:           return value.join(&quot;,&quot;)       case &quot;year&quot;:           return 5000;       case &quot;edition&quot;:           return undefined;       default:           return value;   }});//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000}</code></pre><p>2.字符串缩进</p><p>JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。<br>如果这个参数是一个<strong>数值</strong>，那它表示的是每个级别缩进的空格数。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, 4);</code></pre><p>结果：</p><pre><code class="JSON">{    &#39;title&#39;: &#39;Professional JavaScript&#39;,    &#39;authors&#39;: [        &#39;Nicholas C. Zakas&#39;    ],    &#39;edition&#39;: 3,    &#39;year&#39;: 2011}</code></pre><p>如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON 字符串中被用作缩进字符（不再使用空格）。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, &quot; - -&quot;);</code></pre><p>结果：</p><pre><code class="JSON">{ - -&#39;title&#39;: &#39;Professional JavaScript&#39;, - -&#39;authors&#39;: [ - - - -&#39;Nicholas C. Zakas&#39; - -], - -&#39;edition&#39;: 3, - -&#39;year&#39;: 2011}</code></pre><p>缩进字符串最长不能超过 10 个字符长。如果字符串长度超过了 10 个，结果中将只出现前 10 个字符。</p><p>3.toJSON()方法</p><p>给对象自定义 toJSON() 方法，返回其自身的 JSON 数据格式。</p><pre><code class="JavaScript">var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        toJSON: function(){            return this.title;        }    };var jsonText = JSON.stringify(book);console.log(jsonText);</code></pre><p>假设把一个对象传入 JSON.stringify()，序列化该对象的顺序如下：<br>(1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。<br>(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。<br>(3) 对第(2)步返回的每个值进行相应的序列化。<br>(4) 如果提供了第三个参数，执行相应的格式化。</p><p><strong>解析选项</strong>：JSON.parse() 方法也可以接收另一个参数，该参数是一个函数（还原函数），将在每个键值对儿上调用。<br>如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</p><pre><code class="JavaScript"> var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        releaseDate: new Date(2011, 11, 1)    };var jsonText = JSON.stringify(book);console.log(jsonText);var bookCopy = JSON.parse(jsonText, function(key, value){    if (key == &quot;releaseDate&quot;){        return undefined;    } else {        return value;    }});console.log(&quot;releaseDate&quot; in bookCopy);</code></pre><h1 id="第二十一章-Ajax-与-Comet"><a href="#第二十一章-Ajax-与-Comet" class="headerlink" title="第二十一章 Ajax 与 Comet"></a>第二十一章 Ajax 与 Comet</h1><p>Ajax(Asynchronous Javascript + XML)技术的核心是 XMLHttpRequest 对象，即: XHR。<br>它所指的仅仅是<strong>无须刷新页面即可从服务器端获取数据</strong>的技术，其通信与数据格式无关，并不一定是 XML 数据。</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p><strong>XHR的用法</strong>：</p><p>使用 XMLHttpRequest 构造函数来创建 XHR 对象。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();</code></pre><p>使用 XHR对象的时候，要调用的第一个方法是open()，它接受3个参数:</p><ol><li>要发送请求的类型，如: get/post</li><li>请求的 url</li><li>是否异步发送请求，这个参数是一个布尔值</li></ol><p>再调用 send() 方法，才会真正发起 ajax 请求。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.php&#39;, false)xhr.send(null);</code></pre><p>本例中的请求是同步的，Javascript 代码会等到服务器响应之后再执行。<br>收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性有:</p><ul><li>responseText: 作为响应主体被返回的文本。</li><li>responseXML: 如果响应的内容类型是 “text/xml” 或者 “application/xml”，那么这个属性中将保存着包含响应数据的 XML DOM 文档。</li><li>status: 响应的 HTTP 状态。</li><li>statusText: HTTP 状态的说明。</li></ul><p>发送异步请求：JavaScript 继续执行而不必等待。<br>此时，我们可以检测readyState属性，该属性表示请求/响应过程的当前活动阶段。它的可取值有如下几种：</p><ul><li>0: 未初始化。 尚未调用 open() 方法。</li><li>1: 启动。 已经调用open()方法，但，尚未调用send()方法。</li><li>2: 发送。 已经调用send()方法，但，尚未接收到响应。</li><li>3: 接收。 已经接收到部分响应数据。</li><li>4: 完成。 已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p>readyState 属性的每一次变化，都会触发一次 readyStateChange 事件，我们可以利用这个事件来检测 readyState 值。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    if(xhr.readyState == 4){        if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){            console.log(xhr.responseText);        }        else{            console.log(&#39;fail, &#39; + xhr.status);        }    }}xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.send(null);</code></pre><p>在接收到响应之前，可以调用 abort() 方法来取消异步请求。</p><pre><code class="JavaScript">xhr.abort();</code></pre><p><strong>HTTP 头部信息</strong>：XHR 对象提供了操作头部信息的方法，包括对请求头部和响应头部的操作。</p><p>默认情况下，发送XHR请求的同时，还会发送以下头部信息:</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language: 浏览器当前设置的语言</li><li>Connection: 浏览器与服务器之间的连接类型</li><li>Cookie: 当前页面的任何Cookie</li><li>Host: 发出请求的页面，所在的域</li><li>Referer: 发出请求的页面的URI</li><li>User-Agent: 浏览器的用户代理字符串</li></ul><p>setRequestHeader()：自定义的头部信息。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.setRequestHeader(&quot;MySite&quot;, &quot;wshunli.com&quot;);xhr.send(null);</code></pre><p>getResponseHeader()：获取响应头部信息。</p><pre><code class="JavaScript">var mySite = xhr.getResponseHeader(&#39;MySite&#39;); // wshunli.com</code></pre><p>getAllResponseHeaders()：在服务器端，也可以利用头部信息向浏览器发送额外的结构化数据。</p><pre><code class="JavaScript">var allHeaders = xhr.getAllResponseHeaders();// 返回内容Date: Sun, 14 Nov 2004 18:04:22 GMTServer: Apache/1.3.29 (Unix)Vary: AcceptX-Powerd-By: PHP/4.3.8Connection: closeContent-Type: text/html; charset=iso-8859-1</code></pre><p><strong>GET 请求</strong>：向服务器查询某些信息。</p><pre><code class="JavaScript">xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true);</code></pre><p><strong>POST 请求</strong>：向服务器发送应该被保存的数据。</p><pre><code class="JavaScript">xhr.open(&quot;post&quot;, &quot;post.php&quot;, true);xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);var form = document.getElementById(&quot;my-form&quot;);xhr.send(serialize(form));</code></pre><h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><p><strong>FormData</strong>：</p><p>XMLHttpRequest 2 级定义了 FormData 类型，来处理表单数据的序列化，以及创建与表单格式相同的数据。</p><pre><code class="JavaScript">var data = new FormData();// 添加键值对data.append(&#39;site&#39;, &#39;wshunli.com&#39;);// 直接传入表单元素var data = new FormData(document.forms[0]);</code></pre><p>创建 FromData 的实例后，就可以传给 XHR 的 send() 方法。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest(); ···var form = document.getElementById(&#39;site-info&#39;);xhr.send(new FormData(form));</code></pre><p>XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。</p><p><strong>超时设定</strong>：</p><p>XHR 对象添加了一个 timeout 属性，表示请求在等待多少毫秒之后就终止。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    try{        if(xhr.readyState == 4){            if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){                console.log(xhr.responseText);            }            else{                console.log(&#39;fail, &#39; + xhr.status);            }        }    }    catch(ex){    }}xhr.open(&#39;get&#39;, &#39;example.php&#39;, true);xhr.timeout = 1000; // 1秒超时，仅适用IE8+xhr.ontimeout = function(){    console.log(&#39;fail, timeout&#39;);}xhr.send(null);</code></pre><p>在给 timeout 设置一个数值后，如果在规定时间内浏览器没有接收到响应信息，就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。<br>如果在超时终止请求之后再访问 status 属性，就会导致错误。因此，将相关的代码封装到 try-catch 语句中。</p><p><strong>overrideMimeType() 方法</strong>：重写 XHR 响应的 MIME 类型。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.open(&#39;get&#39;, &#39;text.php&#39;, true);xhr.overrideMimeType(&#39;text/xml&#39;);xhr.send(null);</code></pre><h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><p>进度事件包括以下6个：</p><ul><li>loadstart: 在接收到响应数据的第一个字节时触发</li><li>progress: 在接收响应期间持续不断地触发</li><li>error: 在请求发生错误时触发</li><li>abort: 在因为调用 abort() 方法而终止连接时触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 在通信完成或者触发 error、abort 或 load 事件之后触发</li></ul><p>每个请求都从触发 loadstart 事件开始，接下来是一个或多个 progress 事件，然后触发 error、abort 或者 load 事件中的一个，最后以触发 loadend 事件结束。</p><p><strong>load 事件</strong>：响应接收完毕后将触发 load 事件，因此就没有必要再去检查 readyState 属性了。</p><p><strong>progress 事件</strong>：progress 事件会在浏览器接收新数据的过程中周期性地被触发。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.onload = function(){    if( (xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300) || xhr.status ==304 ){        console.log(xhr.responseText);    }    else{        console.log(&#39;fail, &#39; + xhr.status);    }}xhr.onprogress = function(event){    var statusDiv = document.getElementById(&#39;status&#39;);    if( event.lengthComputable ){        statusDiv.innerHTML = &#39;Received &#39; + event.position + &#39; of &#39; + event.totalSize + &#39; bytes&#39;;    }}xhr.open(&#39;get&#39;, &#39;progress.php&#39;, true);xhr.send(null);</code></pre><p>onprogress 事件处理程序，会接收到一个event对象，其 target 属性是 XHR 对象。<br>event 对象还包含了另外3个额外属性：lengthComputable、position、totalSize。</p><ul><li>lengthComputable 是一个布尔值，它表示进度信息是否可用；</li><li>position 表示已经接收的字节数；</li><li>totalSize 表示根据 Content-Length 响应头确定的预期字节数。</li></ul><h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）：使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。IE中要使用XDR对象实现，其他浏览器XHR对象原生支持。</p><pre><code class="JavaScript">// 发送请求附加 Origin 头部Origin: http://www.wshunli.com// 响应请求Access-Control-Allow-Origin: http://www.wshunli.com</code></pre><p><strong>图像 Ping</strong>：动态创建图像经常用于图像 Ping 。</p><pre><code class="JavaScript">var img = new Image();img.onload = img.onerror = function(){    console.log(&#39;Done&#39;);}img.src = &#39;http://www.wshunli.com/test?action=click&#39;;</code></pre><p>我们可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。</p><p><strong>JSOUP</strong>：(JSON with padding，填充式 JSON 或参数式 JSON) 它看起来与 JSON 非常相似，只不过是被包含在函数调用中的 JSON。</p><pre><code class="JavaScript">function handleResponse(response){    console.log(&quot;You&#39;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);}var script = document.createElement(&quot;script&quot;);script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);</code></pre><p><strong>Comet</strong>: 一种服务器向页面推送数据的技术。</p><p>实现Comet有 2 种方式: 长轮询和流。<br>1.长轮询是相对于传统轮询(短轮询)而言的，传统轮询即浏览器定时向服务器发送请求，查看是否有数据更新。<br>而长轮询则是，页面向服务器发起一个请求后，服务器一直保持连接打开，直到有数据可以发送。<br>发送完数据后，浏览器关闭连接，随即又向服务器发起一个新的请求。<br>这一过程在页面打开期间一直持续不断。<br>2.另外一种实现 Comet 的方式就是HTTP流。流的特点是，在页面的整个生命周期内只有使用一个HTTP连接。<br>也就是说，浏览器向服务器发送一个请求后，服务器保持连接打开，然后周期性地向浏览器发送数据</p><p><strong>服务器发送事件</strong>：SSE(Server-Sent Events)服务器发送事件，是围绕只读 Comet 交互推出的 API 或者模式。</p><p><strong>Web Sockets</strong>：Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。</p><p>创建 Web Sockets，可以先实例一个 WebSocket 对象并传入要连接 URL:</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);</code></pre><p>实例化 WebSocket 对象之后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket也有一个表示当前状态的 readyState 属性。</p><ul><li>WebSocket.OPENING (0) : 正在建立连接</li><li>WebSocket.OPEN (1): 已经建立连接</li><li>WebSocket.CLOSING (2): 正在关闭连接</li><li>WebSocket.CLOSE (3): 已经关闭连接</li></ul><p>WebSocket 没有 readystatechange 事件，readyState 的值永远从0开始。<br>要关闭 Web Socket 连接，可以在任何时候调用close()方法。<br>调用该方法后，readyState 的值立即变为2(正在关闭)，当成功关闭连接后变为3。</p><pre><code class="JavaScript">socket.close();</code></pre><p>发送和接收数据：Web Socket 打开之后就可以通过连接发送和接收数据。</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);socket.send(&quot;Hello World!&quot;);</code></pre><p>Web Socket 只能通过连接发送纯文本数据，对于复杂数据必须进行序列化。</p><pre><code class="JavaScript">socket.onmessage = function(event){    var data = event.data;}</code></pre><p>当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。</p><p>WebSocket 对象的其他事件：<br>WebSocket对象还有其他3个事件，在连接生命周期的不同阶段触发。</p><ul><li>open: 在成功建立连接时触发</li><li>error: 在发生错误时触发，连接不能持续</li><li>close: 在连接关闭时触发</li></ul><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/server.php&#39;);socket.onopen = function(){    console.log(&#39;WebSocket Opened.&#39;)}socket.onerror = function(){    console.log(&#39;WebSocket Error.&#39;)}socket.onclose = function(){    console.log(&#39;WebSocket Closed.&#39;)}</code></pre><p>其中只有 close 事件的event的对象有额外的信息。这个事件的事件对象有3个额外属性: wasClean、code 和 reason。<br>其中，wasClean 是一个布尔值，表示连接是否已经明确关闭；code 是服务器返回的数值状态码；而 reason 是一个字符串，包含服务器发回的信息。</p><pre><code class="JavaScript">socket.onclose = function(event){    console.log(event.wasClean + &#39;,&#39; + event.code + &#39;,&#39; + event.reason);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://www.wshunli.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/228afe2f.html"/>
    <id>http://www.wshunli.com/posts/228afe2f.html</id>
    <published>2017-11-08T09:06:23.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(四) 学习在浏览器中进行实际开发时的错误调试技巧。</strong>(17章)</p><h1 id="第十七章-错误处理与调试"><a href="#第十七章-错误处理与调试" class="headerlink" title="第十七章 错误处理与调试"></a>第十七章 错误处理与调试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>try-catch 语句</strong>：</p><p>try-catch 语句 和 Java 很类似。</p><pre><code class="JavaScript">function testFinally(){    try {        return 2;    } catch (error){        return 1;    } finally {        return 0;    }}function testWithoutFinally(){    try {        return 2;    } catch (error){        return 1;    }}alert(testFinally());alert(testWithoutFinally());</code></pre><p>我们把可能会抛出错误的语句放到 try 语句中，处理错误的代码放到 catch 块中，finally 语句块无论如何都会执行。</p><p><strong>抛出错误</strong>：与 try-catch 语句相配的还有一个 throw 操作符，用于随时抛出自定义错误 。</p><p>在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时，代码才回继续执行。</p><pre><code class="JavaScript">if (!(values instanceof Array)){    throw new Error(&quot;process(): Argument must be an array.&quot;);}</code></pre><p>捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。</p><p><strong>常见的错误类型</strong>：类型转换错误、数据类型错误、通信错误。</p><h2 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h2><p><strong>将消息记录到控制台</strong>：通过 console 对象向 JavaScript 控制台中写入消息。</p><p>error(message): 将错误消息记录到控制台<br>info(message): 将信息性消息记录到控制台<br>log(message): 将一般消息记录到控制台<br>warn(message): 将警告消息记录到控制台</p><p><strong>将消息记录到当前页面</strong>：在页面中开辟一小块区域，用以显示消息。</p><p><strong>抛出错误</strong>：自定义 assert() 函数。<br>两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。</p><pre><code class="JavaScript">function assert(condition, message){    if (!condition){        throw new Error(message);    }}function divide(num1, num2){    assert(typeof num1 == &quot;number&quot; &amp;&amp; typeof num2 == &quot;number&quot;,            &quot;divide(): Both arguments must be numbers.&quot;);    return num1 / num2;}var result = divide(10, 23);result = divide(&quot;hi&quot;, 3);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://www.wshunli.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/95a7e74a.html"/>
    <id>http://www.wshunli.com/posts/95a7e74a.html</id>
    <published>2017-11-07T14:07:10.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/demobox.css">《JavaScript高级程序设计》读书笔记<br><br><a id="more"></a><p><strong>学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。</strong>(15-16章)</p><h1 id="第十五章-使用-Canvas-绘图"><a href="#第十五章-使用-Canvas-绘图" class="headerlink" title="第十五章 使用 Canvas 绘图"></a>第十五章 使用 Canvas 绘图</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>使用 <code>&lt;canves&gt;</code> 元素；指定 width 和 height 属性。</p><pre><code class="JavaScript">&lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;Your browser doesn&#39;t support canvas&lt;/canvas&gt;</code></pre><p>要在画布上绘制，还需取得绘图上下文。</p><pre><code class="JavaScript">var drawing = document.getElementById(&quot;drawing&quot;),//make sure &lt;canvas&gt; is completely supportedif (drawing.getContext){    var context = drawing.getContext(&quot;2d&quot;);}</code></pre><h2 id="2D-上下文"><a href="#2D-上下文" class="headerlink" title="2D 上下文"></a>2D 上下文</h2><p><strong>填充和描边</strong>：2D 上下文的两种基本绘图操作。<br>fillStyle 属性（填充）：指定的样式（颜色、渐变或图像）填充图形；<br>strokeStyle 属性（描边）：只在图形边缘画线。</p><p><strong>绘制矩形</strong>：矩形是唯一一种可以直接在 2D上下文中绘制的形状。</p><p>与矩形有关的方法包括fillRect()、strokeRect和clearRect()。<br>这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形的宽度和矩形高度。</p><div class="demobox"><div class="demobox-result"><canvas id="drawing" width="200" height="100">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing");if(t.getContext){var e=t.getContext("2d");e.fillStyle="#ff0000",e.fillRect(10,10,50,50),e.strokeStyle="rgba(0,0,255,0.5)",e.strokeRect(30,30,50,50),e.clearRect(40,40,10,10)}}()</script></div><div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x77E9;&#x5F62;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.strokeStyle = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>;</span><br><span class="line">    context.strokeRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.clearRect(<span class="number">40</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>绘制路径</strong>：</p><p>首先调用 beginPath() 方法；<br>然后调用一下方法：<br>arc(x,y,radius,startAngle,endAngle,bool);<br>arcTo(x1,y1,x2,y2,radius);<br>lineTo(x,y);<br>moveTo(x,y);<br>rect(x,y,w,h);<br>最后调用 closePath() 方法。</p><p><strong>绘制文本</strong>：fillText(str, x, y, width);strokeText(str, x, y, width)。</p>    <div class="demobox">      <div class="demobox-result">  <canvas id="drawing2" width="200" height="200">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing2");if(t.getContext){var e=t.getContext("2d");e.beginPath(),e.arc(100,100,99,0,2*Math.PI,!1),e.moveTo(194,100),e.arc(100,100,94,0,2*Math.PI,!1),e.moveTo(100,100),e.lineTo(100,15),e.moveTo(100,100),e.lineTo(35,100),e.stroke(),e.strokeText?(e.font="bold 14px Arial",e.textAlign="center",e.textBaseline="middle",e.fillText("12",100,20),e.textAlign="start",e.fillText("12",100,40),e.textAlign="end",e.fillText("12",100,60)):console.log("Your browser doesn't support the canvas text API.")}}()</script></div>    <div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x8DEF;&#x5F84;&#x548C;&#x6587;&#x672C;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">194</span>, <span class="number">100</span>);</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">100</span>, <span class="number">15</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">35</span>, <span class="number">100</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line">    <span class="keyword">if</span> (context.strokeText){</span><br><span class="line">        context.font = <span class="string">&quot;bold 14px Arial&quot;</span>;</span><br><span class="line">        context.textAlign = <span class="string">&quot;center&quot;</span>;</span><br><span class="line">        context.textBaseline = <span class="string">&quot;middle&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Your browser doesn&apos;t support the canvas text API.&quot;</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>变换</strong>：<br>rotate(angle): 围绕原点旋转图像angle角度。<br>scale(scaleX, scaleY): 缩放图像。<br>translate(x,y)：将坐标原点移到（x,y）。</p><p><strong>阴影</strong>：<br>shadowColor()<br>shadowOffsetX:x方向的阴影偏移量。<br>shadowOffsetY:y方向的阴影偏移量。<br>shadowBlur:模糊的像素数，默认为0不模糊。</p><p><strong>渐变</strong>：渐变由 CanvasGradient 实例表示。</p><p>线性渐变：createLinearGradient(x1,y1,x2,y2);</p><pre><code class="JavaScript">var gradient = context.createLinearGradient(30,30,70,70);    gradient.addColorStop(0,&quot;orange&quot;);    gradient.addColorStop(1, &quot;blue&quot;);    context.fillStyle = gradient;    context.fillRect(30, 30,70,70);</code></pre><p>径向渐变：createRadialGradient(x1,y1,r1,x2,y2,r2);</p><pre><code class="JavaScript">var gra = context.createRadialGradient(55,55,10,55,55,30);    gra.addColorStop(0, &quot;blue&quot;);    gra.addColorStop(1, &quot;orange&quot;);    context.fillStyle = gra;    context.fillRect(30,30,50,50);</code></pre><p><strong>模式</strong>：模式就是重复的图像，可以用来填充或描边图形。</p><p>createPattern(img, str);<br>img： 表示一个 HTML 的 img 元素；<br>str： 可取值 “repeat”、“repeat-x”、“repeat-y”和“no-repeat”。</p><pre><code class="JavaScript">var img = document.images[0];var pattern = context.createPattern(img, &quot;repeat&quot;);context.fillStyle = pattern;context.fillRect(10,10,150,150);</code></pre><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p>WebGL 是针对 Canvas 的 3D 上下文。</p><h1 id="第十六章-HTML5-脚本编程"><a href="#第十六章-HTML5-脚本编程" class="headerlink" title="第十六章 HTML5 脚本编程"></a>第十六章 HTML5 脚本编程</h1><h2 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h2><p>跨文档消息传递，简称XDM，指的是来自不同域的页面间传递消息。</p><p>postMessage() 发送消息：</p><pre><code class="JavaScript">var iframeWindow = document.getElementById(&quot;myFrame&quot;).contentWindow;iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wshunli.com&quot;);</code></pre><p>接收消息，触发 window 对象的 message 事件，异步方式。</p><pre><code class="JavaScript">window.addEventListener(&quot;message&quot;,function(){    if(event.origin == &quot;http://www.wshunli.com&quot;){//发送消息的文档所在的域      processMessage(event.data); //处理接收的数据      event.source.postMessage(&quot;Received!&quot;, &quot;http://github.com&quot;); //可选：向来源窗口发送回执  }},false)</code></pre><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p>HTML5新增了 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 两个标签。</p><pre><code class="JavaScript">&lt;video src=&quot;conference.mpg&quot; id=&quot;muvideo&quot;&gt;video palyer not available&lt;/video&gt;&lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;audio player not available&lt;/audio&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/demobox.css&quot;&gt;《JavaScript高级程序设计》读书笔记&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://www.wshunli.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章链接问题</title>
    <link href="http://www.wshunli.com/posts/261b7c4.html"/>
    <id>http://www.wshunli.com/posts/261b7c4.html</id>
    <published>2017-11-06T08:58:12.000Z</published>
    <updated>2017-11-14T14:39:22.182Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 文章链接问题<br><a id="more"></a></p><p>今天 <a href="https://www.google.com/search?safe=active&amp;q=site:wshunli.com" rel="external nofollow noopener noreferrer" target="_blank">搜索</a> 一下网站，发现有个很大的问题。</p><p>有很多链接 404，比如这个链接：</p><p><a href="http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/">http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/</a></p><p>搜索引擎跳转之后是：</p><p><a href="http://www.wshunli.com/2017/10/29/《javascript高级程序设计》读书笔记（一）/">http://www.wshunli.com/2017/10/29/《javascript高级程序设计》读书笔记（一）/</a></p><p>单单因为 <code>JavaScript</code> 大小写的问题，就找不到页面。</p><p>所以在 Hexo 官网找了一下固定链接的插件。</p><p>最终选择是： hexo-abbrlink ; Github ：<a href="https://github.com/rozbo/hexo-abbrlink" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/rozbo/hexo-abbrlink</a></p><p>安装插件：</p><pre><code class="TXT">npm install hexo-abbrlink --save</code></pre><p>在站点配置文件中修改 <code>permalink</code> ：</p><pre><code class="TXT">permalink: posts/:abbrlink.html</code></pre><p>站点配置文件中配置插件：</p><pre><code class="TXT"># abbrlink configabbrlink:  alg: crc32  #support crc16(default) and crc32  rep: hex    #support dec(default) and hex</code></pre><p>链接效果：</p><pre><code class="TXT">crc16 &amp; hexhttps://www.wshunli.com/posts/66c8.htmlcrc16 &amp; dechttps://www.wshunli.com/posts/65535.htmlcrc32 &amp; hexhttps://www.wshunli.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://www.wshunli.com/posts/1690090958.html</code></pre><p>更多内容参考：<a href="https://post.zz173.com/detail/hexo-abbrlink.html" rel="external nofollow noopener noreferrer" target="_blank">https://post.zz173.com/detail/hexo-abbrlink.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 文章链接问题&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.wshunli.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/67855b9d.html"/>
    <id>http://www.wshunli.com/posts/67855b9d.html</id>
    <published>2017-11-05T12:01:26.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>ES6 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><h1 id="字符、数值、正则的扩展"><a href="#字符、数值、正则的扩展" class="headerlink" title="字符、数值、正则的扩展"></a>字符、数值、正则的扩展</h1><p>第4章 字符串的扩展：<a href="http://es6.ruanyifeng.com/#docs/string" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/string</a><br>第5章 数值的扩展：<a href="http://es6.ruanyifeng.com/#docs/array" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/array</a><br>第6章 正则的扩展：<a href="http://es6.ruanyifeng.com/#docs/regex" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/regex</a></p><h1 id="第7章-数组的扩展"><a href="#第7章-数组的扩展" class="headerlink" title="第7章 数组的扩展"></a>第7章 数组的扩展</h1><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符是三个点（<code>...</code>），将一个数组转为用逗号分隔的参数序列。</p><pre><code class="JavaScript">console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5function push(array, ...items) {  array.push(...items);}function add(x, y) {  return x + y;}const numbers = [4, 38];add(...numbers); // 42</code></pre><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><pre><code class="JavaScript">let arrayLike = {    &#39;0&#39;: &#39;a&#39;,    &#39;1&#39;: &#39;b&#39;,    &#39;2&#39;: &#39;c&#39;,    length: 3};// ES5的写法var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]// ES6的写法let arr2 = Array.from(arrayLike);    // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of 方法用于将一组值，转换为数组。</p><pre><code class="JavaScript">Array.of(3, 11, 8) // [3,11,8]</code></pre><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h2><p>数组实例的 copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</p><pre><code class="JavaScript">Array.prototype.copyWithin(target, start = 0, end = this.length)</code></pre><p>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p><pre><code class="JavaScript">[1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5]</code></pre><h2 id="find-amp-findIndex"><a href="#find-amp-findIndex" class="headerlink" title="find() &amp; findIndex()"></a>find() &amp; findIndex()</h2><p>数组实例的 find() 方法，用于找出第一个符合条件的数组成员。<br>它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。</p><pre><code class="JavaScript">[1, 5, 10, 15].find(function(value, index, arr) {  return value &gt; 9;}) // 10</code></pre><p>find() 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><pre><code class="JavaScript">[1, 5, 10, 15].findIndex(function(value, index, arr) {  return value &gt; 9;}) // 2</code></pre><p>findIndex() 方法的用法与 find() 方法非常类似，返回第一个符合条件的数组成员的位置</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p>数组实例的 fill() 方法使用给定值，填充一个数组。</p><pre><code class="JavaScript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7); // [7, 7, 7]new Array(3).fill(7); // [7, 7, 7]// 第二个和第三个参数，用于指定填充的起始位置和结束位置。[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2); // [&#39;a&#39;, 7, &#39;c&#39;]</code></pre><h2 id="entries-，keys-和-values"><a href="#entries-，keys-和-values" class="headerlink" title="entries()，keys() 和 values()"></a>entries()，keys() 和 values()</h2><p>ES6 提供三个新的方法 – entries()，keys() 和 values() – 用于遍历数组。<br>可以用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p><pre><code class="JavaScript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {  console.log(index);}// 0// 1for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {  console.log(elem);}// &#39;a&#39;// &#39;b&#39;for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {  console.log(index, elem);}// 0 &quot;a&quot;// 1 &quot;b&quot;</code></pre><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p><pre><code class="JavaScript">[1, 2, 3].includes(2)     // true[1, 2, 3].includes(4)     // false[1, 2, NaN].includes(NaN) // true// 第二个参数表示搜索的起始位置，默认为0[1, 2, 3].includes(3, 3);  // false</code></pre><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。</p><pre><code class="JavaScript">Array(3) // [, , ,]</code></pre><p>ES6 明确将空位转为 undefined。</p><pre><code class="JavaScript">Array.from([&#39;a&#39;,,&#39;b&#39;]); // [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p><h1 id="第8章-函数的扩展"><a href="#第8章-函数的扩展" class="headerlink" title="第8章 函数的扩展"></a>第8章 函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><pre><code class="JavaScript">function log(x, y = &#39;World&#39;) {  console.log(x, y);}log(&#39;Hello&#39;)          // Hello Worldlog(&#39;Hello&#39;, &#39;China&#39;) // Hello Chinalog(&#39;Hello&#39;, &#39;&#39;)      // Hello</code></pre><p>参数默认值是惰性求值的。</p><p><strong>与解构赋值默认值结合使用</strong>：</p><p>函数默认值生效：当前参数没有传值或传值为 undefined ；<br>解构赋值默认值生效：当前参数传值或没有传值而默认值与 undefined 严格相等。</p><pre><code class="JavaScript">// 写法一function m1({x = 0, y = 0} = {}) {  return [x, y];}// 写法二function m2({x, y} = { x: 0, y: 0 }) {  return [x, y];}m1()               // [0, 0]m2()               // [0, 0]m1( {x: 3, y: 8} ) // [3, 8]m2( {x: 3, y: 8} ) // [3, 8]m1( {x: 3} )       // [3, 0]m2( {x: 3} )       // [3, undefined]m1( {} )           // [0, 0];m2( {} )           // [undefined, undefined]m1( {z: 3} )       // [0, 0]m2( {z: 3} )       // [undefined, undefined]</code></pre><p>区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><p><strong>参数默认值的位置</strong>：</p><p>定义了默认值的参数应该是函数的尾参数，否则这个参数不能省略。</p><pre><code class="JavaScript">// 例一：默认值的参数在前function f(x = 1, y) {  console.log([x, y]);}f();             // [1, undefined]f(2);            // [2, undefined]f(, 1);          // 报错f(undefined, 1); // [1, 1]// 例二：默认值的参数在后function f(x , y= 1) {  console.log([x, y]);}f();             // [undefined, 1]f(2);            // [2, 1]f(2, );          // [2, 1]f(2, undefined); // [2, 1]</code></pre><p>undefined 能触发默认值，null 不能。</p><pre><code class="JavaScript">function foo(x = 5, y = 6) {  console.log(x, y);}foo(undefined, null); // 5 null</code></pre><p><strong>函数的 length 属性</strong>：没有指定默认值的参数个数。</p><p><strong>作用域</strong>：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。</p><pre><code class="JavaScript">var x = 1;function f(x, y = x) {  console.log(y);}f();  // undefinedf(2); // 2// x 没有定义，所以指向外部全局变量 xlet x = 1;function f(y = x) {  let x = 2;  console.log(y);}f();  // 1f(3); // 3</code></pre><p>更复杂的例子：</p><pre><code class="JavaScript">var x = 1; // 全局变量function foo(x, y = function() { x = 2; }) { //函数参数作用域  var x = 3; // 函数内部变量  y();  console.log(x);}foo();          // 3 - 第5行console.log(x); // 1</code></pre><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数。</p><pre><code class="JavaScript">function add(...values) {  let sum = 0;  for (var val of values) {    sum += val;  }  return sum;}add(2, 5, 3); // 10</code></pre><p>rest 参数搭配的变量为数组，arguments 为类似数组的对象。<br>rest 参数之后不能再有其他参数；函数的 length 属性，也不包括 rest 参数。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的 name 属性，返回该函数的函数名。</p><pre><code class="JavaScript">function foo() {}foo.name // &quot;foo&quot;var f = function () {};f.name // &quot;&quot; - ES5f.name // &quot;f&quot; - ES6</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><pre><code class="JavaScript">var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) {  return num1 + num2;};</code></pre><p>箭头函数有几个使用注意点：<br>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。<br>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p><pre><code class="JavaScript">function foo() {  setTimeout(() =&gt; {    console.log(&#39;id:&#39;, this.id);  }, 100);}var id = 21;foo.call({ id: 42 }); // id: 42</code></pre><p>箭头函数 this 指向定义时所在的对象。</p><pre><code class="JavaScript">function Timer() {  this.s1 = 0;  this.s2 = 0;  setInterval(() =&gt; this.s1++, 1000); // 箭头函数  setInterval(function () {           // 普通函数    this.s2++;  }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100); // s1: 3setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100); // s2: 0</code></pre><p>前者的 this 绑定定义时所在的作用域（即Timer函数），后者的 this 指向运行时所在的作用域（即全局对象）。</p><p>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。</p><pre><code class="JavaScript">// ES6function foo() {  setTimeout(() =&gt; {    console.log(&#39;id:&#39;, this.id);  }, 100);}// ES5function foo() {  var _this = this;  setTimeout(function () {    console.log(&#39;id:&#39;, _this.id);  }, 100);}</code></pre><p>由于没有 this，因而也不存在通过 bind()、call()、apply() 来改变 this 的指向。</p><p><strong>嵌套的箭头函数</strong>：箭头函数内部，还可以再使用箭头函数。</p><pre><code class="JavaScript">let insert = (value) =&gt; ({into: (array) =&gt; ({after: (afterValue) =&gt; {  array.splice(array.indexOf(afterValue) + 1, 0, value);  return array;}})});// 等价于function insert(value) {  return {into: function (array) {    return {after: function (afterValue) {      array.splice(array.indexOf(afterValue) + 1, 0, value);      return array;    }};  }};}// 结果相同insert(2).into([1, 3]).after(1); //[1, 2, 3]</code></pre><h2 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h2><p>函数绑定运算符是并排的两个冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><pre><code class="JavaScript">foo::bar;// 等同于bar.bind(foo);</code></pre><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><pre><code class="JavaScript">var method = obj::obj.foo;// 等同于var method = ::obj.foo;</code></pre><p>双冒号运算符的运算结果，还是一个对象，因此可以采用链式写法。</p><pre><code class="JavaScript">let { find, html } = jake;document.querySelectorAll(&quot;div.myClass&quot;)::find(&quot;p&quot;)::html(&quot;hahaha&quot;);</code></pre><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用（Tail Call）是指某个函数的最后一步是调用另一个函数。</p><pre><code class="JavaScript">function f(x) {  if (x &gt; 0) {    return m(x)  }  return n(x);}</code></pre><p><strong>尾调用优化</strong>：即只保留内层函数的调用帧。</p><p>函数调用会在内存形成一个调用记录即“调用帧”，如果函数 A 调用函数 B ，还会形成一个 B 的调用帧，依次类推形成一个调用栈。</p><p>如果函数存在尾调用，只保留最后的函数的调用帧即可，这将大大节省内存。</p><pre><code class="JavaScript">function f() {  let m = 1;  let n = 2;  return g(m + n);}f();// 等同于function f() {  return g(3);}f();// 等同于g(3);</code></pre><p>执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p><p>注意，只有不再用到外层函数的内部变量才能进行“尾调用优化”。<br>下面函数就不会进行“尾调用优化”。</p><pre><code class="JavaScript">function addOne(a){  var one = 1;  function inner(b){    return b + one;  }  return inner(a);}</code></pre><p><strong>尾递归</strong>：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><pre><code class="JavaScript">function factorial(n) {  if (n === 1) return 1;  return n * factorial(n - 1);}factorial(5) // 120// 改写成尾递归function factorial(n, total) {  if (n === 1) return total;  return factorial(n - 1, n * total);}facorial(5, 1) // 120</code></pre><h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><p>ES2017 允许函数的最后一个参数有尾逗号。</p><pre><code class="JavaScript">function clownsEverywhere(  param1,  param2,) { /* ... */ }clownsEverywhere(  &#39;foo&#39;,  &#39;bar&#39;,);</code></pre><h1 id="第9章-对象的扩展"><a href="#第9章-对象的扩展" class="headerlink" title="第9章 对象的扩展"></a>第9章 对象的扩展</h1><h2 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h2><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p><pre><code class="JavaScript">const foo = &#39;bar&#39;;const baz = {foo};// 等同于const baz = {foo: foo};</code></pre><p>除了属性简写，方法也可以简写。</p><pre><code class="JavaScript">const o = {  method() {    return &quot;Hello!&quot;;  }};// 等同于const o = {  method: function() {    return &quot;Hello!&quot;;  }};</code></pre><h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p><pre><code class="JavaScript">// 方法一obj.foo = true;// 方法二obj[&#39;a&#39; + &#39;bc&#39;] = 123;</code></pre><p>如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。<br>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名。</p><pre><code class="JavaScript">let lastWord = &#39;last word&#39;;const a = {  &#39;first word&#39;: &#39;hello&#39;,  [lastWord]: &#39;world&#39;};a[&#39;first word&#39;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#39;last word&#39;] // &quot;world&quot;</code></pre><p>表达式还可以用于定义方法名。</p><pre><code class="JavaScript">let obj = {  [&#39;h&#39; + &#39;ello&#39;]() {    return &#39;hi&#39;;  }};obj.hello(); // hi</code></pre><p>注意：属性名表达式与简洁表示法不能同时使用；属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 <code>[object Object]</code>。</p><h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p><pre><code class="JavaScript">const person = {  sayName() {    console.log(&#39;hello!&#39;);  },};person.sayName.name   // &quot;sayName&quot;</code></pre><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES6 提出“Same-value equality”（同值相等）算法，用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。。</p><pre><code class="JavaScript">Object.is(&#39;foo&#39;, &#39;foo&#39;); // trueObject.is({}, {});       // false</code></pre><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><pre><code class="JavaScript">+0 === -0           // trueNaN === NaN         // falseObject.is(+0, -0)   // falseObject.is(NaN, NaN) // true</code></pre><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign() 方法用于对象的合并，将源对象（source）的所有<strong>可枚举属性</strong>，复制到目标对象（target）。</p><pre><code class="JavaScript">const target = { a: 1 };const source1 = { b: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3}</code></pre><p>Object.assign() 方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>如果 undefined 或 null 作为第一个参数会报错，在之后则会跳过；<br>数值、布尔值可以被转换成包装对象，但依然会被忽略；<br>字符串转对象会被拆分成数组，除了原始值会被拷贝到<code>[[PrimitiveValue]]</code>属性中，每个字符都是可枚举的实义属性，因此是有效的。</p><pre><code class="JavaScript">const v1 = &#39;abc&#39;;const v2 = true;const v3 = 10;const obj = Object.assign({}, v1, v2, v3);console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</code></pre><p>Object.assign() 只拷贝对象的自有属性，属性名为 Symbol 的属性也会被拷贝，继承属性和不可枚举的属性不会被拷贝。<br>Object.assign() 执行的是浅拷贝，对于同名属性会直接覆盖而非合并。<br>Object.assign() 可以用于处理数组，但会把数组转换成属性名为 0、1、2…… 的对象，并依次替换。</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES2017 引入了 <code>Object.getOwnPropertyDescriptors()</code> ，返回指定对象所有自身属性（非继承属性）的描述对象。</p><h2 id="Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="Object.setPrototypeOf()，Object.getPrototypeOf()"></a>Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p><code>__proto__属性</code>:（前后各两个下划线），用来读取或设置当前对象的prototype对象。</p><p><strong>Object.setPrototypeOf()</strong>: 作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数对象本身。<br><strong>Object.getPrototypeOf()</strong>: 读取一个对象的原型对象。</p><h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><p>ES5 引入了 Object.keys() 来返回一个数组，其成员是参数对象的可枚举的自有属性的键名。<br>ES2017 跟着引入了 Object.values() 和 Object.entries() 用于返回属性对应的值，以及以键值对数组的形式返回。<br>可以配合 for…of 循环使用。</p><h2 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。</p><p><strong>可枚举性</strong>：描述对象的 enumerable 属性，如果该属性为false，就表示某些操作会忽略当前属性。</p><p>for…in 循环、Object.keys()、JSON.stringify()、Object.assign() 忽略 enumerable 为 false 的属性。</p><p>ES6 一共有5种方法可以遍历对象的属性。</p><ol><li><code>for...in</code>：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li><li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</li><li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</li><li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li><li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li></ol><p>以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。</p><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p>ES2017 将这个运算符引入了对象。</p><p><strong>解构赋值</strong>:对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。</p><pre><code class="JavaScript">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };x // 1y // 2z // { a: 3, b: 4 }</code></pre><p>解构赋值必须是最后一个参数，否则会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><p><strong>扩展运算符</strong>:</p><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre><code class="JavaScript">let z = { a: 3, b: 4 };let n = { ...z }; // { a: 3, b: 4 }</code></pre><p>扩展运算符可以用于合并两个对象。</p><pre><code class="JavaScript">let ab = { ...a, ...b };// 等同于let ab = Object.assign({}, a, b);</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre><code class="JavaScript">let newVersion = {  ...previousVersion,  name: &#39;New Name&#39; // Override the name property};</code></pre><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><pre><code class="JavaScript">let aWithDefaults = { x: 1, y: 2, ...a };// 等同于let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);</code></pre><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p><pre><code class="JavaScript">// 空对象没有任何效果{...{}, a: 1} // { a: 1 }// 忽略 null 和 undefinedlet emptyObject = { ...null, ...undefined }; // 不报错</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ECMAScript6入门" scheme="http://www.wshunli.com/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/ebc6af5b.html"/>
    <id>http://www.wshunli.com/posts/ebc6af5b.html</id>
    <published>2017-11-05T03:36:26.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>《JavaScript高级程序设计》中学习了前八章，后面是一些 DOM 相关的知识，现在开始学习 ES6 语法。</p><p><a href="http://es6.ruanyifeng.com/" rel="external nofollow noopener noreferrer" target="_blank">《ECMAScript6入门》</a> 作者：阮一峰。</p><h1 id="第1章-ECMAScript6-简介"><a href="#第1章-ECMAScript6-简介" class="headerlink" title="第1章 ECMAScript6 简介"></a>第1章 ECMAScript6 简介</h1><p>ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等。</p><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码。<br>ESLint 用于静态检查代码的语法和风格；Mocha 则是一个测试框架。</p><h1 id="第2章-let-和-const-命令"><a href="#第2章-let-和-const-命令" class="headerlink" title="第2章 let 和 const 命令"></a>第2章 let 和 const 命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>let 命令只在其所在的代码块内有效。</p><pre><code class="JavaScript">{  let a = 10;  var b = 1;}console.log(a); // ReferenceError: a is not defined.console.log(b); // 1</code></pre><p>前面闭包中有说：闭包只能取得函数中任何变量的最后一个值。</p><pre><code class="JavaScript">var a = [];for (var i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 10</code></pre><p>使用 let 声明的变量仅在块级作用域内有效。</p><pre><code class="JavaScript">var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6</code></pre><p>其实 i 仅在当前循环有效。每循环一次就是一个新的变量。</p><p><strong>1.不存在变量提升</strong>：var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined；let 变量声明前使用会报错。</p><pre><code class="JavaScript">console.log(c); // ReferenceError: a is not defined.console.log(d); // undefinedlet c;var d;</code></pre><p><strong>2.暂时性死区</strong>：在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。</p><pre><code class="JavaScript">var tmp = 123;if (true) {  tmp = &#39;abc&#39;; // ReferenceError  let tmp;}</code></pre><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><p><strong>3.不允许重复声明</strong>：let 不允许在相同作用域内，重复声明同一个变量。也不能在函数内部重新声明参数。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>第一种场景，内层变量可能会覆盖外层变量；第二种场景，用来计数的循环变量泄露为全局变量。</p><p>let 实际上为 JavaScript 新增了块级作用域。</p><pre><code class="JavaScript">function f1() {  let n = 5;  if (true) {    let n = 10;  }  console.log(n); // 5}</code></pre><p>内部代码块可以定义外层作用域的同名变量；外层作用域无法读取内层作用域的变量，也不受内层代码块的影响。</p><p><strong>块级作用域与函数声明</strong>：ES6 允许在块级作用域之中声明函数，但函数在块级作用域之外不可引用。<br>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p>const声明一个只读的常量。一旦声明，就必须立即初始化，常量的值不能改变。</p><pre><code class="JavaScript">const PI = 3.1415;console.log(PI); // 3.1415PI = 3; // TypeError: Assignment to constant variable.const foo; // SyntaxError: Missing initializer in const declaration</code></pre><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。<br>const 命令声明的常量也是不提升；同样存在暂时性死区，只能在声明的位置后面使用；并且不可重复声明。</p><p><strong>本质</strong>：const 其实是变量指向的内存地址不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），等同于常量。但对于复合类型的数据（主要是对象和数组），变量保存的只是一个指针，const 只能保证这个指针是固定的。</p><pre><code class="JavaScript">const foo = {};// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = {}; // TypeError: &quot;foo&quot; is read-only</code></pre><p>如果真的想将对象冻结，应该使用 <code>Object.freeze</code> 方法。</p><pre><code class="JavaScript">const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;</code></pre><h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 中，顶层对象的属性与全局变量是等价的。</p><pre><code class="JavaScript">window.a = 1;console.log(a); // 1b = 2;console.log(window.b); // 2</code></pre><p>ES6 规定 let、const、class 命令声明的全局变量，不属于顶层对象的属性。</p><pre><code class="JavaScript">var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.aconsole.log(window.a) // 1let b = 1;console.log(window.b) // undefined</code></pre><h1 id="第3章-变量的解构赋值"><a href="#第3章-变量的解构赋值" class="headerlink" title="第3章 变量的解构赋值"></a>第3章 变量的解构赋值</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对 <strong>变量</strong> 进行赋值，这被称为解构。</p><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><pre><code class="JavaScript">let [a, b, c] = [1, 2, 3];</code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><pre><code class="JavaScript">// 右边比左边少，解构不成功，值为 undefinedlet [bar, foo] = [1]; // undefined,undefined// 右边比左边多，不完全解构let [x, y] = [1, 2, 3]; //1,2</code></pre><p><strong>默认值</strong>：解构赋值允许指定默认值。</p><pre><code class="JavaScript">let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // &#39;a&#39;,&#39;b&#39;let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // &#39;a&#39;,&#39;b&#39;// 只有数组成员 严格等于 undefined 时，默认值才会生效let [x = 1] = [null]; // null</code></pre><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class="JavaScript">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; //&quot;aaa&quot;,&quot;bbb&quot;let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // undefined</code></pre><p>对象的属性没有次序；变量必须与属性同名，才能取到正确的值。</p><p>变量名与属性名不一致:真正被赋值的是后者，而不是前者。</p><pre><code class="JavaScript">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };console.log(baz); // &quot;aaa&quot;</code></pre><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。</p><p>实际上，对象的解构时下面形式的简写：</p><pre><code class="JavaScript">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 完整形式let { foo     , bar      } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 简写形式</code></pre><p>嵌套赋值：</p><pre><code class="JavaScript">let obj = {};let arr = [];({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });console.log(obj); // {prop:123}console.log(arr); // [true]</code></pre><p>对象的解构也可以指定默认值。同样严格等于 undefined 才生效。</p><pre><code class="JavaScript">let {x = 3} = {};console.log(x); // 3let {x: y = 3} = {};console.log(y); // 3</code></pre><p>如果要将一个已经声明的变量用于解构赋值，必须用括号包裹，不能让花括号处于行首。</p><pre><code class="JavaScript">let x;{x} = {x: 1}; // 错误的写法({x} = {x: 1}); // 正确的写法</code></pre><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><pre><code class="JavaScript">// 字符串可以看做数组进行结构const [a, b, c, d, e] = &#39;hello&#39;;    // a:&quot;h&quot;, b:&quot;e&quot;, c:&quot;l&quot;, d:&quot;l&quot;, e:&quot;o&quot;,// 字符串作为类数组对象，拥有length属性。let {length : len} = &#39;hello&#39;;       // len:5</code></pre><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>数值和布尔值也能进行解构，两者会先转为对象，剩下的就是匹配对象中的方法</p><pre><code class="JavaScript">let {toString: s} = 123;s === Number.prototype.toString  // truelet {toString: s} = true;s === Boolean.prototype.toString // true// undefined和null不能转为对象，没有属性let { prop: x } = undefined;     // TypeErrorlet { prop: y } = null;          // TypeError</code></pre><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p><pre><code class="JavaScript">function add([x, y]){  return x + y;}add([1, 2]); // 3</code></pre><p>函数 add() 的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引。</p><p>函数参数的解构也可以使用默认值。</p><pre><code class="JavaScript">function move({x = 0, y = 0} = {}) {  return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3});       // [3, 0]move({});           // [0, 0]move();             // [0, 0]</code></pre><p>下面代码是为函数 move() 的参数指定默认值。</p><pre><code class="JavaScript">function move({x, y} = { x: 0, y: 0 }) {  return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3});       // [3, undefined]move({});           // [undefined, undefined]move();             // [0, 0] - 无参数，默认值生效</code></pre><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>ES6 规定，但凡有可能产生歧义，就不能使用圆括号。以下3种情况下不能用圆括号：</p><p>1.变量声明语句</p><pre><code class="JavaScript">let [(a)] = [1];let {x: (c)} = {};let { o: ({ p: p }) } = { o: { p: 2 } };</code></pre><p>2.函数参数</p><pre><code class="JavaScript">function f([(z)]) { return z; }function f([z,(x)]) { return x; }</code></pre><p>3.赋值语句的模式</p><pre><code class="JavaScript">[(b)] = [3]; // 正确，数组的解构赋值根据索引来，与括号无关({ p: (d) } = {}); // 正确，p 是模式，但 d 不是模式。</code></pre><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>1.<strong>交换变量的值</strong></p><pre><code class="javascript">let x = 1;let y = 2;[x, y] = [y, x];</code></pre><p>2.<strong>从函数返回多个值</strong></p><pre><code class="javascript">// 返回一个数组function example() {  return [1, 2, 3];}let [a, b, c] = example();// 返回一个对象function example() {  return {    foo: 1,    bar: 2  };}let { foo, bar } = example();</code></pre><p>3.<strong>函数参数的定义</strong></p><pre><code class="javascript">// 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1});</code></pre><p>4.<strong>提取JSON数据</strong></p><pre><code class="javascript">let jsonData = {  id: 42,  status: &quot;OK&quot;,  data: [867, 5309]};let { id, status, data: number } = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309]</code></pre><p>5.<strong>函数参数的默认值</strong></p><pre><code class="javascript">jQuery.ajax = function (url, {  async = true,  beforeSend = function () {},  cache = true,  complete = function () {},  crossDomain = false,  global = true,  // ... more config}) {  // ... do stuff};</code></pre><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p>6.<strong>遍历 Map 结构</strong></p><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><pre><code class="javascript">const map = new Map();map.set(&#39;first&#39;, &#39;hello&#39;);map.set(&#39;second&#39;, &#39;world&#39;);for (let [key, value] of map) {  console.log(key + &quot; is &quot; + value);}// first is hello// second is world// 如果只想获取键名或键值，可以写成下面这样。for (let [key] of map) { ... }// 获取键名for (let [,value] of map) { ...}// 获取键值</code></pre><p>7.<strong>输入模块的指定方法</strong></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><pre><code class="javascript">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ECMAScript6入门" scheme="http://www.wshunli.com/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/d8b94418.html"/>
    <id>http://www.wshunli.com/posts/d8b94418.html</id>
    <published>2017-11-05T03:18:50.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。</strong>(8-14章)</p><h1 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p>BOM 的核心对象是 window，表示浏览器的实例。既是范文浏览器窗口的接口，又是 ECMAScript 规定的 Global 对象。</p><p><strong>全局作用域</strong>：全局作用域中声明的变量函数会变成 window 对象的属性和方法。</p><p><strong>窗口关系及框架</strong>：若页面中包含框架，则每个框架都有自己的 window 对象，并且保存在 frames 集合中。</p><p>top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。<br>parent 对象始终指向当前框架的直接上层框架。<br>self 对象始终指向 window。</p><p>所有这些对象都是 window 对象的属性。</p><p><strong>窗口位置</strong>：IE、Safari、Opera、Chrome 提供 screenLeft 和 screenTop 属性，FireFox 提供 screenX 和 screenY 属性，分别用于表示窗口相对于屏幕左边和上边的位置。</p><p><strong>窗口大小</strong>：innerWidth、innerHeight、outerWidth、outerHeight</p><p><strong>导航和打开窗口</strong>: window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。</p><p>接受 4 个参数：要加载的URL、窗口目标、一个特性字符串、一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。</p><p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p><p><strong>间歇调用和超时调用</strong>：JavaScript 是单线程语言，但允许通过设置超时时间和间歇时间调度代码在特定的时刻执行。</p><p>超时调用 setTimeout()：指定的时间过后执行代码。</p><pre><code class="JavaScript">var timeoutId=setTimeout(function(){    console.log(&quot;Hello world!&quot;);},1000);//取消超时调用clearTimeout(timeoutId);</code></pre><p>间歇调用 setInterval()：指定的时间间隔重复执行代码。</p><p><strong>系统对话框</strong>：alert()、confirm()、prompt()</p><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>location 对象不仅提供与当前窗口中加载的文档有关信息，还提供了一些导航功能。<br>即是 window 对象的属性，也是 document 对象的属性。</p><p>除直接修改 location 对象属性外 assign()、replace()、reload() 方法也可以改变当前加载页面。</p><pre><code class="JavaScript">location.assign(&quot;http://www.wshunli.com&quot;);// 等价于window.location=&quot;htttp://www.wshunli.com&quot;;location.href=&quot;htttp://www.wshunli.com&quot;;location.replace=&quot;htttp://www.wshunli.com&quot;;// 无法返回前一个页面location.reload();// 重新加载页面</code></pre><h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p>navigator 对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。</p><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><p>screen 对象用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息 ，如像素高度和宽度等。每个浏览器中的screen对象都包含着不同过的属性，支持也不同。</p><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此每个浏览器窗口、每个标签乃至每个框架，都有自己的history 对象与特定的 window 对象关联。</p><h1 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a>第九章 客户端检测</h1><p>客户端检测主要包括：<br>能力检测：浏览器的特定能力；<br>怪癖检测：浏览器实际中存在的 bug ；<br>用户代理检测：通过检测用户代理字符串识别浏览器。</p><p>尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案。</p><h1 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h1><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM 将任何HTML或XML文档描绘成一个由多层节点构成的树形结构。总共有 12 种节点，其中常用的有 4 种。</p><p>Node.ELEMENT_NODE(1) - 元素节点<br>Node.ATTRIBUTE_NODE(2) - 特性（属性）节点<br>Node.TEXT_NODE(3) - 文本节点<br>Node.COMMENT_NODE(8) - 注释节点</p><p>DOM 节点关系：</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/DOM节点关系.png" alt="DOM节点关系"></p><p><strong>Document 类型</strong>：JavaScript通过Document类型表示文档；浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面，且也是window对象的一个属性，因此可以将其作为全局对象来访问。</p><p>文档属性：<br>document.title：取得当前页面的标题，也可以修改标题。<br>document.URL：页面完整的URL；<br>document.domain：只包含页面的域名；<br>document.referrer：保存着链接到当前页面的那个页面的 URL。<br>文档方法：<br>document.getElementById()<br>document.getElementsByTagName()<br>document.getElementsByName()<br>特殊集合：<br>document.anchors：包含文档中所有带name特性的<code>&lt;a&gt;</code>元素；<br>document.forms：包含文档中所有<code>&lt;form&gt;</code>元素；<br>document.img：包含文档中所有<code>&lt;img&gt;</code>元素；<br>document.links：包含文档中所有带href特性的<code>&lt;a&gt;</code>元素。</p><p><strong>Element 类型</strong>：Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。</p><p>特性（属性）操作：getAttribute()、setAttribute()、removeAttribute()<br>创建元素：document.createElement()</p><p><strong>Text 类型</strong>：文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。</p><p>创建文本节点：document.createTextNode()</p><p>规范文本节点：父元素上调用 normalize()，其实就是将元素的相邻文本节点合并成一个节点。</p><pre><code class="JavaScript">var element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;var textNode = document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);var anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);console.log(element.childNodes.length);  //2element.normalize();console.log(element.childNodes.length);  //1console.log(element.firstChild.nodeValue);  //&quot;Hello World!Yippee!&quot;</code></pre><p>分割文本节点：spiltText()</p><pre><code class="JavaScript">var element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;var textNode=docuemnt.createTextNode(&quot;Hello World!&quot;);element.appendChild(textNode);document.body.appendChild(element);var newNode=element.firstChild.spiltText(5);console.log(element.firstChild.nodeValue); //&quot;Hello&quot;console.log(newNode.nodeValue);            //&quot; World&quot;console.log(element.childNodes.length);    //2</code></pre><p><strong>Attr 类型</strong>：元素的特性（属性）在 DOM 中以 Attr 类型来表示。<br>Attr对象有3个属性：name、value和specified。<br>其中，name是特性名称，value是特性的值，specified是一个布尔值，用以区别特性是在代码中指定的还是默认的。</p><p><strong>Comment 类型</strong>：注释在 DOM 中是通过 Comment 类型来表示的。</p><p><strong>其他节点类型</strong>：</p><p>Node.CDATA_SECTION_NODE(4)<br>Node.ENTITY_REFERENCE_NODE(5)<br>Node.ENTITY_NODE(6)<br>Node.PROCESSING_INSTRUCTION_NODE(7)<br>Node.DOCUMENT_NODE(9)<br>Node.DOCUMENT_TYPE_NODE(10)<br>Node.DOCUMENT_FRAGMENT_NODE(11)<br>Node.NOTATION_NODE(12)</p><h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><p>利用 JavaScript 代码、CSS 样式、表格修改 DOM 元素的结构、属性、内容的技术。</p><p>动态脚本：<code>&lt;script&gt;</code><br>动态样式：<code>&lt;link&gt;</code>,<code>&lt;style&gt;</code><br>操作表格：<code>&lt;table&gt;</code></p><h1 id="第十一章-DOM-扩展"><a href="#第十一章-DOM-扩展" class="headerlink" title="第十一章 DOM 扩展"></a>第十一章 DOM 扩展</h1><p>DOM扩展主要包含两方面：Selector API，HTML5</p><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><p>querySelector() ：接收一个 CSS 选择符，返回匹配的第一个元素；<br>querySelectorAll() ：返回 NodeList 对象。</p><pre><code class="JavaScript">// 取得ID为&quot;myDIV&quot;的元素var myDIV = document.querySelector(&quot;#myDiv&quot;);// 取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName(&quot;em&quot;))var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);</code></pre><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p>Element Traversal 规范为 DOM <strong>元素</strong>新定义了5个属性：<br>childElementCount：返回子元素的个数（不包括文本节点和注释）<br>firstElementChild：指向第一个子元素，firstChild元素版<br>lastElementChild：指向最后一个子元素，lastChild元素版<br>previousElementSibling：指向前一个同辈元素，previousSibling元素版<br>nextElementSibling：指向后一个同辈元素，nextSibling元素版</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p><strong>与类相关的扩展</strong>：</p><p>getElementsByClassName()：返回带有特定类的所有元素的 NodeList。<br>classList属性：HTML5为所有元素添加 classList属性。</p><p><strong>焦点管理</strong>：HTML5也添加了辅助管理DOM焦点的功能。<br>document.activeElement 属性，始终会引用 DOM 中当前获得焦点的元素。<br>document.hasFocus()方法，确定文档是否获得了焦点。</p><pre><code class="JavaScript">var button = document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement === button); // trueconsole.log(document.hasFocus()); // true</code></pre><p><strong>HTMLDocument 的变化</strong>：</p><p>readyState 属性：document.readyState 指示文档是否加载完成。<br>loading：正在加载文档；complete：已经加载完文档。</p><p>head 属性：document.head 属性可以获得<code>&lt;head&gt;</code>元素。</p><p><strong>字符集属性</strong>：</p><p>document.charset：表示文档中实际使用的字符集。<br>document.defaultCharset：当前文档的默认字符集。</p><p><strong>自定义数据属性</strong>：</p><p>HTML5规定可以为元素添加非标准的属性，以此为元素提供与渲染无关的信息。<br>每个自定义数据属性，都要为其添加前缀data-。可通过 dataset 属性访问自定义属性的值。</p><pre><code class="JavaScript">&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myName=&quot;nicholas&quot;&gt;&lt;/div&gt;// 访问上述div元素的自定义属性var div = document.getElementById(&quot;myDiv&quot;);// 访问自定义属性值时，属性名前不必加data-前缀var appId = div.dataset.appId;</code></pre><p><strong>插入标记</strong>：</p><p>innerHTML 属性：<br>在读模式下，innerHTML属性返回调用元素的所有子节点HTML标记。<br>在写模式下，innerHTML属性会根据指定的值创建新的DOM树，然后用新DOM树替换调用元素原先的所有子节点。</p><p>outerHTML 属性：<br>在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。<br>在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。</p><p>insertAdjacentHTML() 方法：<br>语法：insertAdjacentHTML(插入位置，要插入的HTML文本)<br>插入位置必须是下列四个值之一：</p><ul><li>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素</li><li>“afterend”，在当前元素之后插入一个紧邻的同辈元素</li><li>“afterbegin”，给当前元素插入第一个子元素（不管当前元素是否有无子元素）</li><li>“beforeend”，给当前元素插入最后一个子元素（不管当前元素是否有无子元素）</li></ul><p><strong>scrollIntoView() 方法</strong>：所有元素均可调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</p><h1 id="第十二章-DOM2-和-DOM3"><a href="#第十二章-DOM2-和-DOM3" class="headerlink" title="第十二章 DOM2 和 DOM3"></a>第十二章 DOM2 和 DOM3</h1><p>DOM1级主要定义的是HTML和XML文档的底层结构。DOM2 和DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。</p><h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p><p>事件冒泡（event bubbling）：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。<br>事件捕获（event capturing）:不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流.jpg" alt="事件-事件流"></p><p>事件流包括三个阶段：<br>事件捕获阶段：首先发生，为截获事件提供了机会。<br>处于目标阶段：实际的目标接收到事件。<br>事件冒泡阶段：在此阶段可以对事件做出响应。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流三个阶段.jpg" alt="事件-事件流三个阶段"></p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作（比如click、load、mouseover等）<br>事件处理程序（事件侦听器）是响应某个事件的函数。<br>事件处理程序的名字以“on”开头，如click事件的事件处理程序是onclick。</p><p><strong>HTML事件处理程序</strong>：</p><p>为元素添加一个与事件处理程序同名的属性，该属性的值是能够执行的JS代码或JS函数。</p><pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot;&gt;    function showMessage() {        console.log(&quot;Hello world&quot;);    }&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Clicke Me&quot; onclick=&quot;showMessage()&quot; /&gt;</code></pre><p><strong>DOM0级事件处理程序</strong>：</p><p>将一个函数赋值给一个事件处理程序属性。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);// 为按钮指定onclick事件处理程序btn.onclick = function(){    console.log(&quot;Clicked&quot;);}// 删除事件处理程序btn.onclick = null;</code></pre><p><strong>DOM2级事件处理程序</strong>：</p><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()、removeEventListener() 。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);//定义事件处理程序函数var handler = function(){    console.log(this.id);}btn.addEventListener(&quot;click&quot;, handler, false);btn.removeEventListener(&quot;click&quot;, handler, false);</code></pre><p>true：在捕获阶段调用事件处理程序；false：在冒泡阶段调用事件处理程序。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>触发DOM上的某个事件时，会产生一个event事件对象，该对象包含着所有与事件有关的信息。</p><p>兼容DOM（DOM0级和DOM2级）的浏览器将event对象传入到事件处理程序中。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event){    console.log(event.type);  //&quot;click&quot;};btn.addEventListener(&quot;click&quot;, function(event){    console.log(event.type);  //&quot;click&quot;}, false);</code></pre><p><strong>属性/方法</strong>：</p><p>currentTarget：正在处理事件的那个元素<br>target：事件的目标<br>type：事件类型<br>cancelable：可以阻止特定事件的默认行为<br>preventDefault()：阻止特定事件的默认行为<br>stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡<br>eventPhase：事件出于事件流的阶段 捕获阶段为1 处于目标对象为2 冒泡阶段为3</p><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件、合成事件、变动事件。</p><h1 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h1><p>在HTML中，表单是由 <code>&lt;form&gt;</code> 元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://www.wshunli.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/e8afa8c0.html"/>
    <id>http://www.wshunli.com/posts/e8afa8c0.html</id>
    <published>2017-10-29T09:51:02.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p>从今天开始阅读 《JavaScript高级程序设计》（第三版）。</p><p>按照图灵社区推荐的阅读规划：</p><pre><code class="HTML">(一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。(1-7章)(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。(8-14章)(三) 学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。(15-16章)(四) 学习在浏览器中进行实际开发时的错误调试技巧。(17章)(五) 学习JavaScript对各数据载体的操作方法（如JSON、XML），学会Ajax的使用方法。(18-21章)(六) 学习JavaScript的一些高级技巧及实践方案。(22-25章)</code></pre><p><strong>(一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。</strong>(1-7章)</p><h1 id="第一章-JavaScript-简介"><a href="#第一章-JavaScript-简介" class="headerlink" title="第一章 JavaScript 简介"></a>第一章 JavaScript 简介</h1><p>一个完整的 JavaScript 实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。</p><p>ECMAScript：提供核心语言功能；<br>DOM：提供访问和操作网页内容的方法和接口；<br>BOM：提供与浏览器交互的方法和接口。</p><h1 id="第二章-在-HTML-中使用-JavaScript"><a href="#第二章-在-HTML-中使用-JavaScript" class="headerlink" title="第二章 在 HTML 中使用 JavaScript"></a>第二章 在 HTML 中使用 JavaScript</h1><p>HTML 4.01 为 <code>&lt;script&gt;</code> 元素定义了6个属性：async、charset、defer、language（废弃）、src、type 。</p><p>在不存在 defer 和 async 属性时，浏览器都会按照不同<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它们依次进行解析。</p><p>标签的位置：为了避免浏览器在呈现页面时出现明显的延迟，现代Web应用程序一般都把全部 JavaScript 引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p><p>延迟脚本：defer 属性表明脚本在执行时不会影响页面的构造，告诉浏览器立即下载文件，但脚本会被延迟到整个页面都解析完毕后再运行；只适用于外部脚本文件。</p><pre><code class="JavaScript">&lt;script defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></pre><p>异步脚本：async 属性表示当前脚本不必等待其他脚本，也不必阻塞文档呈现，告诉浏览器立即下载文件，且并不保证标记为 async 的脚本按照他们的先后顺序执行；只适用于外部脚本文件。</p><pre><code class="JavaScript">&lt;script async src=&quot;example1.js&quot;&gt;&lt;/script&gt;&lt;script async src=&quot;example2.js&quot;&gt;&lt;/script&gt;</code></pre><p>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p><blockquote><p>页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载；而 load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded)。</p></blockquote><h1 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h1><p>本章内容：语法、数据类型、操作符、控制流语句、函数。<br>其中内容和 Java 类似的部分，不再记笔记。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>区分大小写：ECMAScript 中的一切都区分大小写。</p><p>ECMAScript 5 引入严格模式。在整个脚本中启用严格模式，在顶部添加 <code>&quot;use strict&quot;;</code></p><p>给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 中有5种基本数据类型：Undefined、Null、Boolean、Number、String。<br>还有1种复杂数据类型：Object，Object 本质是一组无序的键值对组成。</p><p><code>typeof 操作符</code>：用来检测变量的数据类型。<br>“undefined”：未定义、”boolean”：布尔值、”string”：字符串、”number”：数值、”object”：对象或 null、 “function”：函数</p><blockquote><p>检测 null 值返回 “Object”、检测函数返回 “function” 。</p></blockquote><p><strong>Undefined 类型</strong>：使用 var 声明变量但未对其初始化时，这个变量的值就是 undefined。</p><blockquote><p>对未声明的变量只能只能执行一项操作，即使用 tyoeof 检测其数据类型，返回 undefined 值。</p></blockquote><p><strong>Null 类型</strong>：null 值表示一个空对象指针；只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。</p><blockquote><p>undefined 表示未初始化的变量；null 表示空对象指针；<code>null == undefined</code> 。</p></blockquote><p><strong>Boolean 类型</strong>：其他类型转换为 Boolean 类型，使用函数 Boolean()。</p><p><strong>Number 类型</strong>：表示整数和浮点数值。</p><p>NaN 即非数值（Not a Number）是一个特殊的数值，表示一个原本要返回数值的操作未返回数值的情况。</p><blockquote><p>任何涉及 NaN 的操作都会返回 NaN；NaN与任何值都不等，包括 NaN 本身。<br>NaN 类型可以使用 isNaN() 函数检测。</p></blockquote><p>数值转换：有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()。<br>Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p><p><code>Number()</code> 函数转换：null和空字符串返回 0；undefined和无法转换的字符串返回 NaN ；对象依次尝试调用 valueOf()、toString()方法，根据函数返回值进行转换。<br><code>parseInt()</code> 函数转换：忽略字符前的空格，找到第一个非空格字符；如果第一个字符不是数字字符或者负号，返回 NaN ；继续解析遇到非数字字符为止。可选第二个参数指定进制。<br><code>parseFloat()</code> 函数转换：和 parseInt() 函数类似，但是字符串中的第一个小数点是有效的。</p><p><strong>String 类型</strong>：符串是不可变的，要改变要先删除。<br>其他类型转换为 String 类型，使用函数 toString() 或 String() 或加一个空字符串（<code>&quot;&quot;</code>）。</p><blockquote><p>数值、布尔值、对象、字符串值 都有 toString() 方法。null、undefined 值没有。<br>String() ：null 返回 <code>&quot;null&quot;</code> ， undefined 返回 <code>&quot;undefined&quot;</code>。其他调用 toString() 方法。</p></blockquote><p><strong>Object 类型</strong>：一组数据（属性）和功能（方法）的组合。</p><p>创建对象的方法：</p><pre><code class="JavaScript">var o = new Object();</code></pre><p>在 ECMAScript 中，Object 类型是其他所有实例的基础，Object 类型具有的属性和方法也同样存在于更具体的对象中。<br>Object 的每个实例（对象）都具有下列属性和方法：</p><ul><li>constructor：保留着用于创建当前对象的函数即构造函数；</li><li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在；</li><li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型；</li><li>propertyIsEnumerable()；toLocaleString()；</li><li>toString()：返回对象的字符串表示；</li><li>valueOf()：返回对象的字符串、数值或布尔值表示。</li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符包括：算数操作符、位操作符、关系操作符、相等操作符。</p><p>用法和概念基本和 Java 一致，相同部分不再记笔记。</p><p>在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。</p><pre><code class="JavaScript">&quot;23&quot;&lt;&quot;3&quot; //true</code></pre><p>相等操作符基本规则：<br>null == undefined，且不转换；<br>对象除非指向同一个否则互相不等；<br>操作值是数值，则另一个值转换为数值进行比较；<br>操作值是布尔值，则将布尔值转换为数值再进行比较，false转换为0,true转换为1。</p><pre><code class="JavaScript">true == 1 ; //truetrue == 2 ; //falseNaN == NaN ; //falseNaN != NaN ; //true</code></pre><p>全等和不全等：两个操作数未经转换就相等为<strong>全等</strong>；转换之后相等为<strong>非全等</strong>。</p><pre><code class="JavaScript">&quot;23&quot; == 23 ; //true&quot;23&quot; === 23 ; //false</code></pre><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>for-in 语句可以用来枚举对象的属性。</p><pre><code class="JavaScript">for (property in expression) {  ...}</code></pre><p>break 和 continue 语句与 label 语句联合使用：多发生在循环嵌套的情况下。</p><pre><code class="JavaScript">var num = 0;outermost:for (var i = 0; i &lt; 10; i++) {  for (var j = 0; j &lt; 10; j++) {    if (i == 5 &amp;&amp; j ==5) {      break outermost;    }    num++;  }}console.log(num);  // 55</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数参数：参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。<br>在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p><p>没有重载：ECMAScript 函数不能像传统意义上那样实现重载。如果在ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p><h1 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h1><p>JavaScript 变量的特征：本质是松散类型，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。</p><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>基本类型指的是简单的数据段，而引用数据类型指那些可能由多个值构成的对象。<br>Undefined、Null、Boolean、Number 和 String 这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p><p><strong>动态的属性</strong>：对引用类型可添加属性和方法，也可改变和删除其属性和方法；对基本类型也能添加属性，但基本类型并不会保存，操作是无效的。</p><p><strong>复制变量值</strong>：从一个变量向另一个变量复制值，基本类型会创建新值并复制到新变量；而引用类型只会复制指向对象的指针，新旧变量会相互影响。</p><p><strong>传递参数</strong>：函数的参数是按值传递时的，即把函数外部的值复制给函数内部的参数（参数实际上是函数的局部变量），就和把值从一个变量复制到另一个变量一样。<br>基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样，复制的是一个指向对象的指针。</p><pre><code class="JavaScript">function setName(obj){  obj.name = &#39;Nicholas&#39;;  obj = new Object();  obj.name = &#39;Greg&#39;;}var person = new Object();setName(person);console.log(person.name);  // =&gt; Nicholas</code></pre><p>对于引用类型，当把参数名指向新的内存空间，再对其做添加属性等操作，不会影响到原来传递的那个对象，所以不是按引用传递参数。</p><p><strong>检测类型</strong>：instanceof 根据原型链，检测变量是什么引用类型的实例。</p><p>检测基本数据类型 typeof 非常有用，但如果变量是对象或 null ，typeof 只能返回 “Object” 。</p><h2 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h2><p><strong>执行环境</strong>：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。有全局执行环境和局部（函数）执行环境之分。</p><p><strong>作用域链</strong>：搜索变量和函数的作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。</p><p><strong>延长作用域链</strong>：try-catch 语句的 catch 块和 with 语句。</p><p><strong>没有块级作用域</strong>：由花括号封闭的代码没有自己的作用域。如 if 、for 语句中只是在语句的执行环境中（全局或函数）。</p><p>查询标识符：从作用域链的前端开始，向上逐级查询，找到后搜索结果停止，没有找到则一直追溯到全局环境的变量对象。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>JavaScript 具有自动垃圾回收机制，即执行环境会负责管理代码执行过程中使用的内存。</p><p>最常用的方法有标记清除和引用计数。</p><p><strong>管理内存</strong>：最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。解除一个值的引用并不意味着自动回收该值所占用的内存——解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><h1 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h1><p>引用类型的值（对象）是引用类型（类、对象定义）的一个实例。</p><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建对象：</p><pre><code class="JavaScript">// 1、使用 Object 构造函数var person = new Object();person.name = &quot;Nicholas&quot;;person.age = 29;// 2、对象字面量表示法var person = {    name : &quot;Nicholas&quot;,    age : 29};// 属性名可以使用字符串var person = {    &quot;name&quot; : &quot;Nicholas&quot;,    &quot;age&quot; : 29,    5 : true //自动转换为字符串};// 与 new Object() 等价var person = {};person.name = &quot;Nicholas&quot;;person.age = 29;</code></pre><p>访问对象属性：</p><pre><code class="JavaScript">// 1、点表示法person.name// 2、方括号表示法person[&quot;name&quot;]// 通过变量访问var n = &#39;name&#39;;console.log(person[n]);// 包含语法错误的字符onsole.log(person[&#39;first name&#39;];</code></pre><h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>ECMAScript 数组的每项可保存任何类型的数据，没项类型可不同；大小可自动调整。</p><p>创建数组：</p><pre><code class="JavaScript">var a1 = new Array();var a2 = new Array(20);var a3 = new Array(&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;);var a4 = [];var a5 = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</code></pre><p><strong>检测数组</strong>：Array.isArray() 方法可检测对象是不是数组。</p><p><strong>转换方法</strong>：toLocaleString()、toString()和 valueOf()方法。</p><p>toLocaleString()、toString() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。<br>toLocaleString() 方法为了取得每一项的值，调用的是每一项的 toLocaleString() 方法。<br><code>valueOf()</code> 方法返回的还是数组。</p><pre><code class="JavaScript">var person1 = {  toLocaleString : function () {      return &quot;Nikolaos&quot;;  },  toString : function() {      return &quot;Nicholas&quot;;  }};var person2 = {  toLocaleString : function () {      return &quot;Grigorios&quot;;  },  toString : function() {      return &quot;Greg&quot;;  }};var people = [person1, person2];console.log(people);                      //Nicholas,Gregconsole.log(people.toString());           //Nicholas,Gregconsole.log(people.toLocaleString());     //Nikolaos,Grigorios</code></pre><p><code>join()</code> 方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];console.log(colors.join(&quot;,&quot;));      //red,green,blueconsole.log(colors.join(&quot;||&quot;));     //red||green||blue</code></pre><p><strong>栈方法</strong>：push() 和 pop() 方法。</p><p><code>push()</code> 方法接收任意数量的参数，把他们逐个加到数组末尾，并返回修改后的数组长度。<br><code>pop()</code> 方法从数组末尾移除最后一项，减少数组长度，然后返回移除项。</p><p><strong>队列方法</strong>：shift() 和 unshift() 方法。</p><p><code>shift()</code> 从数据前端取项方法。类比 pop() 。<br><code>unshift()</code> 从数组前端添加项。类比 push() 。</p><p><strong>重排序方法</strong>：reverse() 和 sort() 方法。</p><p><code>reverse()</code> 反转数组项的顺序。<br><code>sort()</code> 默认升序排列数组项，调用每项的 toString() 转型方法，然后比较字符串。</p><p>sort() 方法可以接受一个比较函数作为参数。比较函数接受两个参数，第一个参数在第二个之前返回负数。</p><pre><code class="JavaScript">// 从小到大：function compare(value1, value2) {    if (value1 &lt; value2) {        return -1;    } else if (value1 &gt; value2) {        return 1;    } else {        return 0;    }}var values = [0, 1, 5, 10, 15];values.sort(compare);console.log(values);    //0,1,5,10,15// 或者function compare(value1, value2) {    return value1 &lt; value2;}var values = [0, 1, 5, 10, 15];values.sort(compare);console.log(values);    //0,1,5,10,15</code></pre><p><strong>操作方法</strong> ：concat() slice() splice() 。</p><p><code>concat()</code> 添加项。创建新数组。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);console.log(colors);     //red,green,blueconsole.log(colors2);    //red,green,blue,yellow,black,brown</code></pre><p><code>slice()</code> 截取。创建新数组。</p><p>在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);console.log(colors2);   //green,blue,yellow,purpleconsole.log(colors3);   //green,blue,yellow</code></pre><p><code>splice()</code> 删除插入替换。改变原数组。</p><p>三个参数：起始位置、要删除的项数、要插入的项。<br>第三个不传是删除功能，第二个为 0 是插入功能，都有则替换。<br>返回：删除的项。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1);              //remove the first itemconsole.log(colors);     //green,blueconsole.log(removed);    //red - one item arrayremoved = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);  //insert two items at position 1console.log(colors);     //green,yellow,orange,blueconsole.log(removed);    //empty arrayremoved = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);    //insert two values, remove oneconsole.log(colors);     //green,red,purple,orange,blueconsole.log(removed);    //yellow - one item array</code></pre><p><strong>位置方法</strong>：indexOf() lastIndexOf() 接收两个参数：要查找的项和（可选）查找起点位置的索引；indexOf()从前往后查找，lastIndexOf()从后往前查找；返回要查找的项的位置，没找到则返回 -1。</p><p><strong>迭代方法</strong>：两个参数：在每项运行的函数和（可选的）作用域对象；其中函数接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。</p><p>every()：对数组中的每一项运行给定函数，如果该函数对<strong>每一项</strong>都返回true，则返回true。有返回false的项时就不会再对后面的项检测了，直接返回false。<br>some()：对数组中的每一项运行给定函数，如果该函数对<strong>任一项</strong>返回true，则返回true。有返回true的项时就不再对后面的项检测了，直接返回ture。</p><p>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</p><p>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。本质上与使用 for 循环迭代数组一样。</p><pre><code class="JavaScript">var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = a.every(function (item, index, array) {  return (item &gt; 2);});console.log(everyResult);  // falsevar someResult = a.some(function (item, index, array) {  return (item &gt; 2);});console.log(someResult);  // truevar filterResult = a.filter(function (item, index, array) {  return (item &gt; 2);});console.log(filterResult);  // [3, 4, 5, 4, 3]var mapResult = a.map(function (item, index, array) {  return (item * 2);});console.log(mapResult);  // [2, 4, 6, 8, 10, 8, 6, 4, 2]var forEachResult = a.forEach(function (item, index, array) {  console.log(item);});console.log(forEachResult);  // undefined</code></pre><p><strong>缩小方法</strong>（递归方法）：reduce() 和 reduceRight() 迭代数组的所有项，然后构建一个最终返回的值；reduce()方法从前往后，reduceRight()从后往前。<br>reduce() 和 reduceRight() 接收两个参数：一个在每项上调用的函数和（可选的）作为缩小基础的初始值。其中函数接收4个参数：前一个值、当前值、项的索引和数组对象。函数的返回值又会作为第一个参数自动传给下一项。</p><pre><code class="JavaScript">var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array){  return prev + cur;},1);console.log(sum); //16</code></pre><h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><p>创建日期对象：</p><pre><code class="JavaScript">var now = new Date();var date = new Date(2005, 4, 5, 17, 55, 55);  // 2005年5月5日下午5点55分55秒</code></pre><p>获取调用时的日期和时间和毫秒数：</p><pre><code class="JavaScript">var start = Date.now();doSomething();var stop = Date.now();var result = stop - start;</code></pre><p>日期的格式化方法：</p><pre><code class="JavaScript">var date = new Date(2015, 2, 5, 17, 55, 55);date.toString();  // &quot;Thu Mar 05 2015 17:55:55 GMT+0800 (CST)&quot;date.toDateString();  // &quot;Thu Mar 05 2015&quot;date.toTimeString();  // &quot;17:55:55 GMT+0800 (CST)&quot;date.toLocaleString();  // &quot;2015/3/5 下午5:55:55&quot;date.toLocaleDateString();  // &quot;2015/3/5&quot;date.toLocaleTimeString();  // &quot;下午5:55:55&quot;</code></pre><h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><p>创建正则表达式：</p><pre><code class="JavaScript">var exp1 = / pattern / flags ;var exp2 = new RegExp(&#39;pattern&#39;, &#39;flags&#39;);</code></pre><p>模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。<br>标志（flags）用以标明正则表达式的行为。正则表达式的匹配模式支持下列3 个标志：</p><ul><li>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li><li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li><li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li></ul><p>RegExp 实例方法：</p><p><code>exec()</code>：返回第一个匹配项信息的数组，数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串；还包含两个额外的属性，index 和 input。<br><code>test()</code>：在模式与该参数匹配的情况下返回true，否则返回false。</p><p>正则表达式：<a href="http://www.runoob.com/regexp/regexp-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/regexp/regexp-tutorial.html</a></p><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>函数实际上是对象。函数名实际上是指向函数对象的指针。<br>每个函数都是 Function 类型的实例，而且与其他引用类型一样具有属性和方法。</p><pre><code class="JavaScript">// 函数声明function sum (num1, num2){  return num1 + num2;}// 函数表达式var sum = function(num1, num2){  return num1 + num2;};// 使用构造函数，不推荐var sum = new Function(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;);</code></pre><p><strong>函数声明与函数表达式</strong>：解释器会率先读取函数声明，并使其在执行任何代码之前可用（函数声明提升）；函数表达式必须等到解释器执行到它所在行才会真正被解释执行。</p><pre><code class="JavaScript">// 函数声明console.log(sum(10,10));function sum (num1, num2){  return num1 + num2;}// 函数表达式console.log(sum(10,10));// Uncaught TypeError: sum is not a functionvar sum = function(num1, num2){  return num1 + num2;};</code></pre><p><strong>作为值的函数</strong>：因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。</p><p><strong>函数的内部属性</strong>：arguments 、this 。</p><p><code>arguments</code>: 是一个类数组对象，包含着传入函数中的所有参数。</p><pre><code class="JavaScript">function factorial(num){    if (num &lt;= 1) {        return 1;    } else {        return num * factorial(num-1)    }}function factorial(num){    if (num &lt;= 1) {        return 1;    } else {        return num * arguments.callee(num-1)    }}</code></pre><p>arguments 的属性 callee 指向拥有此 arguments 的函数。</p><pre><code class="JavaScript">// 无论引用函数时使用的什么名字，都可以保证正常完成递归。var trueFactorial = factorial;factorial = function(){    return 0;};console.log(trueFactorial(5));   //120console.log(factorial(5));       //0</code></pre><p><code>this</code> 引用的是函数据以执行的环境对象。</p><p>在全局作用域中调用函数，this 引用的是全局对象 window；<br>把函数赋给对象 o 并调用时，this 引用的就是对象 o 。</p><p>caller : 调用当前函数的函数的引用，返回后者的源代码。</p><p><strong>函数的属性和方法</strong>：</p><p>函数的两个属性：length 和 prototype 。</p><p><code>length</code>：表示函数希望接收的命名参数的个数。</p><p><code>prototype</code>: 对于ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。不可枚举。</p><p>函数的两个非继承而来的方法：apply() 和 call() 。在特定的作用域中调用函数。</p><p><code>apply()</code>：接受两个参数，运行函数的作用于和参数数组。</p><pre><code class="JavaScript">function sum(num1, num2){    return num1 + num2;}// 参数数组可以是 Array 的实例，也可以是 arguments 对象。function callSum1(num1, num2){    return sum.apply(this, arguments);}function callSum2(num1, num2){    return sum.apply(this, [num1, num2]);}console.log(callSum1(10,10));   //20console.log(callSum2(10,10));   //20</code></pre><p><code>call()</code>：必须明确地传入每个参数。</p><pre><code class="JavaScript">function sum(num1, num2){    return num1 + num2;}function callSum(num1, num2){    return sum.call(this, num1, num2);}console.log(callSum(10,10));   //20</code></pre><p>apply() 和 call() 真正强大的地方是能够扩充函数赖以运行的作用域。而使用它们来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。</p><pre><code class="JavaScript">window.color = &quot;red&quot;;var o = { color: &quot;blue&quot; };function sayColor(){    console.log(this.color);}sayColor();            //redsayColor.call(this);   //redsayColor.call(window); //redsayColor.call(o);      //blue</code></pre><p><code>bind()</code> 方法会创建一个函数的实例，其 this 值会绑定到传给 bind() 函数的值。</p><pre><code class="JavaScript">var objectSayColor = sayColor.bind(o);objectSayColor();   //blue</code></pre><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>Boolean 类型、Number 类型、String 类型。</p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>Global 对象、Math 对象。</p><h1 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h1><p>对象：无序属性的集合，其属性可以包含基本值、对象或者函数。</p><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>属性在创建时都带了一些特征值（characteristic），JavaScript 通过这些特征值来定义他们的行为。</p><p>ECMAScript 中有两种属性：数据属性和访问器属性。<br>描述属性的各种特征，是为了实现JavaScript引擎用的，不能直接访问。</p><p><strong>数据属性</strong>：</p><ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li><li>[[Writeable]]：表示能否修改属性的值。</li><li>[[Value]]：包含这个属性的数据值。</li></ul><p><strong>访问器属性</strong>：</p><ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为数据属性。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li><li>[[Get]]：在读取属性时调用的函数。</li><li>[[Set]]：在写入属性时调用的函数。</li></ul><p><strong>定义及读取特性</strong>：Object.defineProperty() Object.defineProperties()；Object.getOwnPropertyDescriptor() 。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然使用 Object 构造函数或者对象字面量可以创建单个对象，但使用同一接口创建很多对象，会产生大量的重复代码。</p><p><strong>工厂模式</strong>：使用函数来封装以特定接口来创建对象。</p><pre><code class="JavaScript">function createPerson(name,age,job){  var o=new Object();  o.name=name;  o.age=age;  o.job=job;  o.sayName=function(){    console.log(this.name);  };  return o;}var person1=createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;);</code></pre><p><strong>构造函数模式</strong>：</p><pre><code class="JavaScript">function Person(name,age,job){  this.name=name;  this.age=age;  this.job=job;  this.sayName=function(){    console.log(this.name);  };}var person1=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</code></pre><p>要创建Person的实例，必须使用new操作符。用这种方式调用构造函数需要4个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象。</li></ol><p>构造函数和其他函数唯一的区别，就是在于调用他们的方式不同。<br>任何函数，只要通过 new 操作符来调用，那么它就可以作为构造函数。</p><p><strong>原型模式</strong>：</p><p>创建的每一个函数都有一个 prototype（原型）属性，指向一个对象；这个对象（原型对象 ）的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>prototype 就是通过调用构造函数而创建的实例的原型对象。好处是可以让所有的实例共享原型对象包含的属性和方法，不用在构造函数里面定义实例的信息，而是直接添加到原型对象中。</p><pre><code class="JavaScript">function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){    console.log(this.name);};var person1 = new Person();person1.sayName();   //&quot;Nicholas&quot;var person2 = new Person();person2.sayName();   //&quot;Nicholas&quot;console.log(person1.sayName == person2.sayName);  //true</code></pre><p>1.理解原型对象：</p><p>只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，指向原型对象；<br>默认所有原型对象都会获得一个 <code>constructor</code> 属性，指向 <code>prototype</code> 属性所在函数（构造函数）；<br>调用构造函数创建实例后，实例内部将包含一个指针 <code>[[Prototype]]</code> 或者 <code>__proto__</code> 指向构造函数的原型对象。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象.png" alt="向对象的程序设计-理解原型对象"></p><pre><code class="JavaScript">···// 使用 isPrototype() 来检测构造函数的原型对象和实例对象之间是否有关系console.log(Person.prototype.isPrototypeOf(person1));  //trueconsole.log(Person.prototype.isPrototypeOf(person2));  //true// Object.getPrototypeOf() 返回实例对象的原型if (Object.getPrototypeOf){    console.log(Object.getPrototypeOf(person1) == Person.prototype);  //true    console.log(Object.getPrototypeOf(person1).name);  //&quot;Nicholas&quot;}</code></pre><p>当代码读取某个对象的属性时，先从对象实例本身开始，若没有找到才会在原型对象中查找。</p><p>当为对象实例添加属性时，这个属性会屏蔽掉原型对象中的同名属性，即使将这个属性设置为 null ，也只会在实例中设置这个属性。不过使用 delete 操作符可以完全删除实例属性，使得可以重新访问原型中的属性。</p><pre><code class="JavaScript">···person1.name = &quot;Greg&quot;;console.log(person1.name);   //&quot;Greg&quot; - 来自实例console.log(person2.name);   //&quot;Nicholas&quot; - 来自原型delete person1.name;console.log(person1.name);   //&quot;Nicholas&quot; - 来自原型// 使用 hasOwnProperty() 来检测属性存在于实例中还是原型中console.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型person1.name = &quot;Greg&quot;;console.log(person1.hasOwnProperty(&quot;name&quot;)); // true - 来自实例delete person1.name;console.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型</code></pre><p>实例与原型的关系：<br><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象2.png" alt="向对象的程序设计-理解原型对象2"></p><p>2.原型与 in 操作符：单独使用和在 for-in 循环中使用。</p><pre><code class="JavaScript">···// 单独使用时无论属性在原型还是在实例中都返回 trueconsole.log(&quot;name&quot; in person1); // trueperson1.name = &quot;Greg&quot;;console.log(&quot;name&quot; in person1);   //true// for-in 循环时，返回的是所有能通过对象访问的、可枚举的属性；同样也包括原型和实例中的。for (var prop in person1) {  console.log(prop);  // name age job sayName}</code></pre><p>Object.keys() 方法可以取得对象上所有可枚举的实例属性。</p><pre><code class="JavaScript">···var keys = Object.keys(Person.prototype);console.log(keys);   //&quot;name,age,job,sayName&quot;</code></pre><p>Object.getOwnPropertyNames() 方法可以得到所有实例属性，无论其是否可枚举。</p><pre><code class="JavaScript">···var keys = Object.getOwnPropertyNames(Person.prototype);console.log(keys);   //&quot;constructor,name,age,job,sayName&quot;</code></pre><p>3.更简单的原型语法：</p><pre><code class="JavaScript">function Person(){}// 本质是重写了默认的 prototype 对象// constructor 属性指向 ObjectPerson.prototype = {    name : &quot;Nicholas&quot;,    age : 29,    job: &quot;Software Engineer&quot;,    sayName : function () {        console.log(this.name);    }};console.log(friend instanceof Object);  //trueconsole.log(friend instanceof Person);  //trueconsole.log(friend.constructor == Person);  //falseconsole.log(friend.constructor == Object);  //true</code></pre><p>为解决 constructor 无法确定对象类型的问题：</p><pre><code class="JavaScript">function Person(){}// 方法1：Person.prototype = {    // 使 constructor 属性指向构造函数    constructor : Person,    name : &quot;Nicholas&quot;,    age : 29,    job: &quot;Software Engineer&quot;,    sayName : function () {        console.log(this.name);    }};// 方法2：Person.prototype = {    name : &quot;Nicholas&quot;,    age : 29,    job: &quot;Software Engineer&quot;,    sayName : function () {        console.log(this.name);    }};// 设置 constructor 属性不可枚举Object.defineProperty(Person.prototype.&quot;constructor&quot;){  enumerable : false,  value: Person}// 结果相同var friend = new Person();console.log(friend instanceof Object);  //trueconsole.log(friend instanceof Person);  //trueconsole.log(friend.constructor == Person);  //trueconsole.log(friend.constructor == Object);  //false</code></pre><p>4.原型的动态性：</p><p>我们对原型的修改都能立刻反映到实例上。<br>但是重写原型，实例对象还是指向原来的原型，不会指向新重写的原型对象。<br>重写原型切断了新的原型和之前已经存在的对象实例间的联系。</p><p>5.原型对象的问题：原型对象中讯在引用类型的属性，会使所有实例共享该引用。</p><p><strong>组合使用构造函数和原型模式</strong>：</p><p>构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。</p><pre><code class="JavaScript">function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];}Person.prototype = {    constructor: Person,    sayName : function () {        console.log(this.name);    }};var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);console.log(person1.friends);    //&quot;Shelby,Court,Van&quot;console.log(person2.friends);    //&quot;Shelby,Court&quot;console.log(person1.friends === person2.friends);  //falseconsole.log(person1.sayName === person2.sayName);  //true</code></pre><p>实例属性都是在构造函数中定义的，每个实例都会有自己的一份实例属性的副本。</p><p><strong>动态原型模式</strong>：将原型信息封装在构造函数中。</p><pre><code class="JavaScript">function Person(name, age, job){    //properties    this.name = name;    this.age = age;    this.job = job;    //methods    if (typeof this.sayName != &quot;function&quot;){        Person.prototype.sayName = function(){            console.log(this.name);        };    }}var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName();</code></pre><p><code>寄生构造函数模式</code>、<code>稳妥构造函数模式</code>。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript 只支持<strong>实现继承</strong>，主要依靠原型链来实现。</p><p><strong>原型链</strong>：利用原型将一个引用类型继承另一个引用类型的属性和方法。</p><pre><code class="JavaScript">function SuperType(){    this.property = true;}SuperType.prototype.getSuperValue = function(){    return this.property;};function SubType(){    this.subproperty = false;}//继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function (){    return this.subproperty;};var instance = new SubType();console.log(instance.getSuperValue());   //true</code></pre><p>实例以及构造函数和原型之间的关系：</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-原型链.png" alt="向对象的程序设计-原型链"></p><p>getSuperValue() 方法仍然在 SuperType.prototype 中，但 property 位于 SubType.prototype 中。<br>因为我们重写了 SubType 的原型，新原型即 SuperType 的实例；property 是实例的属性，getSuperValue() 则是 SuperType 原型的方法。</p><p>1.注意默认原型：函数的默认原型是 Object 实例，因此默认原型会包含指针指向 Object.prototype 。</p><p>2.确定实例与原型的关系：</p><pre><code class="JavaScript">console.log(instance instanceof Object);      //trueconsole.log(instance instanceof SuperType);   //trueconsole.log(instance instanceof SubType);     //trueconsole.log(Object.prototype.isPrototypeOf(instance));    //trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); //trueconsole.log(SubType.prototype.isPrototypeOf(instance));   //true</code></pre><p>3.谨慎地定义方法：给原型添加方法一定要在替换原型之后；也不能使用字面量创建原型方法。</p><p>4.原型链问题：引用类型的原型属性会被所有实例共享；不能向超类传递参数。</p><p><strong>借用构造函数</strong>：通过 apply() 或 call() 方法在新创建的对象上执行超类的构造函数。</p><pre><code class="JavaScript">function SuperType(){    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}function SubType(){    //继承自 SuperType    SuperType.call(this);}var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);    //&quot;red,blue,green,black&quot;var instance2 = new SubType();console.log(instance2.colors);    //&quot;red,blue,green&quot;</code></pre><p>通过 apply() 或 call() 方法在 SubType 实例的环境下调用了 SuperType 构造函数。</p><p>1.传递参数：</p><pre><code class="JavaScript">function SuperType(name){    this.name = name;}function SubType(){    //继承自 SuperType，传递参数    SuperType.call(this, &quot;Nicholas&quot;);    //实例属性    this.age = 29;}var instance = new SubType();console.log(instance.name);    //&quot;Nicholas&quot;;console.log(instance.age);     //29</code></pre><p>2.问题： 和构造函数模式类似，方法都在构造函数中定义，无法复用。</p><p><strong>组合继承</strong>：JavaScript中最常用的继承。融合了原型链和构造函数的优点。</p><pre><code class="JavaScript">function SuperType(name){    this.name = name;    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){    console.log(this.name);};function SubType(name, age){    SuperType.call(this, name);    this.age = age;}SubType.prototype = new SuperType();SubType.prototype.sayAge = function(){    console.log(this.age);};var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);  //&quot;red,blue,green,black&quot;instance1.sayName();      //&quot;Nicholas&quot;;instance1.sayAge();       //29var instance2 = new SubType(&quot;Greg&quot;, 27);console.log(instance2.colors);  //&quot;red,blue,green&quot;instance2.sayName();      //&quot;Greg&quot;;instance2.sayAge();       //27</code></pre><p><code>原型式继承</code>、<code>寄生式继承</code>、<code>寄生组合式继承</code>。</p><h1 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h1><p>定义函数的方法有两种：<a href="#Function-类型">函数声明与函数表达式</a>。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身函数构成。</p><pre><code class="JavaScript">function factorial(num){    if (num &lt;= 1){        return 1;    } else {        return num * factorial(num-1);    }}var anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(4));  //error! - factorial 已经不是函数</code></pre><p>解决办法是使用命名函数表达式：</p><pre><code class="JavaScript">function factorial = (function f(num){    if (num &lt;= 1){        return 1;    } else {        return num * f(num-1);    }});</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包</strong> 是有权访问另一个函数作用域中的变量的函数。</p><p>1.闭包和变量:闭包只能取得函数中任何变量的最后一个值。</p><pre><code class="JavaScript">function createFunctions(){    var result = new Array();    for (var i=0; i &lt; 10; i++){        result[i] = function(){            return i;        };    }    return result;}</code></pre><p>其中每个函数都引用着保存变量 i 的同一个变量对象,所以函数内部返回的值都是 10 。</p><pre><code class="JavaScript">function createFunctions(){    var result = new Array();    for (var i=0; i &lt; 10; i++){        result[i] = function(num){            return function(){                return num;            };        }(i);    }    return result;}</code></pre><p>2.关于 this 对象:匿名函数通常具有全局性,因此其 this 对象通常指向 windows 。</p><pre><code class="JavaScript">var name = &quot;The Window&quot;;var object = {    name : &quot;My Object&quot;,    getNameFunc : function(){        return function(){            return this.name;        };    }};console.log(object.getNameFunc()());  //&quot;The Window&quot; 在非严格模式下</code></pre><p>this 的值有时候会意外发生改变。</p><pre><code class="JavaScript">var name = &quot;The Window&quot;;var object = {    name : &quot;My Object&quot;,    getName: function(){        return this.name;    }};console.log(object.getName());     //&quot;My Object&quot;console.log((object.getName)());   //&quot;My Object&quot;console.log((object.getName = object.getName)());   //&quot;The Window&quot; 在严格模式下}</code></pre><p>第三个其实是重写了 getName 方法,this 值就指向全局了。</p><h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>JavaScript 没有块级作用域(私有作用域)的概念,可使用匿名函数方法模仿。</p><pre><code class="JavaScript">(function () {    ...})();</code></pre><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>JavaScript 没有私有成员的概念,所有对象属性都是公有的,但是有个私有变量的概念,也就是函数中定义的变量。</p><pre><code class="JavaScript">function Person(name){    this.getName = function(){        return name;    };    this.setName = function (value) {        name = value;    };}var person = new Person(&quot;Nicholas&quot;);console.log(person.getName());   //&quot;Nicholas&quot;person.setName(&quot;Greg&quot;);console.log(person.getName());   //&quot;Greg&quot;</code></pre><p>创建 Person 实例只能 通过 getName() 和 setName() 方法访问内部变量,但是针对每个实例都会创建一组新方法。</p><p>1.静态私有变量</p><pre><code class="JavaScript">(function(){    var name = &quot;&quot;;    Person = function(value){        name = value;    };    Person.prototype.getName = function(){        return name;    };    Person.prototype.setName = function (value){        name = value;    };})();var person1 = new Person(&quot;Nicholas&quot;);console.log(person1.getName());   //&quot;Nicholas&quot;person1.setName(&quot;Greg&quot;);console.log(person1.getName());   //&quot;Greg&quot;var person2 = new Person(&quot;Michael&quot;);console.log(person1.getName());   //&quot;Michael&quot;console.log(person2.getName());   //&quot;Michael&quot;</code></pre><p>初始化未声明的变量,总会创建一个全局变量。严格模式下报错。</p><p>示例代码中 name 变成了一个静态的,所有实例共享的属性。</p><p>2.模块模式</p><p>模块模式是为单例创建私有变量和特权方法。单例即只有一个实例的对象。</p><pre><code class="JavaScript">function BaseComponent(){}function OtherComponent(){}var application = function(){    //私有变量和方法    var components = new Array();    //初始化    components.push(new BaseComponent());    //公共接口    return {        getComponentCount : function(){            return components.length;        },        registerComponent : function(component){            if (typeof component == &quot;object&quot;){                components.push(component);            }        }    };}();application.registerComponent(new OtherComponent());console.log(application.getComponentCount());  //2</code></pre><p>3.增强的模块模式</p><p>针对单例必须是某种类型的实例,同时还对其添加属性或方法的情况。</p><pre><code class="JavaScript">function BaseComponent(){}function OtherComponent(){}var application = function(){    //私有变量和方法    var components = new Array();    //初始化    components.push(new BaseComponent());    //创建 application 的一个局部副本    var app = new BaseComponent();    //公共接口    app.getComponentCount = function(){        return components.length;    };    app.registerComponent = function(component){        if (typeof component == &quot;object&quot;){            components.push(component);        }    };    //返回副本    return app;}();console.log(application instanceof BaseComponent);application.registerComponent(new OtherComponent());console.log(application.getComponentCount());  //2</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://www.wshunli.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript DOM 编程艺术》读书笔记</title>
    <link href="http://www.wshunli.com/posts/25be2399.html"/>
    <id>http://www.wshunli.com/posts/25be2399.html</id>
    <published>2017-10-22T01:58:31.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript DOM 编程艺术》读书笔记<br><a id="more"></a></p><p>本科的时候也有看前端的内容但是没有系统地学习，现在有 WebGIS 相关的项目，并且发现 Android 开发也发生了一些变化: 很多应用不再单单是一个简单的原生 Android 应用，用到了跨平台技术，比如说 React Native 、 Ionic 等等，这都需要 Javascript 基础。所以打算系统地学习下 Javascript 。</p><p>其实有这个想法很久了，包括暑假来到也有意学习前端技术，最开始是在慕课网看 <a href="http://www.imooc.com/course/list?c=fe&amp;sort=pop" rel="external nofollow noopener noreferrer" target="_blank">前端基础</a> 相关视频，然后也简单地在 <a href="http://www.runoob.com/html/html-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">菜鸟教程</a> 看了相关文字内容，最后在廖雪峰的网站看 <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" rel="external nofollow noopener noreferrer" target="_blank">JavaScript全栈教程</a>，这部分对后来 Node.js 后端开发很有帮助。</p><p>但是现在发现 Javascript 水品还不行，没有接近实战的水平，所以打算再系统学习下。<br>按照知乎 <a href="https://www.zhihu.com/question/19713563" rel="external nofollow noopener noreferrer" target="_blank">如何循序渐进、有效地学习JavaScript？</a> 问题的回答，决定先学习 《JavaScript DOM 编程艺术》（第二版），后面再学习 《JavaScript高级程序设计》，最后再刷 <a href="http://es6.ruanyifeng.com/" rel="external nofollow noopener noreferrer" target="_blank">《ECMAScript 6 入门》</a> 学习 ES6 。</p><h1 id="第1章-JavaScript-简史"><a href="#第1章-JavaScript-简史" class="headerlink" title="第1章 JavaScript 简史"></a>第1章 JavaScript 简史</h1><p>本章主要介绍了 JavaScript 的起源、浏览器之间的战争、DOM 的演变史。</p><p>DOM (Document Object Model,文档对象模型) 是一套对文档的内容进行抽象和概念化的方法。<br>感觉和类的说法很类似。</p><h1 id="第2章-JavaScript-语法"><a href="#第2章-JavaScript-语法" class="headerlink" title="第2章 JavaScript 语法"></a>第2章 JavaScript 语法</h1><p>程序设计语言分为解释型和编译型两大类。Java或者C++等语言需要一个编译器，把用Java等高级语言编写出来的源代码翻译为计算机能直接执行的文件。<br>解释型语言不需要编译器–它们仅需要解释器，对于JavaScript而言，Web浏览器负责完成有关解释和执行工作。<br>浏览器的JavaScript解释器将直接读取源代码并执行，相关错误也只能在此时才能发现。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JavaScript 语法基本上和 Java 或者 C++ 类似，下面主要介绍不同点。</p><p>JavaScript 是一种弱类型语言，变量使用前不需要进行类型声明，但不建议这样做。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript 中的数据类型主要包括 字符串、数值、布尔值 三种。</p><ul><li>字符串：单引号双引号都可以，最好根据字符内容选择。</li><li>数值：不单单是整数，允许任意位小数。</li><li>布尔值：true 或 false 。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JavaScript 数组声明不必指出数组长度：</p><pre><code class="JavaScript">var car = Array(5);var car = Array();var car = [];</code></pre><p>声明数组的同时也可以进行填充（向数组添加元素）：</p><pre><code class="JavaScript">var cars = new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);var cars = [&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];</code></pre><p>数组元素类型不必相同，甚至可以是数组或者对象：</p><pre><code class="JavaScript">var cars = new Array(&quot;Saab&quot;,2017,true);var beatles = [];beatles[0] = cars;// beatles[0][1] 的值为 2017 。</code></pre><h3 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h3><p>对象的声明使用 Object 关键字：</p><pre><code class="JavaScript">var car = new Object();var car = {};var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};</code></pre><p>对象属性取值赋值方法：</p><pre><code class="JavaScript">var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};person.lastname = &quot;Wang&quot;;var name = person.lastname;var name = person[&quot;lastname&quot;];</code></pre><h2 id="算数操作符、条件语句、循环语句"><a href="#算数操作符、条件语句、循环语句" class="headerlink" title="算数操作符、条件语句、循环语句"></a>算数操作符、条件语句、循环语句</h2><p>和 Java、C++ 基本一致，不再赘述。</p><p>比较操作符不太一样:<br><strong>==</strong> : 表示类型转换后值是否相等；<br><strong>===</strong> ：严格相等，类型必须相同。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数声明及调用方法：</p><pre><code class="JavaScript">function myFunction(a, b) {    return a * b;}// 调用函数myFunction(2,5);</code></pre><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>全局变量：可以在脚本的任意位置引用，包括函数内部。<br>局部变量：在函数内部声明，只在函数内部有效。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是自包含的数据集合，包含在对象里的数据可通过 属性（property） 和 方法（method） 访问。</p><ul><li>属性是隶属于某个特定对象的变量</li><li>方法是只有某个特定对象才能调用的函数</li></ul><p>对象分类：</p><ul><li>自定义对象：利用 JavaScript 创建的自己的对象；</li><li>内建对象：JavaScript提供的一系列预先定义好的对象。数组也可以看做是 JavaScript 的内建对象的一种。常见的还有Data对象；</li><li>宿主对象：由浏览器提供的预定义对象。常见的有 windows，document 等。</li></ul><h1 id="第3章-DOM"><a href="#第3章-DOM" class="headerlink" title="第3章 DOM"></a>第3章 DOM</h1><p>DOM 三个字母的具体含义:<br>D 是基础，没有文档（Document）DOM 也就无从谈起；<br>O 是对象（Object），JavaScript 本身就可以看做是由对象构成的语言，其重要性不言而喻；<br>M 是模型（Model），其含义是某种事物的表现形式。<br>具体的说 DOM 把文档表示成了一颗家谱树（DOM 使用 parent、child，sibling 等记号来表明家庭成员之间的关系。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>DOM 由许多不同的节点（node）组成，节点可分为三类：<br>元素节点：DOM 的原子是元素节点，可以包含其他元素。<br>文本节点：元素节点的内容。<br>属性节点：元素节点的描述。</p><pre><code class="JavaScript">&lt;p title=&quot;Paragraph&quot;&gt;This is a paragraph.&lt;/p&gt;/*** 元素节点：p* 文本节点：This is a paragraph.* 属性节点：title=&quot;Paragraph&quot;*/</code></pre><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>有三种方法可以获取元素节点，分别通过 id、标签名、class 。</p><pre><code class="JavaScript">// document 特有函数，返回一个元素var x = document.getElementById(&quot;intro&quot;);// getElementsByTagName、getElementsByClassName 返回元素数组var y = document.getElementsByTagName(&quot;p&quot;);var y = x.getElementsByTagName(&quot;p&quot;);// 允许使用通配符var y = x.getElementsByTagName(&quot;*&quot;);var z = document.getElementsByClassName(&quot;intro&quot;);var z = x.getElementsByClassName(&quot;intro&quot;);// 允许查找带有多个类名的元素，并且类名顺序不重要var z = x.getElementsByClassName(&quot;import intro&quot;);</code></pre><h2 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h2><p>获取和设置属性的方法如下：<br>getAttribute()：该方法只能通过元素节点对象调用；<br>setAttribute():该方法允许我们对属性节点的值做出修改。</p><pre><code class="JavaScript">var img = document.getElementById(&quot;image&quot;)；img.getAttribute(&quot;src&quot;);img.src;img.setAttribute(&quot;src&quot;,&quot;landscape.jpg&quot;);img.src = &quot;landscape.jpg&quot;;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;</code></pre><p>通过浏览器查看源代码，其属性并不会改变，也就是说 setAttribute 做出的修改不会反映到文档本身的源码里。这种“表里不一”的的现象源自 DOM 的工作模式：<br>先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。</p><h1 id="第4章-案例研究：JavaScript图片库"><a href="#第4章-案例研究：JavaScript图片库" class="headerlink" title="第4章 案例研究：JavaScript图片库"></a>第4章 案例研究：JavaScript图片库</h1><h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>事件处理函数的作用是，在特定事件发生时调用特定的代码。</p><pre><code class="HTML"> &lt;a href=&quot;images/fireworks.jpg&quot; title=&quot;A fireworks display&quot; onclick=&quot;showPic(this); return false;&quot;&gt;Fireworks&lt;/a&gt;</code></pre><p>事件处理函数的工作机制：在给某元素添加事件处理函数后，一旦事件发生相应的 JavaScript 代码就会执行。<br>被调用的 JavaScript 代码可以返回一个值，这个值将被传递至事件处理函数。</p><p>例如：我们给某链接添加一个 onclick 事件处理函数，并把这个事件处理函数所触发的 JavaScript 代码返回 true 或 false 。<br>这样一来，当这个链接被点击时，JavaScript 代码返回值是 true ，onclick 事件处理函数就认为 这个链接被点击了；反之，认为没有被点击。</p><p>所以在 onclick 事件处理函数所触发的 JavaScript 代码里增加一条 <code>return false;</code> 语句，屏蔽掉链接的默认行为。</p><h2 id="对函数进行拓展"><a href="#对函数进行拓展" class="headerlink" title="对函数进行拓展"></a>对函数进行拓展</h2><h3 id="childNodes-属性"><a href="#childNodes-属性" class="headerlink" title="childNodes 属性"></a>childNodes 属性</h3><p>childNodes 属性可以获取任一元素的所有子元素。</p><pre><code class="JavaScript">var body_element = document.getElementById(&quot;body&quot;)[0];// 得到 body 的所有子元素、数组body_element.childNodes;</code></pre><h3 id="nodeType-属性"><a href="#nodeType-属性" class="headerlink" title="nodeType 属性"></a>nodeType 属性</h3><p>childNodes 属性返回的数组包括所有类型的节点，而不仅仅是元素节点。<br>事实上，文档里的每样东西都是一个节点，设置连空格和换行符都被解释为节点。</p><p>可通过节点的 nodeType 属性区分不同的节点。</p><p><code>node.nodeType</code></p><p>返回值是一个数字。</p><p>nodeType 共有 12 种取值，其中仅 3 种具有实用价值。</p><p>元素节点：1.<br>属性节点：2.<br>文本节点：2.</p><h3 id="nodeValue-属性"><a href="#nodeValue-属性" class="headerlink" title="nodeValue 属性"></a>nodeValue 属性</h3><p>若改变 文本节点 的值，可通过 DOM 提供的 nodeValue 属性。</p><p><code>node.nodeValue</code></p><p>注意：对于元素节点而言，<code>element.nodValue</code> 得到的值并不是元素的文本值。</p><p>正确的做法的先得到元素节点的文本节点，再取 nodeValue 属性：</p><p><code>element.childNodes[0].nodeValue</code></p><h3 id="firstChild-和-lastChild-属性"><a href="#firstChild-和-lastChild-属性" class="headerlink" title="firstChild 和 lastChild 属性"></a>firstChild 和 lastChild 属性</h3><p>firstChild：元素的第一个子元素。<br>lastChild：元素的最后一个元素。</p><pre><code class="JavaScript">function showPic(whichPic) {    var source = whichPic.getAttribute(&quot;href&quot;);//获取资源路径    var placeholder = document.getElementById(&quot;placeholder&quot;);    placeholder.setAttribute(&quot;src&quot;,source);    var text = whichPic.getAttribute(&quot;title&quot;);//获取内容    var description = document.getElementById(&quot;description&quot;);    description.firstChild.nodeValue = text;}</code></pre><h1 id="第5章-最佳实践"><a href="#第5章-最佳实践" class="headerlink" title="第5章 最佳实践"></a>第5章 最佳实践</h1><p>1、在使用任何一句JavaScript代码时，都应该想想，对这个网页是否有用；<br>2、平稳退化（graceful degradation)：如果正确使用了 JavaScript 脚本，可以让访问者在他们的浏览器不支持 JavaScript 的情况下仍能顺利地浏览你网站。<br>虽然某些功能无法使用，但是最基本的操作仍能顺利完成；<br>3、渐进加强：用额外的信息层去包裹原始数据；使 CSS 代码负责提供关于“表示”的信息，JavaScript 代码负责提供关于“行为”的信息。<br>4、分离 JavaScript：在 HTML 文档中使用诸如 onclick 之类的属性也是一种没有效率又容易引发问题的做法。<br>如果利用像 CSS 中的 class 和 id 属性那样，把JavaScript 代码调用行为与 HTML 文档内容和结构分离，网页就会健壮不少。<br>5、向后兼容：对象检测：检测浏览器对 JavaScript 的支持程度。<br>用一个 if 语句的条件表达式看求值结果是 true 还是 false 来采取不同的行动。<br>如在代码前加上 <code>if(!getElementById) return false</code>;<br>6、性能考虑：<br>尽量少访问DOM和尽量减少标记，不管什么时候只要是查询DOM中的某些元素，浏览器就会搜索整个DOM树，从中查找可能匹配的元素。<br>在多个函数都会取得一组类似元素的情况下，可以考虑重新构建代码，把搜索结果保存在一个全局变量里，或者把一组元素以参数形式传递给函数。<br>减少标记数量的目的在于，过多的不必要的元素只会增加DOM树的规模。<br>7、合并和放置脚本：减少请求数量是在性能优化时首先要考虑的；<br>把所以的<code>&lt;script&gt;</code>标签都放在文档的末尾，<code>&lt;/body&gt;</code>标记之前，就可以让页面变得更快。<br>8、压缩脚本：指的是把脚本文件中的不必要的字节，比如空格和注释，统统删除，从而达到“压缩”文件的目的；<br>多数情况下应该有两个版本，一个是工作副本，可以修改代码并添加注释，另一个是精简副本，用于放在站点上，通常在精简副本的文件名上加上 min 字样。</p><h1 id="第6章-案例研究：图片库改进版"><a href="#第6章-案例研究：图片库改进版" class="headerlink" title="第6章 案例研究：图片库改进版"></a>第6章 案例研究：图片库改进版</h1><p>本章主要是第5章内容在 图片库 上的实践。</p><p>共享onload事件：</p><p>假如有两个函数 firstFunction 和 secondFunction 需要在页面加载时执行：</p><pre><code class="JavaScript">window.onload = firstFunction;window.onload = secondFunction;</code></pre><p>这样做的话实际上只有后一个可以执行。</p><pre><code class="JavaScript">window.onload = function(){　　firstFunction();　　secondFunction();}</code></pre><p>这样做创建了一个匿名函数，在需要绑定的函数不是很多的场合的确很实用.</p><p>最佳解决方案,使用 addLoadEvent 函数。<br>这个方案需要额外添加一些代码，但一旦有了这些代码，绑定函数到 onload 就很方便。</p><pre><code class="JavaScript">function addLoadEvent(func){   //将现有的 window.onload 处理函数保存到 oldonload　　var oldonload = window.onload;    //如果现有的 window.onload 上没有处理函数，将 func 添加给它　　if(typeof oldonload != &#39;function&#39;)　　{　　　　window.onload = func;　　}　　else{　　　　window.onload function()　　　　{　　　　　　oldload();　　　　　　func();　　　　}　　}}</code></pre><h1 id="第7章-动态创建标记"><a href="#第7章-动态创建标记" class="headerlink" title="第7章 动态创建标记"></a>第7章 动态创建标记</h1><p>JavaScript 可以通过创建新元素和修改现有元素改变网页的结构。</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><h3 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h3><p>document 的 write() 方法可以方便快速地将字符串插入到文档内。</p><pre><code class="JavaScript">&lt;body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    document.write(&quot;&lt;p&gt;This is inserted.&lt;/p&gt;&quot;);  &lt;/script&gt;&lt;/body&gt;</code></pre><blockquote><p>缺点就是违背了”行为与表现分离的原则”,<br>即使把这句语句挪到外部，还是需要在<code>&lt;body&gt;</code>里边添加<code>&lt;script&gt;</code>标签才可以调用。</p></blockquote><h3 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h3><p>innerHTML 属性可以用来读写某给定元素里地 HTML 元素。</p><pre><code class="JavaScript">&lt;body&gt;  &lt;div id=&quot;testdiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;window.onload = function(){  var testdiv = document.getElementById(&quot;testdiv&quot;);  testdiv.innerHTML=&quot;&lt;p&gt;I inserted &lt;em&gt;this&lt;/em&gt; content.&lt;/p&gt;&quot;;}</code></pre><p>利用此技术无法区分“插入一段内容”还是“替换一段内容”。</p><h2 id="DOM-方法"><a href="#DOM-方法" class="headerlink" title="DOM 方法"></a>DOM 方法</h2><h3 id="createElement-方法"><a href="#createElement-方法" class="headerlink" title="createElement 方法"></a>createElement 方法</h3><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);</code></pre><p>创建元素节点，只创建会出现一个文档碎片（document fragment）。<br>本身并不影响页面表现，它是游荡在JavaScript世界里的一个孤儿。<br>但是它已经有 nodeType 和 nodeName 属性。</p><h3 id="appendChild-方法"><a href="#appendChild-方法" class="headerlink" title="appendChild 方法"></a>appendChild 方法</h3><p>把新创建的节点插入文档的节点树最简单方法是：让其成为某个现有节点的一个子节点。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);</code></pre><h3 id="createTextNode-方法"><a href="#createTextNode-方法" class="headerlink" title="createTextNode 方法"></a>createTextNode 方法</h3><p>创建文本节点填充元素节点的内容。<br>把文本节点插入为元素节点的子节点。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);var txt = document.createTextNode(&quot;Hello World&quot;);para.appendChild(txt);</code></pre><p>改变顺序，二者结果相同。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var txt = document.createTextNode(&quot;Hello World&quot;);para.appendChild(txt);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);</code></pre><h2 id="重回图片库"><a href="#重回图片库" class="headerlink" title="重回图片库"></a>重回图片库</h2><h3 id="在已有元素前插入元素"><a href="#在已有元素前插入元素" class="headerlink" title="在已有元素前插入元素"></a>在已有元素前插入元素</h3><p>DOM 提供了 insertBefore() 方法，把一个元素插入到现有元素之前。</p><p><code>parentElement.insertBefore(newElement,targetElement);</code></p><p>其中：<br>parentElement：目标元素的父元素，<br>newElement：想插入的元素，<br>targetElement：想插入哪个元素之前。</p><pre><code class="JavaScript">var gallery = document.getElementById(&quot;imagegallery&quot;);gallery.parentNode.insertBefore(placeholder,gallery);</code></pre><h3 id="在已有元素后插入元素"><a href="#在已有元素后插入元素" class="headerlink" title="在已有元素后插入元素"></a>在已有元素后插入元素</h3><p>DOM 并没有提供了 insertAfter() 方法，下面编写：</p><pre><code class="JavaScript">function insertAfter (newElement,targetElement){  var parent = targetElement.parentNode;  if(parent.lastChild == targetElement){    parent.appendChild(newElement);  }else{    parent.insertBefore(newElement,targetElement.nextSibling);  }}var gallery = document.getElementById(&quot;imagegallery&quot;);insertAfter(placeholder,gallery);</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax 可以做到只更新页面中的一小部分，其它内容不用重新加载。<br>Ajax 的主要优势是对页面的请求以异步方式发送到服务器。</p><h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>Ajax 的核心是 XMLHttpRequest 对象，XMLHttpRequest 充当浏览器脚本与服务器之间的中间人的角色。<br>JavaScript 可以通过这个对象自己发送请求，同时自己处理响应。</p><pre><code class="JavaScript">function getnewContent (){  var request = new XMLHttpRequest();  if(request){    request.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);    request.onreadystatechange = function(){      if(request.readyState == 4){        var para = document.createElement(&quot;p&quot;);        var txt = document.createTextNode(request.responseText);        para.appendChild(txt);        var testdiv = document.getElementById(&quot;testdiv&quot;);        testdiv.appendChild(para);      }    };    request.send(null);  }}</code></pre><p>其中 readyState 属性的值，有5个可能值：<br>0 表示未初始化<br>1 表示正在加载<br>2 表示加载完毕<br>3 表示正在交互<br>4 表示完成</p><p>访问服务器返回的数据要通过两个属性完成。<br>responseText：保存文本字符串形式的数据。<br>responseXML：保存 Content-Type 头部指定为 “text/xml” 的数据。</p><p>注意 异步请求，脚本在发送 XMLHttpRequest 请求之后仍然会继续执行，不会等待响应返回。</p><h3 id="HIjax"><a href="#HIjax" class="headerlink" title="HIjax"></a>HIjax</h3><p>HIjax 意思是渐进增强地使用 Ajax 。</p><h1 id="第8章-充实文档内容"><a href="#第8章-充实文档内容" class="headerlink" title="第8章 充实文档内容"></a>第8章 充实文档内容</h1><p>JavaScript 脚本只应该用来充实文档内容，要避免使用 DOM 技术来创建核心内容。</p><pre><code class="JavaScript">function displayAbbreviations() {  if (!document.getElementsByTagName || !document.createElement || !document.createTextNode) return false;// 得到所有链接  var abbreviations = document.getElementsByTagName(&quot;abbr&quot;);  if (abbreviations.length &lt; 1) return false;  var defs = new Array();// 遍历链接  for (var i=0; i&lt;abbreviations.length; i++) {    var current_abbr = abbreviations[i];    if (current_abbr.childNodes.length &lt; 1) continue;    var definition = current_abbr.getAttribute(&quot;title&quot;);    var key = current_abbr.lastChild.nodeValue;    defs[key] = definition;  }// 创建列表  var dlist = document.createElement(&quot;dl&quot;);// 遍历访问键  for (key in defs) {    var definition = defs[key];    var dtitle = document.createElement(&quot;dt&quot;);    var dtitle_text = document.createTextNode(key);    dtitle.appendChild(dtitle_text);    var ddesc = document.createElement(&quot;dd&quot;);    var ddesc_text = document.createTextNode(definition);    ddesc.appendChild(ddesc_text);// 添加列表项到列表中    dlist.appendChild(dtitle);    dlist.appendChild(ddesc);  }  if (dlist.childNodes.length &lt; 1) return false;// 创建标题  var header = document.createElement(&quot;h2&quot;);  var header_text = document.createTextNode(&quot;Abbreviations&quot;);  header.appendChild(header_text);// 把标题添加到页面主体  document.body.appendChild(header);// 把列表添加到页面主体  document.body.appendChild(dlist);}addLoadEvent(displayAbbreviations);</code></pre><blockquote><p>我的理解就是把原本 HTML 的内容通过 JavaScript 操作提取出来摘要，再加到 HTML 中充实文档内容。</p></blockquote><h1 id="第9章-CSS-DOM"><a href="#第9章-CSS-DOM" class="headerlink" title="第9章 CSS-DOM"></a>第9章 CSS-DOM</h1><p>我们在浏览器看到的网页其实有三部分构成：</p><ul><li>结构层(structural layer) 由 XHTML 或者 HTML 等标记语言创建。</li><li>表示层(presentation layer) 由 CSS 负责创建。</li><li>行为层(behavior layer) 负责内容应该如何响应事件这一动作，这主要是由 javaScript 和 DOM 负责。</li></ul><h2 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h2><p>在文档中每个人元素都是一个对象，每个元素都有一个 style 属性，他们也是一个对象。</p><h3 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h3><pre><code class="javaScript">element.style.color;// 中间带连字符的 CSS 属性要使用驼峰写法element.style.fontFamily;</code></pre><p>获取样式属性的返回值与设置值采用同样的单位。<br>如我们在 CSS font-size 属性时以 em 为单位，相应的 DOM fontSize 属性也以 em 为单位。</p><blockquote><p>注意 通过 style 获取属性的局限性，即只能返回 <strong>内联样式</strong>。</p></blockquote><p><code>&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;</code></p><p>通过 link 元素引入的 CSS 文件样式不能用 DOM style 属性检索出来。</p><p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></p><p>通过 <code>&lt;head&gt;</code> 部分引入的 <code>&lt;style&gt;</code> 标签里也不能用 DOM style 属性检索出来。</p><pre><code class="HTML">&lt;head&gt;  &lt;style&gt;  hr {color:sienna;}  p {margin-left:20px;}  &lt;/style&gt;&lt;/head&gt;</code></pre><h3 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h3><p>style 对象的各个属性都是可读写的，可以通过元素的 style 属性获取样式，也可以通过它更新样式。</p><pre><code class="JavaScript">element.style.property = value;// 例如：para.style.color = &quot;black&quot;;</code></pre><h2 id="何时该用-DOM-脚本设置样式"><a href="#何时该用-DOM-脚本设置样式" class="headerlink" title="何时该用 DOM 脚本设置样式"></a>何时该用 DOM 脚本设置样式</h2><p>在绝大多数场合还是应该使用 CSS 声明样式。<br>在使用 CSS 不方便的场合，可以利用 DOM 对文档的样式做一些小的增强。</p><p>通过 CSS 设置样式方式：</p><pre><code class="CSS">// 1.通过标签元素p {  font-size: 1em;}// 2.通过class属性.fineorint {  font-size: 1em;}// 3.通过id属性#fineorint {  font-size: 1em;}</code></pre><p>通过 DOM 脚本设置样式的情况：</p><ul><li>根据元素在节点数的位置来设置样式</li><li>根据某种条件反复设置某种样式</li><li>响应事件，即事件发生时设置有关元素的样式</li></ul><h2 id="className-属性"><a href="#className-属性" class="headerlink" title="className 属性"></a>className 属性</h2><p>前面一直在使用 DOM 直接设置或者修改元素的样式，这种让行为层干表示层的活，并不是理想的工作方式。</p><p>与其使用 DOM 直接改变某个元素的样式，倒不如通过 JavaScript 代码修改元素的 class 属性。</p><p>通过修改 DOM 直接改变元素样式：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.style.fontWeight = &quot;bold&quot;;    elem.style.fontSize = &quot;1.2em&quot;;  }}</code></pre><p>通过修改 class 属性：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.setAttribute(&quot;class&quot;,&quot;intro&quot;);  }}</code></pre><p>当然需要提前引入 CSS 样式：</p><pre><code class="CSS">.intro {  font-weight: bold;  font-size: 1.2em;}</code></pre><p>更简单的是通过 className 属性。<br>className 属性是一个可读/可写的属性，凡是元素节点都有这个属性。</p><p>获得元素的 class 属性：<br><code>element.className</code><br>修改元素的 class 属性：<br><code>element.className = value</code></p><p>通过 className 属性修改样式：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.className = &quot;intro&quot;;  }}</code></pre><blockquote><p>缺点：通过 className 属性设置元素的 class 属性将替换原有 class 设置。</p></blockquote><p>可以通过 字符串拼接 解决(注意 intro 前的空格)：</p><p><code>elem.className += &quot; intro&quot;;</code></p><h1 id="第10章-用JavaScript实现动画效果"><a href="#第10章-用JavaScript实现动画效果" class="headerlink" title="第10章 用JavaScript实现动画效果"></a>第10章 用JavaScript实现动画效果</h1><p>JavaScript 能够按照预定的时间间隔重复调用一个函数，而这意味着我们可以随着时间的推移而不断地改变某个元素地样式。</p><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>位置通常是由 CSS 负责设置的：</p><pre><code class="CSS">element {  position: absolute;  top: 50px;  left: 100px;}</code></pre><ul><li><strong>static</strong>: 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li><strong>relative</strong>: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li><li><strong>absolute</strong>: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li><strong>fixed</strong>: 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li><strong>inherit</strong>: 规定应该从父元素继承 position 属性的值。</li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>JavaScript 函数 setTimeout 能让某个函数在经过一段预定的时间后才开始执行。</p><p><code>variable = setTimeout(&quot;function&quot;,interval);</code></p><p>第一个参数为函数名字，第二个参数为间隔时间。若想取消执行：</p><p><code>clearTimeout(variable)</code></p><p>本章主要是定义的一个位置随时间运动的函数：</p><pre><code class="JavaScript">function moveElement(elementID,final_x,final_y,interval) {  if (!document.getElementById) return false;  if (!document.getElementById(elementID)) return false;  var elem = document.getElementById(elementID);  var xpos = parseInt(elem.style.left);  var ypos = parseInt(elem.style.top);  if (xpos == final_x &amp;&amp; ypos == final_y) {    return true;  }  if (xpos &lt; final_x) {    xpos++;  }  if (xpos &gt; final_x) {    xpos--;  }  if (ypos &lt; final_y) {    ypos++;  }  if (ypos &gt; final_y) {    ypos--;  }  elem.style.left = xpos + &quot;px&quot;;  elem.style.top = ypos + &quot;px&quot;;  var repeat = &quot;moveElement(&#39;&quot;+elementID+&quot;&#39;,&quot;+final_x+&quot;,&quot;+final_y+&quot;,&quot;+interval+&quot;)&quot;;  movement = setTimeout(repeat,interval);}</code></pre><h1 id="第11章-HTML5"><a href="#第11章-HTML5" class="headerlink" title="第11章 HTML5"></a>第11章 HTML5</h1><p>本章介绍了 HTML5 的新特性，包括 <code>&lt;canvas&gt;</code>、 <code>&lt;audio&gt;</code>、 <code>&lt;video&gt;</code> 元素及新的表单控件。</p><h1 id="第12章-综合示例"><a href="#第12章-综合示例" class="headerlink" title="第12章 综合示例"></a>第12章 综合示例</h1><p>结合前面的知识实现了一个综合示例，对前面的知识进行了很好的回顾。</p><blockquote><p>这本书看下来，感受最大的是 HTML 和 CSS 基础太差，JavaScript 部分还好。<br>原来计划上个周末看完呢，中间又催文档啥的，这个周末（2017.10.29）才看完。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript DOM 编程艺术》读书笔记&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript编程艺术" scheme="http://www.wshunli.com/tags/JavaScript%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（三）</title>
    <link href="http://www.wshunli.com/posts/21b8791e.html"/>
    <id>http://www.wshunli.com/posts/21b8791e.html</id>
    <published>2017-10-19T03:36:38.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p>或许这就是研究僧生活吧<a id="more"></a> 。专硕也就两年，是时候为未来打算了。</p><p>前阵老师找谈话，问将来的打算，去事业单位还是企业公司等等。</p><p>“打算去互联网公司，做 Android 开发，最好能跟 GIS 有点关系，不想把整个 GIS 都丢掉。”</p><p>回来就查了下阿里巴巴对 Android 工程师的要求：</p><ul><li>熟悉iOS/Android平台原理机制,具备客户端性能优化的经验有一定软件架构设计能力，熟悉常见的异步、同步、多线程、跨进程、组件、容器的设计方法</li><li>具备扎实的数据结构和计算机系统基础，编码功底扎实</li><li>具备C++跨平台开发经验，熟悉NDK开发优先</li><li>具备创新业务技术攻关和落地能力者优先（不限于算法、生物识别、图形图像、3D建模、AR、多媒体等领域）</li></ul><p>也有查 Android 工程师的技术栈。总体来说包括以下几个方面：</p><ul><li>计算机基础，包括计算机网络、操作系统、数据库</li><li>数据结构与算法</li><li>Java 语言基础及设计模式</li><li>Android 技术栈</li><li>C++ 语言，使用 NDK 可加分</li><li>React Native 、Ionic 等跨平台技术</li></ul><p>在国庆前基本上在拿着 《Java编程思想》 啃，学到了不少新的知识点，非常遗憾没有笔记。</p><p>国庆假期在看 《计算机网络(第七版)》 谢希仁，基本上过了一遍，并写了阅读笔记 <a href="https://www.wshunli.com/tags/计算机网络/">计算机网络阅读笔记</a> ，对付面试应该没问题吧。</p><p>基本上国庆后就在抓紧时间做 Node.js 后端的项目，现在已经完成了所有的单元测试，除了逻辑性的错误，问题不大。<br>然后就是 WebGIS 项目，现在在写文档阶段，打算这段时间学习下 Javascript ，尤其是 ES6 。<br>论文外审没过，改投的 计算机应用与软件 ，今天交的审稿费，这次应该能过，感觉上面的论文跟我的差不多水。</p><p>后面模型和视频叠加的技术尽快做完吧。<br>打算简单地过一遍操作系统，然后看 Java 语言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;或许这就是研究僧生活吧
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（六）</title>
    <link href="http://www.wshunli.com/posts/698896b2.html"/>
    <id>http://www.wshunli.com/posts/698896b2.html</id>
    <published>2017-10-10T13:47:27.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p><strong>计算机网络-应用层</strong> 部分读书笔记<a id="more"></a></p><p>运输层为应用进程提供了端到端的通信服务，但不同的网络应用的应用进程之间，还需要有不同的通信规则，因此在运输层协议之上，还需要有 <strong>应用层协议</strong>。</p><h1 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h1><p>域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p>域名存储：</p><ul><li>理论上：我们可以只使用一个域名服务器存储所有的域名和与之对应的IP地址。因为互联网的规模巨大，这个域名服务器一定会因为过负荷而无法正常工作。而且如果出现故障，整个互联网将进入瘫痪状态。</li><li>实际上：DNS被设计成联机分布式数据库系统，并采用C/S方式。因此即使单个计算机出现故障也不会影响整个互联网的正常运行。</li></ul><h2 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h2><p>如今互联网域名采用层次树状的命名方法。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-DNS结构.png-hexo.png" alt="应用层-DNS结构"></p><h3 id="顶级域名："><a href="#顶级域名：" class="headerlink" title="顶级域名："></a>顶级域名：</h3><p><strong>1.国家顶级域名</strong> nTLD<br>cn（中国)　　us(美国)　　uk(英国) ···</p><p><strong>2.通用顶级域名</strong> gTLD<br>com(公司企业)　　　　　　net(网络服务机构)　　　　　org(非营利性组织)　　　　int(国际组织)<br>edu(美国专用的教育机构)　gov(美国的政府部门)　　　　mil(美国的军事部门)　　　name(个人)<br>aero(航空运输企业)　　　 asia(亚太地区)　　　　　　 biz(公司和企业)　　　　　travel(旅游业)<br>coop(合作团体)　　　　　 info(各种情况)　　　　　　 jobs(人力资源管理者)<br>museum(博物馆) 　　　　　pro(有证书的专业人员)　　　tel(Telnic股份有限公司)<br>mobi(移动产品与服务的用户和提供者)</p><p><strong>3.基础结构域名</strong><br>arpa(反向域名) 用于反向域名解析</p><h3 id="二级域名（我国）"><a href="#二级域名（我国）" class="headerlink" title="二级域名（我国）"></a>二级域名（我国）</h3><p><strong>1.类别域名</strong><br>com(工、商、金融等企业)　　　　ac(科研机构)　　　　edu(中国教育机构　　gov(中国政府机构)<br>net(提供互联网络服务的机构)　　mil(中国国防机构)　　 org(非营利性的组织)</p><p><strong>2.行政区域名</strong><br>bj(北京) js(江苏) sx(山西) ···</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><h3 id="域名服务器结构"><a href="#域名服务器结构" class="headerlink" title="域名服务器结构"></a>域名服务器结构</h3><p>理论上：在理论上来说，按照上面的域名的结构可以对照出域名服务器的结构，但是如果这样的话会有许多的域名服务器，这样导致了效率变低。<br>实际上：实际上DNS采用了划分区的方法来解决效率低的问题。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-域名服务器分区.png-hexo.png" alt="应用层-域名服务器分区"></p><p>DNS服务器管辖的范围是 <strong>区</strong> 而不是 域 ，每一个区设置相应的权限域名服务器来保存该区中所有主机的域名到IP地址的映射。区可能等于或者小于域，但一定不能大于域。</p><h3 id="域名服务器的分类和作用"><a href="#域名服务器的分类和作用" class="headerlink" title="域名服务器的分类和作用"></a>域名服务器的分类和作用</h3><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-域名服务器结构.png-hexo.png" alt="应用层-域名服务器结构"></p><p><strong>1. 根域名服务器</strong></p><ul><li>知道所有顶级域名服务器的域名和IP地址。</li><li>只有13个域名，多台服务器使用同一个IP地址。</li><li>本地域名服务器无法解析时，首先要求助根域名服务器。</li></ul><p><strong>2. 顶级域名服务器</strong></p><ul><li>管理所有在该顶级域名服务器中注册的二级域名。</li><li>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</li></ul><p><strong>3. 权限域名服务器</strong></p><ul><li>负责一个区的域名服务器。</li><li>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</li></ul><p><strong>4. 本地域名服务器</strong></p><ul><li>不属于域名服务器层级结构</li><li>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li><li>每一个互联网服务提供者ISP，或者一个大学，甚至一个大学里的一个系，都可以拥有一个本地域名服务器。</li></ul><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>对于用户来说，域名解析过程只有一步，将域名向本地域名服务器查询，本地域名服务器返回查询结果。但是对于本地域名服务器来说就没这么简单了，查询方法有如下两种：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-域名解析过程.png-hexo.png" alt="应用层-域名解析过程"></p><p><strong>1. 迭代查询</strong></p><p>1 用户向本地域名服务器查询。<br>2 本地域名服务器向根域名服务器查询。<br>3 根域名服务器告诉本地域名服务器下一次查询的顶级域名服务器的IP地址。<br>4 本地域名服务器向顶级域名服务器查询。<br>5 顶级域名服务器告诉本地域名服务器下一次查询的权限域名服务器的IP地址。<br>6 本地域名服务器向权限域名服务器查询。<br>7 权限域名服务器将最终的IP地址告诉本地域名服务器。<br>8 本地域名服务器将最终的IP地址告诉用户。</p><p><strong>2. 递归查询</strong></p><p>1 用户向本地域名服务器查询。<br>2 本地域名服务向根域名服务器查询。<br>3 根域名服务器向顶级域名服务器查询。<br>4 顶级域名服务器向权限域名服务器查询。<br>5 权限域名服务器将IP地址告诉顶级域名服务器。<br>6 顶级域名服务器将IP地址告诉根域名服务器。<br>7 根域名服务器将IP地址告诉本地域名服务器。<br>8 本地域名服务器将IP地址告诉用户。</p><h3 id="提高域名服务器可靠性"><a href="#提高域名服务器可靠性" class="headerlink" title="提高域名服务器可靠性"></a>提高域名服务器可靠性</h3><p>DNS服务器把数据复制到几个域名服务器来保存，其中一个是主域名服务器 其他是辅助域名服务器 ，当主域名服务器出现故障，辅助域名服务器可以保证DNS查询工作的正常运行。主域名服务器会定期把数据复制到辅助域名服务器中。而修改数据只需要在主域名服务器操作即可保证数据的一致性。</p><h3 id="提高查询效率"><a href="#提高查询效率" class="headerlink" title="提高查询效率"></a>提高查询效率</h3><p>在域名服务器中使用高速缓存（高速缓存域名服务器） 用来存放最近查询过的域名以及从何处获取域名映射信息的记录。例如：<br>如果不久前已经查询过 www.baidu.com 的IP地址，那么再次向本地域名服务器发出查询申请的时候，本地域名服务器并不需要向根域名服务器发出查询申请，而是直接把高速缓存中上次查询的结果告诉用户。</p><h1 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h1><p>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。<br>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。<br>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求。</p><p>主进程的工作步骤如下:<br>1.打开熟知端口（端口号为 21），使客户进程能够连接上。<br>2.等待客户进程发出连接请求。<br>3.启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。<br>4.回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。</p><p>在进行文件传输时，FTP 客户端和服务器之间会建立两个并行的 TCP 连接。控制进程和数据传输进程为从属进程。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-FTP两个TCP连接.png-hexo.png" alt="应用层-FTP两个TCP连接"></p><p>控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。<br>实际用于传输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。<br>数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p><p>FTP 若存取一个文件，就行必须先获取一个本地文件副本。如果要修改文件，只能对文件的副本进行修改，然后再对修改后的文件副本传回原节点。</p><p><strong>网络文件系统</strong> NFS(Network File System)<br>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。<br>NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。<br>对于上述例子，计算机 A 的 NFS 客户软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 的 NFS 服务器。NFS 服务器更新文件后返回应答信息。在网络上传送的只是少量的修改数据。</p><p><strong>简单文件传送协议</strong> TFTP(Trivial File Transfer Protocol)<br>1.TFTP 是一个很小且易于实现的文件传送协议。<br>2.TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。<br>3.TFTP 只支持文件传输而不支持交互。<br>4.TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p>TFTP 的 <strong>主要特点</strong><br>(1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。<br>(2) 数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。<br>(3) 支持 ASCII 码或二进制传送。<br>(4) 可对文件进行读或写。<br>(5) 使用很简单的首部。</p><h1 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h1><p>TELNET 是一个简单的远程终端协议，也是因特网的正式标准。<br>用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。<br>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。</p><p>TELNET 使用网络虚拟终端 NVT 格式<br>客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。<br>服务器软件把收到的数据和命令，从 NVT 格式转换成远地系统所需的格式。<br>向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式。</p><h1 id="万维网-WWW"><a href="#万维网-WWW" class="headerlink" title="万维网 WWW"></a>万维网 WWW</h1><p>万维网是一个大规模的、联机式的信息储藏所。</p><p>客户程序向服务器发出请求，服务器程序返回客户所需的万维网文档。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-万维网工作过程.png-hexo.png" alt="应用层-万维网工作过程"></p><h2 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符 URL"></a>统一资源定位符 URL</h2><p>统一资源定位符 URL是用来表示从互联网上获取资源位置和访问这些资源的方法。</p><h2 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h2><p>HTTP使用TCP作为其运输层协议，面向事务的应用层协议；<br>服务器在向客户机发送被请求的文件时，并不存储任何关于该客户机的状态信息，即HTTP是一个无状态协议；<br>有时为了能够使Web站点识别用户，可以使用 Cookie。</p><h3 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h3><p>非持久连接：至多一个对象经过一个TCP连接发送。<br>持久连接：多个对象能够经过客户机和服务器之间的单个TCP连接发送。</p><p>HTTP既可以使用非持久连接，也可以使用持久连接，默认方式下HTTP使用持久连接。</p><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>HTTP 有两类报文：<br>请求报文——从客户向服务器发送请求报文。<br>响应报文——从服务器到客户的回答。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-HTTP报文.png-hexo.png" alt="应用层-HTTP报文"></p><p>由于HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p><p>HTTP <strong>请求报文</strong></p><pre><code class="text">GET  /somedir/page.html  HTTP/1.1Host:  www.someschool.eduConnection:  closeUser-agent:  Mozilla/4.0Accept-language:  fr</code></pre><p>HTTP 请求报文的第一行叫做请求行，其后继的行叫做首部行；</p><p>请求行有3个字段：方法字段、URL字段和 HTTP 协议版本字段；<br>方法字段可以取值GET、POST、HEAD、 PUT和DELETE。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-HTTP请求报文方法.png-hexo.png" alt="应用层-HTTP请求报文方法"></p><p>Host 首部行定义了目标所在的主机（Web代理缓存需要）；<br>Connection 首部行值为close表示HTTP使用非持久连接 ；<br>User-agent 首部行用来定义用户代理（即浏览器类型）；<br>Accept-language 首部行表示用户想要得到该对象什么语言版本.</p><p>HTTP <strong>响应报文</strong></p><pre><code class="text">HTTP/1.1  200  OKConnection:  CloseData: Thu,  03  Jul  2003  12:00:15   GMTServer:  Apache/1.3.0 (Unix)Last-Modified:  Sun,  6  May  2007  09:23:24  GMTContent-Length:  6821Content-Type:  text/html(data data data data data)</code></pre><p>该响应报文同样分成3个部分：一个初始状态行，6个首部行，然后是实体主体；<br>实体主体部分是报文的主体，包含了所请求的对象本身；<br>状态行有3个字段：协议版本、状态码和相应状态信息。</p><p>状态码：<br>1xx 表示通知信息，如请求收到了或正在进行处理。<br>2xx 表示成功，如接受或知道了。<br>3xx 表示重定向，如要完成请求还必须采取进一步行动。<br>4xx 表示客户的差错，如请求中有错误的语法或者不能完成。<br>5xx 表示服务器的差错，如服务器失效无法完成请求。<br>更多信息：<a href="http://blog.csdn.net/u014345282/article/details/49101245" rel="external nofollow noopener noreferrer" target="_blank">计算机网络（三）http状态码大全</a></p><p>Date 首部行表示服务器产生并发送该响应报文的日期和时间；<br>Server 首部行表示该报文是由什么服务器产生的（类似请求报文里的User-agent）；<br>Last-Modified 首部行表示对象创建或者最后修改的日期和时间；<br>Content-Length 首部行表明了被发送对象的字节数；<br>Content-Type 首部行表示实体主体中的对象类型.</p><h3 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h3><p>Web缓存器也叫代理服务器，是能够代表初始Web服务器来满足HTTP请求的网络实体；<br>Web缓存器有自己的磁盘存储空间，并在该存储空间中保存最近请求过的对象的拷贝；<br>Web缓存器可以大大减少对客户机请求的响应时间。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-代理服务器.png-hexo.png" alt="应用层-代理服务器"></p><h3 id="在服务器上存放用户的信息"><a href="#在服务器上存放用户的信息" class="headerlink" title="在服务器上存放用户的信息"></a>在服务器上存放用户的信息</h3><p>1.万维网站点使用 Cookie 来跟踪用户。<br>2.Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。<br>3.使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。</p><h2 id="万维网文档"><a href="#万维网文档" class="headerlink" title="万维网文档"></a>万维网文档</h2><h3 id="超文本标记语言-HTML"><a href="#超文本标记语言-HTML" class="headerlink" title="超文本标记语言 HTML"></a>超文本标记语言 HTML</h3><p>HTML 并不是应用层协议，而是一种制作网页的语言。<br>XML 可扩展标记语言，主要是传输数据。<br>XHTML 可扩展超文本标记语言，更严格版本的HTML。</p><h3 id="动态万维网文档"><a href="#动态万维网文档" class="headerlink" title="动态万维网文档"></a>动态万维网文档</h3><p>静态文档是指文档在创建完毕之后就存放在万维网服务器中，就不会改变了。静态文档的最大优点就是简单，可以由不懂程序设计的人员来创建。但是缺点是不够灵活。<br>动态文档（dynamic document）是指文档的内容是在浏览器访问万维网服务器的时候才由应用程序动态创建。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-动态万维网文档.png-hexo.png" alt="应用层-动态万维网文档"></p><p><strong>通用网关接口</strong> CGI</p><p>CGI 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。<br>万维网服务器与 CGI 的通信遵循 CGI 标准。<br>“通用”：CGI 标准所定义的规则对其他任何语言都是通用的。<br>“网关”：CGI 程序的作用像网关。<br>“接口”：有一些已定义好的变量和调用等可供其他 CGI 程序使用。</p><h3 id="活动万维网文档"><a href="#活动万维网文档" class="headerlink" title="活动万维网文档"></a>活动万维网文档</h3><p>活动文档(active document)技术把所有的工作都转移给浏览器端。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-活动万维网文档.png-hexo.png" alt="应用层-活动万维网文档"></p><p>每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。<br>活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。<br>由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>因特网电子邮件系统有3个主要组成部分：用户代理、邮件服务器和简单邮件传输协议；<br>用户代理允许用户阅读、回复、转发和撰写报文；<br>邮件服务器组成了电子邮件体系结构的核心；<br>SMTP则是因特网电子邮件中的主要应用层协议（使用TCP传输）；</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-电子邮件.png-hexo.png" alt="应用层-电子邮件"></p><p>一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器（使用SMTP协议），再传输到接收方的邮件服务器（使用SMTP协议），然后在这里被分发到接收方的邮箱里（POP3或IMAP）。</p><h2 id="简单邮件传送协议-SMTP"><a href="#简单邮件传送协议-SMTP" class="headerlink" title="简单邮件传送协议 SMTP"></a>简单邮件传送协议 SMTP</h2><p>SMTP 通信的三个阶段<br>1.连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。<br>2.邮件传送<br>3.连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。</p><h2 id="邮件读取协议POP3-和-IMAP"><a href="#邮件读取协议POP3-和-IMAP" class="headerlink" title="邮件读取协议POP3 和 IMAP"></a>邮件读取协议POP3 和 IMAP</h2><p>POP 也使用客户服务器的工作方式。<br>在接收邮件的用户 PC 机中必须运行 POP 客户程序，而在用户所连接的 ISP 的邮件服务器中则运行 POP 服务器程序。</p><h2 id="IMAP-协议"><a href="#IMAP-协议" class="headerlink" title="IMAP 协议"></a>IMAP 协议</h2><p>IMAP (Internet Message Access Protocol）也是按客户服务器方式工作，现在较新的是版本 4，即 IMAP4。<br>用户在自己的 PC 机上就可以操纵 ISP 的邮件服务器的邮箱，就像在本地操纵一样。<br>因此 IMAP 是一个联机协议。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。</p><p>IMAP 的特点:<br>1.IMAP最大的好处就是用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。<br>2.IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像附件（此文件可能很大）的邮件。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。<br>3.IMAP 的缺点是如果用户没有将邮件复制到自己的 PC 机上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。</p><h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h1><p>动态主机配置协议 DHCP 提供了即插即用连网(plug-and-play networking)的机制。<br>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p><p>DHCP <strong>使用客户服务器方式</strong><br>1.需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。<br>2.本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。<br>3.DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池(address pool)中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文（DHCPOFFER）。</p><p>DHCP <strong>中继代理</strong>(relay agent)<br>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。<br>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p><p><strong>租用期</strong>(lease period)<br>DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-DHCP工作过程.png-hexo.png" alt="应用层-电子邮件"></p><p>DHCP 协议的<strong>工作过程</strong>：<br>1.DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。<br>2.DHCP 客户从 UDP 端口 68发送 DHCP 发现报文。<br>3.凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文。<br>4.DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文。<br>5.被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。<br>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。<br>6.租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租用期。<br>7.DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。<br>8.DHCP 服务器若不同意，则发回否认报文DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2）。<br>若DHCP服务器不响应步骤6的请求报文DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。<br>9.DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</p><h1 id="应用进程跨越网络的通信"><a href="#应用进程跨越网络的通信" class="headerlink" title="应用进程跨越网络的通信"></a>应用进程跨越网络的通信</h1><p>两个端系统进行通信，真正进行通信的其实是进程而不是程序。<br>不同端系统上的进程通过跨越计算机网络交换报文而相互通信。</p><h2 id="客户机和服务器进程"><a href="#客户机和服务器进程" class="headerlink" title="客户机和服务器进程"></a>客户机和服务器进程</h2><p>网络应用程序是由成对的进程组成的，对每对通信进程，通常将进程分为客户机和服务器，在Web中，浏览器是一个客户机进程，Web服务器是一个服务器进程；对于P2P文件共享，下载文件的对等方被视为客户机，上传文件的对等方被视为服务器；其具体定义为：在给定的一对进程之间的通信会话中，发起通信的进程被视为客户机，在会话开始时等待联系的进程是服务器</p><h2 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h2><p>对于一对通信进程，进程通过被称为套接字的软件接口在网络上发送和接收报文；套接字是同一台主机内应用层与运输层之间的接口；由于该套接字是在网络上建立网络应用程序的可编程接口，因此也将该套接字称为应用程序和网络之间的应用程序编程接口（API）；应用程序开发者可以控制套接字在应用层端的所有东西，但是对该套接字的运输层端几乎没有控制；应用程序开发者对于运输层的控制仅限于：1.选择运输层协议；2.设置一些运输层参数（如最大缓存，最大报文长度）</p><h1 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h1><p>大多数流量密集型应用程序都是基于P2P体系的，例如文件分发、文件搜索/共享、因特网电话等等；P2P体系最突出的特性是其自扩展性；例如，在一个P2P文件共享应用中，尽管每个对等方都由请求文件产生负载，但每个对等方向其他对等方分发文件也为系统增加了服务能力；P2P通常不需要庞大的服务器基础设施和带宽</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;计算机网络-应用层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（五）</title>
    <link href="http://www.wshunli.com/posts/c86dd6b.html"/>
    <id>http://www.wshunli.com/posts/c86dd6b.html</id>
    <published>2017-10-07T01:20:20.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p><strong>计算机网络-运输层</strong> 部分读书笔记<a id="more"></a></p><h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><p>运输层提供应用进程间的逻辑通信。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-运输层和网络层.png-hexo.png" alt="运输层-运输层和网络层"></p><p>网络层为主机之间提供逻辑通信（网络核心部分），运输层为应用进程之间提供端到端的逻辑通信（网络边缘部分）。<br>从运输层来看，通信是两主机应用进程之间相互通信。不同进程可以使用同一运输层协议传输数据。</p><p>运输层要对收到的报文进行差错检测。<br>在网络层，IP数据报首部的检验和字段，只检验首部而不检查数据部分。</p><p><strong>传输层</strong>的两个主要协议</p><p>(1) 用户数据报协议 UDP （User Datagram Protocol）<br>(2) 传输控制协议 TCP （Transmission Control Protocol）</p><p>在 OSI 中，两个对等实体在通信时传达的数据单元叫做传输协议数据单元 TPDU 。<br>在 TCP/IP 中，根据协议不同分别称之为TCP报文段、UDP数据段 。</p><p>UDP 传输数据之前不需要先建立连接，不提供可靠交付。<br>TCP 提供面向连接的服务，传输之前先建立连接，结束后要释放连接。不提供广播或者多播服务。</p><p><strong>运输层</strong>的端口</p><p>为了使运行在不同操作系统的计算机应用程序能够相互通信，使用统一的方法（在运输层使用协议端口号）对 TCP/IP 体系的应用进程进行标志。</p><p>在运输层使用协议端口使软端口，软件端口使应用层的各协议进程与传输实体进行层间交互的一种地址。<br>硬件端口使不同硬件设备进行交互的接口。</p><h1 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h1><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p><p>UDP 的主要特点：</p><ul><li>UDP 是无连接的，即发送数据之前不需要建立连接。</li><li>UDP 使用尽最大努力交付，即不保证可靠交付。</li><li>UDP 是面向报文的，对应用层交下来的报文、IP层交上来的UDP数据报，不合并也不拆分。</li><li>UDP 没有拥塞控制，很适合多媒体通信的要求。</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP 的首部开销小，只有 8 个字节。</li></ul><p>UDP 的首部格式：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-UDP报文段.png-hexo.png" alt="运输层-UDP报文段"></p><ul><li>源端口字段：源端口是一个大于1023的16位数字，由基于UDP应用程序的用户进程随机选择。</li><li>目的端口字段：目的端口号，在终点交付报文使用。</li><li>长度字段：指明了包括首部在内的UDP报文段长度。UDP长字段的值是UDP报文头的长度(8字节)与UDP所携带数据长度的总和。</li><li>校验和字段：指整个UDP报文头和UDP所带的数据的校验和（也包括伪报文头）。</li></ul><p>伪首部不包括在真正的UDP报文头中，但是它可以保证UDP数据被正确的主机收到了。因在校验和中加入了伪头标，故ICMP除能防止单纯数据差错之外，对IP分组也具有保护作用。</p><h1 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h1><p><strong>TCP</strong> 的主要特点：</p><ul><li>TCP 是面向连接的运输层协议。使用之前先建立建立连接，使用后释放。</li><li>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。</li><li>TCP 提供可靠交付的服务，使用 TCP 连接传达的数据，无差错、不丢失、不重复，并且按序到达。</li><li>TCP 提供全双工通信。TCP 连接的两端都设有缓存，允许通信双方的应用进程在任何时候都能发送数据。</li><li>面向字节流。TCP 把应用程序交下来的数据仅仅看成一串无结构的字节流。不保证接收方和发送方的数据块具有对应的大小关系，但是字节流完全一样，由接收方应用程序还原成有意义的应用层数据。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP面向字节流.png-hexo.png" alt="运输层-TCP面向字节流"></p><ul><li>TCP 连接是一条虚连接（逻辑连接）而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。</li><li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li><li>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li></ul><p><strong>TCP</strong> 的连接</p><p>TCP 把<strong>连接</strong>作为最基本的抽象。<br>一条 TCP 连接有两个端点，又叫嵌套字（socket）或插口，由端口号拼接IP地址组成。</p><p>嵌套字 socket = IP地址 ： 端口号</p><p>每条 TCP 连接唯一地被通信两端的两个端点所确定。即：</p><p>TCP 连接 = {socket1，socket2} = {（IP1：port1），（IP2：port2）}</p><p>TCP 连接的端点是个很抽象的嵌套字。同一 IP 地址可以有多个 TCP 连接，同一端口号也可以出现在不同的 TCP 连接中。</p><p>TCP 与 UDP 的<strong>区别</strong>：</p><ul><li>TCP 提供面向连接的服务。</li><li>TCP 不提供广播或多播服务。</li><li>TCP 协议数据单元的首部增大很多，还要占用许多的处理机资源。</li><li>UDP 在传送数据之前不需要先建立连接。</li><li>对方收到 UDP 报文后，不需要给出任何确认。</li><li>在某些情况下 UDP 是一种最有效的工作方式。</li></ul><h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><p>TCP 发送的报文段是交给 IP 层传递的，但是 IP 层只能提供尽最大努力服务。也就是说，TCP下面的网络所提供的是不可靠的传输。</p><p>理想状态下的传输条件有两个特点：</p><ul><li>传输信道不产生差错。</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ul><h2 id="停止等地协议-ARQ"><a href="#停止等地协议-ARQ" class="headerlink" title="停止等地协议 ARQ"></a>停止等地协议 ARQ</h2><p>ARQ 协议（自动重传请求）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用 <strong>确认和超时</strong> 这两个机制，在不可靠服务的基础上实现可靠的信息传输。</p><p>1、无差错情况<br>“停止等待” 即每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-停止等待协议.png-hexo.png" alt="运输层-停止等待协议"></p><p>2、出错情况<br>B 接收分组使检测出差错就丢弃，其他什么也不做（不通知A收到有差错的分组），也可能发送过程中丢失了。<br>A 超过一段时间没有收到确认就认为分组丢失了，因而重传前面发送过的分组。</p><p>3、确认丢失和确认迟到<br>B 发送的确认丢失，A 又重传分组，此时B放弃重复的分组并再次向 A 发送确认。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-停止等待协议-确认迟到和重复.png-hexo.png" alt="运输层-停止等待协议-确认迟到和重复"></p><p>A 收到重复的确认分组就放弃。</p><p>为了提高传输效率，发送方可以连续发送多个分组，不必每发完一个分组就停下来等待确认，即流水线传输。</p><p>流水线传输使用 连续ARQ协议和滑动窗口协议。</p><h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><p>接收方采用累计确认的方式。即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按需到达的最后一个分组确认，这就表示：到这分组为止的所有分组都已正确收到了。</p><h1 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h1><p>TCP（Transmission Control Protocol）传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP报文段.png-hexo.png" alt="运输层-TCP报文段"></p><ul><li>源端口和目标端口：和 UDP 类似，源端口号和目的端口号实现分用功能；</li><li>序号：本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而起数据共100字节，则下一个报文段的序号就是400。</li><li>确认号：是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号。例如，B收到报文段序号字段是501，数据长度为200（字节的序号501-700），则表明B收到了A发送的到700为止的数据。因此B期望的数据序号是701，在确认报文段中确认号置为701。</li><li>数据偏移：数据起始处离TCP报文段的起始处有多远。实际上是TCP报文段首部的长度，因为首部长度不固定，所以数据偏移字段是必要的。数据偏移的单位是4个字节，即首部最大长度为 4*15。</li><li>保留字段： 供今后使用，目前置为0。</li></ul><p>控制位，用来说明本报文的性质：</p><ul><li>紧急URG（URGent）：当URG=1时，此报文应尽快传送，而不要按本来的列队次序来传送。与 “紧急指针” 字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长；</li><li>确认ACK（ARKnowledge）：只有当ACK=1时，确认序号字段才有意义</li><li>推送PSH（PuSH）：当PSH=1时，希望接收方T尽快将本报文段传送给其应用层，而不要比及全部缓存都填满了之后再向上交付。</li><li>复位RST（ReSeT）：当RST=1时，表明TCP连接呈现严重错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接；</li><li>同步比特SYN（SYNchronization）：在建立连接时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若接受建立连接，在响应的报文段中使SYN=1和ACK=1。所以，SYN=1默示这是一个连接请求或连接接受报文，而ACK的值用来区分是哪一种报文；</li><li>终止FIN（FINis）：用来释放一个连接，当FIN=1时，表示发送方的字节串已经发完，并请求释放传输连接；</li></ul><p>其他：</p><ul><li>窗口：指出现在允许对方发送的数据量，窗口值从本报文段的确认号算起，总是动态变化着。</li><li>检验和：检验和覆盖了整个的TCP报文段： TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</li><li>紧急指针：参考标志字段的URG位。</li><li>选项：为了适合复杂网络环境和更好地服务于应用层设计的。TCP选项最长是40字节。</li><li>数据：无任何数据的TCP段也是合法的，通常用于确认和控制信息。</li></ul><p>TCP 报文段的 <strong>选项</strong> 字段。</p><p>最大报文段长度 MSS ：TCP报文段中的 <strong>数据字段</strong> 的最大长度。<br>窗口扩大：就是为了建立TCP连接时协商扩大窗口。<br>时间戳：包含时间戳值和时间戳回送回答字段。计算往返时间、防止序号重复使用时序号绕回。<br>选择确认：见下节。</p><h1 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h1><p><strong>TCP 可靠传输</strong> 的实现：确认和重传、数据校验、数据合理分片和排序、流量控制、拥塞控制。</p><p>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。<br>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP可靠传输.png-hexo.png" alt="运输层-TCP可靠传输"></p><p>发送过的数据未收到确认之前必须保留，以便超时重传时使用。</p><p>发送窗口<strong>后沿</strong>变化有两种可能：发送窗口不动(没收到确认)和前移(收到新的确认)。<br><strong>前沿</strong>通常时不断向前移动，但也有可能不动（没有收到新的确认；收到确认但对方通知的窗口变小了）。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP缓存与窗口.png-hexo.png" alt="运输层-TCP缓存与窗口"></p><p>发送缓存用来暂时存放： 发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。<br>接收缓存用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据； 不按序到达的数据。</p><p>必须强调三点：</p><ul><li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li><li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li></ul><h2 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h2><p>TCP 采用一种自适应算法。<br>TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。但是由于TCP的下层互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同，因此注定超时重传时间要动态变化。</p><h2 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h2><p>选择确认是针对没有出错但是未按序到达的报文段，如果中间只是缺少一些报文段，那么发送方就可以不重传已发送的所有数据，而只是重传缺少的数据。</p><h1 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h1><p>流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制就可以实施流量控制。<br>原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP流量控制.png-hexo.png" alt="运输层-TCP流量控制"></p><p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。<br>解决这个问题，TCP为每一个连接设置一个<strong>持续计时器</strong>（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口<strong>探测报文段</strong>。对方就在确认这个报文的时候给出现在的窗口大小。</p><p>注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。</p><h1 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h1><p>在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这种情况叫做拥塞。</p><h2 id="拥塞控制设计"><a href="#拥塞控制设计" class="headerlink" title="拥塞控制设计"></a>拥塞控制设计</h2><p>拥塞控制是很难设计的，因为它是一个动态的问题，许多情况下，甚至正式拥塞控制机制本身成为引起网络性能恶化甚至死锁的原因。<br>从控制理论的角度来看拥塞控制这个问题，可以分为 <strong>开环控制和闭环控制</strong> 两种方法。</p><p><strong>开环控制</strong> 就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。</p><p><strong>闭环控制</strong> 是基于反馈环路的概念，包括如下措施：</p><ol><li>监测网路系统以便检测拥塞在何时何地发生；</li><li>把拥塞发生的信息传送到可采取行动的地方；</li><li>调整网络系统的行动以解决出现的问题。</li></ol><h2 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h2><p>TCP 拥塞控制的算法有四种，即慢开始（Slow-start)，拥塞避免（Congestion Avoidance)，快重传（Fast Restrangsmit)和快恢复（Fast Recovery）。</p><p>我们假定：<br>1）数据是单方向传送，而另外一个方向只传送确认。<br>2）接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。</p><p><strong>1.</strong> 慢开始和拥塞避免</p><p>发送方维持一个拥塞窗口(cwnd)的状态变量。其大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口小于或等于拥塞窗口。</p><p>慢开始原理：</p><p>当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞。比较好的方法是试探一下，即从小到达逐渐增大发送端的拥塞控制窗口数值。通常在刚刚开始发送报文段时可先将拥塞窗口cwnd(拥塞窗口)设置为一个最大报文段的MSS的数值。</p><p>在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind（接收窗口）足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量– <strong>慢开始门限</strong> ssthresh。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-慢开始和拥塞避免.png-hexo.png" alt="运输层-慢开始和拥塞避免"></p><p>拥塞避免算法的思路是：让拥塞窗口cwnd线性缓慢增长。</p><p><strong>2.</strong> 快重传和快恢复</p><p>快重传的算法思路是：</p><ul><li>要求接收方每收到一个时序的报文段后就立即发出重复确认，而不是等待发送数据时才进行捎带确认</li><li>发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期</li></ul><p>快恢复的算法思路是：</p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始阀值ssthresh减半</li><li>接着不执行慢开始，而是从新阀值ssthresh开始执行拥塞避免算法(加法增大)</li></ul><h2 id="TCP拥塞控制和流量控制的差别"><a href="#TCP拥塞控制和流量控制的差别" class="headerlink" title="TCP拥塞控制和流量控制的差别"></a>TCP拥塞控制和流量控制的差别</h2><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。<br>拥塞控制是一个全局过程，涉及所有主机、所有路由器，以及降低网络传输性能有关的所有因素。</p><p>流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p><h1 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h1><p>TCP是面向连接的协议，运输连接是用来传送TCP报文段的。运输连接有三个阶段：<strong>连接建立、数据传送、连接释放</strong>。</p><p>在TCP连接建立过程中要解决三个问题：</p><ul><li>要使每一方知道对方的存在。</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ul><p>TCP连接的建立是采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），而被动等待连接建立的应用进程叫做服务器（sever）。</p><h2 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h2><p>假定主机A运行的是TCP客户程序，而B运行的是TCP服务器程序。最初两端的TCP都是处于CLOSED状态。A主动打开连接，B被动打开连接。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP连接建立.png-hexo.png" alt="运输层-TCP连接建立"></p><p>B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程A的请求。然后服务器出于LISTEN状态，等待客户A的连接请求。</p><ul><li>A的客户端进程首先创建TCB，然后向B发送连接请求报文段。这时首部中的同不好SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN（SYN = 1）报文段不能携带数据，但是要消耗一个序号。这时客户机A进入同步已发送状态（SYN-SENT）。</li><li>B收到连接请求的报文段后，如果同意建立连接，则向A发送确认。在确认报文段中应当把SYN和ACK的值都置为1，确认号是ack = x + 1，同时也为自己初始化一个序号seq = y。注意该报文也不能携带数据，但是需要消耗掉一个序号。此时TCP服务器进程进入同步收到状态（SYN-RCVD）。</li><li>TCP客户进程收到服务器端的确认后，还要想B发送确认。报文段的ACK置为1，确认号ack = y + 1，而自己的序号为seq = x + 1。TCP的标准规定，ACK报文段可以携带数据，如果不携带数据则不消耗序号，在这种情况下，下一个报文段的序号仍是seq = x + 1.这时TCP连接已经建立，此时A已经进入ESTABLISHED状态。当B收到确认后，也进入ESTABLISHED状态。</li></ul><p>至此，A与B已经建立连接，我们称作“三报文握手”或者“三次握手”。</p><h2 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h2><p>当数据传输结束后，通信的上方都可以释放连接。现在A和B都处于ESTABLISHED状态。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP连接释放.png-hexo.png" alt="运输层-TCP连接释放"></p><ul><li>A的应用进程先向其TCP发出连接释放报文段，然后停止发送数据，主动关闭TCP连接。A的连接释放报文段把FIN置为1，其序号为seq = u，它等于前面已传送过的最后一个字节的序号加1。此时A进入FIN-WAIT-1状态，等待B的确认。TCP规定，FIN不携带数据，但是要消耗掉一个序号。</li><li>B收到连接释放报文段后向A发出确认，确认号是ack = u + 1,这个报文段自己的序号是v，等于B前面已传送数据的最后一个字节的序号加1。然后B进入CLOSE-WAIT状态。TCP服务器进程这时通知高层应用进程，因而从A到B这个方向的连接就释放了，这时TCP的连接处于半关闭状态，即A已经没有数据向B发送了，但是若B仍要发送数据，A依旧要接受。也就是说从B到A这个方向的连接并未关闭。</li><li>A收到来自B的报文段后进入FIN-WAIT-2状态，等待B的连续释放报文。</li><li>如果B已经没有数据向A发送了，其应用进程就会通知TCP释放连接。这时B发送连续确认报文段必须使FIN = 1，现在B的序号为w（在半关闭状态，B可能又发送了一段数据）B还必须重复已经发送过的确认号ack = u + 1。这时B进入了LAST-ACK状态，等待A的确认。</li><li>A在收到B的报文段后进行确认，其确认号为w + 1（TCP规定，FIN报文段需要消耗一个序号），其自己的序号为seq = u + 1。然后进入到TIME-WAIT状态。这时需要注意的是TCP连接还没有释放掉，必须经过时间等待计时器（TIME-WAIT timer）设置的2MSL（Maximum Segment Lifetime）,A才进入关闭状态。MSL叫做最大报文段寿命。</li></ul><p>上述的TCP的释放过程我们称为“四报文握手”或者“四次挥手”。</p><h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP有限状态机.png-hexo.png" alt="运输层-TCP有限状态机"></p><p>可以非常清楚地看出 TCP 连接各种状态之间的关系。</p><ul><li>粗实线箭头表示客户机进程的正常变迁。</li><li>粗虚线箭头表示服务器进程的正常变迁。</li><li>细虚线表示异常变迁。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;计算机网络-运输层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（四）</title>
    <link href="http://www.wshunli.com/posts/6318182c.html"/>
    <id>http://www.wshunli.com/posts/6318182c.html</id>
    <published>2017-10-06T12:00:33.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p><strong>计算机网络-网络层</strong> 部分读书笔记<a id="more"></a></p><p>网络层向上只提供简单灵活的、无连接、尽最大努力交付的数据报（IP数据报或分组）服务。</p><h1 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h1><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP （Address Resolution Protocol）</li><li>网际控制报文协议 ICMP （Internet Control Message Protcol）</li><li>网际组管理协议 IGMP （Internet Group Management Protcol）</li></ul><p>逆地址转换协议 RARP（Reverse Address Resolution Protocol），已淘汰。</p><h2 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h2><p>虚拟互联网就是各种异构的网络逻辑上的互联网络。</p><p>具体连接各异构网络的中间设备如下:<br>物理层：网卡，网线，集线器，中继器，调制解调器<br>链路层：网桥，交换机<br>网络层：路由器<br>运输层及其以上：网关</p><h2 id="IP地址的编址方法"><a href="#IP地址的编址方法" class="headerlink" title="IP地址的编址方法"></a>IP地址的编址方法</h2><p>IP地址的编址方法经历了三个阶段：分类的 IP 地址、子网的划分、构成超网。</p><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><p>IP地址 = 网络号 + 主机号</p><p>IP 地址分为五类：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-IP地址分类.png-hexo.png" alt="网络层-IP地址分类"></p><ul><li>A 类 网络号总数：2^7 - 2 主机号总数：2^24 - 2</li><li>B 类 网络号总数：2^14 - 1 主机号总数：2^16 - 2</li><li>C 类 网络号总数：2^21 - 1 主机号总数：2^8 - 2</li></ul><p>注意：</p><ul><li>主机号全为 0 代表本主机所在的网络地址，全为 1 代表该网络的所有主机所有主机。</li><li>A 类网络号全为 0 为保留地址，意思是本网络，网络号 127 (例如 127.0.0.1) 为本地软件环回测试地址。</li><li>B类、C类网络号全为 0 (128.0.0.0、192.0.0.0) 不指派，主机号要减去全为 0 ，全为 1 的。</li></ul><h3 id="子网的划分"><a href="#子网的划分" class="headerlink" title="子网的划分"></a>子网的划分</h3><p><strong>1.</strong> 从二级 IP 地址到三级 IP 地址</p><p>IP地址 = 网络号 + 主机号 》》 IP地址 = 网络号 + 子网号 + 主机号</p><p><strong>划分子网的思路</strong>：</p><ol><li>可将物理网络划分为若干子网，对外仍然表现为一个网络</li><li>划分方法是从主机号借用若干位作为子网号</li><li>从其他网络发到路由器过程没有变化，但是路由器收到 IP 数据报后，再按照目的网络号和子网号，把 IP 数据报交付目的主机。</li></ol><p><strong>2.</strong>子网掩码</p><p>路由器根据子网掩码把 IP 数据报转发到子网。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-子网掩码.png-hexo.png" alt="网络层-子网掩码"></p><p>子网掩码和 IP 地址逐位“与”运算，得到子网的 IP 地址。</p><p><strong>默认</strong>子网掩码</p><p>在不划分子网时，该网络的子网掩码就是默认网掩码。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-默认子网掩码.png-hexo.png" alt="网络层-默认子网掩码"></p><p>以 B 类地址为例，子网号没有 0、1、15、16 长度，划分子网要全为 0 和全为 1 的情况。</p><h3 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h3><p>无分类编址 CIDR （构造超网）</p><p><strong>1.</strong> 取消传统 A、B、C 类地址及划分子网的概念<br>IP 地址 = 网络前缀 + 主机号</p><p><strong>2.</strong> CIRD 把网络前缀相同的连续 IP 地址组成一个 <strong>CIRD地址块</strong> 。<br>CIRD 记法： 128.14.35.7/20<br><strong>/20</strong> 代表网络前缀位数20位。</p><p>CIRD 使用32位的地址掩码（子网掩码），在CIRD记法中，<strong>/20</strong> 代表子网掩码 1 的个数。</p><h2 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h2><p>IP 数据报的完整格式</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-IP数据报.png-hexo.png" alt="网络层-IP数据报"></p><p>IP 数据报 = 首部 （固定长度+可选字段）+ 数据</p><p>更多信息查看百度百科: <a href="https://baike.baidu.com/item/IP%E6%95%B0%E6%8D%AE%E6%8A%A5" rel="external nofollow noopener noreferrer" target="_blank">IP数据报</a></p><h2 id="IP-层转发分组流程"><a href="#IP-层转发分组流程" class="headerlink" title="IP 层转发分组流程"></a>IP 层转发分组流程</h2><p>转发分组研究的是分组怎样从一个路由器到另一个路由器的问题。</p><ul><li>IP数据报最终一定可以找到目的主机所在目的网络上的路由器(可能要通过多次的间接交付)。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ul><p>在互联网上转发分组时，是从一个路由器转发到下一个路由器。在路由表中，对每一条路由最主要的是以下两个信息：（目的网络地址，下一跳地址）。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-路由表.png-hexo.png" alt="网络层-路由表"></p><h3 id="转发分组算法"><a href="#转发分组算法" class="headerlink" title="转发分组算法"></a>转发分组算法</h3><p>(1) 从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。<br>(2) 若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付给目的主机（这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧）；否则就要执行(3)进行间接交付。<br>(3) 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(4)。<br>(4) 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(5)。<br>(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(6)。<br>(6) 报告转发分组出错。</p><p>由此可见，在IP数据报的首部并没有指明下一跳路由器的IP地址，在IP数据报的首部只有源IP地址和目的IP地址。<br>转发分组是基于目的主机所在的网络，路由表也没有具体指明到某个网络的完整路径。</p><h3 id="划分子网后的分组转发"><a href="#划分子网后的分组转发" class="headerlink" title="划分子网后的分组转发"></a>划分子网后的分组转发</h3><p>划分子网后，路由表中包含：目的网络地址、子网掩码、下一跳地址。</p><p>(1) 从收到的分组的首部提取目的IP地址 D。<br>(2) 先用各网络的子网掩码和D逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。<br>(3) 若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4)。<br>(4) 对路由表中的每一行的子网掩码和D逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)。<br>(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。<br>(6) 报告转发分组出错。</p><h1 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h1><h2 id="IP-地址与-MAC-地址"><a href="#IP-地址与-MAC-地址" class="headerlink" title="IP 地址与 MAC 地址"></a>IP 地址与 MAC 地址</h2><p>MAC 地址是链路层和物理层使用的地址。<br>IP 地址是网络层积以上各层使用的地址。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-IP地址和MAC地址.png-hexo.png" alt="网络层-IP地址和MAC地址"></p><h2 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h2><p>地址解析协议 ARP 根据 IP 地址寻找相应的硬件地址。</p><p>ARP 的原理是 每台主机都有一个 ARP 高速缓存，存储本局域网的所有主机的IP地址和硬件地址的映射表。</p><ul><li>当主机A向局域网内的其他主机B发送 IP 数据报时，从ARP高速缓存中取出B的物理地址即可。</li><li>如果缓存中不存在B的物理地址，则发送ARP请求分组（广播），B接收到分组发送ARP响应分组（单播），并在B的高速缓存中存储A的IP地址和物理地址。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-ARP工作原理.png-hexo.png" alt="网络层-ARP工作原理"></p><p>ARP 解决的是<strong>局域网</strong>上主机或者路由器 IP 与物理地址的映射问题。如果两主机在同一局域网，则通过路由器解决。</p><p>RARP 逆地址解析协议，根据硬件地址查询 IP 地址。现在被包含在 DHCP 中。</p><h1 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h1><p>为了更有效地转发 IP 数据报和提高交付成功的机会。</p><p>ICMP 报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去。<br><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-ICMP数据报.png-hexo.png" alt="网络层-ICMP数据报"></p><p>类型分为 ICMP 差错报告报文和 ICMP 询问报文。<br><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-ICMP数据报分类.png-hexo.png" alt="网络层-ICMP数据报分类"></p><p>用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，令管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。它与传输协议最大的不同：它一般不用于在两点间传输数据，而常常用于返回的错误信息或是分析路由。</p><p>ICMP控制的内容包括但不仅限于：echo响应（ping）、目标网络不可达、目标端口不可达、禁止访问的网络、拥塞控制、重定向、TTL超时…</p><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><p>在Internet的概念中，将整个互联网划分为许多个小的自治系统（AS）。<br>AS的最主要的特征：一个AS对其他AS表现出的是一个单一和一致的路由选择策略。</p><p>路由选择协议分为两类：</p><ul><li>内部网关协议 IGP：在一个AS内部使用的路由选择协议，而这与互联网中其他AS选用什么路由协议无关。例如：RIP、OSPF协议。</li><li>外部网关协议 EGP：若源主机和目的主机不再同一个AS中，就需要使用一种协议将路由选择信息传递到另一个AS中，这就是EGP。例如：BGP协议。</li></ul><h2 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h2><p>RIP （路由信息协议）属于内部网关协议（IGP）的一种，是一种基于距离向量的路由选择协议。<br>RIP 仅和相邻路由、按固定时间、交换本路由知道的所有信息。</p><h2 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h2><p>OSPF 属于内部网关协议（IGP）的一种，基于 Dijkstra 提出的最短路径算法。</p><p>OSPF提出了“区域（Area）”的概念，一个网络可以由单一区域或者多个区域组成。<br>其中，一个特别的区域被称为骨干区域（Backbone Area），该区域是整个OSPF网络的核心区域，并且所有其他的区域都与之直接连接。<br>所有的内部路由都通过骨干区域传递到其他非骨干区域。<br>所有的区域都必须直接连接到骨干区域，如果不能创建直接连接，那么可以通过虚拟链路（Virtual-link）和骨干区域创建虚拟连接。</p><h2 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h2><p>BGP 属于外部网关协议（EGP）的一种。</p><p>由于BGP是工作在AS之间的协议，并且各个AS的情况复杂，所以 BGP只是力求找到一个可以到达目的网络且比较好的路由，而并不是寻找一条最佳路由。<br>每一个AS都应该有一个“BGP发言人”，一般来说，两个BGP发言人是通过一个共享网络连接在一起的，BGP发言人往往是BGP边界路由，但也可以不是。<br>一个BGP发言人与其他AS的BGP发言人要交换路由信息，首先要建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话。当BGP发言人交换了路由信息后，就构造自治系统连通图，最后通过该图来进行路由选择。</p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>IPv6二进位制下为128位长度，以16位为一组，每组以冒号“:”隔开，可以分为8组，每组以4位十六进制方式表示。<br>例如：2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的IPv6地址。</p><p>IPv6 地址分为：</p><ul><li>单播：点对点通信</li><li>多播：一对多通信，数据发送到一组计算机的每一个。</li><li>任播：终点是一组计算机，但数据只发给其中的一个，通常是最近的一个。</li></ul><p>IPv4向IPv6过渡采用双协议栈、隧道技术等。</p><h1 id="地址转换协议-NAT"><a href="#地址转换协议-NAT" class="headerlink" title="地址转换协议 NAT"></a>地址转换协议 NAT</h1><p>NAT 是一种在 IP数据报 通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。<br>这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。</p><h1 id="多协议标记交换-MPLS"><a href="#多协议标记交换-MPLS" class="headerlink" title="多协议标记交换 MPLS"></a>多协议标记交换 MPLS</h1><p>MPLS是利用标记（label）进行数据转发的。当分组进入网络时，要为其分配固定长度的短的标记，并将标记与分组封装在一起，在整个转发过程中，交换节点仅根据标记进行转发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;计算机网络-网络层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（三）</title>
    <link href="http://www.wshunli.com/posts/d4350149.html"/>
    <id>http://www.wshunli.com/posts/d4350149.html</id>
    <published>2017-10-05T06:55:39.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p><strong>计算机网络-数据链路层</strong> 部分读书笔记<a id="more"></a></p><h1 id="链路层的基本概念"><a href="#链路层的基本概念" class="headerlink" title="链路层的基本概念"></a>链路层的基本概念</h1><p>数据链路层属于计算机网络的低层。链路层使用的信道可分为<strong>点对点信道（PPP）</strong>和<strong>广播信道（CSMA/CD）</strong>两种。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层的地位.png-hexo.png" alt="数据链路层的地位"></p><h1 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h1><p><strong>链路</strong> 是两结点间的一段物理线路，中间没有其他交换结点。物理链路。<br><strong>数据链路</strong> 是链路 + 通信协议。逻辑链路。</p><p><strong>帧</strong> – 点对点信道的数据链路层的协议数据单元。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-三层简化模型.png-hexo.png" alt="数据链路层-三层简化模型"></p><p>数据链路层把网络层交换来的数据构成帧发送到链路上，以及把接受的帧中的数据上交给网络层。</p><p>点对点信道的数据链路层进行通信的主要步骤如下：</p><ol><li>结点A的数据链路层把网络层下发的IP数据报添加首部和尾部封装成帧；</li><li>结点A把封装好的帧发给结点B的数据链路层；</li><li>结点B收到的帧若无差错，则提取出IP数据报给网络层，否则丢弃这个帧。</li></ol><h2 id="链路层基本问题"><a href="#链路层基本问题" class="headerlink" title="链路层基本问题"></a>链路层基本问题</h2><ul><li>封装成帧</li></ul><p>链路层将网络层传下来的IP数据报添加首部（SOH）和尾部（EOH）封装成帧，这样接收端在收到物理层上交的比特流后就能根据首尾标记知道帧的开始与结束。首位和尾部的主要作用就是进行帧定界（确定帧的界限），同时还包含一些控制信息。</p><ul><li>透明传输</li></ul><p>表示无论什么样比特组合的数据都能够通过这个数据链路层，而不会因为比特流中还有特定的帧结束或开始标志而发生传输差错。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-透明传输.png-hexo.png" alt="数据链路层-透明传输"></p><p>防止因传输的数据（EOT）中出现尾部控制字符而提前结束。解决办法是添加转义字符（ESC）。</p><ul><li>差错检测</li></ul><p>现实的通信链路不可避免会产生比特差错，即会有一定误码率（BER），这个和信道的信噪比有关系。为了保证数据传输可靠性，加入了一些差错检测措施，例如循环冗余检错技术（CRC）。</p><p>在数据链路层进行差错校验就需要将数据划分为帧，每一帧都加上冗余码，一帧一帧地传送和校验。但是这样只能保证帧无差错传输（无比特差错），无法保证帧丢失、重复或失序等（无传输差错）情况发生。</p><h1 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h1><p>用户通常要连接到某个ISP（Internet Service Provider）才能接入因特网。PPP协议则是用户与ISP通信时使用的数据链路层协议。</p><p>PPP协议主要由三个部分组成：</p><ol><li>一个将IP数据报封装到串行链路的方法。</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP（Link Control Protocol）。</li><li>一套网络控制协议 NCP（Network Control Protocol），其中每个协议支持不同的网络层协议。</li></ol><p>PPP协议的工作状态：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-PPP协议状态.png-hexo.png" alt="数据链路层-PPP协议状态"></p><h1 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h1><p>广播信道可以进行一对多的通信。</p><h2 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h2><p>局域网为一个单位所有，并且地理范围和站点数量有限。按照网络拓扑分类如下：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-局域网网络拓扑分类.png-hexo.png" alt="数据链路层-局域网网络拓扑分类"></p><p>局域网的总线网中以太网最为著名。</p><p>适配器负责计算机与外界局域网通信，即“网卡”。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-网络适配器.png-hexo.png" alt="数据链路层-网络适配器"></p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection)。<br>这个协议有几个要点：</p><ul><li>多点接入：总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是载波监听和碰撞检测。</li><li>载波监听：发送前监听。即不管是在发送前，还是在发送中，每个站总是不停地检测总线上是否有其他站在发送数据，等信道空闲才发送。</li><li>碰撞检测：适配器边发送边监听。以便判断自己发送数据时，是否也有其他站在发送数据。如果同时多个站发送数据，总线上的传输信号会电压会增大。发生碰撞时，适配器就会立即停止发送，等一段随机时间后再次发送。</li></ul><h2 id="使用集线器的星型拓扑"><a href="#使用集线器的星型拓扑" class="headerlink" title="使用集线器的星型拓扑"></a>使用集线器的星型拓扑</h2><p>集线器的特点如下：</p><ul><li>使用集线器的以太网在逻辑上仍是个总线网，各站共享逻辑上的总线，各站使用的还是CSMA/CD协议。</li><li>一个集线器有许多接口，像一个多接口的转发器。</li><li>集线器工作在物理层，每个接口仅简单的转发比特，不进行碰检测。</li><li>自适用串音回波抵消，即接口转发的较强信号对接收的较弱信号没有干扰。</li></ul><h2 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h2><p>MAC 层的硬件地址</p><p>硬件地址又叫物理地址、MAC地址，是主机中固化在适配器 ROM 中的地址。</p><p>适配器有过滤功能。当适配器收到 MAC 帧的时会先检查帧中的目的地址，是发往本站的就接收，否则就丢弃。</p><p>发往本站的帧有三种：单播（一对一）、广播（一对全部）、多播（一对多）。</p><p>MAC 帧的格式</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-MAC帧格式.png-hexo.png" alt="数据链路层-MAC帧格式"></p><p>首部没有帧长度、尾部是帧检验序列 FCS 。</p><h1 id="拓展的以太网"><a href="#拓展的以太网" class="headerlink" title="拓展的以太网"></a>拓展的以太网</h1><ul><li>在物理层拓展以太网</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-物理层拓展以太网.png-hexo.png" alt="数据链路层-物理层拓展以太网"></p><p>优点是扩大了以太网覆盖的地理范围，缺点是当某个系的两站通信时所传送的数据会通过所有的集线器转发，其他系内部在这时都不能通信。</p><ul><li>在链路层拓展以太网</li></ul><p>通过以太网交换机实现，实质是多接口的网桥。<br>具有并行性，相互通信的主机都是独占传输媒体，无碰撞得传输数据。<br>通过自学习建立帧交换表，按照帧目的 MAC 转发，即插即用。</p><ul><li>虚拟局域网</li></ul><p>虚拟局域网 VLAN，是由一些网段构成的与物理位置无关的逻辑组。在 VLAN 中的帧都有明确的标识符，指明该帧属于哪个 VLAN。</p><h1 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h1><ul><li>100BASE-T 以太网（百兆以太网）</li><li>吉比特以太网（千兆以太网）</li><li>10吉比特以太网（万兆以太网）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;计算机网络-数据链路层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（二）</title>
    <link href="http://www.wshunli.com/posts/e65336e0.html"/>
    <id>http://www.wshunli.com/posts/e65336e0.html</id>
    <published>2017-10-04T12:58:39.000Z</published>
    <updated>2017-11-14T14:39:22.186Z</updated>
    
    <content type="html"><![CDATA[<p><strong>计算机网络-物理层</strong> 部分读书笔记<a id="more"></a></p><h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是具体的传输媒体。<br>物理层的作用就是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这种差异。<br>物理层的主要任务是确定与传输媒体接口相关的一些特性，即：</p><ul><li>机械特性，指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li><li>电气特性，指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性，指明某条线上出现的某一电平的电压表示何意。</li><li>过程特性，规程特性 指明对于不同功能的各种可能事件的出现顺序。</li></ul><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><p><strong>信道</strong> 是向某一方向发送信息的媒体。可分为三种基本方式：</p><ul><li>单向通信，单工，只能从一个方向到另一个方向。</li><li>双向交替通信，半双工，双方都可以接收和发送，但不能同时发送。</li><li>双向同时通信，全双工，可以同时发送信息，也可以同时接受信息。</li></ul><p>单项通信只需要一条信道，其余两种需要两条信道。</p><h2 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h2><p>传输媒体也称传输媒介或传输介质，数据传输系统中在发送器和接收器之间的物理通路。</p><ul><li>引导型传输媒体：双绞线、同轴电缆、光纤等</li><li>非引导型传输媒体：无线电微波、卫星通信等</li></ul><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p><strong>信道复用技术</strong>就是使用复用器和分用器将原本需要多个信道传输的信息通过单个信道传输。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-信道复用技术.png-hexo.png" alt="物理层-信道复用技术"></p><ul><li>频分复用（FDM）：不同的用户分配不同的频带。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-频分复用.png-hexo.png" alt="物理层-频分复用"></p><ul><li>时分复用（TDM）及统计时分复用（STDM）：</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-时分复用.png-hexo.png" alt="物理层-时分复用"></p><p>TDM 每个用户周期性占用信道。但是用户暂无数据时，信道利用率不高：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-时分复用弊端.png-hexo.png" alt="物理层-时分复用弊端"></p><p>STDM 用户没有数据就跳过，动态分配时序。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-统计时分复用.png-hexo.png" alt="物理层-统计时分复用"></p><ul><li>波分复用（WDM）：针对光纤的频分复用。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-波分复用.png-hexo.png" alt="物理层-波分复用"></p><ul><li>码分复用（CDM）：码分多址，不同的用户采用不同的码型。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-码分复用.png-hexo.png" alt="物理层-码分复用"></p><p>感觉前两种侧重于模拟信号，后两种侧重于数字信号。</p><h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><ul><li>ADSL 技术，非对称数字用户线。模拟电话用户线基础上。</li><li>HFC 网，光纤同轴混合网。有线电视网基础上。</li><li>FTTx 技术，包括光纤到路边（FTTC）、光纤到大楼（FTTB）及光纤到户（FTTH）等等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;计算机网络-物理层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
