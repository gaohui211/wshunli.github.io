<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  <subtitle>wshunli`s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2018-07-27T01:19:14.147Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins安装Java代码质量分析工具</title>
    <link href="https://www.wshunli.com/posts/57f40b04.html"/>
    <id>https://www.wshunli.com/posts/57f40b04.html</id>
    <published>2018-07-25T01:15:32.000Z</published>
    <updated>2018-07-27T01:19:14.147Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Checkstyle、PMD、FindBugs 三款主流的 Java 静态分析工具，以及 SourceMonitor 代码度量工具，Simian 代码重复检查工具等。</p><h1 id="Jenkins-安装-Java-代码质量分析工具"><a href="#Jenkins-安装-Java-代码质量分析工具" class="headerlink" title="Jenkins 安装 Java 代码质量分析工具"></a>Jenkins 安装 Java 代码质量分析工具</h1><p>在 Java 世界中，Checkstyle、PMD、FindBugs 插件是三款主流的静态分析工具。</p><p>1、Checkstyle 擅长检查编码标准和约定，编码行为以及其他的一些质量指标（如代码复杂度）。</p><p>Checkstyle（<a href="http://checkstyle.sourceforge.net/" rel="external nofollow noopener noreferrer" target="_blank">http://checkstyle.sourceforge.net/</a> ） 是 SourceForge 下的一个项目，提供了一个帮助 JAVA 开发人员遵守某些编码规范的工具。</p><p>CheckStyle 检验的主要内容包括：Javadoc 注释、命名约定、标题、Import 语句、体积大小、空白、修饰符、块、代码问题、类设计和混合检查（包括一些有用的比如非必须的 System.out 和 printstackTrace）。</p><p>在 Jenkins 中安装 CheckStyle 插件并重启。</p><p>在项目中配置 <code>pom.xml</code> （可选）</p><pre><code class="XML">&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;        &lt;version&gt;2.16&lt;/version&gt;        &lt;configuration&gt;            &lt;configLocation&gt;checkstyle.xml&lt;/configLocation&gt;        &lt;/configuration&gt;    &lt;/plugin&gt;    ....&lt;/plugins&gt;</code></pre><p>在 Maven 构建中添加 <code>checkstyle:checkstyle</code> 参数。</p><p>构建完成后输出 XML 分析结果，文件在 <code>target</code> 目录下。</p><p>关于插件使用的更多信息可参考：<br><a href="https://wiki.jenkins.io/display/JENKINS/Checkstyle+Plugin" rel="external nofollow noopener noreferrer" target="_blank">https://wiki.jenkins.io/display/JENKINS/Checkstyle+Plugin</a></p><p>2、PMD 类似于 Checkstyle ，它更加专注于编码和设计实践。</p><p>PMD（<a href="https://pmd.github.io/" rel="external nofollow noopener noreferrer" target="_blank">https://pmd.github.io/</a> ） An extensible cross-language static code analyzer.</p><p>专注于潜在的编码问题，比如未使用或者次优化的代码，代码大小和复杂性，以及良好的编码行为。</p><p>PMD 也附带了 CPD ，以支持探测重复或者近似重复代码。</p><p>在 Jenkins 中安装 PMD 插件并重启。</p><p>在项目中配置 <code>pom.xml</code> （可选）</p><pre><code class="XML">&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;        &lt;version&gt;3.5&lt;/version&gt;    &lt;/plugin&gt;            ....&lt;/plugins&gt;</code></pre><p>在 Maven 构建中添加 <code>pmd:pmd</code> 参数。</p><p>构建完成后输出 XML 分析结果，文件在 <code>target</code> 目录下。</p><p>关于插件使用的更多信息可参考：<br><a href="https://wiki.jenkins.io/display/JENKINS/PMD+Plugin" rel="external nofollow noopener noreferrer" target="_blank">https://wiki.jenkins.io/display/JENKINS/PMD+Plugin</a></p><p>3、FindBugs 专注于识别潜在的危险和错误的代码。</p><p>FindBugs（<a href="http://findbugs.sourceforge.net/" rel="external nofollow noopener noreferrer" target="_blank">http://findbugs.sourceforge.net/</a> ） 检查应用程序的字节码来找出潜在的 bug 、性能问题或者差的编码行为。</p><p>在 Jenkins 中安装 FindBugs 插件并重启。</p><p>在项目中配置 <code>pom.xml</code> （可选）</p><pre><code class="XML">&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;        &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.5.2&lt;/version&gt;        &lt;configuration&gt;            &lt;findbugsXmlOutput&gt;true&lt;/findbugsXmlOutput&gt;            &lt;findbugsXmlWithMessages&gt;true&lt;/findbugsXmlWithMessages&gt;            &lt;xmlOutput&gt;true&lt;/xmlOutput&gt;        &lt;/configuration&gt;    &lt;/plugin&gt;    ....&lt;/plugins&gt;</code></pre><p>在 Maven 构建中添加 <code>findbugs:findbugs</code> 参数。</p><p>构建完成后输出 XML 分析结果，文件在 <code>target</code> 目录下。</p><p>关于插件使用的更多信息可参考：<br><a href="https://wiki.jenkins.io/display/JENKINS/FindBugs+Plugin" rel="external nofollow noopener noreferrer" target="_blank">https://wiki.jenkins.io/display/JENKINS/FindBugs+Plugin</a></p><p>4、Static Analysis Collector 插件汇总静态分析结果</p><p>插件地址：<a href="https://wiki.jenkins.io/display/JENKINS/Analysis+Collector+Plugin" rel="external nofollow noopener noreferrer" target="_blank">https://wiki.jenkins.io/display/JENKINS/Analysis+Collector+Plugin</a></p><h1 id="Jenkins-安装-SourceMonitor-代码度量工具"><a href="#Jenkins-安装-SourceMonitor-代码度量工具" class="headerlink" title="Jenkins 安装 SourceMonitor 代码度量工具"></a>Jenkins 安装 SourceMonitor 代码度量工具</h1><p>SourceMonitor（<a href="http://www.campwoodsw.com/sourcemonitor.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.campwoodsw.com/sourcemonitor.html</a> ） 允许查看软件源代码内部，以了解项目拥有的代码量，并确定模块的相对复杂度。</p><p>在 Jenkins 中也有 SourceMonitor（<a href="https://github.com/jenkinsci/sourcemonitor-plugin" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jenkinsci/sourcemonitor-plugin</a> ）插件，但是好久没更新了，也存在一些问题（<a href="https://issues.jenkins-ci.org/browse/JENKINS-5741" rel="external nofollow noopener noreferrer" target="_blank">https://issues.jenkins-ci.org/browse/JENKINS-5741</a> ）。</p><p>报错如下：</p><pre><code class="TXT">Parsing sourcemonitor resultshudson.AbortException: Parsing file error    at com.thalesgroup.hudson.plugins.sourcemonitor.SourceMonitorParser.invoke(SourceMonitorParser.java:70)    at com.thalesgroup.hudson.plugins.sourcemonitor.SourceMonitorParser.invoke(SourceMonitorParser.java:45)    at hudson.FilePath.act(FilePath.java:1047)    at hudson.FilePath.act(FilePath.java:1025)    at com.thalesgroup.hudson.plugins.sourcemonitor.SourceMonitorPublisher.perform(SourceMonitorPublisher.java:80)    at hudson.tasks.BuildStepMonitor$3.perform(BuildStepMonitor.java:45)    at hudson.model.AbstractBuild$AbstractBuildExecution.perform(AbstractBuild.java:744)    at hudson.model.AbstractBuild$AbstractBuildExecution.performAllBuildSteps(AbstractBuild.java:690)    at hudson.model.Build$BuildExecution.post2(Build.java:186)    at hudson.model.AbstractBuild$AbstractBuildExecution.post(AbstractBuild.java:635)    at hudson.model.Run.execute(Run.java:1819)    at hudson.model.FreeStyleBuild.run(FreeStyleBuild.java:43)    at hudson.model.ResourceController.execute(ResourceController.java:97)    at hudson.model.Executor.run(Executor.java:429)Build step &#39;Publish SourceMonitor results&#39; changed build result to FAILUREBuild step &#39;Publish SourceMonitor results&#39; marked build as failureFinished: FAILURE</code></pre><p>原因是在构建的时候需要添加 <code>sourcemonitor:sourcemonitor</code> 参数。</p><p>SourceMonitor 插件地址：<a href="https://plugins.jenkins.io/sourcemonitor" rel="external nofollow noopener noreferrer" target="_blank">https://plugins.jenkins.io/sourcemonitor</a></p><p>这里可以安装公司内部的 <code>hwSourceMonitor.hpi</code> 插件</p><p>参考资料：<br>1、<a href="http://3ms.huawei.com/km/blogs/details/2503631" rel="external nofollow noopener noreferrer" target="_blank">http://3ms.huawei.com/km/blogs/details/2503631</a><br>2、<a href="http://3ms.huawei.com/hi/group/2033815/wiki_4496373.html" rel="external nofollow noopener noreferrer" target="_blank">http://3ms.huawei.com/hi/group/2033815/wiki_4496373.html</a></p><p><del>也可以使用 HTML Publisher 插件解析 SourceMonitor 输出的 xml 结果。</del></p><p>0、准备 SourceMonitor 并安装 Jenkins Server 上。</p><p>本文安装在 <code>C:\Program Files (x86)\SourceMonitor\SourceMonitor.exe</code> 目录。</p><p>1、安装 HTML Publisher 插件。</p><p>HTML Publisher Plugin 用来把 SourceMonitor 检测的结果可视化。</p><p>2、在构建后添加 Windows 批处理命令。</p><pre><code class="Shell">&quot;C:\Program Files (x86)\SourceMonitor\SourceMonitor.exe&quot; /C &quot;C:\CI_Tools\SourceMonitorCommand.xml&quot;&quot;C:\CI_Tools\msxsl.exe&quot; SourceMonitorReport.xml &quot;C:\CI_Tools\SourceMonitorSummaryGeneration.xsl&quot; -o SourceMonitorSummaryGeneration.xml&quot;C:\CI_Tools\msxsl.exe&quot; SourceMonitorSummaryGeneration.xml &quot;C:\CI_Tools\SourceMonitor.xsl&quot; -o SourceMonitorResult.html</code></pre><p>其中 <code>SourceMonitorCommand.xml</code> 来自</p><p><code>C:\Program Files (x86)\SourceMonitor\Samples\sample_commands.xml</code></p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;sourcemonitor_commands&gt;    &lt;write_log&gt;true&lt;/write_log&gt;    &lt;command&gt;        &lt;project_file&gt;C:\Windows\System32\config\systemprofile\.jenkins\workspace\findbugs-demo\target/sourcemonitor\project.smp&lt;/project_file&gt;        &lt;project_language&gt;Java&lt;/project_language&gt;        &lt;source_directory&gt;C:\Windows\System32\config\systemprofile\.jenkins\workspace\findbugs-demo\src\main\java&lt;/source_directory&gt;        &lt;parse_utf8_files&gt;true&lt;/parse_utf8_files&gt;        &lt;file_extensions&gt;*.java&lt;/file_extensions&gt;        &lt;include_subdirectories&gt;true&lt;/include_subdirectories&gt;        &lt;export&gt;            &lt;export_file&gt;C:\Windows\System32\config\systemprofile\.jenkins\workspace\findbugs-demo\target/sourcemonitor\sourcemonitor.xml&lt;/export_file&gt;            &lt;export_type&gt;2 (project details as XML)&lt;/export_type&gt;            &lt;export_option&gt;Include method metrics: option 3&lt;/export_option&gt;        &lt;/export&gt;    &lt;/command&gt;&lt;/sourcemonitor_commands&gt;</code></pre><p>需要下载 <code>msxsl</code> 工具（<a href="http://www.microsoft.com/en-us/download/details.aspx?id=21714" rel="external nofollow noopener noreferrer" target="_blank">http://www.microsoft.com/en-us/download/details.aspx?id=21714</a> ）并放置到 <code>C:\CI_Tools</code> 目录下。</p><p>3、最后添加 Publish HTML reports 即可。</p><p>不过我没有配置成功，总是提示找不到 <code>SourceMonitorReport.xml</code> 文件。</p><p>如果使用 SourceMonitor 插件遇到如下 OutOfMemoryError 错误。</p><pre><code class="TXT">FATAL: Java heap spacejava.lang.OutOfMemoryError: Java heap space</code></pre><p>解决办法：<a href="https://wiki.jenkins.io/display/JENKINS/Builds+failing+with+OutOfMemoryErrors" rel="external nofollow noopener noreferrer" target="_blank">https://wiki.jenkins.io/display/JENKINS/Builds+failing+with+OutOfMemoryErrors</a></p><h1 id="Jenkins-安装-Simian-代码重复检查工具"><a href="#Jenkins-安装-Simian-代码重复检查工具" class="headerlink" title="Jenkins 安装 Simian 代码重复检查工具"></a>Jenkins 安装 Simian 代码重复检查工具</h1><p>Simian（<a href="http://www.harukizaemon.com/simian/" rel="external nofollow noopener noreferrer" target="_blank">http://www.harukizaemon.com/simian/</a> ） 是一个检查重复代码的工具。</p><p>这里可以使用公司内部的插件</p><p><a href="http://3ms.huawei.com/hi/group/2964/wiki_4145693.html" rel="external nofollow noopener noreferrer" target="_blank">http://3ms.huawei.com/hi/group/2964/wiki_4145693.html</a></p><h1 id="Jenkins-安装-Cobertura-代码测试覆盖率工具"><a href="#Jenkins-安装-Cobertura-代码测试覆盖率工具" class="headerlink" title="Jenkins 安装 Cobertura 代码测试覆盖率工具"></a>Jenkins 安装 Cobertura 代码测试覆盖率工具</h1><p>Cobertura（<a href="https://sourceforge.net/projects/cobertura/" rel="external nofollow noopener noreferrer" target="_blank">https://sourceforge.net/projects/cobertura/</a> ） 一项衡量是否所有代码都被测到的工具。</p><p>在 Jenkins 中安装 Cobertura 插件并重启。</p><p>在项目中配置 <code>pom.xml</code> （可选）</p><pre><code class="XML">&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;        &lt;artifactId&gt;cobertura-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;        &lt;configuration&gt;            &lt;instrumentation&gt;                &lt;ignoreTrivial&gt;false&lt;/ignoreTrivial&gt;            &lt;/instrumentation&gt;            &lt;formats&gt;                &lt;format&gt;html&lt;/format&gt;                &lt;format&gt;xml&lt;/format&gt;            &lt;/formats&gt;        &lt;/configuration&gt;    &lt;/plugin&gt;    ....&lt;/plugins&gt;</code></pre><p>在 Maven 构建中添加 <code>cobertura:cobertura</code> 参数。</p><p><code>compile -D cobertura.report.format=xml clean compile cobertura:cobertura</code></p><p>这里注意添加 <code>-D cobertura.report.format=xml</code> 参数。</p><p>构建完成后输出 XML 分析结果，文件在 <code>target</code> 目录下。</p><p>关于插件使用的更多信息可参考：<br><a href="https://wiki.jenkins.io/display/JENKINS/Cobertura+Plugin" rel="external nofollow noopener noreferrer" target="_blank">https://wiki.jenkins.io/display/JENKINS/Cobertura+Plugin</a></p><blockquote><p>参考资料<br>1、jenkins+maven配置Checkstyle+FindBugs+PMD - 简书<br><a href="https://www.jianshu.com/p/03b9e38d03b2" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/03b9e38d03b2</a><br>2、CheckStyle提高代码质量 - CSDN博客<br><a href="https://blog.csdn.net/lx_yoyo/article/details/73332590" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lx_yoyo/article/details/73332590</a><br>3、Jenkins+maven+checkstyle对java代码进行静态代码分析 - CSDN博客<br><a href="https://blog.csdn.net/hwhua1986/article/details/48339545" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hwhua1986/article/details/48339545</a><br>4、Jenkins+maven+pmd对java代码进行静态代码分析 - CSDN博客<br><a href="https://blog.csdn.net/hwhua1986/article/details/48342745" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hwhua1986/article/details/48342745</a><br>5、[Jenkins]持续集成环境下fingbug插件的安装使用与配置 - Amberly - 博客园<br><a href="https://www.cnblogs.com/amberly/p/7201041.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/amberly/p/7201041.html</a><br>6、静态检查——SourceMonitor的学习和使用 - CSDN博客<br><a href="https://blog.csdn.net/yf210yf/article/details/17535713" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/yf210yf/article/details/17535713</a><br>7、[料理佳餚] Jenkins 增加 SourceMonitor Plugin | 軟體主廚的程式料理廚房 - 點部落<br><a href="https://dotblogs.com.tw/supershowwei/2015/10/14/153562" rel="external nofollow noopener noreferrer" target="_blank">https://dotblogs.com.tw/supershowwei/2015/10/14/153562</a><br>8、CI Server 16 - 整合程式碼複雜度及深度報表 (Source Monitor) - iT 邦幫忙<br><a href="https://ithelp.ithome.com.tw/articles/10107051" rel="external nofollow noopener noreferrer" target="_blank">https://ithelp.ithome.com.tw/articles/10107051</a><br>8、重复代码检查工具simian的基本用法 | 知行一<br><a href="http://purecpp.org/?p=92" rel="external nofollow noopener noreferrer" target="_blank">http://purecpp.org/?p=92</a><br>9、Jenkins集成Simian插件_百度经验<br><a href="https://jingyan.baidu.com/article/c45ad29ccbfd3a051653e272.html" rel="external nofollow noopener noreferrer" target="_blank">https://jingyan.baidu.com/article/c45ad29ccbfd3a051653e272.html</a><br>10、[料理佳餚] Jenkins 增加 Simian Plugin | 軟體主廚的程式料理廚房 - 點部落<br><a href="https://dotblogs.com.tw/supershowwei/2015/10/14/153561" rel="external nofollow noopener noreferrer" target="_blank">https://dotblogs.com.tw/supershowwei/2015/10/14/153561</a><br>11、代码测试覆盖率Cobertura使用 - CSDN博客<br><a href="https://blog.csdn.net/cathy_sunshine/article/details/75258298" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/cathy_sunshine/article/details/75258298</a><br>12、jenkins集成cobertura，调用显示cobertura的report - CSDN博客<br><a href="https://blog.csdn.net/yaominhua/article/details/40684647" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/yaominhua/article/details/40684647</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Checkstyle、PMD、FindBugs 三款主流的 Java 静态分析工具，以及 SourceMonitor 代码度量工具，Simian 代码重复检查工具等。&lt;/p&gt;&lt;h1 id=&quot;Jenkins-安装-Java-代码质量分析工具&quot;&gt;&lt;a href=&quot;#J
      
    
    </summary>
    
      <category term="持续集成" scheme="https://www.wshunli.com/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="Jenkins" scheme="https://www.wshunli.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins服务搭建及环境配置</title>
    <link href="https://www.wshunli.com/posts/5d09cdc2.html"/>
    <id>https://www.wshunli.com/posts/5d09cdc2.html</id>
    <published>2018-07-24T11:16:40.000Z</published>
    <updated>2018-07-27T01:19:14.147Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins 是一款优秀的开源自动化服务器，允许持续集成和持续交付。Jenkins 支持数百个插件，以支持项目的构建、部署和自动化。</p><p>Jenkins 官网：<a href="https://jenkins.io/" rel="external nofollow noopener noreferrer" target="_blank">https://jenkins.io/</a></p><p>「持续集成（Continuous Integration）」、「持续交付（Continuous Delivery）」和「持续部署（Continuous Deployment）」这三个概念的解释。</p><p><strong>持续集成</strong> 强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</p><p><strong>持续交付</strong> 在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。</p><p><strong>持续部署</strong> 则是在持续交付的基础上，把部署到生产环境的过程自动化。</p><h2 id="Jenkins-基础环境"><a href="#Jenkins-基础环境" class="headerlink" title="Jenkins 基础环境"></a>Jenkins 基础环境</h2><p>Jenkins 使用 Java 编写，支持所有主流操作系统。</p><p>本文仅介绍在 Windows 操作系统下 Jenkins 单机本地部署。</p><p>首先应配置 Java 环境，然后部署 Tomcat 服务。</p><p>然后即可安装 Jenkins 应用。</p><p>安装步骤可参考：<a href="https://www.cnblogs.com/hdwang/p/6081994.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/hdwang/p/6081994.html</a></p><p>最后推荐安装一些工具包括：</p><p>1、Apache Maven 软件（特别是Java软件）项目管理及自动构建工具。</p><p>推荐 Maven 配置镜像。</p><pre><code class="XML">&lt;mirror&gt;    &lt;!--This sends everything else to /public --&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;</code></pre><p>Maven 仓库阿里云镜像配置 - CSDN博客<br><a href="https://blog.csdn.net/cwenyifan/article/details/54864504" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/cwenyifan/article/details/54864504</a></p><p>在公司内部推荐使用</p><pre><code class="XML">&lt;mirror&gt;&lt;id&gt;rnd-huawei&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;name&gt;Maven China Mirror&lt;/name&gt;      &lt;url&gt;http://rnd-mirrors.huawei.com/maven/&lt;/url&gt;&lt;/mirror&gt;</code></pre><p>参考链接：MAVEN公司内部镜像配置&amp;Intellij IDEA MAVEN配置 - CE中间件与系统集成 - 3ms知识管理社区<br><a href="http://3ms.huawei.com/hi/group/2027489/wiki_4781465.html" rel="external nofollow noopener noreferrer" target="_blank">http://3ms.huawei.com/hi/group/2027489/wiki_4781465.html</a></p><p>2、Git SVN 源代码版本控制工具。</p><p>具体安装配置操作可参考资料。</p><h2 id="Jenkins-全局工具配置"><a href="#Jenkins-全局工具配置" class="headerlink" title="Jenkins 全局工具配置"></a>Jenkins 全局工具配置</h2><p>JDK 配置 JAVA_HOME 目录即可</p><p>比如 <code>C:\Program Files\Java\jdk1.8.0_171</code></p><p>Git 配置 git.exe 文件即可</p><p>比如 <code>C:\Program Files\Git\bin\git.exe</code></p><p>Maven 配置 MAVEN_HOME 目录即可</p><p>比如 <code>D:\apache-maven\</code></p><h2 id="Jenkins-插件管理高级配置"><a href="#Jenkins-插件管理高级配置" class="headerlink" title="Jenkins 插件管理高级配置"></a>Jenkins 插件管理高级配置</h2><p>推荐配置 <strong>升级站点</strong></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/2.89/update-center.json" rel="external nofollow noopener noreferrer" target="_blank">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/2.89/update-center.json</a></p><p>公司内部推荐使用</p><p><a href="http://cmc-cd-mirror.rnd.huawei.com/jenkins-updates/update-center.json" rel="external nofollow noopener noreferrer" target="_blank">http://cmc-cd-mirror.rnd.huawei.com/jenkins-updates/update-center.json</a></p><p>参考链接：公司Jenkins插件中心上线啦，只需两步，免代理配置和漫长等待，轻松实现Jenkins插件在线自动安装和升级 - 刘珍珍的博客<br><a href="http://3ms.huawei.com/km/blogs/details/5544279" rel="external nofollow noopener noreferrer" target="_blank">http://3ms.huawei.com/km/blogs/details/5544279</a></p><blockquote><p>参考资料<br>1、jenkins详解 - CSDN博客<br><a href="https://blog.csdn.net/qq_26848099/article/details/78901240" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_26848099/article/details/78901240</a><br>2、如何理解持续集成、持续交付、持续部署？ - 知乎<br><a href="https://www.zhihu.com/question/23444990" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhihu.com/question/23444990</a><br>3、使用jekins自动构建部署java maven项目（jdk1.7+tomcat7.0+jenkins2.19.3） - 追极 - 博客园<br><a href="https://www.cnblogs.com/hdwang/p/6081994.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/hdwang/p/6081994.html</a><br>4、Jenkins：插件安装失败问题 - 简书<br><a href="https://www.jianshu.com/p/2b7288e77ff8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/2b7288e77ff8</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jenkins 是一款优秀的开源自动化服务器，允许持续集成和持续交付。Jenkins 支持数百个插件，以支持项目的构建、部署和自动化。&lt;/p&gt;&lt;p&gt;Jenkins 官网：&lt;a href=&quot;https://jenkins.io/&quot; rel=&quot;external nofollow
      
    
    </summary>
    
      <category term="持续集成" scheme="https://www.wshunli.com/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="Jenkins" scheme="https://www.wshunli.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>在线直播技术解决方案及其实现方法（移动端）</title>
    <link href="https://www.wshunli.com/posts/8aeeab4a.html"/>
    <id>https://www.wshunli.com/posts/8aeeab4a.html</id>
    <published>2018-07-04T13:40:33.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>简单地记录下 Android 移动端直播技术实现方法。</p><p>目前对移动端直播技术实现方法了解还不够全面，本文仅介绍一种基于 RTMP 协议的在线直播实现方法。</p><p>直播系统可以简单地分为三部分：服务端、推流端、拉流端。</p><h1 id="简单的直播系统"><a href="#简单的直播系统" class="headerlink" title="简单的直播系统"></a>简单的直播系统</h1><p>1、服务端：SRS</p><p>SRS定位是运营级的互联网直播服务器集群，追求更好的概念完整性和最简单实现的代码。</p><p>源代码：<a href="https://github.com/ossrs/srs" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ossrs/srs</a></p><p>部署方法：<a href="https://github.com/ossrs/srs/wiki/v1_CN_SampleRTMP" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ossrs/srs/wiki/v1_CN_SampleRTMP</a></p><p>2、推流端：OBS Studio</p><p>OBS Studio 是一款优秀的开源直播推流软件，支持 Windows, Mac or Linux 操作系统。</p><p>官网：<a href="https://obsproject.com/" rel="external nofollow noopener noreferrer" target="_blank">https://obsproject.com/</a></p><p>3、拉流端：VLC media player</p><p>VLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。</p><p>官网：<a href="http://www.videolan.org/vlc/" rel="external nofollow noopener noreferrer" target="_blank">http://www.videolan.org/vlc/</a></p><p>其实这里好多视频播放器都支持的。</p><h1 id="移动端实现方法"><a href="#移动端实现方法" class="headerlink" title="移动端实现方法"></a>移动端实现方法</h1><p>1、服务端 SRS</p><p>服务端同样使用 SRS</p><p>2、推流端 yasea</p><p>yasea 是一个优秀的 RTMP 直播流推流库。</p><p>代码仓库：<a href="https://github.com/begeekmyfriend/yasea" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/begeekmyfriend/yasea</a></p><p>3、拉流端 ijkplayer</p><p>使用方法：<a href="https://www.wshunli.com/posts/2f3bf23c.html">https://www.wshunli.com/posts/2f3bf23c.html</a></p><p>源码编译：<a href="https://www.wshunli.com/posts/45f072c2.html">https://www.wshunli.com/posts/45f072c2.html</a></p><p>本文内容比较简单，后面有机会再深入了解。</p><blockquote><p>参考资料<br>1、Android手机直播（一）总览 - 简书<br><a href="https://www.jianshu.com/p/7ebbcc0c5df7" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/7ebbcc0c5df7</a><br>2、轻松入门Android直播相关技术 从0搭建直播系统 - CSDN博客<br><a href="https://blog.csdn.net/lmj623565791/article/details/77937483" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lmj623565791/article/details/77937483</a><br>3、Android直播实现（一）Android端推流、播放 - CSDN博客<br><a href="https://blog.csdn.net/mr_sk/article/details/71083366" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/mr_sk/article/details/71083366</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单地记录下 Android 移动端直播技术实现方法。&lt;/p&gt;&lt;p&gt;目前对移动端直播技术实现方法了解还不够全面，本文仅介绍一种基于 RTMP 协议的在线直播实现方法。&lt;/p&gt;&lt;p&gt;直播系统可以简单地分为三部分：服务端、推流端、拉流端。&lt;/p&gt;&lt;h1 id=&quot;简单的直播系统&quot;
      
    
    </summary>
    
      <category term="前端技术" scheme="https://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="视频" scheme="https://www.wshunli.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="直播" scheme="https://www.wshunli.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="前端" scheme="https://www.wshunli.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（十）</title>
    <link href="https://www.wshunli.com/posts/4691b5a2.html"/>
    <id>https://www.wshunli.com/posts/4691b5a2.html</id>
    <published>2018-07-03T11:43:13.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】希望我的坚持，让我走得更高、看得更远
    
    </summary>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="https://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Android视频播放器ijkplayer源码编译</title>
    <link href="https://www.wshunli.com/posts/45f072c2.html"/>
    <id>https://www.wshunli.com/posts/45f072c2.html</id>
    <published>2018-06-26T06:55:55.000Z</published>
    <updated>2018-07-27T01:19:14.147Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu 16.04 LTS 系统下编译 ijkplayer Android 源码。</p><p>前面介绍过 ijkplayer 的使用，要想支持更多的特性，还是需要编译下源码的。</p><p>本文编译源码的主要目的是支持更多的格式，以及支持 HTTPS 链接。</p><p>NDK 版本：android-ndk-r10e</p><p>ijkplayer 仓库地址 <a href="https://github.com/Bilibili/ijkplayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Bilibili/ijkplayer</a></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>0、最好还是在 Ubuntu 环境下编译，在 Windows 下编译可以参考</p><p><a href="https://blog.csdn.net/u010072711/article/details/51354834" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010072711/article/details/51354834</a></p><p>并不推荐此方法。</p><p>1、然后需要有 Java 及 Android 环境，可参考</p><p><a href="https://www.wshunli.com/posts/80d94eb7.html">https://www.wshunli.com/posts/80d94eb7.html</a></p><p>2、编译之前，还要准备一些工具</p><pre><code class="Shell">sudo apt-get updatesudo apt-get install gitsudo apt-get install yasm</code></pre><h1 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h1><p>1、从 GitHub 拉取源码，并打开源码目录</p><pre><code class="Shell">git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-androidcd ijkplayer-android</code></pre><p>2、切换到指定版本，可在源码仓库查看</p><pre><code class="Shell">git checkout -B latest k0.8.8</code></pre><p>3、配置参数（可选操作，为了支持更多格式）</p><p>参数配置一共有三种方式，选择一种即可。</p><p>(1) 为支持更多的格式，我们选这种</p><pre><code class="Shell">cd configrm module.shln -s module-default.sh module.shcd ..</code></pre><p>(2) 支持 hevc 功能，而且精简后的库</p><pre><code class="Shell">cd configrm module.shln -s module-lite-hevc.sh module.shcd ..</code></pre><p>(3) 精简后的库，默认是这种配置</p><pre><code class="Shell">cd configrm module.shln -s module-lite.sh module.shcd ..</code></pre><p>4、初始化，主要是拉取 ijkplayer 的依赖等，输入命令</p><pre><code class="Shell">./init-android.sh</code></pre><p>初始化 openssl （可选操作，为了支持 HTTPS ）</p><pre><code class="Shell">./init-android-openssl.sh</code></pre><p>5、打开 <code>ijkplayer-android/android/contrib/</code> 目录，Android 下编译脚本就放在该目录下</p><pre><code class="Shell">cd android/contrib</code></pre><p>6、清理并编译 openssl 依赖（可选操作，为了支持 HTTPS ）</p><pre><code class="Shell">./compile-openssl.sh clean./compile-openssl.sh all</code></pre><p>7、清理并编译 ffmpeg 软解码库依赖</p><pre><code class="Shell">./compile-ffmpeg.sh clean./compile-ffmpeg.sh all</code></pre><p>如果遇到问题 <code>fatal error: linux/perf_event.h: No such file or directory</code></p><p>可参考：<a href="https://github.com/Bilibili/ijkplayer/issues/4125" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Bilibili/ijkplayer/issues/4125</a></p><p>在 module-default.sh、module-lite-hevc.sh 中添加如下一行配置即可。</p><pre><code class="Shell">export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;</code></pre><p>8、然后返回上级到 <code>ijkplayer-android/android/</code> 目录，编译源码</p><pre><code class="Shell">cd .../compile-ijk.sh all</code></pre><p>等待编译完成即可。</p><h1 id="导入使用"><a href="#导入使用" class="headerlink" title="导入使用"></a>导入使用</h1><p>打开 Android Studio 并导入 <code>ijkplayer-android/android/ijkplayer/</code> 即可。</p><p><img src="https://img.wshunli.com/Android/ijkplayer/ijkplayer-build.png" alt="ijkplayer-build"></p><p>在这个项目中 module 比较多，大多数是针对不同 CPU 架构的包。</p><blockquote><p>参考资料<br>1、Android 超好用的播放器——ijkplayer - 简书<br><a href="https://www.jianshu.com/p/c5d972ab0309" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c5d972ab0309</a><br>2、IJKPlayer初识-编译与使用 - 简书<br><a href="https://www.jianshu.com/p/a425ee1c2aec" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/a425ee1c2aec</a><br>3、在ubuntu下编译ijkplayer-android - CSDN博客<br><a href="https://blog.csdn.net/u010072711/article/details/51438871" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010072711/article/details/51438871</a><br>4、Android集成IjkPlayer - 简书<br><a href="https://www.jianshu.com/p/79b434b2d5c8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/79b434b2d5c8</a><br>5、Ubuntu编译ijkplayer支持https和更多视频格式 - CSDN博客<br><a href="https://blog.csdn.net/DyncKathline/article/details/78223972" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/DyncKathline/article/details/78223972</a><br>6、Android，ijkplayer增加https协议支持，编译运行ijkplayer - CSDN博客<br><a href="https://blog.csdn.net/linchaolong/article/details/52805666" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/linchaolong/article/details/52805666</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ubuntu 16.04 LTS 系统下编译 ijkplayer Android 源码。&lt;/p&gt;&lt;p&gt;前面介绍过 ijkplayer 的使用，要想支持更多的特性，还是需要编译下源码的。&lt;/p&gt;&lt;p&gt;本文编译源码的主要目的是支持更多的格式，以及支持 HTTPS 链接。&lt;/p&gt;
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="ijkplayer" scheme="https://www.wshunli.com/tags/ijkplayer/"/>
    
  </entry>
  
  <entry>
    <title>Android视频播放器ExoPlayer使用入门</title>
    <link href="https://www.wshunli.com/posts/11deb252.html"/>
    <id>https://www.wshunli.com/posts/11deb252.html</id>
    <published>2018-06-23T11:02:59.000Z</published>
    <updated>2018-07-27T01:19:14.143Z</updated>
    
    <content type="html"><![CDATA[<p>EXOPlayer 是Google 官方开源的一款 Android 播放器，支持本地或者网络的音频和视频播放，支持 DASH、HLS 等流媒体协议，但是不支持 rtsp、rtmp 协议。</p><p>EXOPlayer 仓库地址：<a href="https://github.com/google/ExoPlayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/google/ExoPlayer</a></p><p>Google 的亲儿子，还是要学习下啊。</p><h1 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h1><p>引入依赖可以一次性全部引入所有依赖：</p><pre><code class="gradle">dependencies {    implementation &#39;com.google.android.exoplayer:exoplayer:2.X.X&#39;}</code></pre><p>也可以根据需要引入不同模块。</p><pre><code class="gradle">dependencies {    implementation &#39;com.google.android.exoplayer:exoplayer-core:2.X.X&#39;    implementation &#39;com.google.android.exoplayer:exoplayer-dash:2.X.X&#39;    implementation &#39;com.google.android.exoplayer:exoplayer-hls:2.X.X&#39;    implementation &#39;com.google.android.exoplayer:exoplayer-smoothstreaming:2.X.X&#39;    implementation &#39;com.google.android.exoplayer:exoplayer-ui:2.X.X&#39;}</code></pre><h1 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h1><p>EXOPlayer 使用是非常简单的，首先添加播放器控件。</p><pre><code class="XML">&lt;com.google.android.exoplayer2.ui.SimpleExoPlayerView    android:id=&quot;@+id/exoView&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot; /&gt;</code></pre><p>然后初始化播放器。</p><pre><code class="Java">private void initPlayer() {    //1. 创建一个默认的 TrackSelector    BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();    TrackSelection.Factory videoTackSelectionFactory =            new AdaptiveTrackSelection.Factory(bandwidthMeter);    TrackSelector trackSelector =            new DefaultTrackSelector(videoTackSelectionFactory);    //2.创建ExoPlayer    simpleExoPlayer = ExoPlayerFactory.newSimpleInstance(this, trackSelector);    //3.创建SimpleExoPlayerView    simpleExoPlayerView = (SimpleExoPlayerView) findViewById(R.id.exoView);    //4.为SimpleExoPlayer设置播放器    simpleExoPlayerView.setPlayer(simpleExoPlayer);    simpleExoPlayer.setPlayWhenReady(true);}</code></pre><p>最后添加视频资源就可以播放了。</p><pre><code class="Java">DataSource.Factory mediaDataSourceFactory = new DefaultDataSourceFactory(this,        Util.getUserAgent(this, &quot;ExoPlayerDemo&quot;));MediaSource mediaSource = new ExtractorMediaSource.Factory(mediaDataSourceFactory).createMediaSource(Uri.parse(&quot;http://streams.wshunli.com/videos/dyys_x264.mp4&quot;));simpleExoPlayer.prepare(mediaSource);</code></pre><p>注意添加网络权限，最终效果：</p><p><img src="https://img.wshunli.com/Android/ExoPlayer/exoplayer-result.min.jpg" alt="exoplayer-result"></p><blockquote><p>参考资料<br>1、EXOPlayer简要学习及应用 - CSDN博客<br><a href="https://blog.csdn.net/s1991721/article/details/77587308" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/s1991721/article/details/77587308</a><br>2、ExoPlayer开发指南（官方文档翻译） - CSDN博客<br><a href="https://blog.csdn.net/u014606081/article/details/76181049" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u014606081/article/details/76181049</a><br>3、Google Exoplayer 之全面认识 - Android - 掘金<br><a href="https://juejin.im/entry/5884061f128fe1006c34ea43" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/entry/5884061f128fe1006c34ea43</a><br>4、ExoPlayer2.5 的简单使用 - 简书<br><a href="https://www.jianshu.com/p/c9b136fc16c7" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c9b136fc16c7</a><br>6、ExoPlayer的使用介绍 - 简书<br><a href="https://www.jianshu.com/p/628481250b59" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/628481250b59</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;EXOPlayer 是Google 官方开源的一款 Android 播放器，支持本地或者网络的音频和视频播放，支持 DASH、HLS 等流媒体协议，但是不支持 rtsp、rtmp 协议。&lt;/p&gt;&lt;p&gt;EXOPlayer 仓库地址：&lt;a href=&quot;https://githu
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="ExoPlayer" scheme="https://www.wshunli.com/tags/ExoPlayer/"/>
    
  </entry>
  
  <entry>
    <title>Android视频播放器ijkplayer使用入门</title>
    <link href="https://www.wshunli.com/posts/2f3bf23c.html"/>
    <id>https://www.wshunli.com/posts/2f3bf23c.html</id>
    <published>2018-06-23T08:26:20.000Z</published>
    <updated>2018-07-27T01:19:14.143Z</updated>
    
    <content type="html"><![CDATA[<p>ijkplayer 是 Bilibili 基于 ffmpeg 开发并开源的轻量级视频播放器，支持播放本地网络视频，也支持流媒体播放。</p><p>支持 Android 和 iOS 操作系统，所以文章起名还是有点瑕疵的，哈哈哈 。</p><p>ijkplayer 仓库地址：<a href="https://github.com/Bilibili/ijkplayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Bilibili/ijkplayer</a></p><p>目前 Android 主流的视频播放器是 ijkplayer、ExoPlayer、MediaPlayer。</p><p>其中 MediaPlayer 在前面介绍过了：《第一行代码》读书笔记（七） | CirGIS<br><a href="https://www.wshunli.com/posts/941f84ed.html">https://www.wshunli.com/posts/941f84ed.html</a></p><p>接下来两篇文章会分别介绍 ijkplayer 和 ExoPlayer 的使用，也为移动端直播技术打下基础。</p><h1 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h1><p>根据需要引入依赖，根据建议引入 java 、 armv7a 两种兼容性基本满足要求。</p><pre><code class="gradle">dependencies {    # required, enough for most devices.    compile &#39;tv.danmaku.ijk.media:ijkplayer-java:0.8.8&#39;    compile &#39;tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.8&#39;    # Other ABIs: optional    compile &#39;tv.danmaku.ijk.media:ijkplayer-armv5:0.8.8&#39;    compile &#39;tv.danmaku.ijk.media:ijkplayer-arm64:0.8.8&#39;    compile &#39;tv.danmaku.ijk.media:ijkplayer-x86:0.8.8&#39;    compile &#39;tv.danmaku.ijk.media:ijkplayer-x86_64:0.8.8&#39;    # ExoPlayer as IMediaPlayer: optional, experimental    compile &#39;tv.danmaku.ijk.media:ijkplayer-exo:0.8.8&#39;}</code></pre><h1 id="添加播放控件"><a href="#添加播放控件" class="headerlink" title="添加播放控件"></a>添加播放控件</h1><p>本身 ijkplayer 是没有播放控件的，这里我们采用示例代码的播放控件。</p><p>\ijkplayer\android\ijkplayer\ijkplayer-example\src\main\java\tv\danmaku\ijk\media\example\widget\media</p><p>将其代码复制到合适位置，还有 string 键值对，以及 Manifest 配置。</p><p><img src="https://img.wshunli.com/Android/ijkplayer/ijkplayer-widget.png" alt="ijkplayer-widget"></p><p>其中 Manifest 需要配置权限及声明服务。</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;···&lt;service    android:name=&quot;com.wshunli.ijkplayer.demo.services.MediaPlayerService&quot;    android:enabled=&quot;false&quot;    android:exported=&quot;false&quot;    android:icon=&quot;@mipmap/ic_launcher&quot;    android:label=&quot;@string/app_name&quot; /&gt;</code></pre><p>可能会出现 NullPointerException 错误，删除不必要的代码即可。</p><p><a href="https://github.com/Bilibili/ijkplayer/issues/3969" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Bilibili/ijkplayer/issues/3969</a></p><h1 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h1><p>在布局中添加播放控件。</p><pre><code class="XML">&lt;com.wshunli.ijkplayer.demo.widget.IjkVideoView    android:id=&quot;@+id/ijkvideoview&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;&lt;/com.wshunli.ijkplayer.demo.widget.IjkVideoView&gt;</code></pre><p>然后在 Activity 中使用就可以了。</p><pre><code class="Java">IjkVideoView ijkVideoView;···ijkVideoView = findViewById(R.id.ijkvideoview);ijkVideoView.setVideoURI(Uri.parse(&quot;http://streams.wshunli.com/videos/dyys2_x264.mp4&quot;));//  ijkVideoView.setVideoURI(Uri.parse(&quot;http://streams.wshunli.com/x36xhzz/x36xhzz.m3u8&quot;));ijkVideoView.start();</code></pre><p>默认是支持 m3u8 直播视频流的，挺意外的。</p><p><img src="https://img.wshunli.com/Android/ijkplayer/ijkplayer-livevideo.min.jpg" alt="ijkplayer-livevideo"></p><p>其他还有很多基于或者封装的播放库，这里列举出来就不多介绍了。</p><p>1、支持浮动和全屏的视频播放器。<br><a href="https://github.com/lipangit/JiaoZiVideoPlayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/lipangit/JiaoZiVideoPlayer</a></p><p>2、基于IJKPlayer（兼容系统MediaPlayer与EXOPlayer2），实现了多功能的视频播放器。<br><a href="https://github.com/CarGuo/GSYVideoPlayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/CarGuo/GSYVideoPlayer</a></p><p>3、Android播放器基础库，专注于播放视图组件的高复用性和组件间的低耦合，轻松处理复杂业务。<br><a href="https://github.com/jiajunhui/PlayerBase" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jiajunhui/PlayerBase</a></p><blockquote><p>参考资料<br>1、Android ijkplayer的使用解析 - CSDN博客<br><a href="https://blog.csdn.net/huaxun66/article/details/53401231" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/huaxun66/article/details/53401231</a><br>2、Android ijkplayer的使用解析及播放器的制作 - CSDN博客<br><a href="https://blog.csdn.net/github_2011/article/details/77385498" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/github_2011/article/details/77385498</a><br>3、Android 超好用的播放器——ijkplayer - 简书<br><a href="https://www.jianshu.com/p/c5d972ab0309" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c5d972ab0309</a><br>4、Android集成IjkPlayer - 简书<br><a href="https://www.jianshu.com/p/79b434b2d5c8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/79b434b2d5c8</a><br>5、视频直播技术（四）：使用Ijkplayer播放直播视频 - 灰色飘零 - 博客园<br><a href="http://www.cnblogs.com/renhui/p/6420140.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/renhui/p/6420140.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ijkplayer 是 Bilibili 基于 ffmpeg 开发并开源的轻量级视频播放器，支持播放本地网络视频，也支持流媒体播放。&lt;/p&gt;&lt;p&gt;支持 Android 和 iOS 操作系统，所以文章起名还是有点瑕疵的，哈哈哈 。&lt;/p&gt;&lt;p&gt;ijkplayer 仓库地址：&lt;
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="ijkplayer" scheme="https://www.wshunli.com/tags/ijkplayer/"/>
    
  </entry>
  
  <entry>
    <title>在线直播技术及其实时视频流可视化方法（前端）</title>
    <link href="https://www.wshunli.com/posts/b4d6e25d.html"/>
    <id>https://www.wshunli.com/posts/b4d6e25d.html</id>
    <published>2018-06-23T04:23:34.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，本文为较新研究成果，暂不公开，非常抱歉。 " /> <label for="pass"> 欢迎您访问我的博客，本文为较新研究成果，暂不公开，非常抱歉。 </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【暂不公开】记录在线直播技术及其实时视频流可视化方法（前端）。
    
    </summary>
    
      <category term="前端技术" scheme="https://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="视频" scheme="https://www.wshunli.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="直播" scheme="https://www.wshunli.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="前端" scheme="https://www.wshunli.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android View 体系（一）Android View 体系基础</title>
    <link href="https://www.wshunli.com/posts/f6f583a.html"/>
    <id>https://www.wshunli.com/posts/f6f583a.html</id>
    <published>2018-06-20T02:33:59.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>有很多人觉得自己比较菜，就会称自己为 Android UI 工程师，非常有意思。</p><p>其实 Android UI 体系内容也是比较多的，不仅仅是指 UI 控件的使用，那也太基础了。</p><p>本文主要介绍 Android View 基础，内容可能后面会逐步完善。</p><h1 id="View-介绍"><a href="#View-介绍" class="headerlink" title="View 介绍"></a>View 介绍</h1><p>View 是 Android 中所有控件的基类，同时 ViewGroup 也继承自 View 。</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-View体系/1/ViewGroup介绍.jpg" alt="ViewGroup介绍"></p><p>所以 View 本身可以是一个控件也可以是多个控件，基本上我们平常用到控件都继承自 View ，是一种树状结构。</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-View体系/1/View介绍.min.png" alt="View介绍"></p><h1 id="View-的位置参数"><a href="#View-的位置参数" class="headerlink" title="View 的位置参数"></a>View 的位置参数</h1><p>在 Android 中有两种类型的坐标系，分别是 Android 坐标系和视图坐标系。其实是相对而言的，</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-View体系/1/View坐标系.png" alt="View坐标系"></p><p>Android 坐标系是相对屏幕原点（左上角）而言，视图坐标系是相对父类容器（ViewGroup）而言的。</p><p>在 Android 中，View 的位置由 top、left、right、bottom 四个属性确定，注意都是相对父容器而言。</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-View体系/1/View位置API.png" alt="View位置API"></p><p>View 提供的 API 分别获取对应的数值。</p><ul><li>getTop()：获取 View 顶边到其父布局顶边的距离</li><li>getLeft()：获取 View 左边到其父布局左边的距离</li><li>getRight()：获取 View 右边到其父布局左边的距离</li><li>getBottom()：获取 View 底边到其父布局顶边的距离</li></ul><p>MotionEvent 也提供了一些获取点击位置的方法。</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-View体系/1/MotionEvent位置API.png" alt="MotionEvent位置API"></p><p>其中红点位置为点击位置。</p><ul><li>getX()：获取点击位置离View左边的距离</li><li>getY()：获取点击位置离View顶边的距离</li><li>getRawX()：获取点击位置离屏幕左边的距离</li><li>getRawY()：获取点击位置离屏幕顶边的距离</li></ul><p>其实感觉看懂了下面这张图，也就基本可以理解View的坐标系了。</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-View体系/1/View位置.min.png" alt="View位置"></p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 3.1 View 基础知识<br>2、《Android群英传》 – 第三章 Android 控件架构与自定义控件详解<br>3、Android View体系（一）视图坐标系 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/view/1-coordinate-system.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/view/1-coordinate-system.html</a><br>4、View | Android Developers<br><a href="https://developer.android.com/reference/android/view/View" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/reference/android/view/View</a><br>5、View与ViewGroup的概念 | 菜鸟教程<br><a href="http://www.runoob.com/w3cnote/android-tutorial-view-viewgroup-intro.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/w3cnote/android-tutorial-view-viewgroup-intro.html</a><br>6、Android 坐标系与视图坐标系图解 - CSDN博客<br><a href="https://blog.csdn.net/zhuwentao2150/article/details/52434104" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhuwentao2150/article/details/52434104</a><br>7、Android应用坐标系统全面详解 - CSDN博客<br><a href="https://blog.csdn.net/yanbober/article/details/50419117" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/yanbober/article/details/50419117</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有很多人觉得自己比较菜，就会称自己为 Android UI 工程师，非常有意思。&lt;/p&gt;&lt;p&gt;其实 Android UI 体系内容也是比较多的，不仅仅是指 UI 控件的使用，那也太基础了。&lt;/p&gt;&lt;p&gt;本文主要介绍 Android View 基础，内容可能后面会逐步完善。&lt;
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="View体系" scheme="https://www.wshunli.com/tags/View%E4%BD%93%E7%B3%BB/"/>
    
      <category term="《Android群英传》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（九）</title>
    <link href="https://www.wshunli.com/posts/c3a39066.html"/>
    <id>https://www.wshunli.com/posts/c3a39066.html</id>
    <published>2018-06-09T08:48:00.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】都6月份了，一直拖到现在，也是6得不行
    
    </summary>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="https://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>那些年，我们用过的地图下载器</title>
    <link href="https://www.wshunli.com/posts/73256148.html"/>
    <id>https://www.wshunli.com/posts/73256148.html</id>
    <published>2018-06-09T01:46:27.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>作为地信、遥感等专业的同学，下载线划图、遥感影像应该都接触过，以前很多群发广告都看不惯，借这次下载高程数据的机会，总结下地图下载器，收费部分的搜索下就懂了。。</p><p><strong>本文仅介绍平常接触到的地图下载器，用作学习和研究目的，不提供收费软件破解文件下载</strong>。</p><p><strong>本文标题来源</strong>：那些年，我们用过的地图下载器 - 我也是个傻瓜 - 博客园<br><a href="https://www.cnblogs.com/liweis/p/4575656.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/liweis/p/4575656.html</a></p><p>1、晟兴地球 SXEarth 是一款永久免费的 3DGIS 平台软件。</p><p>支持在线 Google Earth 卫星影像（无水印无偏移）下载，支持拼接为tif，支持模拟飞行，支持场景编辑。</p><p><img src="https://img.wshunli.com/瞎推荐/地图下载器/SXEarth.png" alt="SXEarth"></p><p>下载地址：<a href="http://www.sxsim.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.sxsim.com/</a></p><p>支持的在线地图特别多，平常基本上用这个就够了。</p><p>2、LocaSpace Viewer 免费、开放的三维数字地球</p><p>多种互联网地图集成、影像、地形数据下载、倾斜数据极速浏览、二三维地理、模型数据、量测和空间分析、软件特色应用。</p><p><img src="https://img.wshunli.com/瞎推荐/地图下载器/LocaSpaceViewer.png" alt="LocaSpaceViewer"></p><p>下载地址：<a href="http://www.locaspace.cn/LSV.jsp" rel="external nofollow noopener noreferrer" target="_blank">http://www.locaspace.cn/LSV.jsp</a></p><p>支持的在线底图不是很多，但是在三维场景尤其是倾斜摄影方面很有优势。</p><p>其他收费的在参考资料，这里就先不介绍了。</p><blockquote><p>参考资料<br>1、那些年，我们用过的地图下载器 - 我也是个傻瓜 - 博客园<br><a href="https://www.cnblogs.com/liweis/p/4575656.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/liweis/p/4575656.html</a><br>2、奉上我收藏的地图下载器（低调使用，你懂的），还各个群一个良好的群环境（别再因为苦于找不到下载器而转发广告了） - ThinkGIS<br><a href="http://www.thinkgis.cn/topic/555ac3911cf2f372004ef9ac" rel="external nofollow noopener noreferrer" target="_blank">http://www.thinkgis.cn/topic/555ac3911cf2f372004ef9ac</a><br>3、SXEarth-超强的GIS数据下载利器 | 麻辣GIS<br><a href="https://malagis.com/sxearth-super-gis-data-downloader.html" rel="external nofollow noopener noreferrer" target="_blank">https://malagis.com/sxearth-super-gis-data-downloader.html</a><br>4、只要三步下载GIS数据（亲测可用/免费/无需转发5个群） | 麻辣GIS<br><a href="https://malagis.com/downlod-gis-data-by-3-steps.html" rel="external nofollow noopener noreferrer" target="_blank">https://malagis.com/downlod-gis-data-by-3-steps.html</a><br>5、北京晟兴科技有限公司 官网首页<br><a href="http://www.sxsim.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.sxsim.com/</a><br>6、LocaSpace Viewer 三维数字地球<br><a href="http://www.locaspace.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.locaspace.cn/</a><br>7、太乐地图官网 - 让地理信息应用更简单<br><a href="http://www.arctiler.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.arctiler.com/</a><br>8、谷歌卫星地图下载器-谷歌地图高清卫星地图2018-北斗卫星地图-水经注万能地图下载器-水经注软件<br><a href="http://www.rivermap.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.rivermap.cn/</a><br>9、91卫图助手，Google Earth影像高程历史影像下载专家<br><a href="http://www.91weitu.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.91weitu.com/</a><br>10、谷歌地图高清卫星地图2018_北斗卫星地图_3d地形图-BIGEMAP<br><a href="http://www.bigemap.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.bigemap.com/</a><br>11、谷歌卫星地图下载器<br><a href="http://www.wolfmap.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.wolfmap.cn/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为地信、遥感等专业的同学，下载线划图、遥感影像应该都接触过，以前很多群发广告都看不惯，借这次下载高程数据的机会，总结下地图下载器，收费部分的搜索下就懂了。。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本文仅介绍平常接触到的地图下载器，用作学习和研究目的，不提供收费软件破解文件下载&lt;/s
      
    
    </summary>
    
      <category term="瞎推荐" scheme="https://www.wshunli.com/categories/%E7%9E%8E%E6%8E%A8%E8%8D%90/"/>
    
    
      <category term="GIS" scheme="https://www.wshunli.com/tags/GIS/"/>
    
      <category term="地图下载器" scheme="https://www.wshunli.com/tags/%E5%9C%B0%E5%9B%BE%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（八）使用 Socket 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/c9a2416c.html"/>
    <id>https://www.wshunli.com/posts/c9a2416c.html</id>
    <published>2018-06-08T12:46:26.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>Socket 也称为 “嵌套字”，是计算机网络中的概念，分为流式嵌套字（TCP）和用户数据报嵌套字（UDP）。</p><p>不同用户进程通过 Socket 进行通信也是一种 IPC 方式。</p><p>在使用 Socket 通信前应在 AndroidManifest 中声明权限：</p><pre><code class="XML">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</code></pre><p>1、服务端</p><p>我们需要一个 Service 作为服务端，声明如下：</p><pre><code class="XML">&lt;service    android:name=&quot;.socket.SocketService&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p>Socket 服务端在 Service 启动时，会建立 TCP 连接并监听 8688 端口。</p><pre><code class="Java">public class SocketService extends Service {    private static final String TAG = &quot;SocketService&quot;;    private boolean isDestroyed = false;    private String[] messages = new String[]{            &quot;你好啊，哈哈&quot;,            &quot;请问你叫什么名字呀？&quot;,            &quot;今天北京天气不错啊&quot;,            &quot;你知道吗？我可是可以和多个人同时聊天的哦&quot;,            &quot;给你讲个笑话吧：据说爱笑的人运气不会太差，不知道真假。&quot;    };    public SocketService() {    }    @Override    public void onCreate() {        super.onCreate();        new Thread(new TCPServer()).start();    }    @Override    public IBinder onBind(Intent intent) {        return null;    }    @Override    public void onDestroy() {        isDestroyed = true;        super.onDestroy();    }    private class TCPServer implements Runnable {        @Override        public void run() {            ServerSocket serverSocket = null;            try {                serverSocket = new ServerSocket(8688);            } catch (IOException e) {                e.printStackTrace();            }            while (!isDestroyed) {                try {                    final Socket client = serverSocket.accept();                    Log.d(TAG, &quot;accept&quot;);                    new Thread() {                        @Override                        public void run() {                            responseClient(client);                        }                    }.start();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        private void responseClient(Socket client) {            try {                // 接收客户端消息                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));                // 响应客户端消息                PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())), true);                Log.d(TAG, &quot;欢迎来到聊天室！&quot;);                out.println(&quot;欢迎来到聊天室！&quot;);                while (!isDestroyed) {                    String line = in.readLine();                    Log.d(TAG, &quot;message from Client: &quot; + line);                    if (line == null) break;                    int i = new Random().nextInt(messages.length);                    String message = messages[i];                    out.println(message);                    Log.d(TAG, &quot;response to Client: &quot; + message);                }                out.close();                in.close();                client.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>当与客户端建立连接后，新建 Socket 客户端，接收消息并作出响应。</p><p>2、客户端</p><p>客户端部分首先启动 Socket 服务，并且在连接失败后会不断重新尝试连接。</p><pre><code class="Java">public class SocketActivity extends AppCompatActivity {    private static final String TAG = &quot;SocketActivity&quot;;    private Button bt_send;    private EditText et_receive;    private TextView tv_message;    private PrintWriter mPrintWriter;    private Socket mClientSocket;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_socket);        initView();        Intent service = new Intent(this, SocketService.class);        startService(service);        new Thread() {            @Override            public void run() {                connectSocketServer();            }        }.start();    }    private void initView() {        et_receive = findViewById(R.id.et_receive);        bt_send = findViewById(R.id.bt_send);        tv_message = findViewById(R.id.tv_message);        bt_send.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                final String msg = et_receive.getText().toString();                //向服务器发送信息                if (!TextUtils.isEmpty(msg) &amp;&amp; mPrintWriter != null) {                    Log.d(TAG, &quot;onClick: &quot; + msg);                    new Thread(new Runnable() {                        @Override                        public void run() {                            mPrintWriter.println(msg);                        }                    }).start();                    tv_message.setText(tv_message.getText() + &quot;\n&quot; + &quot;客户端：&quot; + msg);                    et_receive.setText(&quot;&quot;);                }            }        });    }    private void connectSocketServer() {        Socket socket = null;        while (socket == null) {            try {                //选择和服务器相同的端口8688                socket = new Socket(&quot;localhost&quot;, 8688);                mClientSocket = socket;                mPrintWriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), true);            } catch (IOException e) {                SystemClock.sleep(1000);            }        }        try {            // 接收服务器端的消息            BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));            while (!isFinishing()) {                final String msg = br.readLine();                if (msg != null) {                    runOnUiThread(                            new Runnable() {                                @Override                                public void run() {                                    tv_message.setText(tv_message.getText() + &quot;\n&quot; + &quot;服务端：&quot; + msg);                                }                            }                    );                }            }            mPrintWriter.close();            br.close();            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }    @Override    protected void onDestroy() {        if (mClientSocket != null) {            try {                mClientSocket.shutdownInput();                mClientSocket.close();            } catch (IOException e) {                e.printStackTrace();            }        }        super.onDestroy();    }}</code></pre><p>主要使用 socket.getOutputStream() 和 socket.getInputStream() 方法分别发送、接收服务端消息。</p><p>打印日志如下：</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/8.Socket日志.png" alt="8.Socket日志"></p><p>最终效果如下：</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/8.Socket进程间通信.png" alt="8.Socket进程间通信"></p><p>到这里把 Android IPC 通信的几种实现方式基本看了一遍，但是在 Binder 机制原理方面还有欠缺，后面再深入学习。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.6 使用 Socket<br>2、Android IPC机制（五）用Socket实现跨进程聊天程序 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/5-socket.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/5-socket.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Socket 也称为 “嵌套字”，是计算机网络中的概念，分为流式嵌套字（TCP）和用户数据报嵌套字（UDP）。&lt;/p&gt;&lt;p&gt;不同用户进程通过 Socket 进行通信也是一种 IPC 方式。&lt;/p&gt;&lt;p&gt;在使用 Socket 通信前应在 AndroidManifest 中声明
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（七）使用 ContentProvider 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/b68f7dd9.html"/>
    <id>https://www.wshunli.com/posts/b68f7dd9.html</id>
    <published>2018-06-08T11:32:34.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>ContentProvider 是 Andorid 中专门用于不同应用间进行数据共享的方式，底层实现也是 Binder 。</p><p>前面在 <a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider</a> 介绍过，这里就不再详细记录了。</p><p>首先继承 ContentProvider 类实现自己的 Provider ：</p><pre><code class="Java">public class BookProvider extends ContentProvider {    private static final String TAG = &quot;BookProvider&quot;;    public static final String AUTHORITY = &quot;com.wshunli.ipc.demo.book.provider&quot;;    public static final Uri BOOK_CONTENT_URI = Uri.parse(&quot;content://&quot;            + AUTHORITY + &quot;/book&quot;);    public static final Uri USER_CONTENT_URI = Uri.parse(&quot;content://&quot;            + AUTHORITY + &quot;/user&quot;);    public static final int BOOK_URI_CODE = 0;    public static final int USER_URI_CODE = 1;    private static final UriMatcher sUriMatcher = new UriMatcher(            UriMatcher.NO_MATCH);    static {        sUriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_URI_CODE);        sUriMatcher.addURI(AUTHORITY, &quot;user&quot;, USER_URI_CODE);    }    private Context context;    private SQLiteDatabase db;    public BookProvider() {    }    @Override    public boolean onCreate() {        context = getContext();        initProviderData();        return true;    }    private void initProviderData() {        db = new DBHelper(context).getWritableDatabase();        db.execSQL(&quot;delete from &quot; + DBHelper.BOOK_TABLE_NAME);        db.execSQL(&quot;delete from &quot; + DBHelper.USER_TALBE_NAME);        db.execSQL(&quot;insert into book values(3,&#39;Android&#39;);&quot;);        db.execSQL(&quot;insert into book values(4,&#39;Ios&#39;);&quot;);        db.execSQL(&quot;insert into book values(5,&#39;Html5&#39;);&quot;);        db.execSQL(&quot;insert into user values(1,&#39;jake&#39;,1);&quot;);        db.execSQL(&quot;insert into user values(2,&#39;jasmine&#39;,0);&quot;);    }    @Override    public String getType(Uri uri) {        Log.d(TAG, &quot;getType: &quot;);        return null;    }    @Override    public Uri insert(Uri uri, ContentValues values) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        db.insert(table, null, values);        context.getContentResolver().notifyChange(uri, null);        return uri;    }    @Override    public Cursor query(Uri uri, String[] projection, String selection,                        String[] selectionArgs, String sortOrder) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        return db.query(table, projection, selection, selectionArgs, null, null, sortOrder, null);    }    @Override    public int update(Uri uri, ContentValues values, String selection,                      String[] selectionArgs) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        int row = db.update(table, values, selection, selectionArgs);        if (row &gt; 0) {            context.getContentResolver().notifyChange(uri, null);        }        return row;    }    @Override    public int delete(Uri uri, String selection, String[] selectionArgs) {        String table = getTableName(uri);        if (table == null) {            throw new IllegalArgumentException(&quot;Unsupported URI: &quot; + uri);        }        int count = db.delete(table, selection, selectionArgs);        if (count &gt; 0) {            context.getContentResolver().notifyChange(uri, null);        }        return count;    }    private String getTableName(Uri uri) {        String tableName = null;        switch (sUriMatcher.match(uri)) {            case BOOK_URI_CODE:                tableName = DBHelper.BOOK_TABLE_NAME;                break;            case USER_URI_CODE:                tableName = DBHelper.USER_TALBE_NAME;                break;            default:                break;        }        return tableName;    }}</code></pre><p>记得在 AndroidManifest 中声明：</p><pre><code class="XML">&lt;provider    android:name=&quot;.content.BookProvider&quot;    android:authorities=&quot;com.wshunli.ipc.demo.book.provider&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;    android:permission=&quot;com.wshunli.ipc.demo.PROVIDER&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p>其中 DBHelper 为数据库帮助类，代码如下：</p><pre><code class="Java">public class DBHelper extends SQLiteOpenHelper {    private static final String DB_NAME = &quot;book_provider.db&quot;;    public static final String BOOK_TABLE_NAME = &quot;book&quot;;    public static final String USER_TALBE_NAME = &quot;user&quot;;    private static final int DB_VERSION = 3;    private String CREATE_BOOK_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot;            + BOOK_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT)&quot;;    private String CREATE_USER_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot;            + USER_TALBE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT,&quot;            + &quot;sex INT)&quot;;    public DBHelper(Context context) {        super(context, DB_NAME, null, DB_VERSION);    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK_TABLE);        db.execSQL(CREATE_USER_TABLE);    }    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    }}</code></pre><p>然后就是使用了，新建 Activity ：</p><pre><code class="Java">public class ProviderActivity extends AppCompatActivity {    private static final String TAG = &quot;ProviderActivity&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_provider);//        Uri uri = Uri.parse(&quot;content://com.wshunli.ipc.demo.book.provider&quot;);//        getContentResolver().query(uri, null, null, null, null);        Uri bookUri = Uri.parse(&quot;content://com.wshunli.ipc.demo.book.provider/book&quot;);        ContentValues values = new ContentValues();        values.put(&quot;_id&quot;, 6);        values.put(&quot;name&quot;, &quot;程序设计的艺术&quot;);        getContentResolver().insert(bookUri, values);        Cursor bookCursor = getContentResolver().query(bookUri, new String[]{&quot;_id&quot;, &quot;name&quot;}, null, null, null);        while (bookCursor.moveToNext()) {            Book book = new Book();            book.bookId = bookCursor.getInt(0);            book.bookName = bookCursor.getString(1);            Log.d(TAG, &quot;query book:&quot; + book.toString());        }        bookCursor.close();        Uri userUri = Uri.parse(&quot;content://com.wshunli.ipc.demo.book.provider/user&quot;);        Cursor userCursor = getContentResolver().query(userUri, new String[]{&quot;_id&quot;, &quot;name&quot;, &quot;sex&quot;}, null, null, null);        while (userCursor.moveToNext()) {            User user = new User();            user.userId = userCursor.getInt(0);            user.userName = userCursor.getString(1);            user.isMale = userCursor.getInt(2) == 1;            Log.d(TAG, &quot;query user:&quot; + user.toString());        }        userCursor.close();    }}</code></pre><p>日志结果如下：</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/7.ContentProvider进程间通信.png" alt="7.ContentProvider进程间通信"></p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.5 使用 ContentProvider</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ContentProvider 是 Andorid 中专门用于不同应用间进行数据共享的方式，底层实现也是 Binder 。&lt;/p&gt;&lt;p&gt;前面在 &lt;a href=&quot;https://www.wshunli.com/posts/2311b8ab.html&quot;&gt;《第一行代码》读书笔记
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（六）使用 AIDL 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/75f6d3a2.html"/>
    <id>https://www.wshunli.com/posts/75f6d3a2.html</id>
    <published>2018-06-08T06:43:53.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL（Android Interface Definition Language ，Android 接口定义语言），定义客户端与服务使用进程间通信 (IPC) 进行相互通信时都认可的编程接口。</p><p>只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。</p><p>如果不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。</p><p>1、创建 AIDL 文件</p><p>首先在 java 同级目录 aidl 文件夹，然后创建 .aidl 文件。</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/6.AIDL文件.png" alt="6.AIDL文件"></p><pre><code class="Java">// IBookManager.aidlpackage com.wshunli.ipc.demo;// Declare any non-default types here with import statementsimport com.wshunli.ipc.demo.Book;interface IBookManager {    List&lt;Book&gt; getBookList();    void addBook(in Book book);    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);}</code></pre><p>在 <code>.aidl</code> 文件中支持的数据类型包括：</p><ul><li>基本数据类型</li><li>String 和 CharSequence</li><li>List:只支持 ArrayList , 里面的元素都必须被 AIDL 支持</li><li>Map:只支持 HashMap , 里面的元素必须被 AIDL 支持</li><li>实现 Parcelable 接口的对象</li><li>所有 AIDL 接口</li></ul><p>然后创建实现了 Parcelable 的类：</p><pre><code class="Java">public class Book implements Parcelable {    public String name;    public Book(String name) {        this.name = name;    }    @Override    public int describeContents() {        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeString(name);    }    public static Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() {        @Override        public Book createFromParcel(Parcel source) {            return new Book(source);        }        @Override        public Book[] newArray(int size) {            return new Book[size];        }    };    private Book(Parcel source) {        name = source.readString();    }    @Override    public String toString() {        return &quot;Book{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>创建 Book.aidl 文件：</p><pre><code class="Java">// Book.aidlpackage com.wshunli.ipc.demo;// Declare any non-default types here with import statementsparcelable Book;</code></pre><p>这时候重新编译程序，工程就会自动生成 <code>BookManager.aidl</code> 接口对应的文件。</p><p>app\build\generated\source\aidl\debug\com\wshunli\ipc\demoIBookManager.java</p><p>2、创建服务端</p><p>服务端使用 IBookManager.Stub() 方法创建 Binder 实例并在 onBind() 方法中返回。</p><pre><code class="Java">public class BookManagerService extends Service {    private static final String TAG = &quot;BookManagerService&quot;;    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();    private Binder mBinder = new IBookManager.Stub(){        @Override        public List&lt;Book&gt; getBookList() throws RemoteException {            return mBookList;        }        @Override        public void addBook(Book book) throws RemoteException {            mBookList.add(book);        }        @Override        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {        }    };    public BookManagerService() {    }    @Override    public void onCreate() {        super.onCreate();        mBookList.add(new Book(&quot;android&quot;));        mBookList.add(new Book(&quot;ios&quot;));    }    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }}</code></pre><p>其中 onCreate() 方法中填充了数据。</p><p>当然在 AndroidManife 文件中要配置 Service</p><pre><code class="XML">&lt;service    android:name=&quot;com.wshunli.ipc.demo.BookManagerService&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p>3、客户端</p><p>客户端还是使用 bindService() 方法绑定服务。</p><pre><code class="Java">public class BookManagerActivity extends AppCompatActivity {    private static final String TAG = &quot;BookManagerActivity&quot;;    private ServiceConnection connection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            IBookManager bookManager = IBookManager.Stub.asInterface(service);            try {                List&lt;Book&gt; bookList = bookManager.getBookList();                Log.d(TAG, &quot;onServiceConnected: &quot; + bookList.toString());            } catch (RemoteException e) {                e.printStackTrace();            }        }        @Override        public void onServiceDisconnected(ComponentName name) {        }    };    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_book_manager);        Intent intent = new Intent(BookManagerActivity.this, BookManagerService.class);        bindService(intent, connection, BIND_AUTO_CREATE);    }    @Override    protected void onDestroy() {        unbindService(connection);        super.onDestroy();    }}</code></pre><p>其中 IBookManager 对象来调用具体服务器方法，获取数据。</p><p>AIDL 的功能远不止这些，后面再深入研究。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.4 使用 AIDL<br>2、Android 接口定义语言 (AIDL) | Android Developers<br><a href="https://developer.android.com/guide/components/aidl" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/aidl</a><br>3、Android IPC机制（三）在Android Studio中使用AIDL实现跨进程方法调用 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/3-aidl.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/3-aidl.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AIDL（Android Interface Definition Language ，Android 接口定义语言），定义客户端与服务使用进程间通信 (IPC) 进行相互通信时都认可的编程接口。&lt;/p&gt;&lt;p&gt;只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（五）使用 Messenger 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/9da3d2db.html"/>
    <id>https://www.wshunli.com/posts/9da3d2db.html</id>
    <published>2018-06-07T11:05:00.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>通过 Messenger 可以在不同进程之间传递 Message 对象，是一种轻量级的 IPC 方案。</p><p>首先看 Messenger 的构造方法：</p><pre><code class="Java">public Messenger(Handler target) {    mTarget = target.getIMessenger();}public Messenger(IBinder target) {    mTarget = IMessenger.Stub.asInterface(target);}</code></pre><p>实质上还是底层还是基于 AIDL 的。</p><p>对于 Message 对象可以存储传递的数据：</p><pre><code class="Java">public int what; // 消息标识public int arg1; // 整型数据public int arg2; // 整型数据public Object obj;public Messenger replyTo;/*package*/ Bundle data;public void setData(Bundle data) {    this.data = data;}</code></pre><p>其中 obj 只能传输系统中实现了 Parcelable 接口的对象。</p><p>对于 <strong>客户端</strong> 发送消息主要使用 bindService 方法绑定另一个进程的 Service 。</p><pre><code class="Java">public class MessengerActivity extends AppCompatActivity {    private static final String TAG = &quot;MessengerActivity&quot;;    private Messenger messenger;    private ServiceConnection connection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            // 请求服务端            messenger = new Messenger(service);            Message message = Message.obtain(null, MConstants.MSG_FROM_CLIENT);            Bundle bundle = new Bundle();            Log.d(TAG, &quot;这里是客户端，向服务端发送消息&quot;);            bundle.putString(&quot;msg&quot;, &quot;客户端发送内容&quot;);            message.setData(bundle);            // 注意设置 replyTo            message.replyTo = getReplyMessenger;            try {                messenger.send(message);            } catch (RemoteException e) {                e.printStackTrace();            }        }        @Override        public void onServiceDisconnected(ComponentName name) {        }    };    private static class MessageHandler extends Handler {        @Override        public void handleMessage(Message msg) {            Log.d(TAG, &quot;这里是客户端，接收服务端响应&quot;);            switch (msg.what) {                case MConstants.MSG_FROM_SERVICE:                    // 接收服务端响应                    Log.d(TAG, &quot;客户端接收到: &quot; + msg.getData().get(&quot;reply&quot;));                    break;                default:                    super.handleMessage(msg);            }        }    }    private Messenger getReplyMessenger = new Messenger(new MessageHandler());    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_messenger);        Intent intent = new Intent(this, MessengerService.class);        bindService(intent, connection, Context.BIND_AUTO_CREATE);    }    @Override    protected void onDestroy() {        unbindService(connection);        super.onDestroy();    }}</code></pre><p>如果需要接收服务端返回的消息，注意在发送 Message 字段 replyTo 关联处理消息的 Messenger 对象。</p><p>对于 <strong>服务端</strong> ，首先 Messenger 对象关联接收消息的 Handler ，然后在服务端 onBind 中调用 getBinder() 方法得到 Binder 对象。</p><p>其中 MessageHandler 继承 Handler 并重写 handleMessage 方法。</p><pre><code class="Java">public class MessengerService extends Service {    private static final String TAG = &quot;MessengerService&quot;;    private static class MessageHandler extends Handler {        @Override        public void handleMessage(Message msg) {            Log.d(TAG, &quot;这里是服务端，响应客户端消息&quot;);            switch (msg.what) {                case MConstants.MSG_FROM_CLIENT:                    Log.d(TAG, &quot;服务端接收到: &quot; + msg.getData().get(&quot;msg&quot;));                    // 响应客户端请求                    Messenger replyTo = msg.replyTo;                    Message replyMessage = Message.obtain(null, MConstants.MSG_FROM_SERVICE);                    Bundle bundle = new Bundle();                    bundle.putString(&quot;reply&quot;,&quot;服务端响应内容&quot;);                    replyMessage.setData(bundle);                    try {                        replyTo.send(replyMessage);                    } catch (RemoteException e) {                        e.printStackTrace();                    }                    break;                default:                    super.handleMessage(msg);            }        }    }    private final Messenger messenger = new Messenger(new MessageHandler());    @Nullable    @Override    public IBinder onBind(Intent intent) {        return messenger.getBinder();    }}</code></pre><p>如果需要响应客户端请求，使用 replyTo 字段获取 Messenger 实例再发送消息即可。</p><p>最后注意在 Manifest 中注册 Service 组件。</p><pre><code class="XML">&lt;service    android:name=&quot;com.wshunli.ipc.demo.message.MessengerService&quot;    android:process=&quot;:remote&quot; /&gt;</code></pre><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/5.Messenger进程间通信.png" alt="Messenger进程间通信"></p><p>Messenger 进程间通信在服务端是以串行的方式逐个处理的，所以有大量并发请求时使用 Messenger 不太合适。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.4.3 使用 Messenger<br>2、Android IPC机制（二）用Messenger进行进程间通信 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/2-messenger.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/2-messenger.html</a><br>3、Android 基于Message的进程间通信 Messenger完全解析 - CSDN博客<br><a href="https://blog.csdn.net/lmj623565791/article/details/47017485" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lmj623565791/article/details/47017485</a><br>4、Handler之Message详解 - 简书<br><a href="https://www.jianshu.com/p/a6c01dd2efdc" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/a6c01dd2efdc</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过 Messenger 可以在不同进程之间传递 Message 对象，是一种轻量级的 IPC 方案。&lt;/p&gt;&lt;p&gt;首先看 Messenger 的构造方法：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;Java&quot;&gt;public Messenger(Handler target
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（四）使用文件共享实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/60bbb7ec.html"/>
    <id>https://www.wshunli.com/posts/60bbb7ec.html</id>
    <published>2018-06-07T09:09:28.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>使用文件共享也是不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据。</p><p>在 Windows 系统，文件会被加排斥锁导致其他线程无法对其访问，而 Android 是基于 Linux 系统，所以并发读写文件没有限制。</p><pre><code class="Java">// 序列化private void persistToFile() {    new Thread(new Runnable() {        @Override        public void run() {            User user = new User(1, &quot;wshunli&quot;, true);            File dir = new File(getApplicationContext().getCacheDir().getPath() + &quot;/user/&quot;);            if (!dir.exists()) {                dir.mkdirs();            }            File cachedFile = new File(dir.getPath() + &quot;/usercache&quot;);            ObjectOutputStream objectOutputStream = null;            try {                objectOutputStream = new ObjectOutputStream(                        new FileOutputStream(cachedFile));                objectOutputStream.writeObject(user);                Log.d(TAG, &quot;persist user:&quot; + user);            } catch (IOException e) {                e.printStackTrace();            } finally {                try {                    if (objectOutputStream != null) {                        objectOutputStream.close();                    }                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }).start();}// 反序列化private void recoverFromFile() {    new Thread(new Runnable() {        @Override        public void run() {            User user = null;            File dir = new File(getApplicationContext().getCacheDir().getPath() + &quot;/user/&quot;);            File cachedFile = new File(dir.getPath() + &quot;/usercache&quot;);            if (cachedFile.exists()) {                ObjectInputStream objectInputStream = null;                try {                    objectInputStream = new ObjectInputStream(                            new FileInputStream(cachedFile));                    user = (User) objectInputStream.readObject();                    Log.d(TAG, &quot;recover user:&quot; + user);                } catch (IOException e) {                    e.printStackTrace();                } catch (ClassNotFoundException e) {                    e.printStackTrace();                } finally {                    try {                        if (objectInputStream != null) {                            objectInputStream.close();                        }                    } catch (IOException e) {                        e.printStackTrace();                    }                }            }        }    }).start();}</code></pre><p>这样对共享文件格式没有要求，但是在多线程情况下可能导致读出的内容不是最新的。<br>所以文件共享适合对数据同步要求不高的进程间进行通信，并妥善地处理好并发读/写问题。</p><p>而对于 SharedPreferences 有一定的读/写缓存策略，在内存中会有一份缓存，因此在多进程情况下，系统对其的读/写就变得不可靠，所以在进程间通信时，一般不用 SharedPreferences 。</p><blockquote><p>参考资料<br>《Android开发艺术探索》 – 2.4.2 使用文件共享</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用文件共享也是不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据。&lt;/p&gt;&lt;p&gt;在 Windows 系统，文件会被加排斥锁导致其他线程无法对其访问，而 Android 是基于 Linux 系统，所以并发读写文件没有限制。&lt;/p&gt;&lt;pre&gt;&lt;code class=
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（三）使用 Bundle 实现进程间通信</title>
    <link href="https://www.wshunli.com/posts/f0f2eaec.html"/>
    <id>https://www.wshunli.com/posts/f0f2eaec.html</id>
    <published>2018-06-07T07:40:59.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 四大组件中 Activity、Service、Receiver 都支持在 Intent 中附加传递 Bundle 数据。</p><p>Bundle 是以键值对的形式存储数据，支持基本数据类型、数组、实现 Serializable 或 Parcelable 接口的对象以及一些 Android 支持的特殊对象。</p><pre><code class="Java">// 发送数据Intent intent = new Intent(MainActivity.this, SecondActivity.class);Bundle bundle = new Bundle();bundle.putString(&quot;userName&quot;, &quot;wshunli&quot;);intent.putExtras(bundle);startActivity(intent);// 接收数据Bundle bundle = getIntent().getExtras();String userName = null;if (bundle != null) {    userName = bundle.getString(&quot;userName&quot;);}Log.d(TAG, &quot;userName: &quot; + userName);</code></pre><p>使用 Bundle 的 put 与 get 方法族将数据保存至 bundle 对象，调用 Intent 的 putExtras 方法即可。</p><p>Bundle 源码分析，Bundle 继承自 BaseBundle 并实现了 Cloneable 和 Parcelable 接口。</p><p>以 Boolean 类型数据存取为例：</p><pre><code class="Java">ArrayMap&lt;String, Object&gt; mMap = null;public void putBoolean(@Nullable String key, boolean value) {    unparcel();    mMap.put(key, value);}public boolean getBoolean(String key, boolean defaultValue) {    unparcel();    Object o = mMap.get(key);    if (o == null) {        return defaultValue;    }    try {        return (Boolean) o;    } catch (ClassCastException e) {        typeWarning(key, o, &quot;Boolean&quot;, defaultValue, e);        return defaultValue;    }}</code></pre><p>根据源码可知数据存取都是在 ArrayMap 对象中。</p><p>其中 unparcel() 方法源码如下：</p><pre><code class="Java">/** If mParcelledData is non-null, then mMap will be null and the* data are stored as a Parcel containing a Bundle.  When the data* are unparcelled, mParcelledData willbe set to null.*/Parcel mParcelledData = null;/* package */ void unparcel() {    synchronized (this) {        final Parcel source = mParcelledData;        if (source != null) {            initializeFromParcelLocked(source, /*recycleParcel=*/ true);        } else {            if (DEBUG) {                Log.d(TAG, &quot;unparcel &quot;                        + Integer.toHexString(System.identityHashCode(this))                        + &quot;: no parcelled data&quot;);            }        }    }}private void initializeFromParcelLocked(@NonNull Parcel parcelledData, boolean recycleParcel) {    if (LOG_DEFUSABLE &amp;&amp; sShouldDefuse &amp;&amp; (mFlags &amp; FLAG_DEFUSABLE) == 0) {        Slog.wtf(TAG, &quot;Attempting to unparcel a Bundle while in transit; this may &quot;                + &quot;clobber all data inside!&quot;, new Throwable());    }    if (isEmptyParcel(parcelledData)) {        if (DEBUG) {            Log.d(TAG, &quot;unparcel &quot;                    + Integer.toHexString(System.identityHashCode(this)) + &quot;: empty&quot;);        }        if (mMap == null) {            mMap = new ArrayMap&lt;&gt;(1);        } else {            mMap.erase();        }        mParcelledData = null;        return;    }    final int count = parcelledData.readInt();    if (DEBUG) {        Log.d(TAG, &quot;unparcel &quot; + Integer.toHexString(System.identityHashCode(this))                + &quot;: reading &quot; + count + &quot; maps&quot;);    }    if (count &lt; 0) {        return;    }    ArrayMap&lt;String, Object&gt; map = mMap;    if (map == null) {        map = new ArrayMap&lt;&gt;(count);    } else {        map.erase();        map.ensureCapacity(count);    }    try {        parcelledData.readArrayMapInternal(map, count, mClassLoader);    } catch (BadParcelableException e) {        if (sShouldDefuse) {            Log.w(TAG, &quot;Failed to parse Bundle, but defusing quietly&quot;, e);            map.erase();        } else {            throw e;        }    } finally {        mMap = map;        if (recycleParcel) {            recycleParcel(parcelledData);        }        mParcelledData = null;    }    if (DEBUG) {        Log.d(TAG, &quot;unparcel &quot; + Integer.toHexString(System.identityHashCode(this))                + &quot; final map: &quot; + mMap);    }}</code></pre><p>只有使用 Bundle 构造函数实例化 Bundle 对象时，才会给 mParcelledData 赋值，其他大部分情况下 mParcelledData 都是 null 。</p><pre><code class="Java">BaseBundle(Parcel parcelledData) {    readFromParcelInner(parcelledData);}void readFromParcelInner(Parcel parcel) {    // Keep implementation in sync with readFromParcel() in    // frameworks/native/libs/binder/PersistableBundle.cpp.    int length = parcel.readInt();    readFromParcelInner(parcel, length);}private void readFromParcelInner(Parcel parcel, int length) {    if (length &lt; 0) {        throw new RuntimeException(&quot;Bad length in parcel: &quot; + length);    } else if (length == 0) {        // Empty Bundle or end of data.        mParcelledData = NoImagePreloadHolder.EMPTY_PARCEL;        return;    }    final int magic = parcel.readInt();    if (magic != BUNDLE_MAGIC) {        throw new IllegalStateException(&quot;Bad magic number for Bundle: 0x&quot;                + Integer.toHexString(magic));    }    if (parcel.hasReadWriteHelper()) {        // If the parcel has a read-write helper, then we can&#39;t lazily-unparcel it, so just        // unparcel right away.        synchronized (this) {            initializeFromParcelLocked(parcel, /*recycleParcel=*/ false);        }        return;    }    // Advance within this Parcel    int offset = parcel.dataPosition();    parcel.setDataPosition(MathUtils.addOrThrow(offset, length));    Parcel p = Parcel.obtain();    p.setDataPosition(0);    p.appendFrom(parcel, offset, length);    p.adoptClassCookies(parcel);    if (DEBUG) Log.d(TAG, &quot;Retrieving &quot;  + Integer.toHexString(System.identityHashCode(this))            + &quot;: &quot; + length + &quot; bundle bytes starting at &quot; + offset);    p.setDataPosition(0);    mParcelledData = p;}</code></pre><p>从上述代码片段可以知道 mParcelledData 的取值有3种情况：</p><pre><code class="Java">mParcelledData = nullmParcelledData = NoImagePreloadHolder.EMPTY_PARCELmParcelledData = Parcel.obtain()</code></pre><p>在 unparcel() 方法中分别对这三种情况进行了处理，如果为 null 不进行任何操作返回；如果为 EMPTY_PARCEL 则使用 <code>mMap = new ArrayMap&lt;&gt;(1)</code> 创建长度为 1 的 ArrayMap 对象；如果为 Parcel.obtain() 则实例化 ArrayMap 对象并存储数据。</p><blockquote><p>参考资料<br>1、Android Bundle详解 - CSDN博客<br><a href="https://blog.csdn.net/cswhale/article/details/39053411" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/cswhale/article/details/39053411</a><br>2、Android Bundle总结 - CSDN博客<br><a href="https://blog.csdn.net/ylyg050518/article/details/72638852" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/ylyg050518/article/details/72638852</a><br>3、Android细节问题 —— 有了Intent，为什么还要有Bundle？ - 简书<br><a href="https://www.jianshu.com/p/e9db0797293b" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/e9db0797293b</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Android 四大组件中 Activity、Service、Receiver 都支持在 Intent 中附加传递 Bundle 数据。&lt;/p&gt;&lt;p&gt;Bundle 是以键值对的形式存储数据，支持基本数据类型、数组、实现 Serializable 或 Parcelable
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（二）Android 中的多进程模式</title>
    <link href="https://www.wshunli.com/posts/4662fa2f.html"/>
    <id>https://www.wshunli.com/posts/4662fa2f.html</id>
    <published>2018-06-05T14:09:30.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 中多进程指单个应用存在多个进程的情况。</p><h1 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h1><p>在 Android 中开启多线程只有一种方法，即在 AndroidManifest.xml 中指定 <code>android:process</code> 属性。</p><pre><code class="XML">&lt;activity android:name=&quot;.MainActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity    android:name=&quot;.SecondActivity&quot;    android:process=&quot;:remote&quot; /&gt;&lt;activity    android:name=&quot;.ThirdActivity&quot;    android:process=&quot;com.wshunli.ipc.demo.remote&quot; /&gt;</code></pre><p>MainActivity 没有指定 process 属性，则运行在默认进程中，进程名为包名。</p><p>当启动 SecondActivity 或者 ThirdActivity 时，系统会为他们单独创建进程，<br>进程名分别为 <code>com.wshunli.ipc.demo:remote</code> 和 <code>com.wshunli.ipc.demo.remote</code> .</p><p><img src="https://img.wshunli.com/Android/Android开发艺术探索/详解Android-IPC机制/2.开启多进程模式.png" alt="开启多进程模式"></p><p>对于二者的区别，<br>前者 <code>com.wshunli.ipc.demo:remote</code> 代表应用私有进程，其他应用的组件不可与其在同一进程中。<br>后者 <code>com.wshunli.ipc.demo.remote</code> 代表全局进程，其他应用可通过 ShareUID 方式与其在统一进程中。</p><p>Android 系统会为每个应用分配一个唯一的 UID ，具有相同的 UID 应用才能共享数据。</p><p>两个应用通过 ShareUID 跑在同一进程中也是有要求的，需要两个应用有相同的 ShareUID 并且签名相同。<br>在这种情况下，可以互相访问对方的私有数据，看起来像一个应用的两部分。</p><h1 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h1><p>Android 系统为每个应用（或者说每个进程）分配一个独立虚拟机，在内存分配上也有不同的地址空间。</p><p>我们新建一个 UserManager 类，然后写一个静态变量。</p><pre><code class="Java">public class UserManager {    public static int wshunli = 1;}</code></pre><p>在 MainActivity 中将静态变量赋值为 2 ，然后在 SecondActivity 和 ThirdActivity 中打印出来，发现其值仍然是 1 。</p><p>所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。</p><p>一般来说，使用多进程会造成如下几方面的问题：</p><p>(1) 静态成员和单例模式完全失效（不同的虚拟机）。<br>(2) 线程同步机制完全失效（不是同一块内存空间）。<br>(3) SharePreferences 的可靠性下降（底层通过 XML 执行操作，并发读/写都有可能出问题）。<br>(4) Application 会多次创建（启动新进程其实就是启动一个应用的过程，自然会创建新的 Application ）。</p><pre><code class="Java">public class MApplication extends Application {    private static final String TAG = &quot;MApplication&quot;;    @Override    public void onCreate() {        super.onCreate();        int pid = Process.myPid();        Log.d(TAG, &quot;pid: &quot; + pid);    }}</code></pre><p>同一个应用的多线程相当于不同应用采用 ShareUID 模式。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.2 Android 中的多进程模式<br>2、Android 接口定义语言 (AIDL) | Android Developers<br><a href="https://developer.android.com/guide/components/aidl" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/aidl</a><br>3、Android IPC机制（一）开启多进程 | 刘望舒的博客<br><a href="http://liuwangshu.cn/application/ipc/1-process-start.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/application/ipc/1-process-start.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Android 中多进程指单个应用存在多个进程的情况。&lt;/p&gt;&lt;h1 id=&quot;开启多进程模式&quot;&gt;&lt;a href=&quot;#开启多进程模式&quot; class=&quot;headerlink&quot; title=&quot;开启多进程模式&quot;&gt;&lt;/a&gt;开启多进程模式&lt;/h1&gt;&lt;p&gt;在 Android 中开启多
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>详解 Android IPC 机制（一）Android IPC 简介</title>
    <link href="https://www.wshunli.com/posts/4ff64590.html"/>
    <id>https://www.wshunli.com/posts/4ff64590.html</id>
    <published>2018-06-05T11:58:49.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>IPC（Inter-Process Communication，进程间通信）指两进程间进行数据交换的过程。</p><p>IPC 并不是 Android 独有的，Windows 上可通过剪切板、管道和油槽等来进行进程间通信；Linux 可通过命名管道、共享内存和信号量等实现进程间通信。</p><p>虽然 Android 是基于 Linux 内核的操作系统，但是它有自己的进程间通信方式。</p><p>在 Android 中，通过 Binder 可以实现进程间通信，还有 Socket 、ContentProvider 等等。</p><p>IPC 使用场景，一是应用的自身原因需要使用多进程实现；另一个是通过多进程获得更多内存空间。</p><p>我们需要通过 Intent 和 Binder 传输数据时，需要用到 <strong>Serializable</strong> 或者 <strong>Parcelable</strong> 接口完成对象的序列化。</p><p>1、Serializable 接口</p><p>Serializable 是 Java 提供的一个序列化接口，是一个空接口。</p><pre><code class="Java">public class User implements Serializable {    private static final long serialVersionUID = 8929979969779835719L;    public int userId;    public String userName;    public boolean isMale;    ···}</code></pre><p>只需实现 Serializable 接口，一般应该手动指定 serialVersionUID ，当版本升级时能最大限度恢复数据。</p><pre><code class="Java">// 序列化User user = new User(0, &quot;wshunli&quot;, true);try {    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;cache.text&quot;));    out.writeObject(user);    out.close();} catch (IOException e) {    e.printStackTrace();}// 反序列化try {    ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;cache.text&quot;));    User newUser = (User) in.readObject();    Log.d(TAG, &quot;onCreate: &quot; + newUser.toString());    in.close();} catch (IOException e) {    e.printStackTrace();} catch (ClassNotFoundException e) {    e.printStackTrace();}</code></pre><p>序列化：把对象转换为字节序列的过程称为对象的序列化。<br>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</p><p>2、Parcelable 接口</p><p>Parcelable 接口是 Android 系统提供的序列化接口。</p><pre><code class="Java">public class User implements Parcelable {    public int userId;    public String userName;    public boolean isMale;    public Book book;    public User(int userId, String userName, boolean isMale, Book book) {        this.userId = userId;        this.userName = userName;        this.isMale = isMale;        this.book = book;    }    // 内容描述    @Override    public int describeContents() {        return 0;    }    // 序列化    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeInt(userId);        dest.writeString(userName);        dest.writeInt(isMale ? 1 : 0);        dest.writeParcelable(book, 0);    }    // 反序列化    public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;(){        @Override        public User createFromParcel(Parcel source) {            return new User(source);        }        @Override        public User[] newArray(int size) {            return new User[size];        }    };    private User(Parcel source) {        userId = source.readInt();        userName = source.readString();        isMale = source.readInt() == 1;        book = source.readParcelable(Thread.currentThread().getContextClassLoader());    }}</code></pre><p>使用 Parcelable 序列化还是有点麻烦的，不过思路清晰。</p><p>Serializable 和 Parcelable 比较：</p><p>Serializable 是 Java 的序列化接口，需要大量 I/O 操作，开销比较大；<br>Parcelable 是 Android 中的序列化接口，效率更高，因此首选。</p><p>但是在将对象序列化到存储设备或者将对象序列化后的通过网络传输，建议使用 Serializable 接口。</p><blockquote><p>参考资料<br>1、《Android开发艺术探索》 – 2.1 Android IPC 简介、2.3 IPC 基础概念介绍<br>2、Android IPC机制详解（一） - 简书<br><a href="https://www.jianshu.com/p/b9b3051a4ff6" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b9b3051a4ff6</a><br>3、Android 中的IPC机制 - CSDN博客<br><a href="https://blog.csdn.net/a565102223/article/details/70186070" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a565102223/article/details/70186070</a><br>4、Java 之 Serializable 序列化和反序列化的概念,作用的通俗易懂的解释 - CSDN博客<br><a href="https://blog.csdn.net/qq_27093465/article/details/78544505" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_27093465/article/details/78544505</a><br>5、详细介绍Android中Parcelable的原理和使用方法 - CSDN博客<br><a href="https://blog.csdn.net/justin_1107/article/details/72903006" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/justin_1107/article/details/72903006</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IPC（Inter-Process Communication，进程间通信）指两进程间进行数据交换的过程。&lt;/p&gt;&lt;p&gt;IPC 并不是 Android 独有的，Windows 上可通过剪切板、管道和油槽等来进行进程间通信；Linux 可通过命名管道、共享内存和信号量等实现进
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IPC机制" scheme="https://www.wshunli.com/tags/IPC%E6%9C%BA%E5%88%B6/"/>
    
      <category term="《Android开发艺术探索》" scheme="https://www.wshunli.com/tags/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（八）</title>
    <link href="https://www.wshunli.com/posts/6374acae.html"/>
    <id>https://www.wshunli.com/posts/6374acae.html</id>
    <published>2018-06-05T02:05:40.000Z</published>
    <updated>2018-07-27T01:19:14.155Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 网络编程</p><p><a href="https://www.wshunli.com/posts/df51fd76.html">《第一行代码》读书笔记（一）– 平台架构 </a>(第1章)<br><a href="https://www.wshunli.com/posts/b6bcc7db.html">《第一行代码》读书笔记（二）– 应用组件之 Activity </a>(第2、4章)<br><a href="https://www.wshunli.com/posts/fba26489.html">《第一行代码》读书笔记（三）– 应用组件之 Service </a>(第10章)<br><a href="https://www.wshunli.com/posts/4c8f7dec.html">《第一行代码》读书笔记（四）– 应用组件之 BroadcastReceiver </a>(第5章)<br><a href="https://www.wshunli.com/posts/2311b8ab.html">《第一行代码》读书笔记（五）– 应用组件之 ContentProvider </a>(第7章)<br><a href="https://www.wshunli.com/posts/461ff372.html">《第一行代码》读书笔记（六）– 数据存储方案 </a>(第6章)<br><a href="https://www.wshunli.com/posts/941f84ed.html">《第一行代码》读书笔记（七）– 多媒体资源 </a>(第8章)<br><a href="https://www.wshunli.com/posts/6374acae.html">《第一行代码》读书笔记（八）– 网络编程 </a>(第9章)</p><h1 id="第8章-使用网络技术"><a href="#第8章-使用网络技术" class="headerlink" title="第8章 使用网络技术"></a>第8章 使用网络技术</h1><h2 id="WebView-的用法"><a href="#WebView-的用法" class="headerlink" title="WebView 的用法"></a>WebView 的用法</h2><p>WebView 也是 Android 的一个控件，用来显示一些网页，内容也比较多。</p><p>针对 WebView 的封装，可以使用 AgentWeb :</p><p>Justson/AgentWeb: AgentWeb is a powerful library based on Android WebView.<br><a href="https://github.com/Justson/AgentWeb" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Justson/AgentWeb</a></p><p>优化首屏加载速度，可以使用 VasSonic ：</p><p>Tencent/VasSonic: VasSonic is a lightweight and high-performance Hybrid framework developed by tencent VAS team, which is intended to speed up the first screen of websites working on Android and iOS platform.<br><a href="https://github.com/Tencent/VasSonic" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Tencent/VasSonic</a></p><p>对于 WebView 有特殊要求的，可以使用一些浏览器内核：</p><p>Crosswalk - Embedding the Crosswalk Project<br><a href="https://crosswalk-project.org/documentation/android/embedding_crosswalk.html" rel="external nofollow noopener noreferrer" target="_blank">https://crosswalk-project.org/documentation/android/embedding_crosswalk.html</a></p><p>腾讯浏览服务：<br><a href="http://x5.tencent.com/" rel="external nofollow noopener noreferrer" target="_blank">http://x5.tencent.com/</a></p><p>本文只介绍 Android 系统 <a href="https://developer.android.com/reference/android/webkit/WebView" rel="external nofollow noopener noreferrer" target="_blank">WebView</a> 使用。</p><p>在 Android 4.4 以前使用基于 Android WebKit 的 WebView 实现；<br>在 Android 4.4 及以后使用基于 Chromium blink 的 WebView 实现；<br>从 Android 5.0 开始，Google 把 Chromium blink 内核作为 apk 单独从系统抽离出来。</p><pre><code class="Java">WebView webView = findViewById(R.id.webview);webView.getSettings().setJavaScriptEnabled(true);webView.setWebViewClient(new WebViewClient());webView.loadUrl(&quot;https://html5test.com/&quot;);</code></pre><p>这只是简单地显示网页，WebView 本身还有很多技巧。</p><h2 id="使用-HTTP-协议访问网络"><a href="#使用-HTTP-协议访问网络" class="headerlink" title="使用 HTTP 协议访问网络"></a>使用 HTTP 协议访问网络</h2><p>1、使用 HttpURLConnection</p><p>在 Android 上发送 HTTP 请求一般使用 HttpURLConnection 或者 HttpClient 。</p><p>不过 HttpClient 在 Android 6.0 已经废弃。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        HttpURLConnection connection = null;        BufferedReader reader = null;        try {            URL url = new URL(&quot;https://www.wshunli.com/&quot;);            connection = (HttpURLConnection) url.openConnection();            connection.setRequestMethod(&quot;GET&quot;);            connection.setConnectTimeout(8000);            connection.setReadTimeout(8000);            InputStream in = new BufferedInputStream(connection.getInputStream());            reader = new BufferedReader(new InputStreamReader(in));            String line;            while ((line = reader.readLine()) != null) {                Log.d(TAG, line);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if (reader != null) {                try {                    reader.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (connection != null) {                connection.disconnect();            }        }    }}).start();</code></pre><p>上面是发送 GET 请求，发送 POST 请求：</p><pre><code class="Java">connection.setRequestMethod(&quot;POST&quot;);DataOutputStream out = new DataOutputStream(connection.getOutputStream());out.writeBytes(&quot;username=wshunli&amp;password=123456&quot;);</code></pre><p>2、使用 OkHttp</p><p>在实际项目里面使用 HttpURLConnection 还是不太行的，往往使用一些开源的网络框架，比如 OkHttp 等等。</p><p><a href="http://square.github.io/okhttp/" rel="external nofollow noopener noreferrer" target="_blank">OkHttp</a>：An HTTP &amp; HTTP/2 client for Android and Java applications</p><p><a href="https://github.com/square/okhttp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/square/okhttp</a></p><p>首先添加 OkHttp 依赖：</p><pre><code class="groovy">implementation &#39;com.squareup.okhttp3:okhttp:3.10.0&#39;</code></pre><p>使用 OkHttp 发送 GET 请求：</p><pre><code class="Java">OkHttpClient client = new OkHttpClient();Request request = new Request.Builder()        .url(&quot;https://www.shunli.com&quot;)        .build();try {    Response response = client.newCall(request).execute();    String responseData = response.body().string();    Log.d(TAG, &quot;onCreate: &quot; + responseData);} catch (IOException e) {    e.printStackTrace();}</code></pre><p>整个过程清楚简洁。</p><pre><code class="Java">···RequestBody requestBody = new FormBody.Builder()        .add(&quot;username&quot;, &quot;wshunli&quot;)        .add(&quot;password&quot;, &quot;123456&quot;)        .build();Request request = new Request.Builder()        .url(&quot;https://www.shunli.com&quot;)        .post(requestBody)        .build();···</code></pre><p>发送 POST 请求有点不太一样，要使用 RequestBody 传递数据。</p><p>这里只是简单介绍了 OkHttp 的使用，还有很多东西，后面再介绍。</p><h2 id="解析-XML-格式数据"><a href="#解析-XML-格式数据" class="headerlink" title="解析 XML 格式数据"></a>解析 XML 格式数据</h2><p>在网络传递的数据主要有两种： XML 和 JSON 。</p><p>这里我们使用本站的 RSS 订阅源数据。</p><p><a href="https://www.wshunli.com/atom.xml">https://www.wshunli.com/atom.xml</a></p><p>1、Pull 解析方式</p><p>本方法是将请求的 XML 字符串传入 XmlPullParser 对象实例，然后根据节点名字遍历解析 XML 内容。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        OkHttpClient client = new OkHttpClient();        Request request = new Request.Builder()                .url(&quot;https://www.wshunli.com/atom.xml&quot;)                .build();        try {            Response response = client.newCall(request).execute();            String responseData = response.body().string();            parseXMLWithPull(responseData);        } catch (IOException e) {            e.printStackTrace();        }    }}).start();private void parseXMLWithPull(String xmlData) {    try {        XmlPullParserFactory factory = XmlPullParserFactory.newInstance();        XmlPullParser xmlPullParser = factory.newPullParser();        xmlPullParser.setInput(new StringReader(xmlData));        int eventType = xmlPullParser.getEventType();        String title = &quot;&quot;;        String id = &quot;&quot;;        String published = &quot;&quot;;        String updated = &quot;&quot;;        while (eventType != XmlPullParser.END_DOCUMENT) {            String nodeName = xmlPullParser.getName();            switch (eventType) {                case XmlPullParser.START_TAG:                    if (nodeName.equals(&quot;title&quot;)) {                        title = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;id&quot;)) {                        id = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;published&quot;)) {                        published = xmlPullParser.nextText();                    } else if (nodeName.equals(&quot;updated&quot;)) {                        updated = xmlPullParser.nextText();                    }                    break;                case XmlPullParser.END_TAG:                    if (nodeName.equals(&quot;entry&quot;)) {                        Log.d(TAG, &quot;文章标题: &quot; + title);                        Log.d(TAG, &quot;文章链接: &quot; + id);                        Log.d(TAG, &quot;发布时间: &quot; + published);                        Log.d(TAG, &quot;更新时间: &quot; + updated);                    }                    break;                default:                    break;            }            eventType = xmlPullParser.next();        }    } catch (XmlPullParserException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>解析结果示例：</p><pre><code class="TXT">文章标题: 《第一行代码》读书笔记（七）文章链接: https://www.wshunli.com/posts/941f84ed.html发布时间: 2018-06-04T08:41:39.000Z更新时间: 2018-06-04T15:14:46.188Z文章标题: 《第一行代码》读书笔记（六）文章链接: https://www.wshunli.com/posts/461ff372.html发布时间: 2018-06-03T13:54:38.000Z更新时间: 2018-06-04T15:14:46.188Z</code></pre><p>2、SAX 解析方式</p><p>SAX 解析方式也是一种比较常用的方法，虽然比 Pull 方式复杂，但是语义更容易理解。</p><p>通常会新建一个类继承 DefaultHandler ，并重写其方法。</p><pre><code class="Java">public class PostsHandler extends DefaultHandler {    @Override    public void startDocument() throws SAXException {        super.startDocument();    }    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {        super.startElement(uri, localName, qName, attributes);    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {        super.characters(ch, start, length);    }    @Override    public void endElement(String uri, String localName, String qName) throws SAXException {        super.endElement(uri, localName, qName);    }    @Override    public void endDocument() throws SAXException {        super.endDocument();    }}</code></pre><p>其中 startDocument 和 endDocument 分别在开始、结束 XMl 接解析时调用。<br>类似 startElement 和 endElement 分别在开始、结束解析某个节点时调用。<br>而 characters 方法会在获取节点内容时调用，可能会调用多次，注意换行符也会解析出来。</p><pre><code class="Java">public class PostsHandler extends DefaultHandler {    private static final String TAG = &quot;PostsHandler&quot;;    private String nodeName;    private StringBuilder title;    private StringBuilder id;    private StringBuilder published;    private StringBuilder updated;    @Override    public void startDocument() throws SAXException {        title = new StringBuilder();        id = new StringBuilder();        published = new StringBuilder();        updated = new StringBuilder();    }    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {        // 记录节点名称        nodeName = localName;    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {        // 根据节点名称将内容添加到 StringBuilder 中        if (nodeName.equals(&quot;title&quot;)) {            title.append(ch, start, length);        } else if (nodeName.equals(&quot;id&quot;)) {            id.append(ch, start, length);        } else if (nodeName.equals(&quot;published&quot;)) {            published.append(ch, start, length);        } else if (nodeName.equals(&quot;updated&quot;)) {            updated.append(ch, start, length);        }    }    @Override    public void endElement(String uri, String localName, String qName) throws SAXException {        if (localName.equals(&quot;entry&quot;)) {            Log.d(TAG, &quot;文章标题: &quot; + title.toString().trim());            Log.d(TAG, &quot;文章链接: &quot; + id.toString().trim());            Log.d(TAG, &quot;发布时间: &quot; + published.toString().trim());            Log.d(TAG, &quot;更新时间: &quot; + updated.toString().trim());            title.setLength(0);            id.setLength(0);            published.setLength(0);            updated.setLength(0);        }    }    @Override    public void endDocument() throws SAXException {        super.endDocument();    }}</code></pre><p>和前面 Pull 解析功能是一样的。</p><pre><code class="Java">private void parseXMLWithSAX(String xmlData) {    SAXParserFactory factory = SAXParserFactory.newInstance();    try {        XMLReader xmlReader = factory.newSAXParser().getXMLReader();        PostsHandler handler = new PostsHandler();        xmlReader.setContentHandler(handler);        xmlReader.parse(new InputSource(new StringReader(xmlData)));    } catch (SAXException e) {        e.printStackTrace();    } catch (ParserConfigurationException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><p>调用是使用 XMLReader 实例的 setContentHandler 方法。</p><h2 id="解析-JSON-格式数据"><a href="#解析-JSON-格式数据" class="headerlink" title="解析 JSON 格式数据"></a>解析 JSON 格式数据</h2><p>感觉平常 JSON 数据用得更多一些，JSON 和 XML 相比主要有优势在于体积更小。</p><p>以前本站是支持生成 JSON 文件的，因为上传太慢了就取消了。</p><p>这里使用随便使用一个 JSON 文件做测试吧。</p><p><a href="https://raw.githubusercontent.com/wshunli/wshunli.github.io/c28a64a898599442a10c9eee74fed8d54dc89e7f/api/posts.json" rel="external nofollow noopener noreferrer" target="_blank">https://raw.githubusercontent.com/wshunli/wshunli.github.io/c28a64a898599442a10c9eee74fed8d54dc89e7f/api/posts.json</a></p><p>1、使用 JSONObject</p><p>解析 JSON 数据可以使用 JSONObject 或者 GSON 开源库，还有一些 Jackson 、FastJSON 都不错。</p><pre><code class="Java">new Thread(new Runnable() {    @Override    public void run() {        OkHttpClient client = new OkHttpClient();        Request request = new Request.Builder()                .url(&quot;https://raw.githubusercontent.com/wshunli/wshunli.github.io/c28a64a898599442a10c9eee74fed8d54dc89e7f/api/posts.json&quot;)                .build();        try {            Response response = client.newCall(request).execute();            String responseData = response.body().string();            parseJSONWithJSONObject(responseData);        } catch (IOException e) {            e.printStackTrace();        }    }}).start();private void parseJSONWithJSONObject(String jsonData) {    try {        JSONObject jsonObject = new JSONObject(jsonData);        if (jsonObject.has(&quot;data&quot;)){            String data = jsonObject.getString(&quot;data&quot;);            JSONArray jsonArray = new JSONArray(data);            for (int i = 0; i &lt; jsonArray.length(); i++) {                JSONObject object = jsonArray.getJSONObject(i);                String title = object.getString(&quot;title&quot;);                String path = object.getString(&quot;path&quot;);                String date = object.getString(&quot;date&quot;);                String updated = object.getString(&quot;updated&quot;);                Log.d(TAG, &quot;文章标题: &quot; + title);                Log.d(TAG, &quot;文章链接: &quot; + path);                Log.d(TAG, &quot;发布时间: &quot; + date);                Log.d(TAG, &quot;更新时间: &quot; + updated);            }        }    } catch (JSONException e) {        e.printStackTrace();    }}</code></pre><p>也就是使用构造函数传入 JSON 字符串获得 JSONObject 对象实例。</p><p>如果遇到数组的使用 JSONArray 实例逐条遍历即可。</p><p>2、使用 GSON 库</p><p>google/gson: A Java serialization/deserialization library to convert Java Objects into JSON and back<br><a href="https://github.com/google/gson" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/google/gson</a></p><p>使用 GSON 解析 JSON 数据特别简单。</p><pre><code class="groovy">implementation &#39;com.google.code.gson:gson:2.8.4&#39;</code></pre><p>首先根据 JSON 数据定义 Posts 类。</p><pre><code class="Java">public class Posts {    int total;    int pageSize;    int pageCount;    List&lt;Article&gt; data;    public static class Article{        String title;        String path;        String date;        String updated;        public String getTitle() {            return title;        }        public void setTitle(String title) {            this.title = title;        }        public String getPath() {            return path;        }        public void setPath(String path) {            this.path = path;        }        public String getDate() {            return date;        }        public void setDate(String date) {            this.date = date;        }        public String getUpdated() {            return updated;        }        public void setUpdated(String updated) {            this.updated = updated;        }    }    public int getTotal() {        return total;    }    public void setTotal(int total) {        this.total = total;    }    public int getPageSize() {        return pageSize;    }    public void setPageSize(int pageSize) {        this.pageSize = pageSize;    }    public int getPageCount() {        return pageCount;    }    public void setPageCount(int pageCount) {        this.pageCount = pageCount;    }    public List&lt;Article&gt; getData() {        return data;    }    public void setData(List&lt;Article&gt; data) {        this.data = data;    }}</code></pre><p>然后实例化 GSON 对象解析 JSON 字符串。</p><pre><code class="Java">private void parseJSONWithGSON(String jsonDate) {    Gson gson = new Gson();    Posts posts = gson.fromJson(jsonDate, Posts.class);    List&lt;Posts.Article&gt; data = posts.getData();    for (Posts.Article article : data) {        Log.d(TAG, &quot;文章标题: &quot; + article.getTitle());        Log.d(TAG, &quot;文章链接: &quot; + article.getPath());        Log.d(TAG, &quot;发布时间: &quot; + article.getDate());        Log.d(TAG, &quot;更新时间: &quot; + article.getUpdated());    }}</code></pre><p>GSON 也就介绍到这里。</p><blockquote><p>参考资料<br>1、Building Web Apps in WebView | Android Developers<br><a href="https://developer.android.com/guide/webapps/webview" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/webapps/webview</a><br>2、Android：最全面的 Webview 详解 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/52693322" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/52693322</a><br>3、Getting Started: WebView-based Applications for Web Developers - Google Chrome<br><a href="https://developer.chrome.com/multidevice/webview/gettingstarted" rel="external nofollow noopener noreferrer" target="_blank">https://developer.chrome.com/multidevice/webview/gettingstarted</a><br>4、X5 浏览器内核调研报告 - 简书<br><a href="https://www.jianshu.com/p/2a14d303308d" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/2a14d303308d</a><br>5、前端 WebView 指南之 Android 交互篇 - 怡红院落<br><a href="https://imnerd.org/android-webview-and-js.html" rel="external nofollow noopener noreferrer" target="_blank">https://imnerd.org/android-webview-and-js.html</a><br>6、在Android上使用JS引擎是一种什么样的体验？ | 网易杭州前端技术部<br><a href="https://neyoufan.github.io/2016/12/23/android/Android%20Js引擎/在Android上使用JS引擎是一种什么样的体验？/" rel="external nofollow noopener noreferrer" target="_blank">https://neyoufan.github.io/2016/12/23/android/Android%20Js引擎/在Android上使用JS引擎是一种什么样的体验？/</a></p></blockquote><hr><p>到这里可能算又浏览了一遍 《第一行代码》 。</p><p>这次有些内容没有看，比如第 3、12 章的 UI 部分。</p><p>还有 第 11 章 基于位置的服务也没有看，因为前面专业 GIS SDK 接触很多了。</p><p>最后是第 13、14 章的进阶、实战部分，后面再了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《第一行代码》读书笔记 – 网络编程&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.wshunli.com/posts/df51fd76.html&quot;&gt;《第一行代码》读书笔记（一）– 平台架构 &lt;/a&gt;(第1章)&lt;br&gt;&lt;a href=&quot;https://www.wsh
      
    
    </summary>
    
      <category term="移动端技术" scheme="https://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
</feed>
