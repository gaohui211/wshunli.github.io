<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS 博客</title>
  
  <subtitle>wshunli`s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2018-12-18T16:32:52.013Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 frp 的内网穿透实践</title>
    <link href="https://www.wshunli.com/posts/be4c3c8c.html"/>
    <id>https://www.wshunli.com/posts/be4c3c8c.html</id>
    <published>2018-11-09T12:41:15.000Z</published>
    <updated>2018-12-18T16:32:52.013Z</updated>
    
    <content type="html"><![CDATA[<p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>1、利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。<br>2、对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。<br>3、利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务。</p><p>frp 搭建需要一台具有公网 IP 的服务器，并且访问效果和服务器的带宽和内网的上行带宽有关系。</p><h1 id="内网穿透实现方法"><a href="#内网穿透实现方法" class="headerlink" title="内网穿透实现方法"></a>内网穿透实现方法</h1><p>内网穿透有很多商业的软件比如花生壳、NATAPP 等，这里不多介绍。</p><p>还有一些半开源的工具比如 ZeroTier ，配置简单，但是需要额外安装软件。</p><p>再者就是 frp 、ngrok 等开源工具，利用具有公网 IP 的服务器搭建。</p><h1 id="frp-内网穿透实践"><a href="#frp-内网穿透实践" class="headerlink" title="frp 内网穿透实践"></a>frp 内网穿透实践</h1><p>frp：<a href="https://github.com/fatedier/frp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp</a></p><p>中文文档：<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>做内网穿透前需要提前准备一些东西的</p><p>1、一台公网服务器，建议国外的 VPS ，带宽大一些；<br>2、一台内网服务器，我这里是 QNAP 的 NAS ，Linux 系统；<br>3、域名，用于解析，访问内网；<br>4、内网服务，访问的主要内容。</p><h2 id="frp-的安装配置"><a href="#frp-的安装配置" class="headerlink" title="frp 的安装配置"></a>frp 的安装配置</h2><p>这里 具有公网 IP 的机器称为服务端，处于内网环境的机器称为客户端。</p><p>1、下载 frp 文件</p><p>在 <a href="https://github.com/fatedier/frp/releases" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp/releases</a> 下载最新版即可。</p><p>下载并解压文件</p><pre><code class="lang-bash"> cd usr/local/wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gztar -zxvf  frp_0.21.0_linux_amd64.tar.gzcd frp_0.21.0_linux_amd64</code></pre><p>这里主要有 4 个文件，分别是 frpc、frpc.ini 和frps、frps.ini 。</p><p>将 frps 及 <strong>frps.ini</strong> 放到具有公网 IP 的机器上。<br>将 frpc 及 <strong>frpc.ini</strong> 放到处于内网环境的机器上。</p><p>2、配置具有公网 IP 的机器，也就是 frps.ini 文件</p><p>使用 <code>vim frps.ini</code> 命令修改配置文件</p><pre><code class="lang-TXT">[common]bind_port = 7000            # 内网穿透服务端口bind_udp_port = 7001        # 点对点内网穿透vhost_http_port = 10080     # 外部访问的 http 端口vhost_https_port = 10443    # 外部访问的 https 端口dashboard_port = 7500       # 管理面板端口dashboard_user = admin      # 管理面板用户名dashboard_pwd = admin       # 管理面板密码token = asdfgh              # 身份验证</code></pre><p>更多内容参考：<a href="https://github.com/fatedier/frp/blob/master/conf/frps_full.ini" rel="external nofollow noopener noreferrer" target="_blank">frps 完整配置文件</a></p><p>启动 frps 服务</p><pre><code class="lang-bash">./frps -c ./frps.ini</code></pre><p>后台启动方法</p><pre><code class="lang-bash">nohup ./frps -c ./frps.ini &amp;</code></pre><p>3、配置处于内网环境的机器，也就是 frpc.ini 文件</p><p>使用 <code>vim frpc.ini</code> 命令修改配置文件</p><pre><code class="lang-TXT">[common]server_addr = X.X.X.X           # 内网穿透服务地址server_port = 7000              # 内网穿透服务端口token = asdfgh                  # 身份验证，与服务端一致[qnap-web]type = httplocal_ip = 127.0.0.1            # 内网服务地址local_port = 8080               # 内网服务端口use_encryption = true           # 加密传输use_compression = true          # 压缩传输custom_domains = x.wshunli.com  # 访问域名</code></pre><p>这里 <code>custom_domains</code> 是外网服务器解析的域名，否则无法访问；可根据 <code>vhost_http_port</code> 端口反向代理解析。</p><p>更多内容参考：<a href="https://github.com/fatedier/frp/blob/master/conf/frpc_full.ini" rel="external nofollow noopener noreferrer" target="_blank">frpc 完整配置文件</a></p><p>启动 frpc 服务方法与 frps 类似。</p><p>前台启动：<code>./frpc -c ./frpc.ini</code></p><p>后台启动：<code>nohup ./frpc -c ./frpc.ini &amp;</code></p><p>4、frp 控制面板的使用</p><p>这里需要根据公网 IP 服务器访问，即 <code>http://{server_addr}:{dashboard_port}</code></p><p>更多内容参考 <a href="https://github.com/fatedier/frp/blob/master/README_zh.md" rel="external nofollow noopener noreferrer" target="_blank">frp 中文文档</a></p><blockquote><p>参考资料<br>1、一分钟实现内网穿透（ngrok服务器搭建） - 学习笔记 - CSDN博客<br><a href="https://blog.csdn.net/zhangguo5/article/details/77848658" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhangguo5/article/details/77848658</a><br>2、十分钟教你配置frp实现内网穿透 - 诗雨远方的博客 - CSDN博客<br><a href="https://blog.csdn.net/u013144287/article/details/78589643" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u013144287/article/details/78589643</a><br>3、突破电信局域网：frp内网穿透教程（客户端：lede/win） - 电脑讨论 - Chiphell - 分享与交流用户体验<br><a href="https://www.chiphell.com/thread-1853360-1-1.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.chiphell.com/thread-1853360-1-1.html</a><br>4、使用frp进行内网穿透入门 - ＱＱ小冰 - CSDN博客<br><a href="https://blog.csdn.net/weixin_36241363/article/details/78457359" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/weixin_36241363/article/details/78457359</a><br>5、威联通折腾篇二：使用 frp 内网穿透 | Verne in GitHub<br><a href="https://blog.einverne.info/post/2018/06/qnap-frp-usage.html" rel="external nofollow noopener noreferrer" target="_blank">https://blog.einverne.info/post/2018/06/qnap-frp-usage.html</a><br>6、nohup和&amp;后台运行，进程查看及终止 - 弥尘 - 博客园<br><a href="https://www.cnblogs.com/baby123/p/6477429.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/baby123/p/6477429.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。&lt;/p&gt;&lt;p&gt;1、利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。&lt;br&gt;2、对于 http, https 服务支持基于域名的虚拟主机，
      
    
    </summary>
    
      <category term="前端技术" scheme="https://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="frp" scheme="https://www.wshunli.com/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>基于 WinSW 将 Java 程序部署为 Windows 自启动服务</title>
    <link href="https://www.wshunli.com/posts/762f39b0.html"/>
    <id>https://www.wshunli.com/posts/762f39b0.html</id>
    <published>2018-10-20T03:22:36.000Z</published>
    <updated>2018-12-18T16:32:52.013Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍基于 WinSW 将 Java 程序部署 为 Windows 自启动服务。</p><p>我们使用 Java -jar file.jar 将 Java 程序运行，起来，但是窗口关闭，服务就停止了。</p><p>WinSW 可以将 Windows 上的任何一个程序注册为服务，如果不需要，也可以方便的卸载服务。</p><p><a href="https://github.com/kohsuke/winsw" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kohsuke/winsw</a></p><p>1、下载 winsw 文件</p><p>下载 winsw-2.1.2-bin.exe 文件</p><p><a href="http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/" rel="external nofollow noopener noreferrer" target="_blank">http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/</a></p><p>最好修改下文件名称，本文修改为 <code>winsw-ai-server</code></p><p>2、添加配置文件</p><p>根据 winsw 文件名，新建相同名称的 xml 文件</p><pre><code class="lang-XML">&lt;service&gt;    &lt;id&gt;phcj-ai-server&lt;/id&gt;    &lt;name&gt;phcj-ai-server&lt;/name&gt;    &lt;description&gt;系统 AI 后台服务&lt;/description&gt;    &lt;executable&gt;java&lt;/executable&gt;        &lt;onfailure action=&quot;restart&quot; delay=&quot;10 sec&quot;/&gt;    &lt;arguments&gt; -jar &quot;D:\PHCJ\phcj-ai-server\target\phcj-ai-server-0.0.1-SNAPSHOT.jar&quot;&lt;/arguments&gt;    &lt;log mode=&quot;roll-by-size&quot;&gt;        &lt;sizeThreshold&gt;20480&lt;/sizeThreshold&gt;        &lt;keepFiles&gt;8&lt;/keepFiles&gt;    &lt;/log&gt;&lt;/service&gt;</code></pre><p>3、安装并启动服务</p><p>注意以管理员身份运行</p><p>安装服务 <code>./winsw-ai-server.exe install</code></p><p>启动服务 <code>net start phcj-ai-server</code></p><p>停止服务 <code>net stop phcj-ai-server</code></p><p>卸载服务 <code>./winsw-ai-server.exe uninstall</code></p><blockquote><p>参考资料：<br>1、winsw将可运行的jar文件做成后台服务 - qq_31451471的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_31451471/article/details/79298665" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_31451471/article/details/79298665</a><br>2、用winsw让任何Windows程序都能运行为服务 - 简书<br><a href="https://www.jianshu.com/p/fc9e4ea61e13" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/fc9e4ea61e13</a><br>3、使用WinSW将SpringBoot程序安装成Windows自启动服务 - blvyoucan的专栏 - CSDN博客<br><a href="https://blog.csdn.net/blvyoucan/article/details/81131234" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/blvyoucan/article/details/81131234</a><br>4、Spring Boot项目生成jar包，并在windows服务器中注册成服务，开机启动 - LiveYourLife - 博客园<br><a href="https://www.cnblogs.com/LiveYourLife/p/8681137.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/LiveYourLife/p/8681137.html</a><br>5、springboot解决第三方依赖jar包的问题 - 浅夏丶未央 - 博客园<br><a href="https://www.cnblogs.com/xiaosiyuan/p/6894766.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/xiaosiyuan/p/6894766.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍基于 WinSW 将 Java 程序部署 为 Windows 自启动服务。&lt;/p&gt;&lt;p&gt;我们使用 Java -jar file.jar 将 Java 程序运行，起来，但是窗口关闭，服务就停止了。&lt;/p&gt;&lt;p&gt;WinSW 可以将 Windows 上的任何一个程序注册为
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="WinSW" scheme="https://www.wshunli.com/tags/WinSW/"/>
    
  </entry>
  
  <entry>
    <title>Java 调用 Matlab 程序（Java 和 Matlab 混合编程）</title>
    <link href="https://www.wshunli.com/posts/45399dc2.html"/>
    <id>https://www.wshunli.com/posts/45399dc2.html</id>
    <published>2018-10-20T01:24:10.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Java 调用 Matlab 程序（Java 和 Matlab 混合编程）流程方法。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>1、 Java 环境，建议使用如下版本 。</p><p>Java™ SE Development Kit 8, Update 151 (JDK 8u151)</p><p>2、Matlab 工具（开发环境）</p><p>编写 Mattlab 代码，本文以最新版 Matlab 2018b 为例。</p><p>3、MATLAB Runtime（部署环境）</p><p>已经安装过 Matlab 就不需要再安装了，用来执行编译后的 Matlab 程序。</p><p>从以下网址下载即可，本文以 R2018b (9.5) 为例。</p><p><a href="https://ww2.mathworks.cn/products/compiler/matlab-runtime.html" rel="external nofollow noopener noreferrer" target="_blank">https://ww2.mathworks.cn/products/compiler/matlab-runtime.html</a></p><p>MATLAB Runtime 相比 Matlab 更加轻量级，免费。</p><p><strong>环境确认：</strong></p><p>本文建议 Java 版本和 Matlab 自带 JVM 保持一致。</p><p>在 Matlab 命令中输入 <code>version -java</code> 查看机器 Matlab 版本。</p><p><img src="https://img.wshunli.com/Java/Matlab/matlab-version.png" alt="java-version"></p><p>在 CMD 中执行 <code>java -version</code> 查看机器 Java 版本，</p><p><img src="https://img.wshunli.com/Java/Matlab/java-version.png" alt="java-version"></p><h1 id="Matlab-程序打包"><a href="#Matlab-程序打包" class="headerlink" title="Matlab 程序打包"></a>Matlab 程序打包</h1><p>Matlab 支持 C++ 、Java 、.Net 等语言的打包。</p><p>我们将 .m 文件打包为 Java 支持的库，如下图：</p><p><img src="https://img.wshunli.com/Java/Matlab/matlab-package.png" alt="matlab-package"></p><p>感觉和 JVM 虚拟机很类似，Matlab 提供基础环境，我们编写 Matlab 代码即可。</p><h1 id="Java-调用-Matlab-方法"><a href="#Java-调用-Matlab-方法" class="headerlink" title="Java 调用 Matlab 方法"></a>Java 调用 Matlab 方法</h1><p>在 Java 中调用 Matlab 的方法时，有三种方式。</p><p>1、functionName(int arg0, Object… agr1): Object[]</p><p>其中 arg0 表示返回数据的个数，agr1 为数组；返回值也是数组。</p><p>2、functionName(List arg0, List agr1): void</p><p>其中 arg0 、agr1 为列表；返回值为空。</p><p>3、functionName(Object[] arg0, Object[] agr1): void</p><p>其中 arg0 、agr1 为数组；返回值为空。</p><h2 id="方式一，输入返回个数"><a href="#方式一，输入返回个数" class="headerlink" title="方式一，输入返回个数"></a>方式一，输入返回个数</h2><pre><code class="lang-Java">// 定义输出结果  Object[] results = null;  Magic magic = new Magic(); // 实例化 // &#39;2&#39; 表示 2 个输出结果，类似 results=new Object[2];  // &#39;5&#39; 表示输入的参数 results = magic.makesqr(2, 5);  // 输出第一个返回内容  System.out.println(results[0]);  // 输出第二个返回内容  System.out.println(results[1]);</code></pre><h2 id="方式二，列表参数"><a href="#方式二，列表参数" class="headerlink" title="方式二，列表参数"></a>方式二，列表参数</h2><pre><code class="lang-Java">// 定义结果List  List&lt;Object&gt; results = new ArrayList&lt;Object&gt;(2);  // 定义参数List  List&lt;Object&gt; inputs = new ArrayList&lt;Object&gt;(1);  Magic magic = null;  magic = new Magic();  // 注意:结果List要预先加入内容，Null即可  results.add(null);  results.add(null);  // 输入的参数  inputs.add(5);  // 调用方法  magic.makesqr(results, inputs);  // 显示结果  System.out.println(results.get(0));  System.out.println(results.get(1));</code></pre><h2 id="方式三，数组参数"><a href="#方式三，数组参数" class="headerlink" title="方式三，数组参数"></a>方式三，数组参数</h2><pre><code class="lang-Java">// 注意：定义输出结果的时候，要定义数组大小  Object[] results = new Object[2];  Magic magic = null;  magic = new Magic();  // 这种方式，第二参数必须为数组，而不能为可变数组  Object[] inputs = new Object[]{5};  magic.makesqr(results, inputs);  // 输出第一个返回内容  System.out.println(results[0]);  // 输出第二个返回内容  System.out.println(results[1]);</code></pre><h1 id="Java-与-Matlab-数据转换"><a href="#Java-与-Matlab-数据转换" class="headerlink" title="Java 与 Matlab 数据转换"></a>Java 与 Matlab 数据转换</h1><p>数据转换内容比较多，这里主要介绍<strong>数组</strong>的转换。</p><p>1、将 Java 数据转化为 Matlab 数据</p><p>这里以输入 <a href="https://ww2.mathworks.cn/help/javabuilder/MWArrayAPI/com/mathworks/toolbox/javabuilder/MWNumericArray.html" rel="external nofollow noopener noreferrer" target="_blank">MWNumericArray</a> 数据为例</p><p>使用 newInstance 方法实例化</p><pre><code class="lang-Java">//new int[]{11,2} 代表矩阵为 11 行 2 列的矩阵//MWClassID.DOUBLE 代表矩阵中数为 double 类型，MWComplexity.REAL 代表矩阵中是实数MWNumericArray f = MWNumericArray.newInstance(new int[]{11,2}, MWClassID.DOUBLE, MWComplexity.REAL);MWNumericArray f = MWNumericArray.newInstance(new int[]{11,2}, data, MWClassID.DOUBLE);</code></pre><p>另外一种方式：</p><pre><code class="lang-Java">int[] dims = {3, 6};double[] Adata = {1, 7, 13, 2, 8, 14, 3, 9, 15, 4, 10, 16, 5, 11, 17, 6, 12, 18};MWNumericArray A = MWNumericArray.newInstance(dims, Adata, MWClassID.DOUBLE);System.out.println(&quot;A = &quot;);System.out.println(A);</code></pre><p>2、将 Matlab 数据转化为 Java 数据</p><p>这里以返回 <a href="https://www.mathworks.com/help/javabuilder/MWArrayAPI/com/mathworks/toolbox/javabuilder/MWCellArray.html" rel="external nofollow noopener noreferrer" target="_blank">MWCellArray</a> 数据为例</p><pre><code class="lang-Java">MWCellArray cellArray = (MWCellArray) result[0];double[] output = new double[cellArray.numberOfElements()];for (int i = 1; i &lt;= cellArray.numberOfElements(); i++) {    output[i - 1] = ((double[][]) cellArray.get(i))[0][0];}System.out.print(&quot;输出数据：&quot;);System.out.println(Arrays.toString(output));</code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>输入数据为 <code>17行1列</code> 的 MWNumericArray 数据，返回 <code>1行15列</code> 的 MWCellArray 数据。</p><pre><code class="lang-Java">System.out.println(&quot;Running the JAVA client application!!&quot;);AiNet cls = null; // 调用对象MWNumericArray input = null; // 输入Object[] result = new Object[1]; // 输出结果double[] data = new double[]{ // 初始数据        3.43300000000000,        3.40500000000000,        3.37200000000000,        3.35700000000000,        3.34800000000000,        3.31500000000000,        3.28800000000000,        3.28000000000000,        3.26800000000000,        3.24600000000000,        3.23900000000000,        3.24600000000000,        3.25800000000000,        3.27100000000000,        3.28200000000000,        3.28600000000000,        3.30000000000000};input = MWNumericArray.newInstance(new int[]{17, 1}, data, MWClassID.DOUBLE);System.out.print(&quot;输入数据：&quot;);System.out.println(Arrays.toString(input.getDoubleData()));try {    cls = new AiNet();    result = cls.Net(1, input);    MWCellArray cellArray = (MWCellArray) result[0];    double[] output = new double[cellArray.numberOfElements()];    for (int i = 1; i &lt;= cellArray.numberOfElements(); i++) {        output[i - 1] = ((double[][]) cellArray.get(i))[0][0];    }    System.out.print(&quot;输出数据：&quot;);    System.out.println(Arrays.toString(output));    MWArray.disposeArray(output);} catch (MWException e) {    e.printStackTrace();} finally {    MWArray.disposeArray(input);    MWArray.disposeArray(result);    if (cls != null) {        cls.dispose();    }}</code></pre><p>注意使用 MWArray.disposeArray() 方法释放资源。</p><blockquote><p>参考资料<br>1、Java调用MATLAB - 窃·格瓦拉 - CSDN博客<br><a href="https://blog.csdn.net/golden1314521/article/details/43526581" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/golden1314521/article/details/43526581</a><br>2、Java调用Matlab方法的三种方式 - 非技术流 - ITeye博客<br><a href="http://xiaolongfeixiang.iteye.com/blog/1893621" rel="external nofollow noopener noreferrer" target="_blank">http://xiaolongfeixiang.iteye.com/blog/1893621</a><br>3、ML02<em>09_calling_java_from_MATLAB_CH.ppt<br><a href="http://read.pudn.com/downloads85/doc/329263/matlab%E8%AE%B2%E4%B9%89/ML02(11-28)/ML02_09_calling_java_from_MATLAB_CH.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://read.pudn.com/downloads85/doc/329263/matlab%E8%AE%B2%E4%B9%89/ML02(11-28)/ML02_09_calling_java_from_MATLAB_CH.pdf</a><br>4、Java调用Matlab程序 - 移动的天坑的个人空间 - 开源中国<br><a href="https://my.oschina.net/pierrecai/blog/829641" rel="external nofollow noopener noreferrer" target="_blank">https://my.oschina.net/pierrecai/blog/829641</a><br>5、JAVA调用matlab程序 输入输出数据转换 - 简书<br><a href="https://www.jianshu.com/p/c008bd9d5a25" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c008bd9d5a25</a><br>6、(1)在java中使用matlab的函数</em>东东-forest_新浪博客<br><a href="http://blog.sina.com.cn/s/blog_86aea377010171yq.html" rel="external nofollow noopener noreferrer" target="_blank">http://blog.sina.com.cn/s/blog_86aea377010171yq.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Java 调用 Matlab 程序（Java 和 Matlab 混合编程）流程方法。&lt;/p&gt;&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;1、 Java 
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="Matlab" scheme="https://www.wshunli.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Glide 图片加载框架源码解析</title>
    <link href="https://www.wshunli.com/posts/c47606cc.html"/>
    <id>https://www.wshunli.com/posts/c47606cc.html</id>
    <published>2018-09-17T05:18:23.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。<strong>本文内容基于 Glide 4.7.1 版本</strong>。</p><p>Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、可扩展的图片解码管道，以及自动的资源池技术。<a href="https://muyangmin.github.io/glide-docs-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://muyangmin.github.io/glide-docs-cn/</a></p><p>Glide 支持拉取，解码和展示视频快照，图片，和 GIF 动画。Glide 的 API 是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide 使用的是一个定制化的基于 HttpUrlConnection 的栈，但同时也提供了与 Google Volley 和 Square OkHttp 快速集成的工具库。</p><h1 id="Glide-的简单使用"><a href="#Glide-的简单使用" class="headerlink" title="Glide 的简单使用"></a>Glide 的简单使用</h1><p>前面有比较详细的介绍，这里不再赘述。</p><p>Android 图片加载框架 Glide 简单使用 | CirGIS</p><p><a href="https://www.wshunli.com/posts/d82d8606.html">https://www.wshunli.com/posts/d82d8606.html</a></p><h1 id="Glide-的源码解析"><a href="#Glide-的源码解析" class="headerlink" title="Glide 的源码解析"></a>Glide 的源码解析</h1><p>1、我们先看 Glide 的 with() 方法</p><pre><code class="lang-Java">  @NonNull  public static RequestManager with(@NonNull Context context) {    return getRetriever(context).get(context);  }  @NonNull  public static RequestManager with(@NonNull Activity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull FragmentActivity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull Fragment fragment) {    return getRetriever(fragment.getActivity()).get(fragment);  }  @NonNull  public static RequestManager with(@NonNull View view) {    return getRetriever(view.getContext()).get(view);  }</code></pre><p>未完待续。。</p><blockquote><p>参考资料<br>1、Glide源码分析 | lightSky’Blog<br><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" rel="external nofollow noopener noreferrer" target="_blank">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br>2、Android Glide源码解析 - 简书<br><a href="https://www.jianshu.com/p/0c383eaa5675" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c383eaa5675</a><br>3、Android Glide源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/10/10/android-glide/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/10/10/android-glide/</a><br>4、Android源码分析：手把手带你分析 Glide的缓存功能 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/79256892" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/79256892</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Glide 4.7.1 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、可
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Glide" scheme="https://www.wshunli.com/tags/Glide/"/>
    
      <category term="图片加载" scheme="https://www.wshunli.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/2bda06ba.html"/>
    <id>https://www.wshunli.com/posts/2bda06ba.html</id>
    <published>2018-09-16T01:38:40.000Z</published>
    <updated>2018-12-18T16:32:52.009Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 Retrofit 2.4.0 版本</strong>。</p><p>Type-safe HTTP client for Android and Java by Square, Inc. <a href="http://square.github.io/retrofit/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/retrofit/</a></p><p>前面介绍过 OkHttp ，Retrofit 是对 OkHttp 网络请求框架的封装，前者专注于接口的封装，后者专注于真正的网络请求。</p><p><img src="https://img.wshunli.com/Android/Retrofit/Retrofit_OkHttp.png" alt="封装流程图"></p><p>应用程序通过 Retrofit 请求网络，实际上是由 Retrofit 接口层封装请求参数、Header、Url 等信息，由 OkHttp 完成实际的请求操作；在服务端返回数据后，OkHttp 将原始的结果交给 Retrofit，Retrofit 根据用户的需求对结果进行解析。</p><h1 id="Retrofit-的简单使用"><a href="#Retrofit-的简单使用" class="headerlink" title="Retrofit 的简单使用"></a>Retrofit 的简单使用</h1><p>参考官网的介绍：</p><p>1、创建 HTTP API 接口</p><pre><code class="lang-Java">public interface GitHubService {  @GET(&quot;users/{user}/repos&quot;)  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><p>2、创建 Retrofit 实例，并实现接口实例</p><pre><code class="lang-Java">Retrofit retrofit = new Retrofit.Builder()    .baseUrl(&quot;https://api.github.com/&quot;)    .build();GitHubService service = retrofit.create(GitHubService.class);</code></pre><p>3、创建请求实例</p><pre><code class="lang-Java">Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;wshunli&quot;);</code></pre><p>4、发送网络请求</p><pre><code class="lang-Java">// 同步请求call.execute();// 异步请求call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {    @Override    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) {    }    @Override    public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) {        Log.d(TAG, &quot;onFailure: &quot;);    }});</code></pre><p>和 OkHttp 流程差不多，特别是发送请求方法名字都没有变。</p><h1 id="Retrofit-的源码分析"><a href="#Retrofit-的源码分析" class="headerlink" title="Retrofit 的源码分析"></a>Retrofit 的源码分析</h1><p>Retrofit 网络请求完整的流程图如下：</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_full_process.min.png" alt="Retrofit 流程图"></p><p>下面详细介绍。</p><h2 id="创建-Retrofit-实例"><a href="#创建-Retrofit-实例" class="headerlink" title="创建 Retrofit 实例"></a>创建 Retrofit 实例</h2><p>Retrofit 实例化，也是使用的建造者模式。</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_builder.png" alt="retrofit_builder"></p><p>我们先看 Builder 成员变量的含义：</p><pre><code class="lang-Java">// Retrofit#Builderpublic static final class Builder {// 当前系统环境private final Platform platform;// 网络请求器的工厂private @Nullable okhttp3.Call.Factory callFactory;// 网络请求地址private HttpUrl baseUrl;// 数据转换器工厂集合private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();// 网络请求适配器工厂集合private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();// 回调方法执行器private @Nullable Executor callbackExecutor;// 标志位private boolean validateEagerly;</code></pre><p>1、首先构造函数中通过 <code>Platform.get()</code> 初始化了平台参数</p><pre><code class="lang-Java">Builder(Platform platform) {    this.platform = platform;}public Builder() {    this(Platform.get());}Builder(Retrofit retrofit) {    platform = Platform.get();    callFactory = retrofit.callFactory;    baseUrl = retrofit.baseUrl;    converterFactories.addAll(retrofit.converterFactories);    // Remove the default BuiltInConverters instance added by build().    converterFactories.remove(0);    callAdapterFactories.addAll(retrofit.callAdapterFactories);    // Remove the default, platform-aware call adapter added by build().    callAdapterFactories.remove(callAdapterFactories.size() - 1);    callbackExecutor = retrofit.callbackExecutor;    validateEagerly = retrofit.validateEagerly;}</code></pre><p>我们可以看下判断方法：</p><pre><code class="lang-Java">// Platformclass Platform {  private static final Platform PLATFORM = findPlatform();  static Platform get() {    return PLATFORM;  }  private static Platform findPlatform() {    try {      Class.forName(&quot;android.os.Build&quot;);      if (Build.VERSION.SDK_INT != 0) {        return new Android();      }    } catch (ClassNotFoundException ignored) {    }    try {      Class.forName(&quot;java.util.Optional&quot;);      return new Java8();    } catch (ClassNotFoundException ignored) {    }    return new Platform();  }  /* 省略部分无关代码 */}</code></pre><p>后面如果有需要，我们也可以直接拷贝。</p><p>2、然后设置 Retrofit 所需的参数即可</p><pre><code class="lang-Java">public Builder baseUrl(String baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    HttpUrl httpUrl = HttpUrl.parse(baseUrl);    if (httpUrl == null) {    throw new IllegalArgumentException(&quot;Illegal URL: &quot; + baseUrl);    }    return baseUrl(httpUrl);}public Builder baseUrl(HttpUrl baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    List&lt;String&gt; pathSegments = baseUrl.pathSegments();    if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) {    throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl);    }    this.baseUrl = baseUrl;    return this;}/** Add converter factory for serialization and deserialization of objects. */public Builder addConverterFactory(Converter.Factory factory) {    converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}public Builder addCallAdapterFactory(CallAdapter.Factory factory) {    callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}</code></pre><p>3、最后是 build() 方法</p><pre><code class="lang-Java">public Retrofit build() {    if (baseUrl == null) {    throw new IllegalStateException(&quot;Base URL required.&quot;);    }    okhttp3.Call.Factory callFactory = this.callFactory;    if (callFactory == null) {    callFactory = new OkHttpClient();    }    Executor callbackExecutor = this.callbackExecutor;    if (callbackExecutor == null) {    callbackExecutor = platform.defaultCallbackExecutor();    }    // Make a defensive copy of the adapters and add the default Call adapter.    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);    callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));    // Make a defensive copy of the converters.    List&lt;Converter.Factory&gt; converterFactories =        new ArrayList&lt;&gt;(1 + this.converterFactories.size());    // Add the built-in converter factory first. This prevents overriding its behavior but also    // ensures correct behavior when using converters that consume all types.    converterFactories.add(new BuiltInConverters());    converterFactories.addAll(this.converterFactories);    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);}</code></pre><h2 id="创建-API-实例"><a href="#创建-API-实例" class="headerlink" title="创建 API 实例"></a>创建 API 实例</h2><p>获取 API 实例使用 Retrofit 的 <code>create()</code> 方法</p><pre><code class="lang-Java">// Retrofit#create()public &lt;T&gt; T create(final Class&lt;T&gt; service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {        eagerlyValidateMethods(service);    }    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },        new InvocationHandler() {            private final Platform platform = Platform.get();            @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)                throws Throwable {            // If the method is a method from Object then defer to normal invocation.            if (method.getDeclaringClass() == Object.class) {                return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {                return platform.invokeDefaultMethod(method, service, proxy, args);            }            ServiceMethod&lt;Object, Object&gt; serviceMethod =                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);            return serviceMethod.adapt(okHttpCall);            }        });}</code></pre><p>创建 API 实例使用的是 <strong>动态代理</strong> 设计模式。</p><h2 id="创建请求实例"><a href="#创建请求实例" class="headerlink" title="创建请求实例"></a>创建请求实例</h2><p>创建请求实例，跟钱买你的动态代理有关。</p><pre><code class="lang-Java">// Retrofit#create()ServiceMethod&lt;Object, Object&gt; serviceMethod =    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.adapt(okHttpCall);</code></pre><p>1、<code>loadServiceMethod()</code> 方法</p><p>一个 <code>ServiceMethod</code> 对应于一个 API 接口的一个方法，<code>loadServiceMethod()</code> 方法负责加载 <code>ServiceMethod</code></p><pre><code class="lang-Java">// Retrofit#loadServiceMethod()ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) {    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) {        result = serviceMethodCache.get(method);        if (result == null) {        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();        serviceMethodCache.put(method, result);        }    }    return result;}</code></pre><p>2、<code>OkHttpCall</code> 类</p><p><code>OkHttpCall</code> 实现了 <code>retrofit2.Call</code> ，我们通常会使用它的 <code>execute()</code> 和 <code>enqueue()</code> 接口。</p><pre><code class="lang-Java">OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) {    this.serviceMethod = serviceMethod;    this.args = args;}</code></pre><p>构造方法也没有什么好看的。</p><h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>发送网络请求其实也就是 <code>OkHttpCall</code> 类中的方法。</p><p>1、<strong>同步请求</strong> 使用 <code>execute()</code> 方法</p><pre><code class="lang-Java">// OkHttpCall#execute()@Override public Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        if (creationFailure != null) {            if (creationFailure instanceof IOException) {                throw (IOException) creationFailure;            } else if (creationFailure instanceof RuntimeException) {                throw (RuntimeException) creationFailure;            } else {                throw (Error) creationFailure;            }        }        call = rawCall;        if (call == null) {            try {                call = rawCall = createRawCall();            } catch (IOException | RuntimeException | Error e) {                throwIfFatal(e); //  Do not assign a fatal error to creationFailure.                creationFailure = e;                throw e;            }        }    }    if (canceled) {        call.cancel();    }    return parseResponse(call.execute());}</code></pre><p>这里就是 Retrofit 和 OkHttp 交互的核心了，分为三步：</p><p>（1）创建 <code>okhttp3.Call</code> ，包括构造参数</p><pre><code class="lang-Java">private okhttp3.Call createRawCall() throws IOException {    okhttp3.Call call = serviceMethod.toCall(args);    if (call == null) {        throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    }    return call;}</code></pre><p>（2）执行网络请求，也就是 OkHttp 的同步网络请求</p><pre><code class="lang-Java">call.execute()</code></pre><p>（3）解析返回的结果</p><pre><code class="lang-Java">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {    ResponseBody rawBody = rawResponse.body();    // Remove the body&#39;s source (the only stateful object) so we can pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))        .build();    int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) {        try {        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);        } finally {        rawBody.close();        }    }    if (code == 204 || code == 205) {        rawBody.close();        return Response.success(null, rawResponse);    }    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);    try {        T body = serviceMethod.toResponse(catchingBody);        return Response.success(body, rawResponse);    } catch (RuntimeException e) {        // If the underlying source threw an exception, propagate that rather than indicating it was        // a runtime exception.        catchingBody.throwIfCaught();        throw e;    }}</code></pre><p>2、<strong>异步请求</strong> 使用 <code>enqueue()</code> 方法</p><pre><code class="lang-Java">@Override public void enqueue(final Callback&lt;T&gt; callback) {    checkNotNull(callback, &quot;callback == null&quot;);    okhttp3.Call call;    Throwable failure;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        call = rawCall;        failure = creationFailure;        if (call == null &amp;&amp; failure == null) {        try {            call = rawCall = createRawCall();        } catch (Throwable t) {            throwIfFatal(t);            failure = creationFailure = t;        }        }    }    if (failure != null) {        callback.onFailure(this, failure);        return;    }    if (canceled) {        call.cancel();    }    call.enqueue(new okhttp3.Callback() {        @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {        Response&lt;T&gt; response;        try {            response = parseResponse(rawResponse);        } catch (Throwable e) {            callFailure(e);            return;        }        try {            callback.onResponse(OkHttpCall.this, response);        } catch (Throwable t) {            t.printStackTrace();        }        }        @Override public void onFailure(okhttp3.Call call, IOException e) {        callFailure(e);        }        private void callFailure(Throwable e) {        try {            callback.onFailure(OkHttpCall.this, e);        } catch (Throwable t) {            t.printStackTrace();        }        }    });}</code></pre><p>我们可以看到和同步请求是一致的，实际请求交给了 <code>okhttp3.Call#enqueue(Callback responseCallback)</code> 来实现，并在它的 <code>callback</code> 中调用 <code>parseResponse()</code> 解析响应数据，并转发给传入的 <code>callback</code> 。</p><p>Retrofit 源码就先介绍到这里了，后面有机会再详细介绍。</p><blockquote><p>参考资料<br>1、Retrofit分析-漂亮的解耦套路 - 简书<br><a href="https://www.jianshu.com/p/45cb536be2f4" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/45cb536be2f4</a><br>2、Android：手把手带你 深入读懂 Retrofit 2.0 源码 - 简书<br><a href="https://www.jianshu.com/p/0c055ad46b6c" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c055ad46b6c</a><br>3、Retrofit源码分析（超详细） - 简书<br><a href="https://www.jianshu.com/p/097947afddaf" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/097947afddaf</a><br>4、拆轮子系列：拆 Retrofit - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/06/25/Understand-Retrofit/</a><br>5、Retrofit源码解析 | mundane的幻想空间<br><a href="https://mundane799699.github.io/2018/03/13/retrofit-analysis/" rel="external nofollow noopener noreferrer" target="_blank">https://mundane799699.github.io/2018/03/13/retrofit-analysis/</a><br>6、Retrofit源码解析 - 掘金<br><a href="https://juejin.im/post/5acee62c6fb9a028df22ffee" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5acee62c6fb9a028df22ffee</a><br>7、Retrofit源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="https://yuqirong.me/2017/08/03/Retrofit源码解析/" rel="external nofollow noopener noreferrer" target="_blank">https://yuqirong.me/2017/08/03/Retrofit源码解析/</a><br>8、android-cn/android-open-project-analysis<br><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit</a><br>9、【Android】Retrofit源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79933220" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79933220</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Retrofit 2.4.0 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Type-safe HTTP client for Android and Java by Square, In
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Retrofit" scheme="https://www.wshunli.com/tags/Retrofit/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/5bd2f229.html"/>
    <id>https://www.wshunli.com/posts/5bd2f229.html</id>
    <published>2018-09-13T08:28:11.000Z</published>
    <updated>2018-12-18T16:32:52.009Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 OkHttp 3.11.0 版本</strong>。</p><p>网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。</p><p>只是停留在应用层面，会使用一些框架是不行的，还需要深入源码、剖析结构。</p><p>An HTTP+HTTP/2 client for Android and Java applications. <a href="http://square.github.io/okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/okhttp/</a></p><blockquote><p>支持 HTTP/2 协议，允许连接到同一个主机地址的所有请求共享 Socket 。<br>在 HTTP/2 协议不可用的情况下，通过连接池减少请求的延迟。<br>支持 GZip 透明压缩，减少传输的数据包大小。<br>支持响应缓存，避免同一个重复的网络请求。</p></blockquote><h1 id="OkHttp-的简单使用"><a href="#OkHttp-的简单使用" class="headerlink" title="OkHttp 的简单使用"></a>OkHttp 的简单使用</h1><p>一般情况下，对于网络框架有两种常见的使用场景，同步请求和异步请求。</p><p><strong>同步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();Log.d(TAG, &quot;onCreate: &quot; + response.body().string());</code></pre><p><strong>异步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {        Log.d(TAG, &quot;onCreate: &quot; + response.body().string());    }});</code></pre><p>同步请求和异步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><h1 id="OkHttp-的源码分析"><a href="#OkHttp-的源码分析" class="headerlink" title="OkHttp 的源码分析"></a>OkHttp 的源码分析</h1><p>OkHttp 网络请求完整的流程图如下：</p><div align="center"><img src="https://img.wshunli.com/Android/OkHttp/okhttp_full_process.min.png" title="OkHttp 流程图" alt="OkHttp 流程图"></div><p>下面详细介绍。</p><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步请求，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，最后执行 execute() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();</code></pre><h3 id="创建-OkHttpClient-对象"><a href="#创建-OkHttpClient-对象" class="headerlink" title="创建 OkHttpClient 对象"></a>创建 OkHttpClient 对象</h3><p>我们先看 OkHttp 的构造函数：</p><pre><code class="lang-Java">public OkHttpClient() {  this(new Builder());}</code></pre><p>这里是直接实例化，实质上是使用 <strong>建造者模式</strong> 构建 OkHttpClient 实例。</p><p>下面是 OkHttpClient 内部类 Builder 的构造方法：</p><pre><code class="lang-Java">public Builder() {  dispatcher = new Dispatcher();  protocols = DEFAULT_PROTOCOLS;  connectionSpecs = DEFAULT_CONNECTION_SPECS;  eventListenerFactory = EventListener.factory(EventListener.NONE);  proxySelector = ProxySelector.getDefault();  cookieJar = CookieJar.NO_COOKIES;  socketFactory = SocketFactory.getDefault();  hostnameVerifier = OkHostnameVerifier.INSTANCE;  certificatePinner = CertificatePinner.DEFAULT;  proxyAuthenticator = Authenticator.NONE;  authenticator = Authenticator.NONE;  connectionPool = new ConnectionPool();  dns = Dns.SYSTEM;  followSslRedirects = true;  followRedirects = true;  retryOnConnectionFailure = true;  connectTimeout = 10_000;  readTimeout = 10_000;  writeTimeout = 10_000;  pingInterval = 0;}public OkHttpClient build() {  return new OkHttpClient(this);}</code></pre><p>这里 <code>OkHttpClient.Builder</code> 有很多参数，后面再介绍。</p><h3 id="创建-Request-对象"><a href="#创建-Request-对象" class="headerlink" title="创建 Request 对象"></a>创建 Request 对象</h3><p>和 OkHttpClient 类似，Request 也是是使用 <strong>建造者模式</strong> 创建实例。</p><pre><code class="lang-Java">public Builder() {  this.method = &quot;GET&quot;;  this.headers = new Headers.Builder();}public Request build() {  if (url == null) throw new IllegalStateException(&quot;url == null&quot;);  return new Request(this);}</code></pre><p>其中配置默认请求方法为 <code>GET</code> ，还有一些头部的默认参数。</p><h3 id="创建-Call-对象"><a href="#创建-Call-对象" class="headerlink" title="创建 Call 对象"></a>创建 Call 对象</h3><p>OkHttpClient 实现了 <code>Call.Factory</code> ，负责根据请求创建新的 Call 对象。</p><pre><code class="lang-Java">@Override public Call newCall(Request request) {  return RealCall.newRealCall(this, request, false /* for web socket */);}</code></pre><p>Call 只是个接口，实际是实例化的 RealCall 对象。</p><pre><code class="lang-Java">private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  this.client = client;  this.originalRequest = originalRequest;  this.forWebSocket = forWebSocket;  this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);}static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  // Safely publish the Call instance to the EventListener.  RealCall call = new RealCall(client, originalRequest, forWebSocket);  call.eventListener = client.eventListenerFactory().create(call);  return call;}</code></pre><h3 id="发送同步网络请求"><a href="#发送同步网络请求" class="headerlink" title="发送同步网络请求"></a>发送同步网络请求</h3><p>发送请求也是在 <code>RealCall</code> 的 <code>execute()</code> 方法中执行的。</p><pre><code class="lang-Java">// RealCall#execute()@Override public Response execute() throws IOException {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  try {    client.dispatcher().executed(this);    Response result = getResponseWithInterceptorChain();    if (result == null) throw new IOException(&quot;Canceled&quot;);    return result;  } catch (IOException e) {    eventListener.callFailed(this, e);    throw e;  } finally {    client.dispatcher().finished(this);  }}</code></pre><p>在这里主要做了四件事：</p><p>1、检查 Call 是否执行过，没有执行将 <code>executed</code> 赋值为 true ，保证每个请求只执行一次；<br>2、使用 <code>client.dispatcher().executed(this)</code> 来进行实际的请求；<br>3、调用 <code>getResponseWithInterceptorChain()</code> 方法，获取请求响应的结果；<br>4、最后 <code>dispatcher</code> 结束自己。</p><pre><code class="lang-Java">// Dispatcher#executed()/** Used by {@code Call#execute} to signal it is in-flight. */synchronized void executed(RealCall call) {  runningSyncCalls.add(call);}</code></pre><p>在同步请求中 <code>dispatcher</code> 只是负责判断请求执行的状态，在异步请求中参与内容过多。</p><p>下面我们来看 <code>getResponseWithInterceptorChain()</code> 方法：</p><pre><code class="lang-Java">Response getResponseWithInterceptorChain() throws IOException {  // Build a full stack of interceptors.  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();  interceptors.addAll(client.interceptors()); // 加入用户自定义的拦截器  interceptors.add(retryAndFollowUpInterceptor); // 重试和重定向拦截器  interceptors.add(new BridgeInterceptor(client.cookieJar())); // 加入转化请求响应的拦截器  interceptors.add(new CacheInterceptor(client.internalCache())); // 加入缓存拦截器  interceptors.add(new ConnectInterceptor(client)); // 加入连接拦截器  if (!forWebSocket) {      interceptors.addAll(client.networkInterceptors()); // 加入用户自定义的网络拦截器  }  interceptors.add(new CallServerInterceptor(forWebSocket)); // 加入请求响应的拦截器  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,          originalRequest, this, eventListener, client.readTimeoutMillis());  // 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象  return chain.proceed(originalRequest);}</code></pre><p>我们都知道，拦截器是 OkHttp 的精髓。</p><p>1、<code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；<br>2、<code>RetryAndFollowUpInterceptor</code> 是用来重试和重定向的拦截器，在下面我们会讲到；<br>3、<code>BridgeInterceptor</code> 是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；<br>4、<code>CacheInterceptor</code> 是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；<br>5、<code>ConnectInterceptor</code> 用来建立连接的拦截器；<br>6、<code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ；<br>7、<code>CallServerInterceptor</code>是真正向服务器发出请求且得到响应的拦截器；</p><p>最后在聚合了这些拦截器后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器，利用的就是 <strong>责任链模式</strong> 。</p><font font="" size="3" color="#FF0000">下面介绍 OkHttp 中的 拦截器</font><p>拦截器 <code>Interceptor</code> 是 OkHttp 的核心，<strong>实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来</strong>，每一个功能都只是一个 <code>Interceptor</code>，它们再连接成一个 <code>Interceptor.Chain</code>，环环相扣，最终圆满完成一次网络请求。</p><div align="center"><img src="https://img.wshunli.com/Android/OkHttp/okhttp_interceptors.jpg" title="OkHttp 拦截器" alt="OkHttp 拦截器"></div><p>1、<code>RealInterceptorChain</code> 拦截器链</p><p>拦截器链 <code>RealInterceptorChain</code> 是真正把这些拦截器串起来的一个角色，调用 <code>proceed()</code> 方法</p><pre><code class="lang-Java">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,    RealConnection connection) throws IOException {  if (index &gt;= interceptors.size()) throw new AssertionError();  calls++;  // If we already have a stream, confirm that the incoming request will use it.  if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must retain the same host and port&quot;);  }  // If we already have a stream, confirm that this is the only call to chain.proceed().  if (this.httpCodec != null &amp;&amp; calls &gt; 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must call proceed() exactly once&quot;);  }  // Call the next interceptor in the chain.  // 得到下一次对应的 RealInterceptorChain  RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,      connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,      writeTimeout);  // 当前次数的 interceptor  Interceptor interceptor = interceptors.get(index);  // 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法  Response response = interceptor.intercept(next);  // Confirm that the next interceptor made its required call to chain.proceed().  // 确认下一次的 interceptor 调用过 chain.proceed()  if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptor        + &quot; must call proceed() exactly once&quot;);  }  // Confirm that the intercepted response isn&#39;t null.  if (response == null) {    throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);  }  if (response.body() == null) {    throw new IllegalStateException(        &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);  }  return response;}</code></pre><p>在代码中是一次次链式调用拦截器。</p><p>2、<code>RetryAndFollowUpInterceptor</code> 重试和重定向的拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request request = chain.request();  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Call call = realChain.call();  EventListener eventListener = realChain.eventListener();  StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),      createAddress(request.url()), call, eventListener, callStackTrace);  this.streamAllocation = streamAllocation;  int followUpCount = 0;  Response priorResponse = null;  while (true) {    // 如果取消，就释放资源    if (canceled) {      streamAllocation.release();      throw new IOException(&quot;Canceled&quot;);    }    Response response;    boolean releaseConnection = true;    try {      // 调用下一个拦截器      response = realChain.proceed(request, streamAllocation, null, null);      releaseConnection = false;    } catch (RouteException e) {      // The attempt to connect via a route failed. The request will not have been sent.      // 路由连接失败，请求将不会被发送      if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {        throw e.getFirstConnectException();      }      releaseConnection = false;      continue;    } catch (IOException e) {      // An attempt to communicate with a server failed. The request may have been sent.      // 服务器连接失败，请求可能已被发送      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);      if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;      releaseConnection = false;      continue;    } finally {      // We&#39;re throwing an unchecked exception. Release any resources.      // 抛出未检查的异常，释放资源      if (releaseConnection) {        streamAllocation.streamFailed(null);        streamAllocation.release();      }    }    // Attach the prior response if it exists. Such responses never have a body.    if (priorResponse != null) {      response = response.newBuilder()          .priorResponse(priorResponse.newBuilder()                  .body(null)                  .build())          .build();    }    // 如果不需要重定向，那么 followUp 为空，会根据响应码判断    Request followUp;    try {      followUp = followUpRequest(response, streamAllocation.route());    } catch (IOException e) {      streamAllocation.release();      throw e;    }    // 释放资源，返回 response    if (followUp == null) {      if (!forWebSocket) {        streamAllocation.release();      }      return response;    }    // 关闭 response 的 body    closeQuietly(response.body());    if (++followUpCount &gt; MAX_FOLLOW_UPS) {      streamAllocation.release();      throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);    }    if (followUp.body() instanceof UnrepeatableRequestBody) {      streamAllocation.release();      throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());    }    // response 和 followUp 比较是否为同一个连接    // 若为重定向就销毁旧连接，创建新连接    if (!sameConnection(response, followUp.url())) {      streamAllocation.release();      streamAllocation = new StreamAllocation(client.connectionPool(),          createAddress(followUp.url()), call, eventListener, callStackTrace);      this.streamAllocation = streamAllocation;    } else if (streamAllocation.codec() != null) {      throw new IllegalStateException(&quot;Closing the body of &quot; + response          + &quot; didn&#39;t close its backing stream. Bad interceptor?&quot;);    }    // 将重定向操作得到的新请求设置给 request    request = followUp;    priorResponse = response;  }}</code></pre><p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p><p>3、<code>BridgeInterceptor</code> 桥街和适配拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request userRequest = chain.request();  Request.Builder requestBuilder = userRequest.newBuilder();  // 将用户友好的 request 构造为发送给服务器的 request  RequestBody body = userRequest.body();  // 若有请求体，则构造  if (body != null) {    MediaType contentType = body.contentType();    if (contentType != null) {      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());    }    long contentLength = body.contentLength();    if (contentLength != -1) {      requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);    } else {      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);      requestBuilder.removeHeader(&quot;Content-Length&quot;);    }  }  if (userRequest.header(&quot;Host&quot;) == null) {    requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));  }  if (userRequest.header(&quot;Connection&quot;) == null) {    requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);  }  // If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing  // the transfer stream.  // 使用 gzip 压缩  boolean transparentGzip = false;  if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {    transparentGzip = true;    requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);  }  // 设置 cookie  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());  if (!cookies.isEmpty()) {    requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));  }  // 设置 UA  if (userRequest.header(&quot;User-Agent&quot;) == null) {    requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());  }  // 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse  Response networkResponse = chain.proceed(requestBuilder.build());  // 保存 networkResponse 的 cookie  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());  // 将 networkResponse 构造为对用户友好的 response  Response.Builder responseBuilder = networkResponse.newBuilder()      .request(userRequest);  // 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体  if (transparentGzip      &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))      &amp;&amp; HttpHeaders.hasBody(networkResponse)) {    GzipSource responseBody = new GzipSource(networkResponse.body().source());    Headers strippedHeaders = networkResponse.headers().newBuilder()        .removeAll(&quot;Content-Encoding&quot;)        .removeAll(&quot;Content-Length&quot;)        .build();    responseBuilder.headers(strippedHeaders);    String contentType = networkResponse.header(&quot;Content-Type&quot;);    responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));  }  return responseBuilder.build();}</code></pre><p>在 <code>BridgeInterceptor</code> 这一步，先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</p><p>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</p><p>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</p><p>4、<code>CacheInterceptor</code> 缓存拦截器</p><p>分析 <code>CacheInterceptor</code> 拦截器 <code>intercept()</code> 方法的源代码</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {    // 得到 request 对应缓存中的 response    Response cacheCandidate = cache != null            ? cache.get(chain.request())            : null;    // 获取当前时间，会和之前缓存的时间进行比较    long now = System.currentTimeMillis();    // 得到缓存策略    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();    Request networkRequest = strategy.networkRequest;    Response cacheResponse = strategy.cacheResponse;    // 追踪缓存，其实就是计数    if (cache != null) {        cache.trackResponse(strategy);    }    // 缓存不适用，关闭    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&#39;t applicable. Close it.    }    // If we&#39;re forbidden from using the network and the cache is insufficient, fail.    // 禁止网络并且没有缓存的话，返回失败    if (networkRequest == null &amp;&amp; cacheResponse == null) {        return new Response.Builder()                .request(chain.request())                .protocol(Protocol.HTTP_1_1)                .code(504)                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)                .body(Util.EMPTY_RESPONSE)                .sentRequestAtMillis(-1L)                .receivedResponseAtMillis(System.currentTimeMillis())                .build();    }    // If we don&#39;t need the network, we&#39;re done.    // 不用网络请求，返回缓存    if (networkRequest == null) {        return cacheResponse.newBuilder()                .cacheResponse(stripBody(cacheResponse))                .build();    }    Response networkResponse = null;    try {        // 交给下一个拦截器，返回 networkResponse        networkResponse = chain.proceed(networkRequest);    } finally {        // If we&#39;re crashing on I/O or otherwise, don&#39;t leak the cache body.        if (networkResponse == null &amp;&amp; cacheCandidate != null) {            closeQuietly(cacheCandidate.body());        }    }    // 如果我们同时有缓存和 networkResponse ，根据情况使用    if (cacheResponse != null) {        if (networkResponse.code() == HTTP_NOT_MODIFIED) {            Response response = cacheResponse.newBuilder()                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())                    .cacheResponse(stripBody(cacheResponse))                    .networkResponse(stripBody(networkResponse))                    .build();            networkResponse.body().close();            // 更新原来的缓存至最新            // Update the cache after combining headers but before stripping the            // Content-Encoding header (as performed by initContentStream()).            cache.trackConditionalCacheHit();            cache.update(cacheResponse, response);            return response;        } else {            closeQuietly(cacheResponse.body());        }    }    Response response = networkResponse.newBuilder()            .cacheResponse(stripBody(cacheResponse))            .networkResponse(stripBody(networkResponse))            .build();    // 保存之前未缓存的缓存    if (cache != null) {        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {            // Offer this request to the cache.            CacheRequest cacheRequest = cache.put(response);            return cacheWritingResponse(cacheRequest, response);        }        if (HttpMethod.invalidatesCache(networkRequest.method())) {            try {                cache.remove(networkRequest);            } catch (IOException ignored) {                // The cache cannot be written.            }        }    }    return response;}</code></pre><p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p><p>5、<code>ConnectInterceptor</code> 拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Request request = realChain.request();  StreamAllocation streamAllocation = realChain.streamAllocation();  // We need the network to satisfy this request. Possibly for validating a conditional GET.  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);  HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);  RealConnection connection = streamAllocation.connection();  return realChain.proceed(request, streamAllocation, httpCodec, connection);}</code></pre><p>实际上建立连接就是创建了一个 <code>HttpCodec</code> 对象，它是对 <code>HTTP</code> 协议操作的抽象，有两个实现：<code>Http1Codec</code> 和 <code>Http2Codec</code>，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。</p><p>6、<code>CallServerInterceptor</code> 拦截器，发送和接收数据</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  HttpCodec httpCodec = realChain.httpStream();  StreamAllocation streamAllocation = realChain.streamAllocation();  RealConnection connection = (RealConnection) realChain.connection();  Request request = realChain.request();      long sentRequestMillis = System.currentTimeMillis();  // 整理请求头并写入  httpCodec.writeRequestHeaders(request);  Response.Builder responseBuilder = null;  // 检查是否为有 body 的请求方法  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {      // If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100      // Continue&quot; response before transmitting the request body. If we don&#39;t get that, return what      // we did get (such as a 4xx response) without ever transmitting the request body.      // 如果有 Expect: 100-continue 在请求头中，那么要等服务器的响应      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {          httpCodec.flushRequest();          responseBuilder = httpCodec.readResponseHeaders(true);      }      if (responseBuilder == null) {          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.          // 写入请求体          Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);          request.body().writeTo(bufferedRequestBody);          bufferedRequestBody.close();      } else if (!connection.isMultiplexed()) {          // If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP/1 connection from          // being reused. Otherwise we&#39;re still obligated to transmit the request body to leave the          // connection in a consistent state.          streamAllocation.noNewStreams();      }  }  httpCodec.finishRequest();  // 得到响应头  if (responseBuilder == null) {      responseBuilder = httpCodec.readResponseHeaders(false);  }  // 构造 response  Response response = responseBuilder          .request(request)          .handshake(streamAllocation.connection().handshake())          .sentRequestAtMillis(sentRequestMillis)          .receivedResponseAtMillis(System.currentTimeMillis())          .build();  int code = response.code();  // 如果为 web socket 且状态码是 101 ，那么 body 为空  if (forWebSocket &amp;&amp; code == 101) {      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.      response = response.newBuilder()              .body(Util.EMPTY_RESPONSE)              .build();  } else {      // 读取 body      response = response.newBuilder()              .body(httpCodec.openResponseBody(response))              .build();  }  // 如果请求头中有 close 那么断开连接  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))          || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {      streamAllocation.noNewStreams();  }  // 抛出协议异常  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {      throw new ProtocolException(              &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());  }  return response;}</code></pre><p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>和同步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {    }});</code></pre><p>异步请求在 <code>Callback</code> 回调中获取响应，有 <code>onResponse()</code> 、 <code>onFailure()</code> 两个方法。</p><h3 id="发送异步网络请求"><a href="#发送异步网络请求" class="headerlink" title="发送异步网络请求"></a>发送异步网络请求</h3><p>前面三个步骤完全一致，我们从发送异步网络请求开始，异步请求是调用 <code>RealCall</code> 实例的 <code>enqueue()</code> 方法。。</p><pre><code class="lang-Java">// RealCall#enqueue()@Override public void enqueue(Callback responseCallback) {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  client.dispatcher().enqueue(new AsyncCall(responseCallback));}</code></pre><p>这里使用 <code>Dispatcher</code> 分发器我来处理请求。</p><pre><code class="lang-Java">// Dispatcher#enqueue()synchronized void enqueue(AsyncCall call) {  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {    runningAsyncCalls.add(call);    executorService().execute(call);  } else {    readyAsyncCalls.add(call);  }}</code></pre><p>实质上异步网络请求是在 <code>Dispatcher</code> 中做到任务调度。</p><font font="" size="3" color="#FF0000">下面介绍 OkHttp 中的 任务调度</font><p>我们来看 <code>Dispatcher</code> 类的源代码。</p><pre><code class="lang-Java">public final class Dispatcher {  private int maxRequests = 64;  private int maxRequestsPerHost = 5;  private @Nullable Runnable idleCallback;  /** Executes calls. Created lazily. */  // 线程池的实现  private @Nullable ExecutorService executorService;  /** Ready async calls in the order they&#39;ll be run. */  // 就绪等待网络请求的异步队列  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running asynchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的异步队列  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running synchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的同步队列  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();  public Dispatcher(ExecutorService executorService) {    this.executorService = executorService;  }  public Dispatcher() {  }  // 创建线程池  public synchronized ExecutorService executorService() {    if (executorService == null) {      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));    }    return executorService;  }  /* 省略部分无关代码*/  synchronized void enqueue(AsyncCall call) {    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {      runningAsyncCalls.add(call);      executorService().execute(call);    } else {      readyAsyncCalls.add(call);    }  }  /* 省略部分无关代码*/}</code></pre><p>异步请求是放在线程池中执行的，如果最大异步请求数小于 64 并且 单个 HOST 的异步请求数小于 5 ，将请求添加到 <code>runningAsyncCalls</code> 中，否则添加到 <code>readyAsyncCalls</code> 中。</p><p>我们来看添加进线程池的 <code>AsyncCall</code> 类，实际上 <code>AsyncCall</code> 是继承自 <code>NamedRunnable</code> 的 <code>RealCall</code> 内部类。<code>NamedRunnable</code> 是实现了 <code>Runnable</code> 接口的抽象类。</p><pre><code class="lang-Java">final class AsyncCall extends NamedRunnable {  private final Callback responseCallback;  AsyncCall(Callback responseCallback) {    super(&quot;OkHttp %s&quot;, redactedUrl());    this.responseCallback = responseCallback;  }  String host() {    return originalRequest.url().host();  }  Request request() {    return originalRequest;  }  RealCall get() {    return RealCall.this;  }  @Override protected void execute() {    boolean signalledCallback = false;    try {      // 和同步请求相同，调用拦截器，得到响应      Response response = getResponseWithInterceptorChain();      if (retryAndFollowUpInterceptor.isCanceled()) {        signalledCallback = true;        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));      } else {        signalledCallback = true;        responseCallback.onResponse(RealCall.this, response);      }    } catch (IOException e) {      if (signalledCallback) {        // Do not signal the callback twice!        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);      } else {        eventListener.callFailed(RealCall.this, e);        responseCallback.onFailure(RealCall.this, e);      }    } finally {      // 在 runningAsyncCalls 中移除      client.dispatcher().finished(this);    }  }}</code></pre><p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p><p>不同的是在得到 <code>Response</code> 后，进行结果的回调。</p><p>在 <code>AsyncCall</code> 的最后调用了 <code>Dispatcher</code> 的 <code>finished()</code> 方法。</p><pre><code class="lang-Java">// Dispatcher#finished()/** Used by {@code AsyncCall#run} to signal completion. */void finished(AsyncCall call) {  finished(runningAsyncCalls, call, true);}/** Used by {@code Call#execute} to signal completion. */void finished(RealCall call) {  finished(runningSyncCalls, call, false);}private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) {  int runningCallsCount;  Runnable idleCallback;  synchronized (this) {    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#39;t in-flight!&quot;);    // 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中    if (promoteCalls) promoteCalls();    runningCallsCount = runningCallsCount();    idleCallback = this.idleCallback;  }  if (runningCallsCount == 0 &amp;&amp; idleCallback != null) {    idleCallback.run();  }}</code></pre><p>这里所做的工作就是把执行过的 Call 移除，然后将 <code>readyAsyncCalls</code> 中的 Call 移动到 <code>runningAsyncCalls</code> 中并加入线程池中。</p><blockquote><p>基本上 OkHttp 的请求响应的流程就介绍完了，主要是关于 OkHttp 的 <strong>拦截器链</strong> 和 <strong>任务调度</strong> 原理。</p></blockquote><p>还有很多细节没有涉及，需要花费很大的精力，才能理解分析透彻，后面有机会再介绍。</p><blockquote><p>参考资料：<br>1、拆轮子系列：拆 OkHttp - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/07/11/Understand-OkHttp/</a><br>2、OkHttp源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="http://yuqirong.me/2017/07/25/OkHttp源码解析/" rel="external nofollow noopener noreferrer" target="_blank">http://yuqirong.me/2017/07/25/OkHttp源码解析/</a><br>3、OkHttp源码分析 - 掘金<br><a href="https://juejin.im/post/5af4482951882567286064e6" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5af4482951882567286064e6</a><br>4、okhttp源码分析（一）——基本流程（超详细） - 简书<br><a href="https://www.jianshu.com/p/37e26f4ea57b" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/37e26f4ea57b</a><br>5、OKHttp源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/03/12/android-okhttp/</a><br>6、OkHttp 源码解析（一）：基本流程 - Coding - SegmentFault 思否<br><a href="https://segmentfault.com/a/1190000012656606" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000012656606</a><br>7、【Android】OkHttp源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79175824" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79175824</a><br>8、深入浅出 OkHttp 源码 - DiyCode<br><a href="https://www.diycode.cc/topics/640" rel="external nofollow noopener noreferrer" target="_blank">https://www.diycode.cc/topics/640</a><br>9、Okhttp框架源码分析 - 简书<br><a href="https://www.jianshu.com/p/18a4861600d1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/18a4861600d1</a><br>10、OkHttp 3.7源码分析（一）——整体架构 - CSDN博客<br><a href="https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320</a><br>11、okhttp网络框架源码解析 - CSDN博客<br><a href="https://blog.csdn.net/fanguangjun123/article/details/78621585" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/fanguangjun123/article/details/78621585</a><br>12、OKHttp网络框架源码解析（一）okHttp框架同步异步请求流程和源码分析 - CSDN博客<br><a href="https://blog.csdn.net/qq_24675479/article/details/79483193" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_24675479/article/details/79483193</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 OkHttp 3.11.0 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。&lt;/p&gt;&lt;p&gt;只是停留在应用
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
      <category term="OkHttp" scheme="https://www.wshunli.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》编程题目 Java 实现（01-10）</title>
    <link href="https://www.wshunli.com/posts/25842bb5.html"/>
    <id>https://www.wshunli.com/posts/25842bb5.html</id>
    <published>2018-09-11T13:07:05.000Z</published>
    <updated>2018-12-18T16:32:52.009Z</updated>
    
    <content type="html"><![CDATA[<p>《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。</p><p>笔试中的重要性不必多说，面试官还总是喜欢让手写代码。</p><p>1、赋值运算函数</p><p>2、单例设计模式</p><p>在设计模式中有详细的介绍，这里不再赘述，请移步：</p><p><a href="https://www.wshunli.com/posts/d1c4534.html">https://www.wshunli.com/posts/d1c4534.html</a></p><p>3、二维数组中查找目标值</p><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>（1）直接暴力查找</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    for (int[] anArray : array) {        for (int anAnArray : anArray) {            if (anAnArray == target) return true;        }    }    return false;}</code></pre><p>（2）从右上角/左下角的元素出发</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    int row = array.length;    int col = array[0].length;    for (int i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0; ) {        int value = array[i][j];        if (value == target) return true;        if (value &lt; target) i++;        if (value &gt; target) j--;    }    return false;}</code></pre><p>4、替换字符串中的空格</p><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成 “%20” 。</p></blockquote><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;);}</code></pre><p>这个太偷懒了，不那么偷懒：</p><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    StringBuilder builder = new StringBuilder();    String string = str.toString();    for (int i = 0; i &lt; string.length(); i++) {        char charAt = string.charAt(i);        if (charAt == &#39; &#39;) {            builder.append(&quot;%20&quot;);        } else {            builder.append(charAt);        }    }    return builder.toString();}</code></pre><p>5、从尾到头打印链表</p><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList 。</p></blockquote><p>（1）借助堆栈的“后进先出”实现</p><pre><code class="lang-Java">/***    public class ListNode {*        int val;*        ListNode next = null;*        ListNode(int val) {*            this.val = val;*        }*    }*/public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    Stack&lt;Integer&gt; integers = new Stack&lt;&gt;();    while (listNode != null) {        integers.push(listNode.val);        listNode = listNode.next;    }    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (!integers.isEmpty()) {        arrayList.add(integers.pop());    }    return arrayList;}</code></pre><p>（2）借助递归实现</p><pre><code class="lang-Java">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    if (listNode != null) {        this.printListFromTailToHead(listNode.next);        arrayList.add(listNode.val);    }    return arrayList;}</code></pre><p>（3）使用 Collections 的 reverse 方法</p><pre><code class="lang-Java">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (listNode != null) {        arrayList.add(listNode.val);        listNode = listNode.next;    }    Collections.reverse(arrayList);    return arrayList;}</code></pre><p>6、由前序和中序遍历重建二叉树</p><p>7、用两个栈实现队列<br>8、求旋转数组的最小数字<br>9、斐波那契数列的第n项（青蛙跳台阶）<br>10、二进制中1的个数<br>11、数值的整数次方<br>12、打印1到最大的n位数<br>13、O(1)时间删除链表节点<br>14、使数组中的奇数位于偶数前面<br>15、找链表中倒数第K个节点<br>16、输出反转后的链表<br>17、合并两个有序链表<br>18、判断二叉树A中是否包含子树B<br>19、二叉树的镜像<br>20、顺时针打印矩阵<br>21、包含min函数的栈<br>22、判断一个栈是否是另一个栈的弹出序列<br>23、层序遍历二叉树<br>24、后序遍历二叉搜索树<br>25、二叉树中和为某值的路径<br>26、复杂链表的复制<br>27、二叉搜索树转换为双向链表<br>28、打印字符串中所有字符的排列<br>29、数组中出现次数超过一半的数字<br>30、找出最小的K个数<br>31、连续子数组的最大和<br>32、从1到整数n中1出现的次数<br>33、把数组中的数排成一个最小的数<br>34、求第N个丑数<br>35、第一个出现一次的字符<br>36、数组中逆序对的个数<br>37、两个链表的第一个公共节点<br>38、数字在排序数组中出现的次数<br>39、二叉树的深度<br>40、数组中只出现一次的两个数，而其他数都出现两次。<br>41、和为s的连续整数序列<br>42、翻转字符串<br>43、n个骰子的点数及出现的概率44. 扑克牌的顺子<br>44、圆圈中最后剩下的数<br>45、1+2+3+…+n的和<br>46、不用加减乘除做加法<br>47、不能被继承的类<br>48、字符串转换为整数<br>49、树中两个节点的最低公共祖先<br>50、找出重复的数<br>51、构建乘积数组<br>52、正则表达式匹配<br>53、表示数值的字符串<br>54、字符流中第一个不重复的字符<br>55、链表中环的入口节点<br>56、删除链表中重复的节点<br>57、二叉树的下一个节点<br>58、对称的二叉树<br>59、按之字形顺序打印二叉树<br>60、把二叉树打印成多行<br>61、序列化二叉树<br>62、二叉搜索树的第K个节点<br>63、数据流中的中位数<br>64、滑动窗口的最大值<br>65、矩阵中的路径<br>66、机器人的运动范围</p><blockquote><p>参考资料<br>1、剑指Offer<em>编程题</em>牛客网<br><a href="https://www.nowcoder.com/ta/coding-interviews" rel="external nofollow noopener noreferrer" target="_blank">https://www.nowcoder.com/ta/coding-interviews</a><br>2、【剑指offer】Java版代码（完整版） - CSDN博客<br><a href="https://blog.csdn.net/baiye_xing/article/details/78428561" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/baiye_xing/article/details/78428561</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。&lt;/p&gt;&lt;p&gt;笔试中的重要性不必多说，面试官还总是喜欢让手写代码。&lt;/p&gt;&lt;p&gt;1、赋值运算函数&lt;/p&gt;&lt;p&gt;2、单例设计模式&lt;/p&gt;&lt;p&gt;在设计模式中有详细的介绍，这里不再赘述，请移
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指Offer》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十四）观察者模式</title>
    <link href="https://www.wshunli.com/posts/58b1d741.html"/>
    <id>https://www.wshunli.com/posts/58b1d741.html</id>
    <published>2018-09-10T12:19:14.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/14.Observer.png" title="观察者模式" alt="观察者模式"></div><p>观察者模式所涉及的角色有：</p><p>(1) 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>(2) 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>(3) 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>(4) 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers(String newState) {        for (Observer observer : list) {            observer.update(newState);        }    }}</code></pre><p>2、具体主题角色类</p><pre><code class="lang-Java">public class ConcreteSubject extends Subject {    private String state;    public String getState() {        return state;    }    public void change(String newState) {        state = newState;        System.out.println(&quot;ConcreteSubject：&quot; + state);        this.nodifyObservers(state);//状态发生改变，通知各个观察者    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(String state);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    private String observerState;//观察者的状态    @Override    public void update(String state) {        /**         * 更新观察者的状态，使其与目标的状态保持一致         */        observerState = state;        System.out.println(&quot;ConcreteObserver：&quot; + observerState);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p>当主题对象的状态改变时，将通知所有观察者，观察者接收到主题对象的通知后，将可以进行其他操作，进行响应。</p><p><strong>推模型和拉模型</strong>：</p><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><p>（1）推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><p>（2）拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把 <strong>主题对象自身</strong> 通过 update() 方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><p>前面就是典型的推模型，下面介绍拉模型。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers() {        for (Observer observer : list) {            observer.update(this);        }    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(Subject subject);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    @Override    public void update(Subject subject) {        String state = ((ConcreteSubject) subject).getState();        System.out.println(&quot;ConcreteObserver：&quot; + state);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p><strong>两种模式的比较</strong>：</p><p>（1）推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</p><p>（2）推模型可能会使得观察者对象难以复用，因为观察者的 update() 方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的 update() 方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update() 方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p><p><strong>观察者模式的优缺点</strong>：</p><p>优点：观察者和被观察者是抽象耦合的；建立一套触发机制。<br>缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch14" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch14</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之观察者模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。&lt;/p&gt;&lt;h1 id=&quot;观
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十三）享元模式</title>
    <link href="https://www.wshunli.com/posts/180f2df5.html"/>
    <id>https://www.wshunli.com/posts/180f2df5.html</id>
    <published>2018-09-10T10:43:03.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/13.Flyweight.png" title="享元模式" alt="享元模式"></div><p>享元模式所涉及到的角色如下：</p><p>(1) 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p><p>(2) 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p><p>(3) 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p><p>1、创建一个接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、创建实现接口的实体类</p><pre><code class="lang-Java">public class Circle implements Shape {    private String color;    private int x;    private int y;    private int radius;    public Circle(String color) {        this.color = color;    }    public void setX(int x) {        this.x = x;    }    public void setY(int y) {        this.y = y;    }    public void setRadius(int radius) {        this.radius = radius;    }    @Override    public void draw() {        System.out.println(&quot;Circle: Draw() [Color : &quot; + color                + &quot;, x : &quot; + x + &quot;, y :&quot; + y + &quot;, radius :&quot; + radius);    }}</code></pre><p>3、创建一个工厂，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();    public static Shape getCircle(String color) {        Circle circle = (Circle) circleMap.get(color);        if (circle == null) {            circle = new Circle(color);            circleMap.put(color, circle);            System.out.println(&quot;Creating circle of color : &quot; + color);        }        return circle;    }}</code></pre><p>4、享元模式的使用</p><pre><code class="lang-Java">public class FlyweightPatternMain {    private static final String colors[] =            {&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot;};    public static void main(String[] args) {        for (int i = 0; i &lt; 20; ++i) {            Circle circle =                    (Circle) ShapeFactory.getCircle(getRandomColor());            circle.setX(getRandomX());            circle.setY(getRandomY());            circle.setRadius(100);            circle.draw();        }    }    private static String getRandomColor() {        return colors[(int) (Math.random() * colors.length)];    }    private static int getRandomX() {        return (int) (Math.random() * 100);    }    private static int getRandomY() {        return (int) (Math.random() * 100);    }}</code></pre><p><strong>享元模式的优缺点</strong>：</p><p>优点：系统有大量相似对象；需要缓冲池的场景。<br>缺点：注意划分外部状态和内部状态，否则可能会引起线程安全问题，这些类必须有一个工厂对象加以控制。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch13" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch13</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之享元模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html</a><br>2、设计模式读书笔记——享元模式 - chenssy - 博客园<br><a href="https://www.cnblogs.com/chenssy/p/3330555.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chenssy/p/3330555.html</a><br>3、享元模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/flyweight-pattern.html</a><br>4、JAVA设计模式-享元模式（Flyweight） - 简书<br><a href="https://www.jianshu.com/p/f88b903a166a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f88b903a166a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;&lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;he
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十二）桥接模式</title>
    <link href="https://www.wshunli.com/posts/f75ecf9a.html"/>
    <id>https://www.wshunli.com/posts/f75ecf9a.html</id>
    <published>2018-09-10T09:09:30.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/12.Bridge.png" title="桥接模式" alt="桥接模式"></div><p>桥接模式包含如下角色：</p><p>(1) Abstraction：抽象类，抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。Shape<br>(2) RefinedAbstraction：扩充抽象类，扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。Circle<br>(3) Implementor：实现类接口，定义实现部分的接口，这个接口不用和 Abstraction 里面的方法一致，通常是由 Implementor 接口提供基本的操作，而 Abstraction 里面定义的是基于这些基本操作的业务方法，也就是说 Abstraction 定义了基于这些基本操作的较高层次的操作。DrawAPI<br>(4) ConcreteImplementor：具体实现类，真正实现 Implementor 接口的对象。GreenCircle、RedCircle</p><p>1、创建桥接实现接口</p><pre><code class="lang-Java">public interface DrawAPI {    void drawCircle(int radius, int x, int y);}</code></pre><p>2、创建实现了 DrawAPI 接口的实体桥接实现类</p><pre><code class="lang-Java">public class GreenCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}public class RedCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}</code></pre><p>3、使用 DrawAPI 接口创建抽象类 Shape</p><pre><code class="lang-Java">public abstract class Shape {    protected DrawAPI drawAPI;    protected Shape(DrawAPI drawAPI) {        this.drawAPI = drawAPI;    }    public abstract void draw();}</code></pre><p>4、创建实现了 Shape 接口的实体类</p><pre><code class="lang-Java">public class Circle extends Shape {    private int x, y, radius;    public Circle(DrawAPI drawAPI, int x, int y, int radius) {        super(drawAPI);        this.x = x;        this.y = y;        this.radius = radius;    }    @Override    public void draw() {        drawAPI.drawCircle(radius, x, y);    }}</code></pre><p>5、使用 Shape 和 DrawAPI 类画出不同颜色的圆</p><pre><code class="lang-Java">public class BridgePatternMain {    public static void main(String[] args) {        Shape redCircle = new Circle(new RedCircle(), 100, 100, 10);        Shape greenCircle = new Circle(new GreenCircle(), 100, 100, 10);        redCircle.draw();        greenCircle.draw();    }}</code></pre><p><strong>桥接模式的优缺点</strong>：</p><p>优点：抽象和实现的分离；优秀的扩展能力；实现细节对客户透明。<br>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch12" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch12</a></p><blockquote><p>参考资料<br>1、Java设计模式之十五（桥接模式） - CSDN博客<br><a href="https://blog.csdn.net/shaopeng5211/article/details/8827507" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/shaopeng5211/article/details/8827507</a><br>2、JAVA设计模式之 桥接模式【Bridge Pattern】 - CSDN博客<br><a href="https://blog.csdn.net/janice0529/article/details/44102637" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/janice0529/article/details/44102637</a><br>3、java中的桥接模式 - 简书<br><a href="https://www.jianshu.com/p/c71562c98258" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c71562c98258</a><br>4、讲故事，学（Java）设计模式—桥接模式 - ImportNew<br><a href="http://www.importnew.com/6857.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.importnew.com/6857.html</a><br>5、桥接模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/bridge-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/bridge-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。&lt;/p&gt;&lt;h1 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十一）组合模式</title>
    <link href="https://www.wshunli.com/posts/fb6e1df3.html"/>
    <id>https://www.wshunli.com/posts/fb6e1df3.html</id>
    <published>2018-09-10T08:40:17.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/11.Composite.png" title="组合模式" alt="组合模式"></div><p>组合模式的包含角色：</p><p>(1) Component 抽象构件角色，定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>(2) Leaf 叶子构件，叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>(3) Composite 树枝构件，树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</p><p>1、抽象构件角色</p><pre><code class="lang-Java">public abstract class Component {    public void operation() {        System.out.println(&quot;Component.operation()&quot;);    }}</code></pre><p>2、树枝构件</p><pre><code class="lang-Java">public class Composite extends Component {    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;&gt;();    public void add(Component component) {        componentArrayList.add(component);    }    public void remove(Component component) {        componentArrayList.remove(component);    }    public ArrayList&lt;Component&gt; getChildren() {        return this.componentArrayList;    }}</code></pre><p>3、树叶构件</p><pre><code class="lang-Java">public class Leaf extends Component {    @Override    public void operation() {        System.out.println(&quot;Leaf.operation()&quot;);    }}</code></pre><p>4、组合模式的使用</p><pre><code class="lang-Java">public class CompositeMain {    public static void main(String[] args) {        Composite root = new Composite();        root.operation();        Composite branch = new Composite();        root.add(branch);        Leaf leaf1 = new Leaf();        Leaf leaf2 = new Leaf();        branch.add(leaf1);        branch.add(leaf2);        display(root);    }    public static void display(Composite root) {        for (Component component : root.getChildren()) {            if (component instanceof Leaf) {                component.operation();            } else {                display((Composite) component);            }        }    }}</code></pre><p><strong>组合模式的优缺点</strong>：</p><p>优点：高层模块调用简单；节点自由增加。<br>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch11" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch11</a></p><blockquote><p>参考资料<br>1、JAVA设计模式十七—Composite(组合模式) - CSDN博客<br><a href="https://blog.csdn.net/hfmbook/article/details/7693069" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hfmbook/article/details/7693069</a><br>2、Java设计模式—组合模式 - CSDN博客<br><a href="https://blog.csdn.net/qq_25827845/article/details/52496522" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_25827845/article/details/52496522</a><br>3、组合模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/composite-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/composite-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。&lt;/p&gt;&lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十）代理模式</title>
    <link href="https://www.wshunli.com/posts/b4b3761.html"/>
    <id>https://www.wshunli.com/posts/b4b3761.html</id>
    <published>2018-09-10T08:12:52.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p>代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/10.Proxy.png" title="代理模式" alt="代理模式"></div><p>代理模式一般涉及到的角色有：</p><p>(1) 抽象角色：声明真实对象和代理对象的共同接口；<br>(2) 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装；<br>(3) 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p><p>1、抽象对象角色</p><pre><code class="lang-Java">public abstract class AbstractObject {    public abstract void operation();}</code></pre><p>2、目标对象角色</p><pre><code class="lang-Java">public class RealObject extends AbstractObject {    @Override    public void operation() {        System.out.println(&quot;RealObject.operation()&quot;);    }}</code></pre><p>3、代理对象角色</p><pre><code class="lang-Java">public class ProxyObject extends AbstractObject {    RealObject realObject = new RealObject();    @Override    public void operation() {        //调用目标对象之前可以做相关操作        System.out.println(&quot;before&quot;);        realObject.operation();        //调用目标对象之后可以做相关操作        System.out.println(&quot;after&quot;);    }}</code></pre><p>4、代理模式的使用</p><pre><code class="lang-Java">public class ProxyMain {    public static void main(String[] args) {        AbstractObject object = new ProxyObject();        object.operation();    }}</code></pre><p><strong>代理模式的优缺点</strong>：</p><p>优点：给对象增加了本地化的扩展性，增加了存取操作控制。<br>缺点：会产生多余的代理类。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch10" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch10</a></p><blockquote><p>参考资料<br>1、Java设计模式之代理模式(Proxy) - CSDN博客<br><a href="https://blog.csdn.net/liangbinny/article/details/18656791" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/liangbinny/article/details/18656791</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。&lt;/p&gt;&lt;p&gt;代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。&lt;/p&gt;&lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（九）装饰者模式</title>
    <link href="https://www.wshunli.com/posts/d95b685e.html"/>
    <id>https://www.wshunli.com/posts/d95b685e.html</id>
    <published>2018-09-10T06:37:20.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>动态的给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/9.Decorator.png" title="装饰者模式" alt="装饰者模式"></div><p>一般来说装饰者模式有下面几个参与者：</p><p>(1) Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为。<br>(2) ConcreteComponent：定义具体对象，即被装饰者。<br>(3) Decorator：抽象装饰者，继承自 Component ，从外类来扩展 ConcreteComponent 。对于 ConcreteComponent 来说，不需要知道 Decorator 的存在，Decorator 是一个接口或抽象类<br>(4) ConcreteDecorator：具体装饰者，用于扩展 ConcreteComponent 。</p><p>1、抽象构件角色 Component</p><pre><code class="lang-Java">public interface Component {    public void sampleOperation();}</code></pre><p>2、具体构件角色 ConcreteComponent</p><pre><code class="lang-Java">public class ConcreteComponent implements Component {    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteComponent.sampleOperation()&quot;);    }}</code></pre><p>3、装饰角色 Decorator</p><pre><code class="lang-Java">public class Decorator implements Component {    Component component;    public Decorator(Component component) {        this.component = component;    }    @Override    public void sampleOperation() {        // 委派给构件        component.sampleOperation();    }}</code></pre><p>4、具体装饰角色 ConcreteDecorator</p><pre><code class="lang-Java">public class ConcreteDecoratorA extends Decorator {    public ConcreteDecoratorA(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() end&quot;);    }}public class ConcreteDecoratorB extends Decorator {    public ConcreteDecoratorB(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() end&quot;);    }}</code></pre><p>5、装饰者模式的使用</p><pre><code class="lang-Java">public class DecoratorMain {    public static void main(String[] args) {        ConcreteComponent concreteComponent = new ConcreteComponent();        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);        concreteDecoratorA.sampleOperation();        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteComponent);        concreteDecoratorB.sampleOperation();    }}</code></pre><p><strong>装饰者模式的优缺点</strong>：</p><p>优点：装饰模式可以提供比继承更多的灵活性；通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>缺点：使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch09" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch09</a></p><blockquote><p>参考资料<br>1、学习、探究Java设计模式——装饰者模式 - CSDN博客<br><a href="https://blog.csdn.net/a553181867/article/details/52108423" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a553181867/article/details/52108423</a><br>2、Java设计模式之装饰者模式(Decorator pattern) - 简书<br><a href="https://www.jianshu.com/p/c26b9b4a9d9e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c26b9b4a9d9e</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;&lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（八）外观模式</title>
    <link href="https://www.wshunli.com/posts/82583d16.html"/>
    <id>https://www.wshunli.com/posts/82583d16.html</id>
    <published>2018-09-10T06:10:36.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/8.Facade.png" title="外观模式" alt="外观模式"></div><p>外观模式包含如下两个角色：</p><p>(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p><p>(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p><p>1、创建子系统角色类</p><pre><code class="lang-Java">public class ModuleA {    public void testA() {        System.out.println(&quot;ModuleA.testA()&quot;);    }}public class ModuleB {    public void testB() {        System.out.println(&quot;ModuleB.testB()&quot;);    }}public class ModuleC {    public void testC() {        System.out.println(&quot;ModuleC.testC()&quot;);    }}</code></pre><p>2、创建外观角色类</p><pre><code class="lang-Java">public class Facade {    public void test() {        ModuleA a = new ModuleA();        a.testA();        ModuleB b = new ModuleB();        b.testB();        ModuleC c = new ModuleC();        c.testC();    }}</code></pre><p>3、外观模式使用</p><pre><code class="lang-Java">public class FacadeMain {    public static void main(String[] args) {        Facade facade = new Facade();        facade.test();    }}</code></pre><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</p><p><strong>外观模式的优缺点</strong>：</p><p>优点：客户代码将变得很简单，与之关联的对象也很少；降低了大型软件系统中的编译依赖性。<br>缺点：不能很好地限制客户使用子系统类；增加新的子系统可能需要修改外观类或客户端的源代码。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch08" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch08</a></p><blockquote><p>参考资料<br>1、深入浅出外观模式（一） · 设计模式Java版<br><a href="https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html" rel="external nofollow noopener noreferrer" target="_blank">https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html</a><br>2、浅谈JAVA设计模式之——外观模式(Facade) - CSDN博客<br><a href="https://blog.csdn.net/l1028386804/article/details/45568655" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/l1028386804/article/details/45568655</a><br>3、java中的外观模式（门面模式） - 简书<br><a href="https://www.jianshu.com/p/1424c90ca255" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/1424c90ca255</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。&lt;/p&gt;&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（七）适配器模式</title>
    <link href="https://www.wshunli.com/posts/69ceed63.html"/>
    <id>https://www.wshunli.com/posts/69ceed63.html</id>
    <published>2018-09-10T01:13:31.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</p><p>适配器模式有 <strong>类的适配器模式和对象的适配器模式</strong> 两种不同的形式。</p><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类的适配器模式把适配的类的 API 转换成为目标类的 API 。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ClassAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，提供一个中间环节，即类 Adapter ，把 Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是继承关系，这决定了这个适配器模式是类的。</p><p>模式所涉及的角色有：</p><p>(1)目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</p><p>(2)源(Adapee)角色：现在需要适配的接口。</p><p>(3)适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色 ClassAdapter 扩展了 Adaptee ,同时又实现了目标(Target)接口。</p><pre><code class="lang-Java">public class ClassAdapter extends Adaptee implements Target {    /**     * 由于源类Adaptee没有方法sampleOperation2()     * 因此适配器补充上这个方法     */    @Override    public void sampleOperation2() {        System.out.println(&quot;ClassAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的 API 转换成为目标类的 API。</p><p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用委派关系连接到 Adaptee 类。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ObjectAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，需要提供一个包装(Wrapper)类 Adapter。这个包装类包装了一个 Adaptee 的实例，从而此包装类能够把Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是委派关系，这决定了适配器模式是对象的。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色</p><pre><code class="lang-Java">public class ObjectAdapter {    private Adaptee adaptee;    public ObjectAdapter(Adaptee adaptee) {        this.adaptee = adaptee;    }    /**     * 源类Adaptee有方法sampleOperation1     * 因此适配器类直接委派即可     */    public void sampleOperation1() {        this.adaptee.sampleOperation1();    }    /**     * 源类Adaptee没有方法sampleOperation2     * 因此由适配器类需要补充此方法     */    public void sampleOperation2() {        System.out.println(&quot;ObjectAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="类适配器和对象适配器的权衡"><a href="#类适配器和对象适配器的权衡" class="headerlink" title="类适配器和对象适配器的权衡"></a>类适配器和对象适配器的权衡</h2><p>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。</p><p>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><p>在 Android 开发过程中, ListView 的 Adapter 是我们最为常见的类型之一。</p><p><strong>适配器模式的优缺点</strong>：</p><p>优点：更好的复用性、更好的扩展性。<br>缺点：过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch07" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch07</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之适配器模式 - java_my_life - 博客园<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a><br>2、JAVA学习笔记—策略设计模式与适配器模式 - tongye - 博客园<br><a href="https://www.cnblogs.com/tongye/p/6676039.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/tongye/p/6676039.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（六）原型模式</title>
    <link href="https://www.wshunli.com/posts/b7ba42b9.html"/>
    <id>https://www.wshunli.com/posts/b7ba42b9.html</id>
    <published>2018-09-07T14:31:45.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/6.Prototype.png" alt="原型模式"></p><p>原型模式的参与角色:</p><p>(1) 客户角色：客户类提出创建对象的请求。</p><p>(2) 抽象原型角色：这是一个抽象角色，通常由一个java接口或抽象类实现，具体原型都需要实现该接口。</p><p>(3) 具体原型角色：客户端所需要的被复制的对象。</p><p>1、创建抽象原型角色</p><pre><code class="lang-Java">public class Prototype implements Cloneable {    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}</code></pre><p>2、创建具体原型角色</p><pre><code class="lang-Java">public class ConcretePrototype1 extends Prototype {    public static int classFlag = 1;    @Override    protected ConcretePrototype1 clone() throws CloneNotSupportedException {        return (ConcretePrototype1) super.clone();    }}public class ConcretePrototype2 extends Prototype {    public static int classFlag = 2;    @Override    protected ConcretePrototype2 clone() throws CloneNotSupportedException {        return (ConcretePrototype2) super.clone();    }}</code></pre><p>3、原型模式的使用</p><pre><code class="lang-Java">public class PrototypePatternMain {    public static void main(String[] args) throws CloneNotSupportedException {        Prototype prototype1 = new ConcretePrototype1();        ConcretePrototype1 concretePrototype1 = (ConcretePrototype1) prototype1.clone();        System.out.println(concretePrototype1.classFlag);        Prototype prototype2 = new ConcretePrototype2();        ConcretePrototype2 concretePrototype2 = (ConcretePrototype2) prototype2.clone();        System.out.println(concretePrototype2.classFlag);    }}</code></pre><p>优点：1、性能提高。2、逃避构造函数的约束。</p><p>缺点：1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。2、必须实现 Cloneable 接口。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch06" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch06</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之原型模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html</a><br>2、23种设计模式（5）：原型模式 - CSDN博客<br><a href="https://blog.csdn.net/zhengzhb/article/details/7393528" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhengzhb/article/details/7393528</a><br>3、java中的原型模式 - 简书<br><a href="https://www.jianshu.com/p/4e1f2d090f20" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4e1f2d090f20</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;&lt;h1 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（五）建造者模式</title>
    <link href="https://www.wshunli.com/posts/325f89c7.html"/>
    <id>https://www.wshunli.com/posts/325f89c7.html</id>
    <published>2018-09-07T10:07:47.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/5.Builder.png" alt="建造者模式"></p><p>建造者模式中的四个要素：</p><p>(1) 产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。</p><p>(2) 抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。</p><p>(3) 建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。</p><p>(4) 导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。</p><p>1、构造产品实例类</p><pre><code class="lang-Java">public class Product {    private String name;    private String type;    private String size;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public String getSize() {        return size;    }    public void setSize(String size) {        this.size = size;    }    @Override    public String toString() {        return &quot;Product{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, type=&#39;&quot; + type + &#39;\&#39;&#39; +                &quot;, size=&#39;&quot; + size + &#39;\&#39;&#39; +                &#39;}&#39;;    }    public void show() {        System.out.println(this.toString());    }}</code></pre><p>2、抽象建造者</p><pre><code class="lang-Java">public abstract class Builder {    public abstract void name(String name);    public abstract void type(String type);    public abstract void size(String size);    public abstract Product build();}</code></pre><p>3、建造者实例</p><pre><code class="lang-Java">public class ConcreteBuilder extends Builder {    private Product product = new Product();    @Override    public void name(String name) {        product.setName(name);    }    @Override    public void type(String type) {        product.setType(type);    }    @Override    public void size(String size) {        product.setSize(size);    }    public Product build() {        return product;    }}</code></pre><p>4、导演类</p><pre><code class="lang-Java">public class Director {    private Builder builder = new ConcreteBuilder();    public Product getAProduct() {        builder.name(&quot;Burger&quot;);        builder.type(&quot;Wrapper&quot;);        builder.size(&quot;big&quot;);        return builder.build();    }    public Product getBProduct() {        builder.name(&quot;Coke&quot;);        builder.type(&quot;Bottle&quot;);        builder.size(&quot;small&quot;);        return builder.build();    }}</code></pre><p>5、建造者模式的使用</p><pre><code class="lang-Java">public class BuilderPatternMain {    public static void main(String[] args) {        Director director = new Director();        Product aProduct = director.getAProduct();        aProduct.show();        Product bProduct = director.getBProduct();        bProduct.show();    }}</code></pre><p>优点：1、建造者独立，易扩展。2、便于控制细节风险。</p><p>缺点：1、产品必须有共同点，范围有限制。2、如内部变化复杂，会有很多的建造类。</p><p>使用场景：1、需要生成的对象具有复杂的内部结构。2、需要生成的对象内部属性本身相互依赖。</p><p>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch05" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch05</a></p><blockquote><p>参考资料<br>1、建造者模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/builder-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/builder-pattern.html</a><br>2、建造者模式（Builder Pattern）- 最易懂的设计模式解析 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/54910597" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/54910597</a><br>3、23种设计模式（4）：建造者模式 - CSDN博客<br><a href="https://blog.csdn.net/zhengzhb/article/details/7375966" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhengzhb/article/details/7375966</a><br>4、Java 设计模式 — 建造者模式 - 简书<br><a href="https://www.jianshu.com/p/7d16da4e61b8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/7d16da4e61b8</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;&lt;h1 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（四）抽象工厂模式</title>
    <link href="https://www.wshunli.com/posts/4e3be4ad.html"/>
    <id>https://www.wshunli.com/posts/4e3be4ad.html</id>
    <published>2018-09-07T07:45:07.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>工厂模式可以分为三类：</p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p><p>本文及主要介绍抽象工厂模式。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式 (Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，属于对象创建型模式。</p><p>抽象工厂模式中，一个工厂可以提供多个不同种类产品对象，而不是单一种类的产品对象。</p><p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p><p><strong>产品等级结构</strong>： 产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p><strong>产品族</strong>： 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</p><p>抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong>，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/4.AbstractFactory.png" alt="抽象工厂模式"></p><p>抽象工厂模式包含角色和工厂方法模式相同。</p><p>假设有一个移动终端工厂，可以制造苹果系列的移动产品和华为系列的移动产品。<br>这个工厂下有两个子厂，一个负责制造苹果系列的 Pad 和华为系列的 Pad ，另一个负责制造苹果系列的手机和华为系列的手机。这便是一个典型的抽象工厂的实例。</p><p>1、创建产品产品接口</p><pre><code class="lang-Java">// 苹果系列public interface Apple {    void AppleStyle();}// 华为系列public interface Huawei {    void HuaweiStyle();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">// 苹果系列产品public class iPhone implements Apple {    @Override    public void AppleStyle() {        System.out.println(&quot;Apple&#39;s style: iPhone!&quot;);    }}public class iPad implements Apple {    @Override    public void AppleStyle() {        System.out.println(&quot;Apple&#39;s style: iPad!&quot;);    }}// 华为系列产品public class Honor implements Huawei {    @Override    public void HuaweiStyle() {        System.out.println(&quot;Huawei&#39;s style: Honor!&quot;);    }}public class HuaweiPad implements Huawei {    @Override    public void HuaweiStyle() {        System.out.println(&quot;Huawei&#39;s style: HuaweiPad!&quot;);    }}</code></pre><p>3、创建抽象工厂接口</p><pre><code class="lang-Java">public interface Factory {    Apple createAppleProduct();    Huawei createHuaweiProduct();}</code></pre><p>4、实现具体工厂类，生成实例对象，和工厂方法模式的核心区别</p><pre><code class="lang-Java">// 手机工厂public class PhoneFactory implements Factory {    @Override    public Apple createAppleProduct() {        return new iPhone();    }    @Override    public Huawei createHuaweiProduct() {        return new Honor();    }}// 平板工厂public class PadFactory implements Factory {    @Override    public Apple createAppleProduct() {        return new iPad();    }    @Override    public Huawei createHuaweiProduct() {        return new HuaweiPad();    }}</code></pre><p>5、调用不同工厂的方法生成实例对象</p><pre><code class="lang-Java">public class AbstractFactoryMain {    public static void main(String[] args) {        Factory factory = new PhoneFactory();        Apple apple = factory.createAppleProduct();        apple.AppleStyle();        Huawei huawei = factory.createHuaweiProduct();        huawei.HuaweiStyle();        factory = new PadFactory();        apple = factory.createAppleProduct();        apple.AppleStyle();        huawei = factory.createHuaweiProduct();        huawei.HuaweiStyle();    }}</code></pre><p><strong>抽象工厂模式优缺点</strong>:</p><p>优点:<br>1、抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。<br>2、增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合“开闭原则”。</p><p>缺点：<br>1、在添加新的产品对象（不同于现有的产品等级结构）时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。<br>2、开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</p><p><strong>适用环境</strong>：</p><p>1、一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>2、系统中有多于一个的产品族，而每次只使用其中某一产品族。<strong>与工厂方法模式的区别</strong>。<br>3、属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>4、系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch04" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch04</a></p><blockquote><p>参考资料<br>1、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a><br>2、《JAVA与模式》之抽象工厂模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;/p&gt;&lt;p&gt;工厂模式可以分为三类：&lt;/p&gt;&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽象工厂模
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（三）工厂方法模式</title>
    <link href="https://www.wshunli.com/posts/4982f93c.html"/>
    <id>https://www.wshunli.com/posts/4982f93c.html</id>
    <published>2018-09-07T07:40:09.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>工厂模式可以分为三类：</p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p><p>本文及主要介绍工厂方法模式。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式 (Factory Method Pattern) 又称为工厂模式，也叫虚拟构造器 (Virtual Constructor) 模式或者多态工厂( Polymorphic Factory) 模式，它属于类创建型模式。</p><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/3.FactoryMethod.png" alt="工厂方法模式"></p><p>工厂方法模式包含如下角色：</p><p>(1) Product：抽象产品，工厂方法模式所创建的对象的超类，也就是所有产品类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>(2) ConcreteProduct：具体产品，这个角色实现了抽象产品（Product）所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品的实例。</p><p>(3) Factory：抽象工厂，担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>(4) ConcreteFactory：具体工厂，担任这个角色的是实现了抽象工厂接口的具体 Java 类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建具体产品对象。</p><p>1、创建抽象产品接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">public class Point implements Shape {    @Override    public void draw() {        System.out.println(&quot;Point.draw()&quot;);    }}public class Line implements Shape {    @Override    public void draw() {        System.out.println(&quot;Line.draw()&quot;);    }}public class Plane implements Shape {    @Override    public void draw() {        System.out.println(&quot;Plane.draw()&quot;);    }}</code></pre><p>以上内容和简单工厂模式相同。</p><p>3、创建抽象工厂接口</p><pre><code class="lang-Java">public interface ICreator {    Shape getShape();}</code></pre><p>4、实现具体工厂类，生成实例对象</p><pre><code class="lang-Java">public class PointCreator implements ICreator {    @Override    public Shape getShape() {        return new Point();    }}public class LineCreator implements ICreator {    @Override    public Shape getShape() {        return new Line();    }}public class PlaneCreator implements ICreator {    @Override    public Shape getShape() {        return new Plane();    }}</code></pre><p>5、调用不同工厂的方法生成实例对象</p><pre><code class="lang-Java">public class FactoryMethodMain {    public static void main(String[] args) {        ICreator creator = new PointCreator();        Shape shape = creator.getShape();        shape.draw();        creator = new LineCreator();        shape = creator.getShape();        shape.draw();        creator = new PlaneCreator();        shape = creator.getShape();        shape.draw();    }}</code></pre><p><strong>工厂方法模式的优缺点</strong>:</p><p>优点：<br>1、在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。<br>2、基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。<br>3、使用工厂方法模式的另一个优点是在系统中加入新产品时，只要添加一个具体工厂和具体产品就可以了。</p><p>缺点：<br>1、在添加新产品时，需要编写新的具体产品类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度。<br>2、由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p><p><strong>适用场景</strong>：</p><p>1、一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。<br>2、一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>3、将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch03" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch03</a></p><blockquote><p>参考资料<br>1、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;/p&gt;&lt;p&gt;工厂模式可以分为三类：&lt;/p&gt;&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽象工厂模
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（二）简单工厂模式</title>
    <link href="https://www.wshunli.com/posts/6ae09785.html"/>
    <id>https://www.wshunli.com/posts/6ae09785.html</id>
    <published>2018-09-07T07:39:09.000Z</published>
    <updated>2018-12-18T16:32:52.005Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>工厂模式可以分为三类：</p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p><p>本文及主要介绍简单工厂模式。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>在简单工厂模式中，可以根据参数的不同返回不同类的实例。</p><p>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/2.SimpleFactory.png" alt="简单工厂模式"></p><p>简单工厂模式包含如下角色：</p><p>(1) Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑。</p><p>(2) Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的 <strong>公共接口</strong> 。</p><p>(3) ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p><p>1、创建抽象产品接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">public class Point implements Shape {    @Override    public void draw() {        System.out.println(&quot;Point.draw()&quot;);    }}public class Line implements Shape {    @Override    public void draw() {        System.out.println(&quot;Line.draw()&quot;);    }}public class Plane implements Shape {    @Override    public void draw() {        System.out.println(&quot;Plane.draw()&quot;);    }}</code></pre><p>3、工厂角色，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    // 使用 getShape 方法获取形状类型的对象    public Shape getShape(String shapeType) {        if (shapeType == null) {            return null;        }        if (shapeType.equalsIgnoreCase(&quot;POINT&quot;)) {            return new Point();        } else if (shapeType.equalsIgnoreCase(&quot;LINE&quot;)) {            return new Line();        } else if (shapeType.equalsIgnoreCase(&quot;PLANE&quot;)) {            return new Plane();        }        return null;    }}</code></pre><p>4、使用该工厂，通过传递类型信息来获取实体类的对象</p><pre><code class="lang-Java">public class SimpleFactoryMain {    public static void main(String[] args) {        ShapeFactory shapeFactory = new ShapeFactory();        //获取 Point 的对象，并调用它的 draw 方法        Shape shape1 = shapeFactory.getShape(&quot;POINT&quot;);        //调用 Point 的 draw 方法        shape1.draw();        //获取 Line 的对象，并调用它的 draw 方法        Shape shape2 = shapeFactory.getShape(&quot;LINE&quot;);        //调用 Line 的 draw 方法        shape2.draw();        //获取 Plane 的对象，并调用它的 draw 方法        Shape shape3 = shapeFactory.getShape(&quot;PLANE&quot;);        //调用 Plane 的 draw 方法        shape3.draw();    }}</code></pre><p><strong>简单工厂模式优缺点</strong>:</p><p>优点：<br>通过使用工厂类，外界不再需要关心如何创造各种具体的产品，只要提供一个产品的名称作为参数传给工厂，就可以直接得到一个想要的产品对象，并且可以按照接口规范来调用产品对象的所有功能（方法）。构造容易，逻辑简单。</p><p>缺点：<br>1、简单工厂模式中的 if else 判断非常多，当系统中的具体产品类不断增多时候，就要不断的修改工厂类，对系统的维护和扩展不利。<br>2、一个工厂类中集合了所有的类的实例创建逻辑，什么时候它不能工作了，整个系统都会受到影响。<br>3、简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p><p><strong>适用场景</strong>：</p><p>1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch02" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch02</a></p><blockquote><p>参考资料<br>1、工厂模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/factory-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/factory-pattern.html</a><br>2、JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式) - CSDN博客<br><a href="https://blog.csdn.net/jason0539/article/details/23020989" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/jason0539/article/details/23020989</a><br>3、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;/p&gt;&lt;p&gt;工厂模式可以分为三类：&lt;/p&gt;&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽象工厂模
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
</feed>
