<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2017-12-08T14:50:58.576Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《第一行代码》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/b6bcc7db.html"/>
    <id>http://www.wshunli.com/posts/b6bcc7db.html</id>
    <published>2017-12-06T07:35:48.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件</p><a id="more"></a><p>Android 应用的四大组件 Activity，Service，Broadcast Receiver， Content Provider 最为核心。</p><h1 id="第2章-先从看得到的入手"><a href="#第2章-先从看得到的入手" class="headerlink" title="第2章 先从看得到的入手"></a>第2章 先从看得到的入手</h1><p>Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片或查看地图等操作。</p><h2 id="Activity-创建及销毁"><a href="#Activity-创建及销毁" class="headerlink" title="Activity 创建及销毁"></a>Activity 创建及销毁</h2><p>要创建 Activity，必须创建 <a href="https://developer.android.com/reference/android/app/Activity.html" rel="external nofollow noopener noreferrer" target="_blank">Activity</a> 的子类（或使用其现有子类）。</p><h3 id="实现用户界面"><a href="#实现用户界面" class="headerlink" title="实现用户界面"></a>实现用户界面</h3><p>Activity 的用户界面是由层级式视图 — 衍生自 View 类的对象 — 提供的，也可以利用 Android 提供的现成视图设计和组织布局。</p><p>利用视图定义布局的最常见方法是借助保存在您的应用资源内的 XML 布局文件。</p><pre><code class="Java">setContentView(R.layout.activity_main);</code></pre><p>不过，也可以在 Activity 代码中创建新 View，并通过将新 View 插入 ViewGroup 来创建视图层次，然后通过将根 ViewGroup 传递到 setContentView() 来使用该布局。</p><h3 id="在清单文件中声明-Activity"><a href="#在清单文件中声明-Activity" class="headerlink" title="在清单文件中声明 Activity"></a>在清单文件中声明 Activity</h3><p>Activity 需要在 清单文件 中声明。</p><pre><code class="XML">&lt;manifest ... &gt;  &lt;application ... &gt;    &lt;activity android:name=&quot;.MainActivity&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    ...  &lt;/application ... &gt;  ...&lt;/manifest &gt;</code></pre><p><code>&lt;action&gt;</code> 元素指定这是应用的“主”入口点。<br><code>&lt;category&gt;</code> 元素指定此 Activity 应列入系统的应用启动器内（以便用户启动该 Activity）。</p><h3 id="结束-Activity"><a href="#结束-Activity" class="headerlink" title="结束 Activity"></a>结束 Activity</h3><p>通过调用 Activity 的 finish() 方法来结束该 Activity。</p><h2 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h2><h3 id="Activity-状态"><a href="#Activity-状态" class="headerlink" title="Activity 状态"></a>Activity 状态</h3><p>Activity 在其生命周期中最多有4种状态：</p><ul><li>运行状态：Activity 位于屏幕前台并具有用户焦点。</li><li>暂停状态：另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。</li><li>停止状态：该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。</li><li>销毁状态：系统结束 Activity （调用其 finish() 方法）或直接终止其进程，将其从内存中删除。</li></ul><h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>当一个 Activity 转入和转出上述不同状态时，系统会通过各种回调方法向其发出通知。</p><pre><code class="Java">public class ExampleActivity extends Activity {    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // The activity is being created.    }    @Override    protected void onStart() {        super.onStart();        // The activity is about to become visible.    }    @Override    protected void onResume() {        super.onResume();        // The activity has become visible (it is now &quot;resumed&quot;).    }    @Override    protected void onPause() {        super.onPause();        // Another activity is taking focus (this activity is about to be &quot;paused&quot;).    }    @Override    protected void onStop() {        super.onStop();        // The activity is no longer visible (it is now &quot;stopped&quot;)    }    @Override    protected void onDestroy() {        super.onDestroy();        // The activity is about to be destroyed.    }}</code></pre><p>这些方法共同定义 Activity 的整个生命周期。可以通过实现这些方法监控 Activity 生命周期中的三个嵌套循环：</p><ul><li>Activity 的 <strong>完整生命周期</strong> 发生在 onCreate() 与 onDestroy() 之间，就是完整的生存期。</li><li>Activity 的 <strong>可见生命周期</strong> 发生在 onStart() 与 onStop() 之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。</li><li>Activity 的 <strong>前台生命周期</strong> 发生在 onResume() 与 onPause() 之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。</li></ul><p><img src="https://img.wshunli.com/Android/第一行代码/2.activity_lifecycle.png" alt="activity_lifecycle"></p><h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><p>第4章 手机平板要兼容</p><p>第5章 全局大喇叭</p><p>第7章 跨程序共享数据</p><p>第10章 后台默默的劳动者</p><blockquote><p>参考资料<br>1、Activity | Android Developers<br><a href="https://developer.android.com/guide/components/activities.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/activities.html</a><br>2、Activity/Service 生命周期 · 笔试面试知识整理<br><a href="https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html" rel="external nofollow noopener noreferrer" target="_blank">https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/df51fd76.html"/>
    <id>http://www.wshunli.com/posts/df51fd76.html</id>
    <published>2017-12-06T03:33:44.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 平台架构</p><a id="more"></a><p>我最开始学习 Android 是在 2014 年下半年，看的是《疯狂Android讲义》。</p><p>在 2015 年参加 ESRI 中国组织的 GIS 开发大赛，也是主要在暑假学习了不少 Android 入门知识。</p><p>后面在较长一段时间，感觉停滞在 Android 入门的水平不前。也有尝试在项目中使用一些优秀的框架或者类库，但是感觉自身的水平并没有多大的提高。</p><p>所以有意在前面学习计算机基础、Java 语言基础，后面打算深入之后学习下数据结构及算法。也为明年找工作做准备。</p><p>其实这本书 《第一行代码》 在考研结束以后已经看过一遍了，这次再复习一遍，毕竟有一段时间没有具体做 Android 开发了，再者希望能记忆一些常用的知识点。</p><h1 id="第1章-开启启程"><a href="#第1章-开启启程" class="headerlink" title="第1章 开启启程"></a>第1章 开启启程</h1><h2 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h2><p>总的来说，Android的系统体系结构分为四层，自顶向下分别是：</p><ul><li>应用程序(Applications)</li><li>应用程序框架(Application Frameworks)</li><li>系统运行库与 Android 运行环境(Libraris &amp; Android Runtime)</li><li>Linux 核心层</li></ul><p><img src="https://img.wshunli.com/Android/第一行代码/1.Android系统架构.png" alt="1.Android系统架构"></p><h3 id="Linux核心层"><a href="#Linux核心层" class="headerlink" title="Linux核心层"></a>Linux核心层</h3><p><strong>Linux 内核</strong>(Linux Kernel)<br>Android 平台的基础是 Linux 内核，Linux 内核直接和硬件打交道。硬件驱动、进程管理、内存管理、网络管理的功能在这里实现。</p><p><strong>硬件抽象层</strong>(Hardware Abstraction Layer)<br>硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。<br>HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。</p><h3 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h3><p><strong>Android 运行环境</strong>(Android Runtime)<br>每个应用都在其自己的进程中运行，有其自己的 Android Runtime (ART) 实例（Android 5.0 之前是 Dalvik）。<br>并且 Android 还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能。</p><p><strong>原生C/C++ 库</strong>(Native C/C++ Libraries)<br>许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。<br>Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。</p><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><p><strong>Java API 框架</strong>(Java API Framework)</p><p>提供构建应用的各种 API 。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器。</li><li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件。</li><li>通知管理器，可让所有应用在状态栏中显示自定义提醒。</li><li>Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈。</li><li>内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据。</li></ul><p>开发者可以完全访问 Android 系统应用使用的框架 API。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>系统应用</strong>(System Apps)</p><p>所有安装在手机上的应用程序都属于应用层，包括系统自带的软件和自己开发的软件。</p><h2 id="搭建-Android-开发环境"><a href="#搭建-Android-开发环境" class="headerlink" title="搭建 Android 开发环境"></a>搭建 Android 开发环境</h2><p>前面已经写过了，不再重复。<br>《ArcGIS Runtime SDK for Android学习笔记》-1、Android开发环境搭建 | CirGIS<br><a href="https://www.wshunli.com/posts/f6977dbb.html">https://www.wshunli.com/posts/f6977dbb.html</a></p><blockquote><p>参考资料<br>1、平台架构 | Android Developers<br><a href="https://developer.android.com/guide/platform/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/platform/index.html</a><br>2、Android系统架构简介 - 简书<br><a href="http://www.jianshu.com/p/69f0d25c727a" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/69f0d25c727a</a><br>3、Android系统架构介绍 - LCore的专栏 - CSDN博客<br><a href="http://blog.csdn.net/lcore/article/details/20993367" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/lcore/article/details/20993367</a><br>4、android系统体系结构 - CSDN博客<br><a href="http://blog.csdn.net/spy19881201/article/details/5775484" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/spy19881201/article/details/5775484</a><br>5、Android系统开篇 - Gityuan博客 | 袁辉辉博客<br><a href="http://gityuan.com/android/" rel="external nofollow noopener noreferrer" target="_blank">http://gityuan.com/android/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 平台架构&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（九）</title>
    <link href="http://www.wshunli.com/posts/8c5a6523.html"/>
    <id>http://www.wshunli.com/posts/8c5a6523.html</id>
    <published>2017-12-05T09:51:24.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— Java I/O 系统。</p><a id="more"></a><p>第18章 <strong>Java I/O 系统</strong></p><h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h1><p>File 类不仅仅可以代表一个特定文件的名称，还可以代表一个目录下的一组文件的名称。</p><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><blockquote><p>参考资料<br>1、Java 编程思想（六）Java I/O - Invoker’s Tower - CSDN博客<br><a href="http://blog.csdn.net/kingcat666/article/details/78027078" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/kingcat666/article/details/78027078</a><br>2、java基础学习总结——流 - 孤傲苍狼 - 博客园<br><a href="http://www.cnblogs.com/xdp-gacl/p/3634409.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/xdp-gacl/p/3634409.html</a><br>3、《Java编程思想》学习笔记11——Java I/O - CSDN博客<br><a href="http://blog.csdn.net/chjttony/article/details/6966246" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/chjttony/article/details/6966246</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— Java I/O 系统。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（八）</title>
    <link href="http://www.wshunli.com/posts/f697447c.html"/>
    <id>http://www.wshunli.com/posts/f697447c.html</id>
    <published>2017-12-05T09:46:52.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 容器深入研究。</p><a id="more"></a><p>第17章 <strong>容器深入研究</strong></p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java容器1.png" alt="Java容器"></p><p>先占坑。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 容器深入研究。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（七）</title>
    <link href="http://www.wshunli.com/posts/1fc6c3f.html"/>
    <id>http://www.wshunli.com/posts/1fc6c3f.html</id>
    <published>2017-12-04T13:54:10.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类型信息及泛型。</p><a id="more"></a><h1 id="第14章-类型信息"><a href="#第14章-类型信息" class="headerlink" title="第14章 类型信息"></a>第14章 类型信息</h1><p>RTTI (Run-Time Type Identification, 运行时类型识别) 是 Java 中非常有用的机制。</p><pre><code class="Java">abstract class Shape {  void draw() { System.out.println(this + &quot;.draw()&quot;); }  abstract public String toString();}class Circle extends Shape {  public String toString() { return &quot;Circle&quot;; }}class Square extends Shape {  public String toString() { return &quot;Square&quot;; }}public class Shapes {  public static void main(String[] args) {    List&lt;Shape&gt; shapeList = Arrays.asList(      new Circle(), new Square()    );    for(Shape shape : shapeList) shape.draw();  }}/* Output:Circle.draw()Square.draw()*/</code></pre><p>在Java运行时，RTTI 维护类的相关信息，识别一个对象的类型。</p><p>1.Class 对象</p><p>类是程序的一部分，每个类都有一个Class对象。</p><pre><code class="Java">interface HasBatteries {}interface Waterproof {}interface Shoots {}class Toy {  // Comment out the following default constructor  // to see NoSuchMethodError from (*1*)  Toy() {}  Toy(int i) {}}class FancyToy extends Toyimplements HasBatteries, Waterproof, Shoots {  FancyToy() { super(1); }}public class ToyTest {  static void printInfo(Class cc) {    print(&quot;Class name: &quot; + cc.getName() + // 全限定的类型      &quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;); // Class 对象是否表示某接口    print(&quot;Simple name: &quot; + cc.getSimpleName()); // 不含包名的类名    print(&quot;Canonical name : &quot; + cc.getCanonicalName()); // 含包名的类名  }  public static void main(String[] args) {    Class c = null;    try {      c = Class.forName(&quot;typeinfo.toys.FancyToy&quot;); // 获取 Class 对象的引用    } catch(ClassNotFoundException e) {      print(&quot;Can&#39;t find FancyToy&quot;);      System.exit(1);    }    printInfo(c);    for(Class face : c.getInterfaces()) // 获取 Class 对象中包含的接口      printInfo(face);    Class up = c.getSuperclass(); // 获取 Class 对象的直接基类    Object obj = null;    try {      // Requires default constructor:      obj = up.newInstance(); // 实现虚拟构造器    } catch(InstantiationException e) {      print(&quot;Cannot instantiate&quot;);      System.exit(1);    } catch(IllegalAccessException e) {      print(&quot;Cannot access&quot;);      System.exit(1);    }    printInfo(obj.getClass());  }} /* Output:Class name: typeinfo.toys.FancyToy is interface? [false]Simple name: FancyToyCanonical name : typeinfo.toys.FancyToyClass name: typeinfo.toys.HasBatteries is interface? [true]Simple name: HasBatteriesCanonical name : typeinfo.toys.HasBatteriesClass name: typeinfo.toys.Waterproof is interface? [true]Simple name: WaterproofCanonical name : typeinfo.toys.WaterproofClass name: typeinfo.toys.Shoots is interface? [true]Simple name: ShootsCanonical name : typeinfo.toys.ShootsClass name: typeinfo.toys.Toy is interface? [false]Simple name: ToyCanonical name : typeinfo.toys.Toy*/</code></pre><p>2.类加载器是通过判断这个类包含的Class对象是否已经加载来判断它是否已经加载过这个类。为使用类而做的准备工作实际上包括三个步骤：</p><p>1 加载。这个由类加载器去完成。查找相关的字节码，并从这些字节码中创建一个Class对象。<br>2 链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且必须的话将解析这个类创建的对其他类的引用。<br>3 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了静态方法或者静态域进行首次引用时才执行。</p><pre><code class="Java">class Initable {  static final int staticFinal = 47;  static final int staticFinal2 =    ClassInitialization.rand.nextInt(1000);  static {    System.out.println(&quot;Initializing Initable&quot;);  }}class Initable2 {  static int staticNonFinal = 147;  static {    System.out.println(&quot;Initializing Initable2&quot;);  }}class Initable3 {  static int staticNonFinal = 74;  static {    System.out.println(&quot;Initializing Initable3&quot;);  }}public class ClassInitialization {  public static Random rand = new Random(47);  public static void main(String[] args) throws Exception {    Class initable = Initable.class;    System.out.println(&quot;After creating Initable ref&quot;);    // Does not trigger initialization:    System.out.println(Initable.staticFinal);    // Does trigger initialization:    System.out.println(Initable.staticFinal2);    // Does trigger initialization:    System.out.println(Initable2.staticNonFinal);    Class initable3 = Class.forName(&quot;Initable3&quot;);    System.out.println(&quot;After creating Initable3 ref&quot;);    System.out.println(Initable3.staticNonFinal);  }} /* Output:After creating Initable ref47Initializing Initable258Initializing Initable2147Initializing Initable3After creating Initable3 ref74*/</code></pre><p>3.instanceof</p><p>返回一个布尔值，判断对象是不是某个特定类型的实例。</p><pre><code class="Java">x instanceof Boy</code></pre><p>4.反射：运行时的类信息</p><p>反射机制是在运行状态中，<br>对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取的信息以及动态调用对象的方法的功能称为反射。</p><p>5.动态代理</p><p>代理是一本基本的设计模式；代理通常充当着中间人的角色。</p><h1 id="第15章-泛型"><a href="#第15章-泛型" class="headerlink" title="第15章 泛型"></a>第15章 泛型</h1><p>Java SE5 泛型实现了参数化类型的概念，使代码可以应用于多种类型。</p><p>泛型的出现，最引人注目的原因是为了创造容器类</p><p>一个只能持有单个对象的类：</p><pre><code class="Java">public class Holder {  private Automobile a;  public Holder(Automobile a) { this.a = a; }  Automobile get() { return a; }}</code></pre><p>显然，Holder 类的重用性很差，只能持有 Automobile 类对象。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><pre><code class="Java">public class Holder3&lt;T&gt; {  private T a;  public Holder3(T a) { this.a = a; }  public void set(T a) { this.a = a; }  public T get() { return a; }  public static void main(String[] args) {    Holder3&lt;Automobile&gt; h3 =      new Holder3&lt;Automobile&gt;(new Automobile());    Automobile a = h3.get(); // No cast needed    // h3.set(&quot;Not an Automobile&quot;); // Error    // h3.set(1); // Error  }}</code></pre><p>告诉编译器使用什么类型，然后编译器帮你处理一切细节。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口；例如生成器，这是一种专门负责创建对象的类。</p><p>生成器接口定义如下：</p><pre><code class="Java">public interface Generator&lt;T&gt; { T next(); }</code></pre><p>实现生成器接口</p><pre><code class="Java">public class CoffeeGeneratorimplements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt; {  private Class[] types = { Latte.class, Mocha.class,    Cappuccino.class, Americano.class, Breve.class, };  private static Random rand = new Random(47);  public CoffeeGenerator() {}  // For iteration:  private int size = 0;  public CoffeeGenerator(int sz) { size = sz; }  public Coffee next() {    try {      return (Coffee)        types[rand.nextInt(types.length)].newInstance();      // Report programmer errors at run time:    } catch(Exception e) {      throw new RuntimeException(e);    }  }  class CoffeeIterator implements Iterator&lt;Coffee&gt; {    int count = size;    public boolean hasNext() { return count &gt; 0; }    public Coffee next() {      count--;      return CoffeeGenerator.this.next();    }    public void remove() { // Not implemented      throw new UnsupportedOperationException();    }  };  public Iterator&lt;Coffee&gt; iterator() {    return new CoffeeIterator();  }  public static void main(String[] args) {    CoffeeGenerator gen = new CoffeeGenerator();    for(int i = 0; i &lt; 5; i++)      System.out.println(gen.next());    for(Coffee c : new CoffeeGenerator(5))      System.out.println(c);  }} /* Output:Americano 0Latte 1Americano 2Mocha 3Mocha 4Breve 5Americano 6Latte 7Cappuccino 8Cappuccino 9*/</code></pre><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一个基本指导原则：无论何时，只要你能做到，你就应该使用泛型方法。</p><pre><code class="Java">public class GenericMethods {  public &lt;T&gt; void f(T x) {    System.out.println(x.getClass().getName());  }  public static void main(String[] args) {    GenericMethods gm = new GenericMethods();    gm.f(&quot;&quot;);    gm.f(1);    gm.f(1.0);    gm.f(1.0F);    gm.f(&#39;c&#39;);    gm.f(gm);  }} /* Output:java.lang.Stringjava.lang.Integerjava.lang.Doublejava.lang.Floatjava.lang.CharacterGenericMethods*/</code></pre><p>泛型方法与可变参数列表能够很好地共存:</p><pre><code class="Java">public class GenericVarargs {  public static &lt;T&gt; List&lt;T&gt; makeList(T... args) {    List&lt;T&gt; result = new ArrayList&lt;T&gt;();    for(T item : args)      result.add(item);    return result;  }  public static void main(String[] args) {    List&lt;String&gt; ls = makeList(&quot;A&quot;);    System.out.println(ls);    ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);    System.out.println(ls);    ls = makeList(&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;));    System.out.println(ls);  }} /* Output:[A][A, B, C][, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]*/</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十四章 01 类型信息<br><a href="https://zhuanlan.zhihu.com/p/26081790" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/26081790</a><br>2、《java编程思想》14章类型信息 读书笔记 - CSDN博客<br><a href="http://blog.csdn.net/L2HL2H/article/details/51120480" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/L2HL2H/article/details/51120480</a><br>3、《Java编程思想》读书笔记 第十四章 02 反射<br><a href="https://zhuanlan.zhihu.com/p/26190300" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/26190300</a><br>4、Java泛型详解 | ZiWenXie<br><a href="https://www.ziwenxie.site/2017/03/01/java-generic/" rel="external nofollow noopener noreferrer" target="_blank">https://www.ziwenxie.site/2017/03/01/java-generic/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类型信息及泛型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/d3fc1ba0.html"/>
    <id>http://www.wshunli.com/posts/d3fc1ba0.html</id>
    <published>2017-12-04T12:22:17.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。</p><a id="more"></a><h1 id="第13章-字符串"><a href="#第13章-字符串" class="headerlink" title="第13章 字符串"></a>第13章 字符串</h1><p>1.不可变的 String<br>String 对象是不可变的，每当修改 String 对象的时候，实际上都是创建了一个新的 String 对象，最初的 String 对象丝毫未动。</p><p>2.重载“+”与 StringBuilder<br>String 对象的不可变性带来一定的效率问题，例如为 String 对象重载的“+”操作符。（用于String的“+”、“+=”是 Java 中仅有的两个重载过的操作符，而 Java 并不允许程序员重载任何操作符）。</p><pre><code class="Java">public class WhitherStringBuilder {  public String implicit(String[] fields) {    String result = &quot;&quot;;    for(int i = 0; i &lt; fields.length; i++)      result += fields[i];    return result;  }  public String explicit(String[] fields) {    StringBuilder result = new StringBuilder();    for(int i = 0; i &lt; fields.length; i++)      result.append(fields[i]);    return result.toString();  }}</code></pre><p>StringBuilder 提供了丰富而全面的方法，包括 append(),toString(),delete(),insert(),replace(),substring() 甚至 reverse()。</p><p>3.String 上的操作</p><p><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">Java 字符串常用操作（String类）</a></p><p>String 是固定不变的，而 StringBuffer 和 StringBuilder 可以改变它们的值。<br>二者唯一的区别是 StringBuilder 是非同步的而 StringBuffer 是同步的。</p><p>4.格式化输出</p><p>Java SE5 推出了类似 C语言中 printf() 风格的格式化输出这一功能。</p><pre><code class="Java">public class SimpleFormat {  public static void main(String[] args) {    int x = 5;    double y = 5.332542;    // The old way:    System.out.println(&quot;Row 1: [&quot; + x + &quot; &quot; + y + &quot;]&quot;);    // The new way:    System.out.format(&quot;Row 1: [%d %f]\n&quot;, x, y);    // or    System.out.printf(&quot;Row 1: [%d %f]\n&quot;, x, y);  }}/* Output:Row 1: [5 5.332542]Row 1: [5 5.332542]Row 1: [5 5.332542]*/</code></pre><p>format() 和 printf() 是等价的。</p><p><strong>Formatter</strong> 看一看成一个翻译器，劲格式化字符串与数据翻译成需要的结果。</p><pre><code class="Java">private Formatter f = new Formatter(System.out);f.format(&quot;%s The Turtle is at (%d,%d)\n&quot;, name, x, y);</code></pre><p>5.正则表达式</p><p>6.扫描输入</p><p>Java SE5 新增了 Scanner 类接受任意类型的输入对象。</p><h1 id="第16章-数组"><a href="#第16章-数组" class="headerlink" title="第16章 数组"></a>第16章 数组</h1><h1 id="第19章-枚举类型"><a href="#第19章-枚举类型" class="headerlink" title="第19章 枚举类型"></a>第19章 枚举类型</h1><blockquote><p>参考资料<br>1、读书笔记 JAVA编程思想 第13章 字符串 - CSDN博客<br><a href="http://blog.csdn.net/imaginedranges/article/details/73335553" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/imaginedranges/article/details/73335553</a><br>2、Java 字符串常用操作（String类） - 薛遗山 - 博客园<br><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/b6f25079.html"/>
    <id>http://www.wshunli.com/posts/b6f25079.html</id>
    <published>2017-12-04T09:04:23.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 异常处理。</p><a id="more"></a><p>第12章 <strong>通过异常处理错误</strong></p><p>Java的基本理念是“结构不佳的代码不能运行”。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java异常.png" alt="Java异常"></p><p>Java 中的异常处理都是围绕着 try-catch-finally, throw, throws 这几个展开的，也就是：</p><p>try-catch-finally：捕获异常并处理。<br>throw：遇到错误的时候抛出一个异常。<br>throws：声明一个方法可能抛出的异常（所有可能抛出的异常都需要声明）。</p><pre><code class="Java">class ThreeException extends Exception {}public class FinallyWorks {  static int count = 0;  public static void main(String[] args) {    while(true) {      try {        // Post-increment is zero first time:        if(count++ == 0) throw new ThreeException();        System.out.println(&quot;No exception&quot;);      } catch(ThreeException e) {        System.out.println(&quot;ThreeException&quot;);      } finally {        System.out.println(&quot;In finally clause&quot;);        if(count == 2) break; // out of &quot;while&quot;      }    }  }}/* Output:ThreeExceptionIn finally clauseNo exceptionIn finally clause*/</code></pre><p>throw 与 throws 的差别</p><p>throw 是语句抛出一个 Throwable 类型的异常，总是出现在函数体中；程序会在 throw 语句之后立即终止。</p><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用 throws 子句来声明抛出异常；<br>throws 语句用在方法定义时声明该方法要抛出的异常类型，多个异常可使用逗号分割。</p><pre><code class="Java">f() throws Exception1, Exception2, Exception3, ... {    ...}</code></pre><p>例如：</p><pre><code class="Java">import java.lang.Exception;public class TestException {    public int div(int x, int y) throws MyException {        if (y == 0) {            throw new MyException(&quot;除数不能为0&quot;);        }        return (int)(x/y);    }    public static void main(String[] args) {        int x = 1;        int y = 0;        try {            int result = div(x, y);        } catch (MyException e) {            System.out.println(e.getMessage());        }    }}//自定义异常类class MyException extends Exception {    String message;    public MyException(String ErrorMessage) {        message = ErrorMessage;    }    public String getMessage() {        return message;    }}</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十二章 通过异常处理<br><a href="https://zhuanlan.zhihu.com/p/25935822" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25935822</a><br>2、Java编程思想第四版读书笔记——第十二章 通过异常处理错误 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/51780879" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/51780879</a><br>3、Java 异常处理<br><a href="https://zhuanlan.zhihu.com/p/24043941" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/24043941</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 异常处理。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/d96c953e.html"/>
    <id>http://www.wshunli.com/posts/d96c953e.html</id>
    <published>2017-12-03T11:07:09.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 集合。</p><a id="more"></a><p>这部分只是还是挺重要的，面试题里面有好多。</p><p>第11章 <strong>持有对象</strong></p><p>Java 容器类提供了完善的方法保存对象，并经其划分为 <strong>Collection</strong> 和 <strong>Map</strong> 两个不同的概念。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java容器.png" alt="Java容器"></p><p><strong>Collection</strong> 一个独立的元素序列；<strong>Map</strong> 一组成对的“键值对”对象。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>1.<strong>Collection</strong> 一个独立的元素序列，这些元素服从一条或者多条规则。</p><p>List 必须按照插入的顺序保存元素，而 Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序。</p><pre><code class="java">public class SimpleCollection {  public static void main(String[] args) {    Collection&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;();    for(int i = 0; i &lt; 10; i++)      c.add(i); // Autoboxing    for(Integer i : c)      System.out.print(i + &quot;, &quot;);  }}/* Output:0, 1, 2, 3, 4, 5, 6, 7, 8, 9,*/</code></pre><p>2.Arrays 和 Collections 类有很多实用的方法，可以在 Collection 中添加一组元素。</p><pre><code class="Java">public class AddingGroups {  public static void main(String[] args) {    Collection&lt;Integer&gt; collection =      new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5));    Integer[] moreInts = { 6, 7, 8, 9, 10 };    collection.addAll(Arrays.asList(moreInts));    // Runs significantly faster, but you can&#39;t    // construct a Collection this way:    Collections.addAll(collection, 11, 12, 13, 14, 15);    Collections.addAll(collection, moreInts);    // Produces a list &quot;backed by&quot; an array:    List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20);    list.set(1, 99); // OK -- modify an element    // list.add(21); // Runtime error because the                     // underlying array cannot be resized.  }}</code></pre><p>Arrays.asList() 接受一个数组或者可变参数列表，并将之转换为 List 对象。<br>需要注意的是，此种方式获得的 List 对象，由于底层实现仍然是数组，在添加或者删除元素时会出现 UnsupportedOperationException 异常。</p><p>Collections.addAll() 接收一个 Collection 对象、一个数组或者是可变参数列表作为参数，得到新的 Collection 对象。</p><p>3.容器的打印</p><pre><code class="Java">public class PrintingContainers {  static Collection fill(Collection&lt;String&gt; collection) {    collection.add(&quot;rat&quot;);    collection.add(&quot;cat&quot;);    collection.add(&quot;dog&quot;);    collection.add(&quot;dog&quot;);    return collection;  }  static Map fill(Map&lt;String,String&gt; map) {    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);    map.put(&quot;cat&quot;, &quot;Rags&quot;);    map.put(&quot;dog&quot;, &quot;Bosco&quot;);    map.put(&quot;dog&quot;, &quot;Spot&quot;);    return map;  }      public static void main(String[] args) {    print(fill(new ArrayList&lt;String&gt;()));    print(fill(new LinkedList&lt;String&gt;()));    print(fill(new HashSet&lt;String&gt;()));    print(fill(new TreeSet&lt;String&gt;()));    print(fill(new LinkedHashSet&lt;String&gt;()));    print(fill(new HashMap&lt;String,String&gt;()));    print(fill(new TreeMap&lt;String,String&gt;()));    print(fill(new LinkedHashMap&lt;String,String&gt;()));  }}/* Output:[rat, cat, dog, dog][rat, cat, dog, dog][dog, cat, rat][cat, dog, rat][rat, cat, dog]{dog=Spot, cat=Rags, rat=Fuzzy}{cat=Rags, dog=Spot, rat=Fuzzy}{rat=Fuzzy, cat=Rags, dog=Spot}*/</code></pre><p>Collection 打印出来的内容用 [ ] 括住，Map 打印出来的内容用 { } 括住。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口在 Collection 基础上添加了大量的方法。可分为 ArrayList 和 LinkedList 两种。</p><p><strong>ArrayList</strong> 数据结构采用的是线性表，优势是访问和查询十分方便，但添加和删除的时候效率很低。<br><strong>LinkedList</strong> 数据结构采用的是链表，优势是删除和添加的效率很高，但随机访问元素时效率较 ArrayList 类低。</p><p>List 重要价值在于提供了一种可修改的序列。</p><p>contains(Object o) 确定某个对象是否在列表中。<br>remove(int index) 移除指定位置上的元素。<br>indexOf() 返回列表中首次出现指定元素的索引，如果不包含该元素，返回-1。</p><p>LikedList 增加了可以使其用作栈、队列或双端队列的方法。</p><pre><code class="Java">public class Stack&lt;T&gt; {    private LinkedList&lt;T&gt; storage = new LinkedList&lt;&gt;();    public void push(T v){        storage.addFirst(v);    }    public T peek(){        return storage.getFirst();    }    public T pop(){        return storage.removeFirst();    }    public boolean empty(){        return storage.isEmpty();    }    public String toString(){        return storage.toString();    }}</code></pre><p>LikedList 具有直接实现栈（LIFO）的所有功能的方法。</p><p>addFirst(E e)/addLast(E e)：将元素添加到列表的开头/结尾<br>getFirst()/element()：返回列表的第一个元素<br>peek()/peekFirst()：获取但不移除列表的第一个元素<br>offer(E e)/offerLast(E e)：将元素插入到列表末尾</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列是典型的先进先出（FIFO）的容器。</p><pre><code class="Java">public class QueueDemo {    public static void printQ(Queue queue) {  while(queue.peek() != null)      System.out.print(queue.remove() + &quot; &quot;);  System.out.println();    }    public static void main(String[] args) {  Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();  Random random = new Random(47);  for(int i = 0; i &lt; 10; i++)      queue.offer(random.nextInt(i+10));  printQ(queue);  Queue&lt;Character&gt; qCharacters = new LinkedList&lt;Character&gt;();  for(char c : &quot;Brontosaurus&quot;.toCharArray())      qCharacters.offer(c);  printQ(qCharacters);    }}/* Output: 8 1 1 1 5 14 3 1 0 1 B r o n t o s a u r u s*/</code></pre><p>LinkedList 提供了方法以支持队列的行为，并且它实现了 Queue 接口，<br>因此 LinkedList 可以用作 Queue 的一种实现，也可以将 LinkedList 向上转型为 Queue 。</p><p><strong>PriorityQueue</strong> 优先级队列声明下一个弹出的元素是最需要的元素(具有最高的优先级)，可以确保当调用 peek()、poll() 和 remove() 方法时，获取的元素将是队列中优先级最高的元素。</p><pre><code class="java">PriorityQueue priorityQueue = new PriorityQueue&lt;Integer&gt;(  inis.size(),Collections.reverseOrder());</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 具有与 Collection 完全一样的接口，实际上就是 Collection ，只是行为不同。</p><p><strong>HashSet</strong> 数据结构采用的是散列表，主要是设计用来做高性能集运算的，例如对两个集合求交集、并集、差集等。<br>集合中包含一组不重复出现且无特性顺序的元素，其值是不可重复与无序的。</p><p>LinkedHashSet 的核心概念相对于 HashSet 来说就是一个可以保持顺序的Set集合。</p><p><strong>TreeSet</strong> 数据结构使用的是红黑树，性能上低于HashSet，用于排序。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map：一组成对的“键值对”对象，允许使用键来查找值；<br>映射表允许我们使用另一个对象来查找某个对象，它被称为“关联数组”，因为它将某些对象与另外一些对象关联在了一起，或者被称为“字典”</p><pre><code class="Java">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</code></pre><p>get(Object o)：返回指定键所映射的值，如果不包含该键的映射关系，返回 null 。<br>put(K key, V value)：将指定的值与此映射中的指定键关联，如果已经存在映射关系，更新值。<br>hashCode()：返回此映射的哈希码值。</p><h2 id="Map-的三种实现"><a href="#Map-的三种实现" class="headerlink" title="Map 的三种实现"></a>Map 的三种实现</h2><p>HashMap：基于“拉链法”实现的散列表，一般用于单线程中，不是线程安全的。<br>HashTable：基于“拉链法”实现的散列表，一般用于多线程中，是线程安全的。<br>TreeMap：有序的散列表，通过红黑树实现的，一般用于单线程中存储有序的映射。</p><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>迭代器，用于遍历容器，JDK源码如下：</p><pre><code class="Java">package java.util;import java.util.function.Consumer;public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}</code></pre><p>Java 的 Iterator 只能单向移动：</p><pre><code class="Java">public class SimpleIteration {  public static void main(String[] args) {    List&lt;Pet&gt; pets = Pets.arrayList(12);    Iterator&lt;Pet&gt; it = pets.iterator();    while(it.hasNext()) {      Pet p = it.next();      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    }    System.out.println();    // A simpler approach, when possible:    for(Pet p : pets)      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    System.out.println();        // An Iterator can also remove elements:    it = pets.iterator();    for(int i = 0; i &lt; 6; i++) {      it.next();      it.remove();    }    System.out.println(pets);  }}/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]*/</code></pre><p>Iterator() 要求容器返回一个Iterator。Iterator 准备好返回序列的第一个元素。<br>next() 获得序列中的下一个元素。<br>hasNext() 检查序列中是否还有元素。<br>remove() 将迭代器新近返回的元素删除。</p><h2 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h2><p>ListIterator 是 Iterator 的一个子类，只能用于各种List的访问。<br>ListIterator 可以双向移动，可以产生当前位置的前一个和后一个元素的索引，并且可以使用 set() 方法，将最近访问过的元素进行替换。<br>此外，还可以通过 listIterator(int index) 的方法，获得一个一开始就指向 index 位置的 ListIterator。</p><h1 id="Foreach-与迭代器"><a href="#Foreach-与迭代器" class="headerlink" title="Foreach 与迭代器"></a>Foreach 与迭代器</h1><p>foreach 语法主要用于数组，同样可以用于 Collection 对象。</p><pre><code class="Java">public class ForEachCollections {  public static void main(String[] args) {    Collection&lt;String&gt; cs = new LinkedList&lt;String&gt;();    Collections.addAll(cs,      &quot;Take the long way home&quot;.split(&quot; &quot;));    for(String s : cs)      System.out.print(&quot;&#39;&quot; + s + &quot;&#39; &quot;);  }}/* Output:&#39;Take&#39; &#39;the&#39; &#39;long&#39; &#39;way&#39; &#39;home&#39;*/</code></pre><p>因为 java SE5 引入了 Iterable 接口，该接口包含产生 Iterator 的 iterator 方法，<br>并且 Iterable 接口被 foreach 用来造序列中移动。</p><blockquote><p>参考资料<br>1、Java 容器知识整理 - FullStackDeveloper - SegmentFault<br><a href="https://segmentfault.com/a/1190000002903035" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002903035</a><br>2、Java编程思想读书笔记——持有对象 - CSDN博客<br><a href="http://blog.csdn.net/baidu_21088863/article/details/78175347" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/baidu_21088863/article/details/78175347</a><br>3、Java编程思想第四版读书笔记——第十一章 持有对象 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/49491441" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/49491441</a><br>4、深入Java源码解析容器类List、Set、Map - 简书<br><a href="http://www.jianshu.com/p/047e33fdefd2" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/047e33fdefd2</a><br>5、《Java编程思想》读书笔记 第十一章 持有对象 02 Map<br><a href="https://zhuanlan.zhihu.com/p/25816448" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25816448</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 集合。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入全景图片</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-panoview.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-panoview.html</id>
    <published>2017-11-30T09:14:59.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>一款基于 Three.js 全景显示的 Hexo 插件。</p><a id="more"></a><h1 id="Threejs-介绍"><a href="#Threejs-介绍" class="headerlink" title="Threejs 介绍"></a>Threejs 介绍</h1><p><a href="https://threejs.org/" rel="external nofollow noopener noreferrer" target="_blank">three.js</a> The aim of the project is to create an easy to use, lightweight, 3D library. The library provides <code>&lt;canvas&gt;</code>, <code>&lt;svg&gt;</code>, CSS3D and WebGL renderers.</p><div id="panoview9294" style="margin:0 auto"></div><script src="https://unpkg.com/three@0.88.0/build/three.min.js"></script><script>function init(){var e,n;(e=document.getElementById("panoview9294")).style.width;(camera=new THREE.PerspectiveCamera(75,2,1,1e3)).target=new THREE.Vector3(0,0,0),scene=new THREE.Scene;var t=new THREE.SphereBufferGeometry(500,60,40);t.scale(-1,1,1);var o=new THREE.MeshBasicMaterial({map:(new THREE.TextureLoader).load("https://img.wshunli.com/pano/pano2.jpg")});n=new THREE.Mesh(t,o),scene.add(n),(renderer=new THREE.WebGLRenderer).setPixelRatio(window.devicePixelRatio),renderer.setSize(window.innerWidth,window.innerHeight),renderer.domElement.style.width="800px",renderer.domElement.style.height="400px",e.appendChild(renderer.domElement),e.addEventListener("mousedown",onDocumentMouseDown,!1),e.addEventListener("mousemove",onDocumentMouseMove,!1),e.addEventListener("mouseup",onDocumentMouseUp,!1),e.addEventListener("dragover",function(e){e.preventDefault(),e.dataTransfer.dropEffect="copy"},!1),e.addEventListener("dragenter",function(e){document.body.style.opacity=.5},!1),e.addEventListener("dragleave",function(e){document.body.style.opacity=1},!1)}function onDocumentMouseDown(e){e.preventDefault(),isUserInteracting=!0,onMouseDownMouseX=e.clientX,onMouseDownMouseY=e.clientY,onMouseDownLon=lon,onMouseDownLat=lat}function onDocumentMouseMove(e){!0===isUserInteracting&&(lon=.1*(onMouseDownMouseX-e.clientX)+onMouseDownLon,lat=.1*(e.clientY-onMouseDownMouseY)+onMouseDownLat)}function onDocumentMouseUp(e){isUserInteracting=!1}function onDocumentMouseWheel(e){var n=camera.fov+.05*e.deltaY;return camera.fov=THREE.Math.clamp(n,10,75),camera.updateProjectionMatrix(),!1}function animate(){requestAnimationFrame(animate),update()}function update(){!1===isUserInteracting&&(lon+=.1),lat=Math.max(-85,Math.min(85,lat)),phi=THREE.Math.degToRad(90-lat),theta=THREE.Math.degToRad(lon),camera.target.x=500*Math.sin(phi)*Math.cos(theta),camera.target.y=500*Math.cos(phi),camera.target.z=500*Math.sin(phi)*Math.sin(theta),camera.lookAt(camera.target),renderer.render(scene,camera)}var camera,scene,renderer,isUserInteracting=!1,onMouseDownMouseX=0,onMouseDownMouseY=0,lon=0,onMouseDownLon=0,lat=0,onMouseDownLat=0,phi=0,theta=0;init(),animate()</script><h1 id="Hexo-中插入全景图片"><a href="#Hexo-中插入全景图片" class="headerlink" title="Hexo 中插入全景图片"></a>Hexo 中插入全景图片</h1><p><a href="https://github.com/wshunli/hexo-tag-panoview" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-panoview</a> 是一款在 Hexo 中使用 <strong>全景图片</strong> 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-panoview --save</code></pre><p>之后在文章内使用 <code>panoview</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% panoview "https://img.wshunli.com/pano/pano2.jpg" 400 800 %}{% endpanoview %}</code></pre><p>其中：<br><code>panoview</code> 和 <code>endpanoview</code> 是 Hexo 的标签，不需要修改；<br><code>https://img.wshunli.com/pano/pano2.jpg</code> 部分是全景照片，建议 1024*512 ；<br><code>400</code> 是指全景的高度；<br><code>800</code> 是指全景的宽度。</p><p>灵感来自 <a href="https://threejs.org/examples/?q=pano#webgl_panorama_equirectangular" rel="external nofollow noopener noreferrer" target="_blank">webgl_panorama_equirectangular</a><br>也是我发布的第二个 npm 组件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一款基于 Three.js 全景显示的 Hexo 插件。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="panoview" scheme="http://www.wshunli.com/tags/panoview/"/>
    
      <category term="hexo-tag-panoview" scheme="http://www.wshunli.com/tags/hexo-tag-panoview/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入 AntV 动态图表</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-antv.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-antv.html</id>
    <published>2017-11-30T02:53:24.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p><strong>让数据栩栩如生</strong><br><a id="more"></a></p><div id="antv1269"></div><script src="https://gw.alipayobjects.com/as/g/datavis/assets/1.0.5/g2/3.0.0/g2.min.js"></script><script type="text/javascript">var chart=new G2.Chart({container:"antv1269",height:300,forceFit:!0,data:[{genre:"Sports",sold:275},{genre:"Strategy",sold:115},{genre:"Action",sold:120},{genre:"Shooter",sold:350},{genre:"Other",sold:150}],options:{scales:{genre:{alias:"游戏种类"},sold:{alias:"销售量"}},geoms:[{type:"interval",position:"genre*sold",color:"genre"}]}});chart.render()</script><h1 id="AntV-介绍"><a href="#AntV-介绍" class="headerlink" title="AntV 介绍"></a>AntV 介绍</h1><p><a href="https://antv.alipay.com" rel="external nofollow noopener noreferrer" target="_blank">AntV</a> 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。</p><h1 id="Hexo-中使用-AntV"><a href="#Hexo-中使用-AntV" class="headerlink" title="Hexo 中使用 AntV"></a>Hexo 中使用 AntV</h1><p><a href="https://github.com/wshunli/hexo-tag-antv" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-antv</a> 是一款在 Hexo 中使用 AntV 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-antv --save</code></pre><p>之后在文章内使用 <code>antv</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% antv 300 %}data:[    // TODO antv data goes here],options: {    // TODO antv options goes here}{% endantv %}</code></pre><p>其中：<br><code>antv</code> 和 <code>endantv</code> 是 Hexo 的标签，不需要修改；<br><code>300</code> 是指图表的高度，图表宽度是自适应的；<br><code>data</code> 部分是图表的数据；<br><code>options</code> 部分是图表的配置。</p><pre><code class="JavaSript">const options = {  scales: {object}, // 列定义声明  coord: {object}, // 坐标系配置  axes: {object}, // 坐标轴配置  legends: {object}, // 图例配置  guides: {array}, // 图表辅助元素配置  filters: {object}, // 数据过滤配置  tooltip: {object}, // 提示信息配置  facet: {object}, // 分面配置  geoms: {array} // 图形语法相关配置}</code></pre><p>更详细配置可参考官方文档：<a href="https://antv.alipay.com/zh-cn/g2/3.x/api/options.html" rel="external nofollow noopener noreferrer" target="_blank">配置项声明方式</a></p><p>下面我们来看一个饼图的使用样例：</p><pre><code class="javaSript">{% antv %}data:[  { genre: 'Sports', sold: 275 },  { genre: 'Strategy', sold: 115 },  { genre: 'Action', sold: 120 },  { genre: 'Shooter', sold: 350 },  { genre: 'Other', sold: 150 }],options: {    scales: {      'genre': {        alias: '游戏种类'      },      'sold': {        alias: '销售量'      }    },    geoms: [      {        type: 'percent',        position: 'genre*sold',        color: 'genre'      }    ]  }{% endantv %}</code></pre><p>即开头的图表效果。</p><p>灵感来自 <a href="https://github.com/quentin-chen/hexo-tag-echarts3" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-echarts3</a>，AntV 也刚刚发布了 3.0 版本所以就想尝试下。<br>最主要目的还是尝试发布自己的 npm 组件，可能现在还不够实用，后面我会不断完善。</p><blockquote><p>参考资料<br>1、发布自己的module - 我的第一个npm组件！<br><a href="https://segmentfault.com/a/1190000006250554" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000006250554</a><br>2、在 Hexo 中插入 ECharts 动态图表<br><a href="http://kchen.cc/2016/11/05/echarts-in-hexo/" rel="external nofollow noopener noreferrer" target="_blank">http://kchen.cc/2016/11/05/echarts-in-hexo/</a><br>3、标签插件（Tag） | Hexo<br><a href="https://hexo.io/zh-cn/api/tag.html" rel="external nofollow noopener noreferrer" target="_blank">https://hexo.io/zh-cn/api/tag.html</a><br>4、Hexo高级教程之插件开发<br><a href="http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;让数据栩栩如生&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="AntV" scheme="http://www.wshunli.com/tags/AntV/"/>
    
      <category term="hexo-tag-antv" scheme="http://www.wshunli.com/tags/hexo-tag-antv/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/6e418c5b.html"/>
    <id>http://www.wshunli.com/posts/6e418c5b.html</id>
    <published>2017-11-28T13:15:08.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类与接口。</p><a id="more"></a><h1 id="第5章-初始化与清理"><a href="#第5章-初始化与清理" class="headerlink" title="第5章 初始化与清理"></a>第5章 初始化与清理</h1><p>1.构造器初始化 initialize()<br>Java 采用构造器（constructor）<code>初始化</code>和<code>创建</code>对象，两个过程捆绑在一起。<br>类中没有构造器即构造函数时，编译器会自动创建一个默认构造器；反之，则不会自动创建。</p><p>2.方法重载：每个重载方法都有一个独一无二的参数类型列表。</p><p>3.this 关键字只能在方法内部使用，表示“调用方法的那个对象”。<br>static 方法就是没有 this 的方法，可以在没有创建对象的情况下仅仅通过类名本身调用 static 方法。</p><p>4.垃圾回收 finalize()</p><ul><li>对象可能不被垃圾回收。</li><li>垃圾回收并不等于“析构”。</li><li>垃圾回收只与内存有关。</li></ul><p>5.成员初始化及构造器初始化<br>Java 尽力保证：所有变量在使用前都能的到恰当的初始化。</p><p>6.初始化顺序：在类的内部，成员变量会在任何方法（包括构造器）调用之前初始化。<br>含静态数据的初始化：先静态对象后非静态对象。</p><p>7.声明数组变量</p><pre><code class="Java">int[] a;   // 首选的方法int a[];  // 效果相同，但不是首选方法</code></pre><p>初始化：</p><pre><code class="Java">int[] a = new int[5];int[] a = {1, 2, 3, 4, 5};</code></pre><p>可变参数列表：</p><pre><code class="Java">void fun (Object... args){  for(Object obj : args){    system.out.printf(obj + &quot;&quot;);  }}</code></pre><p>8.枚举类型 enum</p><pre><code class="Java">public enum Spiiness{  NOT, MILD, MEDIUM, HOT, FLAMING}</code></pre><h1 id="第6章-访问权限控制"><a href="#第6章-访问权限控制" class="headerlink" title="第6章 访问权限控制"></a>第6章 访问权限控制</h1><p>访问权限（由大到小）：public、protected、包访问权限和 private 。</p><ul><li>default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li></ul><p><img src="https://img.wshunli.com/Java/Java编程思想/访问控制.png-hexo.png" alt="访问控制"></p><h1 id="第7章-复用类"><a href="#第7章-复用类" class="headerlink" title="第7章 复用类"></a>第7章 复用类</h1><p>复用代码有两种方法：在新类中产生现有类的对象（组合）；按照现有类的类型创建新类（继承）。</p><p>1.组合，将对象的引用置于新类中即可。</p><p>2.继承，使用 extends 实现，导出类自动获得基类的所有域和方法。</p><p>没有参数的初始化构建过程，从基类“向外”扩散；带参数的构造器使用 super 显式地调用基类构造器语句。</p><p>3.代理是一种介于组合和继承的中庸之道，将成员对象置于构造地类中（类似组合），与此同时在新类中暴露该成员对象的所有方法（类似继承）。</p><pre><code class="Java">public class SpaceShipDelegation {  private String name;  private SpaceShipControls controls =    new SpaceShipControls();  public SpaceShipDelegation(String name) {    this.name = name;  }  // Delegated methods:  public void back(int velocity) {    controls.back(velocity);  }  public void forward(int velocity) {    controls.forward(velocity);  }  public static void main(String[] args) {    SpaceShipDelegation protector =      new SpaceShipDelegation(&quot;NSEA Protector&quot;);    protector.forward(100);  }}</code></pre><p>4.向上转型<br>新类和基类之间的关系，新类是现有类的一种类型。<br>基类所有的方法和属性在导出类中也同样存在，导出类可以转化为基类，即向上转型。</p><p>5.final 关键字，指“这是无法改变的”，可用在 <strong>数据、方法和类</strong> 上。</p><p>final 数据：一个永不改变的编译常量；一个运行时被初始化的值，而不希望被改变。<br>final 方法：方法锁定，在继承中保持行为不变，并且不会被覆盖；效率。<br>final 类：不允许继承。</p><p>final 强调不允许改变，static 强调只有一份。</p><p>6.初始化及类的加载</p><pre><code class="Java">//: reusing/Beetle.java// The full process of initialization.import static net.mindview.util.Print.*;class Insect {  private int i = 9;  protected int j;  Insect() {    print(&quot;i = &quot; + i + &quot;, j = &quot; + j);    j = 39;  }  private static int x1 =    printInit(&quot;static Insect.x1 initialized&quot;);  static int printInit(String s) {    print(s);    return 47;  }}public class Beetle extends Insect {  private int k = printInit(&quot;Beetle.k initialized&quot;);  public Beetle() {    print(&quot;k = &quot; + k);    print(&quot;j = &quot; + j);  }  private static int x2 =    printInit(&quot;static Beetle.x2 initialized&quot;);  public static void main(String[] args) {    print(&quot;Beetle constructor&quot;);    Beetle b = new Beetle();  }}/* Output:static Insect.x1 initializedstatic Beetle.x2 initializedBeetle constructori = 9, j = 0Beetle.k initializedk = 47j = 39*/</code></pre><h1 id="第8章-多态"><a href="#第8章-多态" class="headerlink" title="第8章 多态"></a>第8章 多态</h1><p>多态作用是消除类型之间的耦合关系，允许将多种类型视为同一类型处理。</p><p>1.方法调用绑定</p><p>将一个方法调用同一个方法主题关联起来被称作绑定：<br>前期绑定：在程序执行前进行绑定；<br>后期绑定：运行时根据对象的类型进行绑定。</p><p>Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定</p><pre><code class="Java">public class Shape {    public void draw() {}    public void erase() {}}class Circle extends Shape {    public void draw() { System.out.println(&quot;Circle.draw()&quot;); }    public void erase() { System.out.println(&quot;Circle.erase()&quot;); } }class Square extends Shape {    public void draw() { System.out.println(&quot;Square.draw()&quot;); }    public void erase() { System.out.println(&quot;Square.erase()&quot;); } }public static void main(String[] args) {    Shape shape = new Circle();    shape.draw();}/* Output:Circle.draw()*/</code></pre><p>因为继承，将 Shape 引用指向一个新创建的 Circle 对象不会有任何问题；<br>又因为时后期绑定，会使得程序能够正确调用 Circle.draw() 。</p><h1 id="第9章-接口"><a href="#第9章-接口" class="headerlink" title="第9章 接口"></a>第9章 接口</h1><p>接口和内部类为我们提供了一种将接口和实现分离的更加结构化的方法。</p><p>1.抽象类和抽象方法</p><p>抽象方法是不完整的，仅有声明而没有方法体。</p><pre><code class="Java">abstract void f();</code></pre><p>包含抽象方法的类叫做抽象类；如果一个类包含一个或多个抽象方法，该类必须被定义为抽象的。</p><p>继承自抽象类的新类需要提供所有抽象方法的定义，否则也是抽象类。</p><p>2.接口</p><p>interface 关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。<br>要让一个类遵循特定接口或者一组接口，需要使用 implements 关键字。</p><pre><code class="Java">interface Instrument {    int VALUE = 5;//final &amp;&amp; static    void play(String s);    void adjust();}class Wind implements Instrument {    public void play(String s) {        System.out.print(&quot;Wind.play()&quot;);    }    public void adjust() {        System.out.println(&quot;&quot;Wind.adjust()&quot;&quot;);    }}</code></pre><ul><li>接口中的方法默认是 public 的，不需要显式声明为 public 的；</li><li>接口中的任何域都自动是 static 和 final 的；</li><li>当要实现一个接口时，在接口中被定义的方法必须被显式声明为 public 的，否则只能得到默认的包访问权限。</li></ul><h1 id="第10章-内部类"><a href="#第10章-内部类" class="headerlink" title="第10章 内部类"></a>第10章 内部类</h1><p>将一个类的定义放在另一个类的定义的内部，这就是内部类。</p><pre><code class="Java">public class Parcel1 {  class Destination {    private String label;    Destination(String whereTo) {      label = whereTo;    }    String readLabel() { return label; }  }  // Using inner classes looks just like  // using any other class, within Parcel1:  public void ship(String dest) {    Destination d = new Destination(dest);    System.out.println(d.readLabel());  }  public static void main(String[] args) {    Parcel1 p = new Parcel1();    p.ship(&quot;Tasmania&quot;);  }}/* Output:Tasmania*/</code></pre><p>1.内部类不仅是一种名字隐藏和组织代码的模式，还拥有与其他外围类的所有元素的访问权限。</p><p>2.使用 .this 与 .new</p><p>.this 用来生成对外围对象的引用。</p><pre><code class="Java">public class DotThis {  void f() { System.out.println(&quot;DotThis.f()&quot;); }  public class Inner {    public DotThis outer() {      return DotThis.this;      // A plain &quot;this&quot; would be Inner&#39;s &quot;this&quot;    }  }  public Inner inner() { return new Inner(); }  public static void main(String[] args) {    DotThis dt = new DotThis();    DotThis.Inner dti = dt.inner();    dti.outer().f();  }}/* Output:DotThis.f()*/</code></pre><p>.new 用来创建外部类对象的内部类对象。</p><pre><code class="Java">public class DotNew {  public class Inner {}  public static void main(String[] args) {    DotNew dn = new DotNew();    DotNew.Inner dni = dn.new Inner();  }}</code></pre><p>3.匿名内部类</p><pre><code class="Java">public class Parcel7 {  public Contents contents() {    return new Contents() { // Insert a class definition      private int i = 11;      public int value() { return i; }    }; // Semicolon required in this case  }  public static void main(String[] args) {    Parcel7 p = new Parcel7();    Contents c = p.contents();  }}</code></pre><p>4.嵌套类</p><p>如果不需要内部类对象与外部类对象之间的联系，内部类声明可为 static ，通常称为嵌套类。</p><ul><li>创建嵌套类对象并不需要其外围对象。</li><li>不能从嵌套类对象中访问非静态的外围类对象。</li></ul><p>5.闭包和回调</p><p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。</p><p>回调（Callback）程序在特定时间自己回头调用预先实现的方法。</p><blockquote><p>参考资料<br>1、Java 修饰符<br><a href="http://www.runoob.com/java/java-modifier-types.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/java/java-modifier-types.html</a><br>2、《Java编程思想》读书笔记 第九章 接口<br><a href="https://zhuanlan.zhihu.com/p/25597956" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25597956</a><br>3、Java—内部类（二）—实现闭包与回调<br><a href="http://blog.csdn.net/yuwenhao07/article/details/53607117" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/yuwenhao07/article/details/53607117</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类与接口。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/235f2f09.html"/>
    <id>http://www.wshunli.com/posts/235f2f09.html</id>
    <published>2017-11-28T12:47:30.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 基础知识部分。</p><a id="more"></a><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a>第3章 操作符</h1><p>Java 中的数据是通过使用操作符来操作的。</p><ul><li>赋值操作符</li><li>算术操作符</li><li>关系操作符</li><li>逻辑操作符</li><li>按位操作符</li><li>其他操作符</li></ul><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a>第4章 控制执行流程</h1><p>1.Java 中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p>2.Foreach 语法，用于数组或容器</p><pre><code class="Java">int [] numbers = {10, 20, 30, 40, 50};for(int x : numbers ){    System.out.print( x );    System.out.print(&quot;,&quot;);}// 10,20,30,40,50,</code></pre><p>3.return、break、continue</p><p>return：指定方法的返回值或者退出当前方法。</p><p>break：主要用于循环或者 switch 语句，退出整个语句块。<br>continue：跳转到下一次循环迭代。</p><p>4.Java 分支结构：swich 语句与 if 语句</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 基础知识部分。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/1349c3d1.html"/>
    <id>http://www.wshunli.com/posts/1349c3d1.html</id>
    <published>2017-11-28T02:58:36.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 一切皆对象。</p><a id="more"></a><h1 id="第1章-对象导论"><a href="#第1章-对象导论" class="headerlink" title="第1章 对象导论"></a>第1章 对象导论</h1><p>本章主要介绍 OOP 面向对象的思想以及抽象、封装、继承、多态的概念。</p><p>JAVA 是一种面向对象编程语言：</p><ul><li>万物皆对象，每一个对象都会存储数据，并且可以对自身执行操作。因此，每一个对象包含两部分：成员变量和成员方法。在成员方法中可以改变成员变量的值。</li><li>程序是对象的集合，他们通过发送消息来告知彼此所要做的事情，也就是调用相应的成员函数。</li><li>每一个对象都有自己的由其他对象所构成的存储，也就是说在创建新对象的时候可以在成员变量中使用已存在的对象。</li><li>每个对象都拥有其类型，每个对象都是某个类的一个实例，每一个类区别于其它类的特性就是可以向它发送什么类型的消息，也就是它定义了哪些成员函数。</li><li>某一个特定类型的所有对象都可以接受同样的消息。</li></ul><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a>第2章 一切都是对象</h1><p>1.Java 中一切都被视为对象，但是操作的标识符实际是对象的引用。</p><pre><code class="Java">String s;                         // s 为引用，并不是对象。String s = new String(&quot;wshunli&quot;); // s 与新的对象关联String s = &quot;wshunli&quot;;             // 等价</code></pre><p>2.数据存储位置可分为：寄存器、堆栈、堆、常量存储、非 RAM 存储。</p><ul><li>寄存器位于处理器内部，最快的存储区；</li><li>堆栈通常位于 RAM 中，存储对象引用；</li><li>堆通常也是位于 RAM 中，存储所有 Java 对象；</li><li>常量存储直接存放在代码内部；</li><li>非 RAM 存储的数据完全存活于程序之外，比如流对象和持久化对象。</li></ul><p>3.Java 基本数据类型：</p><ul><li>byte、short、int、long</li><li>float、double</li><li>boolean</li><li>char</li></ul><p>4.类：字段、方法组成。</p><p>5.HelloWorld：</p><pre><code class="Java">public class HelloWorld {    /* 第一个Java程序     * 它将打印字符串 Hello World     */    public static void main(String []args) {        System.out.println(&quot;Hello World&quot;); // 打印 Hello World    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 一切皆对象。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（四）</title>
    <link href="http://www.wshunli.com/posts/9695607b.html"/>
    <id>http://www.wshunli.com/posts/9695607b.html</id>
    <published>2017-11-19T06:34:43.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      看得更远，走得更远。
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《React Native开发指南》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/46b86b5e.html"/>
    <id>http://www.wshunli.com/posts/46b86b5e.html</id>
    <published>2017-11-18T04:23:39.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。<br><a id="more"></a></p><p>我选择的是先看 《React Native开发指南》 入门。</p><h1 id="第1章-初识-React-Native"><a href="#第1章-初识-React-Native" class="headerlink" title="第1章 初识 React Native"></a>第1章 初识 React Native</h1><p><a href="https://facebook.github.io/react-native/" rel="external nofollow noopener noreferrer" target="_blank">React Native</a> 是一款用来开发真正原生、可渲染 iOS 和 Android 移动应用的 JavaScript 框架。<br>React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。<br>在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。</p><h1 id="第2章-React-Native-工作原理"><a href="#第2章-React-Native-工作原理" class="headerlink" title="第2章 React Native 工作原理"></a>第2章 React Native 工作原理</h1><p>React Native 使用 Virtual DOM 作为中间层，介于开发者描述的视图与实际页面渲染的视图之间。<br>Virtual DOM 不仅能提升性能，而且提供了强大的抽象能力，在开发者代码和实际渲染之间加入一个抽象层。</p><p>React Native 调用 Objective-C 的 API 渲染 iOS 组件，调用 Java 接口渲染 Android 组件，而不是渲染到浏览器 DOM 上。</p><p>React Native 的渲染周期和 React 完全相同；组件也很类似，只是名称有差别，但是和原生的组件名字差不多；使用 JSX 以及 React 的内联样式。</p><p>React Native 同样可以调用宿主平台的接口，比如数据存储，操控硬件设备等等。</p><h1 id="第3章-构建你的第一个应用"><a href="#第3章-构建你的第一个应用" class="headerlink" title="第3章 构建你的第一个应用"></a>第3章 构建你的第一个应用</h1><p>类似 React ，使用 React Native 构建 Android 应用，可使用 <code>create-react-native-app</code> 脚手架工具。</p><pre><code class="JSX">npm install -g create-react-native-app</code></pre><p>安装完成后执行以下命令即可创建 React Native 项目：</p><pre><code class="JSX">create-react-native-app first-react-native-app// 打开项目目录cd first-react-native-appnpm start</code></pre><p>基本上就构建完成。</p><p>运行在 Andoroid 系统:</p><pre><code class="JSX">npm run android</code></pre><p>代码也比较容易理解：</p><pre><code class="JSX">import React from &#39;react&#39;;import { StyleSheet, Text, View } from &#39;react-native&#39;;export default class App extends React.Component {  render() {    return (      &lt;View style={styles.container}&gt;        &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt;        &lt;Text&gt;Changes you make will automatically reload.&lt;/Text&gt;        &lt;Text&gt;Shake your phone to open the developer menu.&lt;/Text&gt;      &lt;/View&gt;    );  }}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: &#39;#fff&#39;,    alignItems: &#39;center&#39;,    justifyContent: &#39;center&#39;,  },});</code></pre><p>感觉和 React.js 差不多，比较容易理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。&lt;br&gt;
    
    </summary>
    
      <category term="跨平台技术" scheme="http://www.wshunli.com/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React Native" scheme="http://www.wshunli.com/tags/React-Native/"/>
    
      <category term="《React Native开发指南》" scheme="http://www.wshunli.com/tags/%E3%80%8AReact-Native%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/86c8e45a.html"/>
    <id>http://www.wshunli.com/posts/86c8e45a.html</id>
    <published>2017-11-15T08:05:27.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习 《深入浅出React和Redux》<br><a id="more"></a></p><h1 id="第3章-从-Flux-到-Redux"><a href="#第3章-从-Flux-到-Redux" class="headerlink" title="第3章 从 Flux 到 Redux"></a>第3章 从 Flux 到 Redux</h1><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>Redux 是 Flux 单向数据流思想的另一种实现方式，先介绍 Flux 的优缺点。</p><h3 id="MVC-介绍"><a href="#MVC-介绍" class="headerlink" title="MVC 介绍"></a>MVC 介绍</h3><p>MVC 框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分为三个部分：<br><img src="https://img.wshunli.com/React/深入浅出React和Redux/MVC.png-hexo.png" alt="MVC"></p><ul><li>Model （模型）负责管理数据，大部分业务逻辑也应该放在Model 中；</li><li>View （视图）负责渲染用户界面，应该避免在View 中涉及业务逻辑；</li><li>Controller （控制器）负责接受用户输入根据用户输入调用对应的Model 部分逻辑，把产生的数据结果交给View 部分，让View 渲染出必要的输出。</li></ul><p>MVC 框架提出的数据流很理想，用户请求先到达 Controller ，由 Controller 调用 Model 获得数据，然后把数据交给 View，但是在实际框架实现中，总是允许 View 和 Model 可以直接通信，MVC 很快就变得非常复杂。</p><p>Flux 执行更严格的数据流控制。一个 Flux 应用包含四个部分：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/Flux.png-hexo.png" alt="Flux"></p><ul><li>Dispatcher ，处理动作分发，维持Store 之间的依赖关系；</li><li>Store ，负责存储数据和处理数据相关逻辑；</li><li>Action ，驱动 Dispatcher 的JavaScript 对象；</li><li>View ，视图部分，负责显示用户界面。</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Flux 的基本原则是“单向数据流”， Redux 在此基础上强调三个基本原则：</p><ul><li>唯一数据源（ Single Source of Truth);</li><li>保持状态只读（ State is read-only);</li><li>数据改变只能通过纯函数完成（ Changes are made with pure functions ）。</li></ul><blockquote><p>参考资料<br>1、Flux | Application Architecture for Building User Interfaces<br><a href="https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow" rel="external nofollow noopener noreferrer" target="_blank">https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow</a><br>2、Flux 架构入门教程 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2016/01/flux.html</a><br>3、</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习 《深入浅出React和Redux》&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>又拍云CDN全站加速</title>
    <link href="http://www.wshunli.com/posts/97fe98e3.html"/>
    <id>http://www.wshunli.com/posts/97fe98e3.html</id>
    <published>2017-11-11T11:44:24.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。</p><a id="more"></a><p>前几天使用 Travis CI 自动构建 Hexo 博客并且上传至 Github 和 Coding，就在想能不能同时上传至 <a href="https://console.upyun.com/register/?invite=H1_D-bC4W" rel="external nofollow noopener noreferrer" target="_blank">又拍云</a>。</p><p>今天晚上使用 ftp 上传至又拍云，网站实现全站 CDN 加速。</p><p>前面发现是有工具可以直接上传至又拍云：</p><p><a href="https://github.com/Menci/hexo-deployer-upyun" rel="external nofollow noopener noreferrer" target="_blank">hexo-deployer-upyun</a></p><p>但是这个工具在 Windows 系统下使用有问题，并且我已经使用 Travis CI 自动部署了，继续使用这个工具有<strong>令牌</strong>暴露的风险。</p><p>所以就想使用 ftp 上传至又拍云，然后就发现了这个工具：</p><p><a href="https://github.com/git-ftp/git-ftp" rel="external nofollow noopener noreferrer" target="_blank">Git-ftp</a> – uploads to FTP servers the Git way</p><p>在 linux 下的安装方法：</p><pre><code class="Shell">git clone https://github.com/git-ftp/git-ftp.gitcd git-ftp# choose the newest releasetag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;# checkout the latest taggit checkout &quot;$tag&quot;sudo make install</code></pre><p>配置 git-ftp ：</p><pre><code class="Shell">git config git-ftp.url &quot;ftp://ftp.example.net:21/public_html&quot;git config git-ftp.user &quot;ftp-user&quot;git config git-ftp.password &quot;secr3t&quot;</code></pre><p>第一次上传执行：</p><pre><code class="Shell">git ftp init</code></pre><p>后面上传执行，只会上传变化的部分：</p><pre><code class="Shell">git ftp push</code></pre><p>使用方法也很简单，下面就默认在原来 <a href="https://www.wshunli.com/posts/7dcaaf9e.html">Travis CI 自动部署</a> 的基础上:</p><p>在 <code>.travis.yml</code> 文件中修改：</p><pre><code class="Shell">install:  - npm install  - git clone https://github.com/git-ftp/git-ftp.git  - cd git-ftp  - tag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;  - git checkout &quot;$tag&quot;  - sudo make install  - cd ..</code></pre><p>在 <code>publish-to-gh-pages.sh</code> 中修改</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;git ftp init# git ftp push</code></pre><p>第一次上传之后，修改 <code>publish-to-gh-pages.sh</code> 文件</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;# git ftp initgit ftp push -v</code></pre><p>其中 UPYUN_USE 和 UPYUN_PSD 是在 Travis 中配置的 UPYUN ftp 用户名密码。<br>具体值可参考：<a href="https://docs.upyun.com/api/developer_tools/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.upyun.com/api/developer_tools/</a></p><p>其实有点弊端就是上传之后更新具有一定的延迟性，但是速度快很多。</p><blockquote><p>参考资料<br>1、travis-ci-deploy-ftp<br><a href="https://github.com/ansediao/travis-ci-deploy-ftp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ansediao/travis-ci-deploy-ftp</a><br>2、How to use git-ftp： 使用 git-ftp 管理你的 FTP<br><a href="https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9</a><br>3、使用 git-ftp 将 git 两次提交发生变化的文件上传到服务器<br><a href="http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server" rel="external nofollow noopener noreferrer" target="_blank">http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="Upyun" scheme="http://www.wshunli.com/tags/Upyun/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/d0f6201d.html"/>
    <id>http://www.wshunli.com/posts/d0f6201d.html</id>
    <published>2017-11-10T05:40:03.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。</p><a id="more"></a><p>之间就简单地使用 <a href="https://reactjs.org" rel="external nofollow noopener noreferrer" target="_blank">React</a> 搭建过一次 Demo ，借这次机会把 React 给搞定了，至少能写个简单的界面。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React技术栈.png-hexo.png" alt="React技术栈"></p><p>看着这 React技术栈 ，还是压力山大啊。</p><p>这次选了两本书 《深入浅出React和Redux》 和 《React全栈》。书都很新也很薄，这次先看一本入门。</p><h1 id="第1章-React-新的前端思维方式"><a href="#第1章-React-新的前端思维方式" class="headerlink" title="第1章 React 新的前端思维方式"></a>第1章 React 新的前端思维方式</h1><p>首先使用 <code>creat-react-app</code> 创建一个 React 应用。</p><p>在确认 Node.js 和 npm 安装好之后，在命令行执行以下命令安装 <code>creat-react-app</code> 工具。</p><pre><code class="Shell">npm install -g create-react-appcreate-react-app first-react-appnpm start</code></pre><p>浏览器会自动打开 <a href="http://localhost:3000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:3000/</a> 显示如下界面：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app.png-hexo.png" alt="first-react-app"></p><p>我们来看一下 first-react-app 的目录结构：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app2.png-hexo.png" alt="first-react-app"></p><p>在开发过程中，我们主要关注 src 目录的内容。</p><p>其中 <code>src/index.js</code> 文件是应用的入口文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import App from &#39;./App&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>这里的代码渲染了一个 App 组件，效果就是首页界面。<br>我们看下 App 组件是怎么定义的，在 <code>src/App.js</code> 文件中：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import logo from &#39;./logo.svg&#39;;import &#39;./App.css&#39;;class App extends Component {  render() {    return (      &lt;div className=&quot;App&quot;&gt;        &lt;header className=&quot;App-header&quot;&gt;          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;        &lt;/header&gt;        &lt;p className=&quot;App-intro&quot;&gt;          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.        &lt;/p&gt;      &lt;/div&gt;    );  }}export default App;</code></pre><p>React 应用实际上依赖很复杂的技术栈，我们使用 <code>creat-react-app</code> 避免一开始就浪费太多精力配置技术栈。</p><p>我们启动 React 的命令是 <code>npm start</code> ，在 <code>package.json</code> 中：</p><pre><code class="JS">  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  }</code></pre><p>npm build 可以创建生产环境优化代码；<br>npm teat 用于单元测试；<br>npm eject 把 react-scripts 技术栈配置都弹射到应用顶层，不可逆。</p><h2 id="添加-React-组件"><a href="#添加-React-组件" class="headerlink" title="添加 React 组件"></a>添加 React 组件</h2><p>仿照着增加一个新的 React 组件。同样在 src 目录新建文件 <code>ClickCounter.js</code> 写入如下代码：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;class ClickCounter extends Component {  constructor(props) {    super(props);    this.onClickButton = this.onClickButton.bind(this);    this.state = {      count: 0    }  }  onClickButton() {    this.setState({count: this.state.count + 1});  }  render() {    const counterStyle = {      margin: &#39;16px&#39;    }    return (      &lt;div style={counterStyle}&gt;        &lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;        &lt;div&gt;          Click Count: &lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    );  }}export default ClickCounter;</code></pre><p>修改 <code>src/index.js</code> 文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import ClickCounter from &#39;./ClickCounter&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;ClickCounter /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>其中在 index.js 中使用 import 导入 ClickCounter 组件，替代之前的 App 组件。</p><pre><code class="JSX">import ClickCounter from &#39;./ClickCounter&#39;;</code></pre><p>在 ClickCounter.js 的第一行我们以同样的方式引入 React 和 Component 。</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;</code></pre><p>Component 为所有组件的基类，提供很多组件共有的功能。</p><pre><code class="JSX">class ClickCounter extends Component {}</code></pre><p>React 没有在代码中直接使用，但在 JSX 使用的范围内必须有 React，因为 JSX 最终会被转译成依赖 React 的表达式。</p><p><strong>JSX</strong>：JSX 是 JavaScript 的一种扩展语法，使我们能够在 JavaScript 中编写类似 HTML 的代码。<br>JSX 的基本语法规则：遇到 HTML 标签（以&lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。</p><p>首先，在 JSX 中使用的元素不限于 HTML 元素，可以是 React 组件。而区分二者的方法是首字母是否大写。<br>其次，在 JSX 中可以通过 onClick 这样的方式为元素添加事件处理函数。</p><pre><code class="JSX">&lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;</code></pre><h2 id="React-的工作方式"><a href="#React-的工作方式" class="headerlink" title="React 的工作方式"></a>React 的工作方式</h2><p>React的理念归结为一个公式：UI=render(data) 。</p><p>用户看到的界面（UI）是一个函数（render）的执行结果，只接受数据（data）作为参数。这是一个纯函数，即输出只依赖于输入的函数，两次函数的调用如果输入相同，那么输出也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于data ，哪些属于render ，想要更新用户界面，要做的就是更新data ，用户界面自然会做出响应，所以React 实践的也是“响应式编程”（ Reactive Programming ）的思想。</p><p><strong>Virtual DOM</strong>：是对DOM树的抽象，它并不触及浏览器部分，只是存在于 JavaScript 空间的树形结构，每次在渲染 React 组件，React 会对前后两次产生的 Virtual DOM 进行比较，最后只有发生了改变的地方会被重新渲染。</p><blockquote><p>总而言之，React利用函数式编程的思维来解决用户界面渲染的问题，强制所有组件都以数据驱动渲染的模式进行开发。</p></blockquote><h1 id="第2章-设计高质量的-React-组件"><a href="#第2章-设计高质量的-React-组件" class="headerlink" title="第2章 设计高质量的 React 组件"></a>第2章 设计高质量的 React 组件</h1><p>作为软件设计的通则，组件的划分要满足高内聚（High Cohesion ）和低搞合（ Low Coupling）的原则。</p><h2 id="React-组件的数据"><a href="#React-组件的数据" class="headerlink" title="React 组件的数据"></a>React 组件的数据</h2><p>React 组件的数据分为两种， prop 和 state。</p><p>prop 是组件的对外接口， state 是组件的内部状态，对外用 prop ，内部用 state 。</p><h3 id="React-的-prop"><a href="#React-的-prop" class="headerlink" title="React 的 prop"></a>React 的 prop</h3><p>prop ( property 的简写）是外部传递给组件的数据， React 组件通过定义自己能够接受的 prop 就定义了自己的对外公共接口。</p><pre><code class="JSX">&lt;SampleButtonid= &quot;sample&quot; borderWidth={2} onClick={onButtonClick}style={{color :"red"}}/&gt;</code></pre><p>当 prop 的值不是字符串类型时，在 JSX 中必须用花括号 {} 包住，<br>所以 style 的值有两层花括号，外层花括号代表是 JSX 的语法，内层的花括号代表这是一个对象常量。</p><pre><code class="JSX">class ControlPanel extends Component {  render() {    console.log(&#39;enter ControlPanel render&#39;);    return (      &lt;div&gt;        &lt;Counter caption=&quot;First&quot; initValue={0}/&gt;        &lt;Counter caption=&quot;Second&quot; initValue={10} /&gt;        &lt;Counter caption=&quot;Third&quot; initValue={20} /&gt;      &lt;/div&gt;    );  }}</code></pre><p>上面是给 prop 赋值，下面读取 prop 的值：</p><pre><code class="JSX">class Counter extends Component {  constructor(props) {    console.log(&#39;enter constructor: &#39; + props.caption);    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue || 0    }  }  ···</code></pre><p>在构造函数中可以通过参数 props 获得传人 prop 值，在其他函数中则可以通过 <code>this.props</code> 访问传人 prop 的值。</p><pre><code class="JSX">  ··· render() {    console.log(&#39;enter render &#39; + this.props.caption);    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }</code></pre><p><strong>propTypes 检查</strong>：组件声明接口规范，即组件支持的 prop 及其格式。</p><pre><code class="JSX">Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number};</code></pre><p>建议在开发阶段使用，产品环境下去除。</p><h3 id="React-的-state"><a href="#React-的-state" class="headerlink" title="React 的 state"></a>React 的 state</h3><p>state 代表组件的内部状态。</p><p>1、初始化 state</p><p>通常在组件的构造函数结尾处初始化 state 。</p><pre><code class="JSX">constructor(props) {    ···    this.state = {      count: props.initValue || 0    }  }</code></pre><p>React 的 defaultProps 给 prop 默认初始值：</p><pre><code class="JSX">Counter.defaultProps = {  initValue: 0}// this.state 可省去判断this.state = {  count: props.initValue}</code></pre><p>2、读取更新 state</p><p>this.state 读取 state<br>this.setState 更新 state</p><pre><code class="JSX">onClickIncrementButton() {  this.setState({count: this.state.count + 1});}</code></pre><h3 id="prop-和state-的区别"><a href="#prop-和state-的区别" class="headerlink" title="prop 和state 的区别"></a>prop 和state 的区别</h3><ul><li>prop 用于定义外部接口， state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时， state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><p>组件是绝不应该去修改传人的 props 值，否则会影响其他组件。</p><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：</p><ul><li>装载过程（ Mount ），也就是把组件第一次在DOM 树中渲染的过程；</li><li>更新过程（ Update ），当组件被重新渲染的过程；</li><li>卸载过程（ Unmount ），组件从DOM 中删除的过程。</li></ul><p>三种不同的过程， React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React组件生命周期.png-hexo.png" alt="React组件生命周期"></p><p><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a></p><h3 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h3><p>当组件第一次渲染的时候，依次调用的函数如下：</p><ul><li>constructor()</li><li>getlnitialState()</li><li>getDefaultProps()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p>1、constructor()<br>ES6 中类的构造函数，主要是初始化 state 和绑定成员函数的 this 环境。</p><p>2、getlnitialState() 和 getDefaultProps()<br>getlnitialState() 返回值用来初始化组件的 this.state ，getDefaultProps() 返回值用来作为 prop 的初始值。<br>这两个方法只有用 React.createClass 方法创建组件类时才会生效。</p><pre><code class="JSX">const Sample = React.createClass({  getInitialState() {    console.log(&#39;enter getInitialState&#39;);  }  getDefaultProps() {    console.log(&#39;enter getDefaultProps&#39;);  }});</code></pre><p>而在 ES6 中使用 defaultProps 指定初试 prop 初始值。</p><pre><code class="JSX">const Sample extends React.Component({  constructor(props) {    super(props);    this.state = {foo: &quot;bar&quot;}  }}Sample.defaultProps = {  return {sampleProp: 0}};</code></pre><p>React.createClass 已经被 Facebook 官方逐渐废弃。</p><p>3、render()</p><p>render() 函数在 React 中必须实现，其他生命周期函数在 React.Component 中都有默认实现。</p><p>render() 并不做实际的渲染动作，只是返回 JSX 描述的结构，最终由 React 操作渲染过程。<br>不需要渲染界面可以返回 null 或者 false 。</p><p>4、componentWillMount() 和 componentDidMount()</p><p>在装载过程中，componentWillMount() 会在调用 render() 函数之前被调用， componentDidMount() 会在调用 render() 函数之后被调用。</p><p>componentWillMount() 是将要装载，虽然还没有渲染出来结果，但是修改组件状态已经晚了。<br>componentDidMount() 是 render() 函数返回的内容已经渲染好了，组件已经被装载在 DOM 树上了。</p><p>componentWilIMount() 和 componentDidMount() 这对兄弟函数还有一个区别：<br>componentWillMount() 可以在服务器端被调用，也可以在浏览器端被调用；<br>而componentDidMount() 只能在浏览器端被调用，在服务器端使用 React 的时候不会被调用。</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>当组件的 props 或者 state 被修改的时候，就会引发组件的更新过程。<br>更新过程会依次调用下面的生命周期函数：</p><ul><li>componentWillReceiveProps(nextProps)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><p>1、componentWillReceiveProps(nextProps)</p><p>只要是父组件的 render() 函数被调用，在 render() 函数里面被谊染的子组件就会经历更新过程，<br>不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps() 函数。</p><p>componentWillReceiveProps(nextProps) 适合根据新的 props 值（也就是参数 nextProps ）来计算出是不是要更新内部状态state 。</p><p>注意，更新组件内部状态的方法 this.setState() 方法触发的更新过程不会调用这个函数，否则会导致 componentWillReceiveProps 再次被调用，陷入死循环。</p><p>当组件的 props 发生改变：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当组件的 state 发生改变：</p><pre><code class="TXT">&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当父组件导致子组件重新渲染：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>2、shouldComponentUpdate(nextProps, nextState)</p><p>shouldComponentUpdate() 函数决定组件是否需要渲染，返回布尔值。</p><pre><code class="JSX">shouldComponentUpdate(nextProps, nextState) {  return (nextProps.caption !== this.props.caption) ||         (nextState.count !== this.state.count);}</code></pre><p>3、componentWillUpdate() 和 componentDidUpdate()</p><p>当组件的 shouldComponentUpdate() 函数返回 true ,React 接下来依次调用对应组件的 componentWillUpdate()、render() 和 componentDidUpdate() 函数。</p><p>和装载过程不同的是，当在服务器端使用 React 渲染时，二者都可以在服务端调用。</p><h3 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h3><p>componentWillUnmount() 表示组件要从 DOM 树上删除掉之前，比较适合做一些清理工作。</p><h2 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h2><p><code>ControlPanel.js</code></p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import Counter from &#39;./Counter.js&#39;;const style = {  margin: &#39;20px&#39;};class ControlPanel extends Component {  constructor(props) {    super(props);    this.onCounterUpdate = this.onCounterUpdate.bind(this);    this.initValues = [ 0, 10, 20];    const initSum = this.initValues.reduce((a, b) =&gt; a+b, 0);    this.state = {      sum: initSum    };  }  onCounterUpdate(newValue, previousValue) {    const valueChange = newValue - previousValue;    this.setState({ sum: this.state.sum + valueChange});  }  render() {    return (      &lt;div style={style}&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;First&quot; /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Second&quot; initValue={this.initValues[1]} /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Third&quot; initValue={this.initValues[2]} /&gt;        &lt;hr/&gt;        &lt;div&gt;Total Count: {this.state.sum}&lt;/div&gt;      &lt;/div&gt;    );  }}export default ControlPanel;</code></pre><p><code>Counter.js</code></p><pre><code class="JSX">import React, { Component, PropTypes } from &#39;react&#39;;const buttonStyle = {  margin: &#39;10px&#39;};class Counter extends Component {  constructor(props) {    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue    }  }  onClickIncrementButton() {    this.updateCount(true);  }  onClickDecrementButton() {    this.updateCount(false);  }  updateCount(isIncrement) {    const previousValue = this.state.count;    const newValue = isIncrement ? previousValue + 1 : previousValue - 1;    this.setState({count: newValue})    this.props.onUpdate(newValue, previousValue)  }  render() {    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }}Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number,  onUpdate: PropTypes.func};Counter.defaultProps = {  initValue: 0,  onUpdate: f =&gt; f //什么都不做的函数};export default Counter;</code></pre><blockquote><p>参考资料<br>1、React.Component - React<br><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a><br>2、React组件生命周期<br><a href="https://nsne.github.io/2017/02/15/react-component-lifecycle/" rel="external nofollow noopener noreferrer" target="_blank">https://nsne.github.io/2017/02/15/react-component-lifecycle/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署Hexo博客</title>
    <link href="http://www.wshunli.com/posts/7dcaaf9e.html"/>
    <id>http://www.wshunli.com/posts/7dcaaf9e.html</id>
    <published>2017-11-09T11:14:08.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。</p><a id="more"></a><p>我一般都是将博客的源文件保存到私有仓库中，虽然几个简单地命令就能部署，但是过程还是很繁琐。最近申请了 Github Student Developer Pack ，就想利用软件开发中的持续集成工具 Travis CI 来帮助完成 Hexo 博客的部署过程。这样就只需要把源代码 push 到仓库就能自动部署好了。</p><p>CI 是 Continuous Integration 的缩写，持续集成之意。持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><h1 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h1><p>关于 Hexo 博客的搭建请参考文章：<a href="https://www.wshunli.com/posts/9642fffa.html">https://www.wshunli.com/posts/9642fffa.html</a></p><h1 id="Travis-CI-配置"><a href="#Travis-CI-配置" class="headerlink" title="Travis CI 配置"></a>Travis CI 配置</h1><p>1.使用 GitHub 账户登录 <a href="https://travis-ci.org" rel="external nofollow noopener noreferrer" target="_blank">Travis CI</a> 官网，然后用 Github 账号登陆，就可以看到可以持续集成的仓库。</p><p>还有个地址 <a href="https://travis-ci.com" rel="external nofollow noopener noreferrer" target="_blank">https://travis-ci.com</a> 可以部署 Github 私有仓库。</p><p>选择要启用的项目，打开<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo1.png" alt=""></p><p>然后选择一些通用的设置<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo2.png" alt=""></p><p>2.登陆 GitHub –Settings -Developer Settings 选项，找到 Personal access tokens 页面。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo3.png" alt=""></p><p>点击右上角的 Generate new token 按钮会生成新的token，点击后提示输入密码后继续，然后来到如下界面。<br>取个名字，勾选相应权限，这里只需要 repo 下全部和 user 下的 user:email 即可。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo4.png" alt=""></p><p>生成完成后，将该token拷贝下来。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo5.png" alt=""></p><p><strong>如果需要将代码同时部署到 Coding 类似</strong>：<br>3.登陆 Coding ，账户 -访问令牌，新建访问令牌：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding1.png" alt=""></p><p>勾选相应权限：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding2.png" alt=""></p><p>4.将上面获取到的token添加到 Environment Variables 部分，值为该 token ，而名称为 GH_TOKEN、CD_TOKEN 。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo6.png" alt=""></p><h1 id="创建-travis-yml"><a href="#创建-travis-yml" class="headerlink" title="创建 .travis.yml"></a>创建 .travis.yml</h1><p>要想自动部署还需在博客源码新增加 <code>.travis.yml</code> 配置文件。</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - npm install -g hexo-cliinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:    - cd ./public    - git init    - git config user.name &quot;yourname&quot; # 修改name    - git config user.email &quot;youremail&quot; # 修改email    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master     # GH_TOKEN 是在 Travis 中配置 token 的名称branches:    only:        - master #只监测 master 分支，master是我的分支的名称，可根据自己情况设置env:    global:        - GH_REF: github.com/yourname/yourname.github.io.git         # 设置 GH_REF，注意更改 yourname</code></pre><h1 id="实现自动部署"><a href="#实现自动部署" class="headerlink" title="实现自动部署"></a>实现自动部署</h1><p>将原代码 push 到 Github 即可，如果配置没问题就该自动构建了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>虽然实现了基本的自动部署，还是有问题的。</p><h2 id="master-commit-树被清空"><a href="#master-commit-树被清空" class="headerlink" title="master commit 树被清空"></a>master commit 树被清空</h2><p>自动部署会把原来的 commit 清空，显然不是我们想要的结果。</p><p>为了解决这个问题，将配置文件改为了如下的内容：</p><pre><code class="TXT">after_script:    - git clone https://${GH_REF} .deploy_git    - cd .deploy_git    - git checkout master    - cd ../    - mv .deploy_git/.git/ ./public/    - cd ./public    - git config user.name &quot;yourname&quot;    - git config user.email &quot;your email&quot;    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master</code></pre><h2 id="添加-commit-时间戳"><a href="#添加-commit-时间戳" class="headerlink" title="添加 commit 时间戳"></a>添加 commit 时间戳</h2><p>commit 的描述一直是 <code>Travis CI Auto Builder</code> 。</p><pre><code class="TXT">Travis CI Auto BuilderTravis CI Auto BuilderTravis CI Auto Builder// 之前Site updated: 2017-11-07 22:05:16Site updated: 2017-11-07 17:19:32Site updated: 2017-11-06 18:04:53</code></pre><p>最终 <code>.travis.yml</code> 配置文件：</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - export TZ=&#39;Asia/Shanghai&#39;  - npm install -g hexo-cli  - chmod +x ./publish-to-gh-pages.shinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:  - ./publish-to-gh-pages.shenv:    global:        - GH_REF: github.com/yourname/yourname.github.io.git        # 设置GH_REF，注意更改成自己的仓库地址        - CD_REF: git.coding.net/yourname/repository.git        # 同时部署到 Coding，repository 为仓库名称</code></pre><p>其中 <code>publish-to-gh-pages.sh</code> 文件：</p><pre><code class="TXT">#!/bin/bashset -evgit clone https://${GH_REF} .deploy_gitcd .deploy_gitgit checkout mastercd ../mv .deploy_git/.git/ ./public/cd ./publicgit config user.name  &quot;yourname&quot;git config user.email &quot;youremail&quot;git add .git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot;git push --force --quiet &quot;https://${TravisCIToken}@${GH_REF}&quot; master:mastergit push --force --quiet &quot;https://yourname:${CD_TOKEN}@${CD_REF}&quot; master:master# 同时部署到 Coding，注意修改 yourname</code></pre><blockquote><p>参考资料<br>1、使用Travis CI自动部署Hexo博客<br><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" rel="external nofollow noopener noreferrer" target="_blank">http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a><br>2、使用 Travis CI 自动部署 Hexo<br><a href="http://www.jianshu.com/p/5e74046e7a0f" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/5e74046e7a0f</a><br>3、使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器<br><a href="https://segmentfault.com/a/1190000009054888" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000009054888</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="TravisCI" scheme="http://www.wshunli.com/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/2a9bf8cf.html"/>
    <id>http://www.wshunli.com/posts/2a9bf8cf.html</id>
    <published>2017-11-09T06:52:46.000Z</published>
    <updated>2017-12-08T14:50:58.576Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>这部分学习 ES6 中新增的数据类型。</p><h1 id="第10章-Symbol"><a href="#第10章-Symbol" class="headerlink" title="第10章 Symbol"></a>第10章 Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。</p><pre><code class="JavaScript">let s = Symbol();typeof s // &quot;symbol&quot;// 字符串参数let s1 = Symbol(&#39;foo&#39;);s1.toString() // &quot;Symbol(foo)&quot;// 对象参数-调用 toString 方法const obj = {  toString() {    return &#39;abc&#39;;  }};const sym = Symbol(obj);sym // Symbol(abc)</code></pre><p>Symbol 值不能与其他类型的值进行运算；可显式转为字符串或布尔值，但不能转为数值。</p><pre><code class="JavaScript">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym // TypeError: can&#39;t convert symbol to string// 字符串String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;// 布尔值let sym = Symbol();Boolean(sym) // true!sym  // false</code></pre><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>Symbol 值唯一，能保证对象不会出现同名的属性。</p><pre><code class="JavaScript">let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = &#39;Hello!&#39;;// 第二种写法let a = {  [mySymbol]: &#39;Hello!&#39;};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });// 以上写法都得到同样结果console.log(a[mySymbol]); // &quot;Hello!&quot;</code></pre><pre><code class="JavaScript"></code></pre><h1 id="第11章-Set-和-Map-数据结构"><a href="#第11章-Set-和-Map-数据结构" class="headerlink" title="第11章 Set 和 Map 数据结构"></a>第11章 Set 和 Map 数据结构</h1><h1 id="第12章-Proxy"><a href="#第12章-Proxy" class="headerlink" title="第12章 Proxy"></a>第12章 Proxy</h1><h1 id="第13章-Reflect"><a href="#第13章-Reflect" class="headerlink" title="第13章 Reflect"></a>第13章 Reflect</h1><h1 id="第14章-Promise-对象"><a href="#第14章-Promise-对象" class="headerlink" title="第14章 Promise 对象"></a>第14章 Promise 对象</h1><h1 id="第15章-Iterator-和-for…of-循环"><a href="#第15章-Iterator-和-for…of-循环" class="headerlink" title="第15章 Iterator 和 for…of 循环"></a>第15章 Iterator 和 for…of 循环</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
</feed>
