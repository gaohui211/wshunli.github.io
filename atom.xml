<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  <subtitle>wshunli`s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2018-09-10T11:53:44.823Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java设计模式（十三）享元模式</title>
    <link href="https://www.wshunli.com/posts/180f2df5.html"/>
    <id>https://www.wshunli.com/posts/180f2df5.html</id>
    <published>2018-09-10T10:43:03.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/13.Flyweight.png" title="享元模式" alt="享元模式"></div><p>享元模式所涉及到的角色如下：</p><p>(1) 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p><p>(2) 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p><p>(3) 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p><p>1、创建一个接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、创建实现接口的实体类</p><pre><code class="lang-Java">public class Circle implements Shape {    private String color;    private int x;    private int y;    private int radius;    public Circle(String color) {        this.color = color;    }    public void setX(int x) {        this.x = x;    }    public void setY(int y) {        this.y = y;    }    public void setRadius(int radius) {        this.radius = radius;    }    @Override    public void draw() {        System.out.println(&quot;Circle: Draw() [Color : &quot; + color                + &quot;, x : &quot; + x + &quot;, y :&quot; + y + &quot;, radius :&quot; + radius);    }}</code></pre><p>3、创建一个工厂，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();    public static Shape getCircle(String color) {        Circle circle = (Circle) circleMap.get(color);        if (circle == null) {            circle = new Circle(color);            circleMap.put(color, circle);            System.out.println(&quot;Creating circle of color : &quot; + color);        }        return circle;    }}</code></pre><p>4、享元模式的使用</p><pre><code class="lang-Java">public class FlyweightPatternMain {    private static final String colors[] =            {&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot;};    public static void main(String[] args) {        for (int i = 0; i &lt; 20; ++i) {            Circle circle =                    (Circle) ShapeFactory.getCircle(getRandomColor());            circle.setX(getRandomX());            circle.setY(getRandomY());            circle.setRadius(100);            circle.draw();        }    }    private static String getRandomColor() {        return colors[(int) (Math.random() * colors.length)];    }    private static int getRandomX() {        return (int) (Math.random() * 100);    }    private static int getRandomY() {        return (int) (Math.random() * 100);    }}</code></pre><p><strong>享元模式的优缺点</strong>：</p><p>优点：系统有大量相似对象；需要缓冲池的场景。<br>缺点：注意划分外部状态和内部状态，否则可能会引起线程安全问题，这些类必须有一个工厂对象加以控制。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch13" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch13</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之享元模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html</a><br>2、设计模式读书笔记——享元模式 - chenssy - 博客园<br><a href="https://www.cnblogs.com/chenssy/p/3330555.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chenssy/p/3330555.html</a><br>3、享元模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/flyweight-pattern.html</a><br>4、JAVA设计模式-享元模式（Flyweight） - 简书<br><a href="https://www.jianshu.com/p/f88b903a166a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f88b903a166a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;&lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;he
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十二）桥接模式</title>
    <link href="https://www.wshunli.com/posts/f75ecf9a.html"/>
    <id>https://www.wshunli.com/posts/f75ecf9a.html</id>
    <published>2018-09-10T09:09:30.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/12.Bridge.png" title="桥接模式" alt="桥接模式"></div><p>桥接模式包含如下角色：</p><p>(1) Abstraction：抽象类，抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。Shape<br>(2) RefinedAbstraction：扩充抽象类，扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。Circle<br>(3) Implementor：实现类接口，定义实现部分的接口，这个接口不用和 Abstraction 里面的方法一致，通常是由 Implementor 接口提供基本的操作，而 Abstraction 里面定义的是基于这些基本操作的业务方法，也就是说 Abstraction 定义了基于这些基本操作的较高层次的操作。DrawAPI<br>(4) ConcreteImplementor：具体实现类，真正实现 Implementor 接口的对象。GreenCircle、RedCircle</p><p>1、创建桥接实现接口</p><pre><code class="lang-Java">public interface DrawAPI {    void drawCircle(int radius, int x, int y);}</code></pre><p>2、创建实现了 DrawAPI 接口的实体桥接实现类</p><pre><code class="lang-Java">public class GreenCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}public class RedCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}</code></pre><p>3、使用 DrawAPI 接口创建抽象类 Shape</p><pre><code class="lang-Java">public abstract class Shape {    protected DrawAPI drawAPI;    protected Shape(DrawAPI drawAPI) {        this.drawAPI = drawAPI;    }    public abstract void draw();}</code></pre><p>4、创建实现了 Shape 接口的实体类</p><pre><code class="lang-Java">public class Circle extends Shape {    private int x, y, radius;    public Circle(DrawAPI drawAPI, int x, int y, int radius) {        super(drawAPI);        this.x = x;        this.y = y;        this.radius = radius;    }    @Override    public void draw() {        drawAPI.drawCircle(radius, x, y);    }}</code></pre><p>5、使用 Shape 和 DrawAPI 类画出不同颜色的圆</p><pre><code class="lang-Java">public class BridgePatternMain {    public static void main(String[] args) {        Shape redCircle = new Circle(new RedCircle(), 100, 100, 10);        Shape greenCircle = new Circle(new GreenCircle(), 100, 100, 10);        redCircle.draw();        greenCircle.draw();    }}</code></pre><p><strong>桥接模式的优缺点</strong>：</p><p>优点：抽象和实现的分离；优秀的扩展能力；实现细节对客户透明。<br>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch12" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch12</a></p><blockquote><p>参考资料<br>1、Java设计模式之十五（桥接模式） - CSDN博客<br><a href="https://blog.csdn.net/shaopeng5211/article/details/8827507" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/shaopeng5211/article/details/8827507</a><br>2、JAVA设计模式之 桥接模式【Bridge Pattern】 - CSDN博客<br><a href="https://blog.csdn.net/janice0529/article/details/44102637" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/janice0529/article/details/44102637</a><br>3、java中的桥接模式 - 简书<br><a href="https://www.jianshu.com/p/c71562c98258" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c71562c98258</a><br>4、讲故事，学（Java）设计模式—桥接模式 - ImportNew<br><a href="http://www.importnew.com/6857.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.importnew.com/6857.html</a><br>5、桥接模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/bridge-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/bridge-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。&lt;/p&gt;&lt;h1 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十一）组合模式</title>
    <link href="https://www.wshunli.com/posts/fb6e1df3.html"/>
    <id>https://www.wshunli.com/posts/fb6e1df3.html</id>
    <published>2018-09-10T08:40:17.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/11.Composite.png" title="组合模式" alt="组合模式"></div><p>组合模式的包含角色：</p><p>(1) Component 抽象构件角色，定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>(2) Leaf 叶子构件，叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>(3) Composite 树枝构件，树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</p><p>1、抽象构件角色</p><pre><code class="lang-Java">public abstract class Component {    public void operation() {        System.out.println(&quot;Component.operation()&quot;);    }}</code></pre><p>2、树枝构件</p><pre><code class="lang-Java">public class Composite extends Component {    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;&gt;();    public void add(Component component) {        componentArrayList.add(component);    }    public void remove(Component component) {        componentArrayList.remove(component);    }    public ArrayList&lt;Component&gt; getChildren() {        return this.componentArrayList;    }}</code></pre><p>3、树叶构件</p><pre><code class="lang-Java">public class Leaf extends Component {    @Override    public void operation() {        System.out.println(&quot;Leaf.operation()&quot;);    }}</code></pre><p>4、组合模式的使用</p><pre><code class="lang-Java">public class CompositeMain {    public static void main(String[] args) {        Composite root = new Composite();        root.operation();        Composite branch = new Composite();        root.add(branch);        Leaf leaf1 = new Leaf();        Leaf leaf2 = new Leaf();        branch.add(leaf1);        branch.add(leaf2);        display(root);    }    public static void display(Composite root) {        for (Component component : root.getChildren()) {            if (component instanceof Leaf) {                component.operation();            } else {                display((Composite) component);            }        }    }}</code></pre><p><strong>组合模式的优缺点</strong>：</p><p>优点：高层模块调用简单；节点自由增加。<br>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch11" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch11</a></p><blockquote><p>参考资料<br>1、JAVA设计模式十七—Composite(组合模式) - CSDN博客<br><a href="https://blog.csdn.net/hfmbook/article/details/7693069" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hfmbook/article/details/7693069</a><br>2、Java设计模式—组合模式 - CSDN博客<br><a href="https://blog.csdn.net/qq_25827845/article/details/52496522" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_25827845/article/details/52496522</a><br>3、组合模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/composite-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/composite-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。&lt;/p&gt;&lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十）代理模式</title>
    <link href="https://www.wshunli.com/posts/b4b3761.html"/>
    <id>https://www.wshunli.com/posts/b4b3761.html</id>
    <published>2018-09-10T08:12:52.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p>代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/10.Proxy.png" title="代理模式" alt="代理模式"></div><p>代理模式一般涉及到的角色有：</p><p>(1) 抽象角色：声明真实对象和代理对象的共同接口；<br>(2) 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装；<br>(3) 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p><p>1、抽象对象角色</p><pre><code class="lang-Java">public abstract class AbstractObject {    public abstract void operation();}</code></pre><p>2、目标对象角色</p><pre><code class="lang-Java">public class RealObject extends AbstractObject {    @Override    public void operation() {        System.out.println(&quot;RealObject.operation()&quot;);    }}</code></pre><p>3、代理对象角色</p><pre><code class="lang-Java">public class ProxyObject extends AbstractObject {    RealObject realObject = new RealObject();    @Override    public void operation() {        //调用目标对象之前可以做相关操作        System.out.println(&quot;before&quot;);        realObject.operation();        //调用目标对象之后可以做相关操作        System.out.println(&quot;after&quot;);    }}</code></pre><p>4、代理模式的使用</p><pre><code class="lang-Java">public class ProxyMain {    public static void main(String[] args) {        AbstractObject object = new ProxyObject();        object.operation();    }}</code></pre><p><strong>代理模式的优缺点</strong>：</p><p>优点：给对象增加了本地化的扩展性，增加了存取操作控制。<br>缺点：会产生多余的代理类。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch10" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch10</a></p><blockquote><p>参考资料<br>1、Java设计模式之代理模式(Proxy) - CSDN博客<br><a href="https://blog.csdn.net/liangbinny/article/details/18656791" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/liangbinny/article/details/18656791</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。&lt;/p&gt;&lt;p&gt;代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。&lt;/p&gt;&lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（九）装饰者模式</title>
    <link href="https://www.wshunli.com/posts/d95b685e.html"/>
    <id>https://www.wshunli.com/posts/d95b685e.html</id>
    <published>2018-09-10T06:37:20.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>动态的给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/9.Decorator.png" title="装饰者模式" alt="装饰者模式"></div><p>一般来说装饰者模式有下面几个参与者：</p><p>(1) Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为。<br>(2) ConcreteComponent：定义具体对象，即被装饰者。<br>(3) Decorator：抽象装饰者，继承自 Component ，从外类来扩展 ConcreteComponent 。对于 ConcreteComponent 来说，不需要知道 Decorator 的存在，Decorator 是一个接口或抽象类<br>(4) ConcreteDecorator：具体装饰者，用于扩展 ConcreteComponent 。</p><p>1、抽象构件角色 Component</p><pre><code class="lang-Java">public interface Component {    public void sampleOperation();}</code></pre><p>2、具体构件角色 ConcreteComponent</p><pre><code class="lang-Java">public class ConcreteComponent implements Component {    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteComponent.sampleOperation()&quot;);    }}</code></pre><p>3、装饰角色 Decorator</p><pre><code class="lang-Java">public class Decorator implements Component {    Component component;    public Decorator(Component component) {        this.component = component;    }    @Override    public void sampleOperation() {        // 委派给构件        component.sampleOperation();    }}</code></pre><p>4、具体装饰角色 ConcreteDecorator</p><pre><code class="lang-Java">public class ConcreteDecoratorA extends Decorator {    public ConcreteDecoratorA(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() end&quot;);    }}public class ConcreteDecoratorB extends Decorator {    public ConcreteDecoratorB(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() end&quot;);    }}</code></pre><p>5、装饰者模式的使用</p><pre><code class="lang-Java">public class DecoratorMain {    public static void main(String[] args) {        ConcreteComponent concreteComponent = new ConcreteComponent();        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);        concreteDecoratorA.sampleOperation();        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteComponent);        concreteDecoratorB.sampleOperation();    }}</code></pre><p><strong>装饰者模式的优缺点</strong>：</p><p>优点：装饰模式可以提供比继承更多的灵活性；通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>缺点：使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch09" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch09</a></p><blockquote><p>参考资料<br>1、学习、探究Java设计模式——装饰者模式 - CSDN博客<br><a href="https://blog.csdn.net/a553181867/article/details/52108423" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a553181867/article/details/52108423</a><br>2、Java设计模式之装饰者模式(Decorator pattern) - 简书<br><a href="https://www.jianshu.com/p/c26b9b4a9d9e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c26b9b4a9d9e</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;&lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot;
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（八）外观模式</title>
    <link href="https://www.wshunli.com/posts/82583d16.html"/>
    <id>https://www.wshunli.com/posts/82583d16.html</id>
    <published>2018-09-10T06:10:36.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/8.Facade.png" title="外观模式" alt="外观模式"></div><p>外观模式包含如下两个角色：</p><p>(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p><p>(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p><p>1、创建子系统角色类</p><pre><code class="lang-Java">public class ModuleA {    public void testA() {        System.out.println(&quot;ModuleA.testA()&quot;);    }}public class ModuleB {    public void testB() {        System.out.println(&quot;ModuleB.testB()&quot;);    }}public class ModuleC {    public void testC() {        System.out.println(&quot;ModuleC.testC()&quot;);    }}</code></pre><p>2、创建外观角色类</p><pre><code class="lang-Java">public class Facade {    public void test() {        ModuleA a = new ModuleA();        a.testA();        ModuleB b = new ModuleB();        b.testB();        ModuleC c = new ModuleC();        c.testC();    }}</code></pre><p>3、外观模式使用</p><pre><code class="lang-Java">public class FacadeMain {    public static void main(String[] args) {        Facade facade = new Facade();        facade.test();    }}</code></pre><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</p><p><strong>外观模式的优缺点</strong>：</p><p>优点：客户代码将变得很简单，与之关联的对象也很少；降低了大型软件系统中的编译依赖性。<br>缺点：不能很好地限制客户使用子系统类；增加新的子系统可能需要修改外观类或客户端的源代码。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch08" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch08</a></p><blockquote><p>参考资料<br>1、深入浅出外观模式（一） · 设计模式Java版<br><a href="https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html" rel="external nofollow noopener noreferrer" target="_blank">https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html</a><br>2、浅谈JAVA设计模式之——外观模式(Facade) - CSDN博客<br><a href="https://blog.csdn.net/l1028386804/article/details/45568655" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/l1028386804/article/details/45568655</a><br>3、java中的外观模式（门面模式） - 简书<br><a href="https://www.jianshu.com/p/1424c90ca255" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/1424c90ca255</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。&lt;/p&gt;&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（七）适配器模式</title>
    <link href="https://www.wshunli.com/posts/69ceed63.html"/>
    <id>https://www.wshunli.com/posts/69ceed63.html</id>
    <published>2018-09-10T01:13:31.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</p><p>适配器模式有 <strong>类的适配器模式和对象的适配器模式</strong> 两种不同的形式。</p><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类的适配器模式把适配的类的 API 转换成为目标类的 API 。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ClassAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，提供一个中间环节，即类 Adapter ，把 Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是继承关系，这决定了这个适配器模式是类的。</p><p>模式所涉及的角色有：</p><p>(1)目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</p><p>(2)源(Adapee)角色：现在需要适配的接口。</p><p>(3)适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色 ClassAdapter 扩展了 Adaptee ,同时又实现了目标(Target)接口。</p><pre><code class="lang-Java">public class ClassAdapter extends Adaptee implements Target {    /**     * 由于源类Adaptee没有方法sampleOperation2()     * 因此适配器补充上这个方法     */    @Override    public void sampleOperation2() {        System.out.println(&quot;ClassAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的 API 转换成为目标类的 API。</p><p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用委派关系连接到 Adaptee 类。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ObjectAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，需要提供一个包装(Wrapper)类 Adapter。这个包装类包装了一个 Adaptee 的实例，从而此包装类能够把Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是委派关系，这决定了适配器模式是对象的。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色</p><pre><code class="lang-Java">public class ObjectAdapter {    private Adaptee adaptee;    public ObjectAdapter(Adaptee adaptee) {        this.adaptee = adaptee;    }    /**     * 源类Adaptee有方法sampleOperation1     * 因此适配器类直接委派即可     */    public void sampleOperation1() {        this.adaptee.sampleOperation1();    }    /**     * 源类Adaptee没有方法sampleOperation2     * 因此由适配器类需要补充此方法     */    public void sampleOperation2() {        System.out.println(&quot;ObjectAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="类适配器和对象适配器的权衡"><a href="#类适配器和对象适配器的权衡" class="headerlink" title="类适配器和对象适配器的权衡"></a>类适配器和对象适配器的权衡</h2><p>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。</p><p>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><p>在 Android 开发过程中, ListView 的 Adapter 是我们最为常见的类型之一。</p><p><strong>适配器模式的优缺点</strong>：</p><p>优点：更好的复用性、更好的扩展性。<br>缺点：过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch07" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch07</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之适配器模式 - java_my_life - 博客园<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a><br>2、JAVA学习笔记—策略设计模式与适配器模式 - tongye - 博客园<br><a href="https://www.cnblogs.com/tongye/p/6676039.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/tongye/p/6676039.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（六）原型模式</title>
    <link href="https://www.wshunli.com/posts/b7ba42b9.html"/>
    <id>https://www.wshunli.com/posts/b7ba42b9.html</id>
    <published>2018-09-07T14:31:45.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/6.Prototype.png" alt="原型模式"></p><p>原型模式的参与角色:</p><p>(1) 客户角色：客户类提出创建对象的请求。</p><p>(2) 抽象原型角色：这是一个抽象角色，通常由一个java接口或抽象类实现，具体原型都需要实现该接口。</p><p>(3) 具体原型角色：客户端所需要的被复制的对象。</p><p>1、创建抽象原型角色</p><pre><code class="lang-Java">public class Prototype implements Cloneable {    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}</code></pre><p>2、创建具体原型角色</p><pre><code class="lang-Java">public class ConcretePrototype1 extends Prototype {    public static int classFlag = 1;    @Override    protected ConcretePrototype1 clone() throws CloneNotSupportedException {        return (ConcretePrototype1) super.clone();    }}public class ConcretePrototype2 extends Prototype {    public static int classFlag = 2;    @Override    protected ConcretePrototype2 clone() throws CloneNotSupportedException {        return (ConcretePrototype2) super.clone();    }}</code></pre><p>3、原型模式的使用</p><pre><code class="lang-Java">public class PrototypePatternMain {    public static void main(String[] args) throws CloneNotSupportedException {        Prototype prototype1 = new ConcretePrototype1();        ConcretePrototype1 concretePrototype1 = (ConcretePrototype1) prototype1.clone();        System.out.println(concretePrototype1.classFlag);        Prototype prototype2 = new ConcretePrototype2();        ConcretePrototype2 concretePrototype2 = (ConcretePrototype2) prototype2.clone();        System.out.println(concretePrototype2.classFlag);    }}</code></pre><p>优点：1、性能提高。2、逃避构造函数的约束。</p><p>缺点：1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。2、必须实现 Cloneable 接口。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch06" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch06</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之原型模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html</a><br>2、23种设计模式（5）：原型模式 - CSDN博客<br><a href="https://blog.csdn.net/zhengzhb/article/details/7393528" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhengzhb/article/details/7393528</a><br>3、java中的原型模式 - 简书<br><a href="https://www.jianshu.com/p/4e1f2d090f20" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/4e1f2d090f20</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;&lt;h1 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（五）建造者模式</title>
    <link href="https://www.wshunli.com/posts/325f89c7.html"/>
    <id>https://www.wshunli.com/posts/325f89c7.html</id>
    <published>2018-09-07T10:07:47.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/5.Builder.png" alt="建造者模式"></p><p>建造者模式中的四个要素：</p><p>(1) 产品类：一般是一个较为复杂的对象，也就是说创建对象的过程比较复杂，一般会有比较多的代码量。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。</p><p>(2) 抽象建造者：引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。</p><p>(3) 建造者：实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。</p><p>(4) 导演类：负责调用适当的建造者来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。一般来说，导演类被用来封装程序中易变的部分。</p><p>1、构造产品实例类</p><pre><code class="lang-Java">public class Product {    private String name;    private String type;    private String size;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getType() {        return type;    }    public void setType(String type) {        this.type = type;    }    public String getSize() {        return size;    }    public void setSize(String size) {        this.size = size;    }    @Override    public String toString() {        return &quot;Product{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, type=&#39;&quot; + type + &#39;\&#39;&#39; +                &quot;, size=&#39;&quot; + size + &#39;\&#39;&#39; +                &#39;}&#39;;    }    public void show() {        System.out.println(this.toString());    }}</code></pre><p>2、抽象建造者</p><pre><code class="lang-Java">public abstract class Builder {    public abstract void name(String name);    public abstract void type(String type);    public abstract void size(String size);    public abstract Product build();}</code></pre><p>3、建造者实例</p><pre><code class="lang-Java">public class ConcreteBuilder extends Builder {    private Product product = new Product();    @Override    public void name(String name) {        product.setName(name);    }    @Override    public void type(String type) {        product.setType(type);    }    @Override    public void size(String size) {        product.setSize(size);    }    public Product build() {        return product;    }}</code></pre><p>4、导演类</p><pre><code class="lang-Java">public class Director {    private Builder builder = new ConcreteBuilder();    public Product getAProduct() {        builder.name(&quot;Burger&quot;);        builder.type(&quot;Wrapper&quot;);        builder.size(&quot;big&quot;);        return builder.build();    }    public Product getBProduct() {        builder.name(&quot;Coke&quot;);        builder.type(&quot;Bottle&quot;);        builder.size(&quot;small&quot;);        return builder.build();    }}</code></pre><p>5、建造者模式的使用</p><pre><code class="lang-Java">public class BuilderPatternMain {    public static void main(String[] args) {        Director director = new Director();        Product aProduct = director.getAProduct();        aProduct.show();        Product bProduct = director.getBProduct();        bProduct.show();    }}</code></pre><p>优点：1、建造者独立，易扩展。2、便于控制细节风险。</p><p>缺点：1、产品必须有共同点，范围有限制。2、如内部变化复杂，会有很多的建造类。</p><p>使用场景：1、需要生成的对象具有复杂的内部结构。2、需要生成的对象内部属性本身相互依赖。</p><p>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch05" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch05</a></p><blockquote><p>参考资料<br>1、建造者模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/builder-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/builder-pattern.html</a><br>2、建造者模式（Builder Pattern）- 最易懂的设计模式解析 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/54910597" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/54910597</a><br>3、23种设计模式（4）：建造者模式 - CSDN博客<br><a href="https://blog.csdn.net/zhengzhb/article/details/7375966" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhengzhb/article/details/7375966</a><br>4、Java 设计模式 — 建造者模式 - 简书<br><a href="https://www.jianshu.com/p/7d16da4e61b8" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/7d16da4e61b8</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;&lt;h1 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（四）抽象工厂模式</title>
    <link href="https://www.wshunli.com/posts/4e3be4ad.html"/>
    <id>https://www.wshunli.com/posts/4e3be4ad.html</id>
    <published>2018-09-07T07:45:07.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>工厂模式可以分为三类：</p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p><p>本文及主要介绍抽象工厂模式。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式 (Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，属于对象创建型模式。</p><p>抽象工厂模式中，一个工厂可以提供多个不同种类产品对象，而不是单一种类的产品对象。</p><p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p><p><strong>产品等级结构</strong>： 产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p><p><strong>产品族</strong>： 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</p><p>抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong>，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/4.AbstractFactory.png" alt="抽象工厂模式"></p><p>抽象工厂模式包含角色和工厂方法模式相同。</p><p>假设有一个移动终端工厂，可以制造苹果系列的移动产品和华为系列的移动产品。<br>这个工厂下有两个子厂，一个负责制造苹果系列的 Pad 和华为系列的 Pad ，另一个负责制造苹果系列的手机和华为系列的手机。这便是一个典型的抽象工厂的实例。</p><p>1、创建产品产品接口</p><pre><code class="lang-Java">// 苹果系列public interface Apple {    void AppleStyle();}// 华为系列public interface Huawei {    void HuaweiStyle();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">// 苹果系列产品public class iPhone implements Apple {    @Override    public void AppleStyle() {        System.out.println(&quot;Apple&#39;s style: iPhone!&quot;);    }}public class iPad implements Apple {    @Override    public void AppleStyle() {        System.out.println(&quot;Apple&#39;s style: iPad!&quot;);    }}// 华为系列产品public class Honor implements Huawei {    @Override    public void HuaweiStyle() {        System.out.println(&quot;Huawei&#39;s style: Honor!&quot;);    }}public class HuaweiPad implements Huawei {    @Override    public void HuaweiStyle() {        System.out.println(&quot;Huawei&#39;s style: HuaweiPad!&quot;);    }}</code></pre><p>3、创建抽象工厂接口</p><pre><code class="lang-Java">public interface Factory {    Apple createAppleProduct();    Huawei createHuaweiProduct();}</code></pre><p>4、实现具体工厂类，生成实例对象，和工厂方法模式的核心区别</p><pre><code class="lang-Java">// 手机工厂public class PhoneFactory implements Factory {    @Override    public Apple createAppleProduct() {        return new iPhone();    }    @Override    public Huawei createHuaweiProduct() {        return new Honor();    }}// 平板工厂public class PadFactory implements Factory {    @Override    public Apple createAppleProduct() {        return new iPad();    }    @Override    public Huawei createHuaweiProduct() {        return new HuaweiPad();    }}</code></pre><p>5、调用不同工厂的方法生成实例对象</p><pre><code class="lang-Java">public class AbstractFactoryMain {    public static void main(String[] args) {        Factory factory = new PhoneFactory();        Apple apple = factory.createAppleProduct();        apple.AppleStyle();        Huawei huawei = factory.createHuaweiProduct();        huawei.HuaweiStyle();        factory = new PadFactory();        apple = factory.createAppleProduct();        apple.AppleStyle();        huawei = factory.createHuaweiProduct();        huawei.HuaweiStyle();    }}</code></pre><p><strong>抽象工厂模式优缺点</strong>:</p><p>优点:<br>1、抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。<br>2、增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合“开闭原则”。</p><p>缺点：<br>1、在添加新的产品对象（不同于现有的产品等级结构）时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。<br>2、开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</p><p><strong>适用环境</strong>：</p><p>1、一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。<br>2、系统中有多于一个的产品族，而每次只使用其中某一产品族。<strong>与工厂方法模式的区别</strong>。<br>3、属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。<br>4、系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch04" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch04</a></p><blockquote><p>参考资料<br>1、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a><br>2、《JAVA与模式》之抽象工厂模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;/p&gt;&lt;p&gt;工厂模式可以分为三类：&lt;/p&gt;&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽象工厂模
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（三）工厂方法模式</title>
    <link href="https://www.wshunli.com/posts/4982f93c.html"/>
    <id>https://www.wshunli.com/posts/4982f93c.html</id>
    <published>2018-09-07T07:40:09.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>工厂模式可以分为三类：</p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p><p>本文及主要介绍工厂方法模式。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式 (Factory Method Pattern) 又称为工厂模式，也叫虚拟构造器 (Virtual Constructor) 模式或者多态工厂( Polymorphic Factory) 模式，它属于类创建型模式。</p><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/3.FactoryMethod.png" alt="工厂方法模式"></p><p>工厂方法模式包含如下角色：</p><p>(1) Product：抽象产品，工厂方法模式所创建的对象的超类，也就是所有产品类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>(2) ConcreteProduct：具体产品，这个角色实现了抽象产品（Product）所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品的实例。</p><p>(3) Factory：抽象工厂，担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>(4) ConcreteFactory：具体工厂，担任这个角色的是实现了抽象工厂接口的具体 Java 类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建具体产品对象。</p><p>1、创建抽象产品接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">public class Point implements Shape {    @Override    public void draw() {        System.out.println(&quot;Point.draw()&quot;);    }}public class Line implements Shape {    @Override    public void draw() {        System.out.println(&quot;Line.draw()&quot;);    }}public class Plane implements Shape {    @Override    public void draw() {        System.out.println(&quot;Plane.draw()&quot;);    }}</code></pre><p>以上内容和简单工厂模式相同。</p><p>3、创建抽象工厂接口</p><pre><code class="lang-Java">public interface ICreator {    Shape getShape();}</code></pre><p>4、实现具体工厂类，生成实例对象</p><pre><code class="lang-Java">public class PointCreator implements ICreator {    @Override    public Shape getShape() {        return new Point();    }}public class LineCreator implements ICreator {    @Override    public Shape getShape() {        return new Line();    }}public class PlaneCreator implements ICreator {    @Override    public Shape getShape() {        return new Plane();    }}</code></pre><p>5、调用不同工厂的方法生成实例对象</p><pre><code class="lang-Java">public class FactoryMethodMain {    public static void main(String[] args) {        ICreator creator = new PointCreator();        Shape shape = creator.getShape();        shape.draw();        creator = new LineCreator();        shape = creator.getShape();        shape.draw();        creator = new PlaneCreator();        shape = creator.getShape();        shape.draw();    }}</code></pre><p><strong>工厂方法模式的优缺点</strong>:</p><p>优点：<br>1、在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。<br>2、基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。<br>3、使用工厂方法模式的另一个优点是在系统中加入新产品时，只要添加一个具体工厂和具体产品就可以了。</p><p>缺点：<br>1、在添加新产品时，需要编写新的具体产品类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度。<br>2、由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p><p><strong>适用场景</strong>：</p><p>1、一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。<br>2、一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>3、将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch03" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch03</a></p><blockquote><p>参考资料<br>1、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;/p&gt;&lt;p&gt;工厂模式可以分为三类：&lt;/p&gt;&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽象工厂模
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（二）简单工厂模式</title>
    <link href="https://www.wshunli.com/posts/6ae09785.html"/>
    <id>https://www.wshunli.com/posts/6ae09785.html</id>
    <published>2018-09-07T07:39:09.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p>工厂模式可以分为三类：</p><p>1）简单工厂模式（Simple Factory）<br>2）工厂方法模式（Factory Method）<br>3）抽象工厂模式（Abstract Factory）</p><p>本文及主要介绍简单工厂模式。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>在简单工厂模式中，可以根据参数的不同返回不同类的实例。</p><p>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/2.SimpleFactory.png" alt="简单工厂模式"></p><p>简单工厂模式包含如下角色：</p><p>(1) Factory：工厂角色<br>工厂角色负责实现创建所有实例的内部逻辑。</p><p>(2) Product：抽象产品角色<br>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的 <strong>公共接口</strong> 。</p><p>(3) ConcreteProduct：具体产品角色<br>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p><p>1、创建抽象产品接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、实现具体产品角色</p><pre><code class="lang-Java">public class Point implements Shape {    @Override    public void draw() {        System.out.println(&quot;Point.draw()&quot;);    }}public class Line implements Shape {    @Override    public void draw() {        System.out.println(&quot;Line.draw()&quot;);    }}public class Plane implements Shape {    @Override    public void draw() {        System.out.println(&quot;Plane.draw()&quot;);    }}</code></pre><p>3、工厂角色，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    // 使用 getShape 方法获取形状类型的对象    public Shape getShape(String shapeType) {        if (shapeType == null) {            return null;        }        if (shapeType.equalsIgnoreCase(&quot;POINT&quot;)) {            return new Point();        } else if (shapeType.equalsIgnoreCase(&quot;LINE&quot;)) {            return new Line();        } else if (shapeType.equalsIgnoreCase(&quot;PLANE&quot;)) {            return new Plane();        }        return null;    }}</code></pre><p>4、使用该工厂，通过传递类型信息来获取实体类的对象</p><pre><code class="lang-Java">public class SimpleFactoryMain {    public static void main(String[] args) {        ShapeFactory shapeFactory = new ShapeFactory();        //获取 Point 的对象，并调用它的 draw 方法        Shape shape1 = shapeFactory.getShape(&quot;POINT&quot;);        //调用 Point 的 draw 方法        shape1.draw();        //获取 Line 的对象，并调用它的 draw 方法        Shape shape2 = shapeFactory.getShape(&quot;LINE&quot;);        //调用 Line 的 draw 方法        shape2.draw();        //获取 Plane 的对象，并调用它的 draw 方法        Shape shape3 = shapeFactory.getShape(&quot;PLANE&quot;);        //调用 Plane 的 draw 方法        shape3.draw();    }}</code></pre><p><strong>简单工厂模式优缺点</strong>:</p><p>优点：<br>通过使用工厂类，外界不再需要关心如何创造各种具体的产品，只要提供一个产品的名称作为参数传给工厂，就可以直接得到一个想要的产品对象，并且可以按照接口规范来调用产品对象的所有功能（方法）。构造容易，逻辑简单。</p><p>缺点：<br>1、简单工厂模式中的 if else 判断非常多，当系统中的具体产品类不断增多时候，就要不断的修改工厂类，对系统的维护和扩展不利。<br>2、一个工厂类中集合了所有的类的实例创建逻辑，什么时候它不能工作了，整个系统都会受到影响。<br>3、简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p><p><strong>适用场景</strong>：</p><p>1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch02" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch02</a></p><blockquote><p>参考资料<br>1、工厂模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/factory-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/factory-pattern.html</a><br>2、JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式) - CSDN博客<br><a href="https://blog.csdn.net/jason0539/article/details/23020989" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/jason0539/article/details/23020989</a><br>3、java中的工厂模式 - 简书<br><a href="https://www.jianshu.com/p/bf8341c75304" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/bf8341c75304</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。&lt;/p&gt;&lt;p&gt;工厂模式可以分为三类：&lt;/p&gt;&lt;p&gt;1）简单工厂模式（Simple Factory）&lt;br&gt;2）工厂方法模式（Factory Method）&lt;br&gt;3）抽象工厂模
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年秋季校园招聘数字政通面试</title>
    <link href="https://www.wshunli.com/posts/93b729e9.html"/>
    <id>https://www.wshunli.com/posts/93b729e9.html</id>
    <published>2018-09-06T13:48:00.000Z</published>
    <updated>2018-09-10T11:53:44.831Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1+9xixiYPBwGuVoPy9e6ch6d8UVZLaZdCH2f9f2xOLVUfBViHGLKL1aC9XuH7b5CCTqSi0Z/1tEy1YrAGDpybmry3OwJ8pgXrsuFP1QKiboZgjVf2F3+Q7TfEuEMVwqeBbD6uLqExo5gnYFPamZN+1F7a6bxs94QIRqqZysO144kkkSdOl9zv5A4OyGZ0DLBCUVy6cifpSBVBlXNC7ECBtiGnLAR+wE5jdCRl71SsA6txo+bhZ55LVv0o7Kl7Gd4Z66NvMOU0orApSIhX9ukVmUwNlWRiWPDnp/xCM3qsB2kjh/XMIPZWdeWCOscuz4u/pxzsDE/occ3KXzqQ460CScAFdOeGhn4mj3AUMYLynYgelbDMWpZ7TQUGpWg+/OwgKKh+t1UmHg6+bLbuqaZPc6CdtViYN46uT2TwVysqtST7aGGHewQGIeE9Vu8LyfDHUVb6LKBHPRVEcN3T91Bsz2bhmzDygdyaSYFTQOTL7sdBzBcxFZM/JU7OVM1cvPWFiq/1ihJvbtumOyifavMCsWz63cQvc4zoXNZdo1IcUf/NDnGbwx4RubaKfWaO4R1gds+BcKHCoBgdYpcXwIUj+c3wM4fUDZFfbX9uskip9w7LcbphycDZ32clTWeAtZknKrhTm9eYtOBIFLOseMiFRwq/mopdt8/TagNaOCnaciCytA0hFi0KZn8alCQs3gSCJhB+KuYZ3L8lL9UzNCFa5fp+RcoKhAZ9Q1OW5FaUX0bNrM3YrndPyZIc1p8hbCEENMcNeEGonZBSn8KI9kRV+XSea3KfRVaqoZ1iQt4NdWwe1H9gK2hgx/bupAYLySqH+abN4ldvGXXEqRuwfILeUA/QDBfXeuR6kLHMZPRLW3hp+LIJTWKr5UmUaSI2H5h9wln2FiPa89rpgfGA9oNq7WVmcfRsmrTE9P1u5m1/u6077GhIuc9TOmp3r1xAWIKh3cpry87+KioGmdS1G4Yxg4MB3ykutRJse0tiM+NKwtpRSkZd+U+EQUZRD7mRvxPUSaYzJZRFf9jhyUgCVhDP3avGLXsA9KA/vjyODcxUE3tiame74Y4kSlJBP5lqUWLbOcdmZqiis/s7IFsjHqHvHvrfevifh/X7sb3gPuRI0EKQy2lYnVm5JnpzwKCmgMFDU2kCDlhVWLEHPmNdi4Y826PhKzdftAjhuONOKwjee0UMRTse5AfHGeAqWiNwqMaRtfqVxU2Pu+rSnQpfiUUMHs+5Q62FdR68tYlt3JTYBCQoxzfNf7E/d0OIZ5CiYKUA56jdpbvIt9gJ+2SUUxT2TKvB7iGdKhxIR9gcOB5CQ4gE/ObKsq08r4w3WGxt2ySFKk7dJp9ckR8C+Wqli3zYSV2++eQaEU16t75Kzj6LW+o1uuwJBxC7caHSflkhhaHLmjSYpvu2rq42qbtFiIKyvqzGJRCO6kbRVnkXlnifsmjN4sK/7zKapxak+R3DhXhSnxlEhljKtdPpHEPykWoOPOLWwxEZsU60jb5qSSgGnbTrCn2gYPQgZ0TignCWJj8Psoz/JbMvG/X1gyRrCclCChet4vI0GA33Un97NPXwbJzTTVFbgdBs1Kt9CJ0hqmdGthq4LHUwwaWkFm8s+acI/m9AW9TufRvUPIJeXBoATk0iv1gi6euoTWzf5OlmgTn0MkHS/BYCvKRTrXmMtv8gasF5aT8s40tNxN/D745uPV3TFkTT+YEwX76Hkazjvnsln19HLdWLWHRA4Y8s1ndYmf0CZJ+u0NgTQoxA4GbfySOxLS0cJv99BvztwcF9c/snuRsPi+txE0QB6FrJiHUyQ0fqQSX9S7SF/ti4zdztDSjzywYUGFkLjqgMvUQ2MOJFQeK8VJswAwVYGD7FMawDIn+D7ax6ySvscttL8MyohezPNu1Pud4h8GqE9VNxOtRs315OExG+ebCTWjKLP6lyxoCjk7i6fbSv44lFnI52SiB6mbtKuCb4amliGMdNNSlkROcOLg0pl5pzfi7HdVReIYuxw5NtRci6gBGTl3JI4SRkyRxOlMozMFtFVQnzXKAvQZ2zDwXB53jDNcB7Mop9Z6P5BSXqG6X55l4NrTuimNqFWJA7UaUBu//P/lrV6ro7YfciCL39386tjcgk+I/el5eBTu8pHJBUnEsN0dgl2KrNYKhBhBggxZqWkh2Nhi8g1yoMsCDBNcK+Ui36b4d7Ehj+I92f0trNtGpIyVL36sD9P/F8oXob61SgGpIEHNmmV1yenOeoe1L3SJutHZPKrsoZTTH2szsqEHeae6Fb3I2XqgVDbckNn/E+wei1KEgkk4cjbHnjjMzzS9SJCdH3MC3HcLgJBnFo156uxqaDxc1Huv8kHmOrUh6eIJFM7gi53dsJGWiELXPqs6FqryK+j9icd0yDs9TRZdBoXGywEGTAjGYPsuvgHgvQqPd8lybcxs/nydzH7JqRp3lOu1g5BpfcKHX8twt88YONi/iDwrzy7K9qnpnVBtOewoK0S5Yi3oy0vYi5czK0UdXvpYQX2NI0xsLskoeu+fU39peqPy1roF9xCqnPiFg9h3KQaMOlPi+W18mzw4xij8MjOZkEX4L2sdy8NwbnX1Cs9hyyOVRL86kSS5bBJeUcJPF18tyD6MJZkz87vUbPM8kH5VN5nDRLu89xWUGt/REyghYKFHtt80XbnbnPLcJtuHYrO2c6IvyKH3od8tNaktl8Y0rPxEarK1MoiNReXzuxlX/ENCGDcc519x1zah+zLmfXKnWkuTIezkMIjxO2g3IaJ1Sbfj+9GINjT0YA2aSp5TVLsn51fk5Sgxq3qwpQyQOR0lMiqDeOGZ/poJm7mfZHYFABCexmyRbcgiVGHVphwXab3g9FLEjZabQlor0a+HbH/NOK2xzY+MEizJRFo5N7VB1fyN7CQrqtETVVm2AjLo/Y5Yp/6DaM/1CCa0M5vVVAP4xdbKqmBmn1iZuSYOBZfpI9kJUHHwb9V4EfEjNvor2+UQhPi8AxO71iMpl7Cnutf7zWigTttNM+zFY1l7B45rgZ5PrmB7aY8w2galOSkJXX5ltQ8m11FF4eR4GfgB4TQOn2bWd7fQaaotN0eup1LxmP0oNwmrahU2FU1AadIRsdJ9rOnFsfzE1l1otG+epoo7+O59aGn7skjUZldKrH0ytMYj9kRY/+dsiMUb1iETNME7I5V4ep4ISDNaPiufyVtpotLkiH15tJv2HdDktvMryIckoTF5y9UMojO0ZqJSwlMNpkW/q6yQUYrnZLuT7ZAhhJmHMukKdoN8wzFZnQlGOtM+sY85kkOv1O3w3SoN0Iom+XeR5LfbKQ3LVdsDzKwO5DZ8UnqAFk3np/halTvE9Y4S0JeEylpJi39ZBtDzOwmvRu0C+NqhBOQTGNAIhXx12XNrtaP2K7zoR/8xiKeO1vynY2TZm/RCsDEWtX3Ih0Ah18/OyNC29fH4ObkGi91J9xRdh2QR9VDlWXRTjLwWCelIuIBJzgJtPYpU5dePADDAR2PtCmRtZDS5yknh4TUbhN7b0DtvK4ZvEI16fg+uWhbokWSxfmHIqYB+3RN1gKV71z/JQKOxBZos+rhZ5abvqwXR//BKTVWScbln+9h+fk9PRok+reiZNdGxrUPa9U6z6pQCAauibOvDG5avStObdsawtmx2X2S7UROzEMOgaoL0L9cvzafvclNDaUiNZnPLjp3bk6rVC5r0LEwBvYaF3IdUjgGBh4lsyjmFrk4d5QqMi9ISHC8EbAmdmCTVcRsm4GILno+xfQGhSBmiOhUQnsG/hZMG8PKw5TRZklp+sswhZ9qaHOBowOoTDiohj/Jtcq8qvwAMFnbPNQ23AOUs1Z1TSh7DGevWSQUJunHa2OE45tQfFDYOelj31Ngmkd5MerLXWH4t/dxIP8K/jktYd9DmIvnUF3Z5SDgyp/+pkPoG3SzupkS3tknaZv1GqG6rNez45b1sTIV9zQo8GO5Q2irpyeo2kEl/LEWjF2lkdS7K/tZoelQa35UACKpsjhD4+KNmO8ZckGPCXnbZ4GaCKHNyI+ZNYuuQ7jCPxNwUjxepGM0rkmvu7Xy/cx/b5A2/FFEu0UiY2KpQwXzG1dpXx5U1GFpfnUKFjM7fcE7M39SvwT+oKSfdQO1LCOOEO3bRMeDtd1JoqBGRIuN2OJkUIKztiq3z60AHl35DpcAx9gtCPM/50QELOStV8qvio8LqUqvKWJU1apY4sjb5wTe8+XzldNuti0Y+mQcvHrBJ0Pt/2ctLVWsqSubKDGptyZ9p4NykHXAaPZI1JvdDnku6G+FgkNxsQlzbfIyIUoKT2pEoxb3wVbrf/JscYuNibUfyOnJWGz2LbTEUfsq3N85zuAvGM94LmJJIa4HxN1mlEMZAkrviyNHLc+4BGHhhITL55QfQZfD7rLFFq4iQr43z+odtfaVeb2cdKX7g9eNrYF/9Yp5LzMTVePRjw0QelWzCY7OQ4E8YDhGnpeQIu2MDLZxgyfa9aJg2Byle9mfFtRQLFCD08Ifi4kK5HT9z4Pin9GBZSK2RtxOa8QzgasGEiGlx0KvjjId+2m5B3gwxnNlZbzMKYH3uZ/PcxE8jVbsCYbj+yt35ceZNW0E102mDCL/qPpKy82WuUYx5WR4b5JU+GB8guaSx7LztQFhWnVmBPYQVB3JZzYafyyacicMByJuAg7vi4LbXv4oY7GHusIKBnUqnHNdgCpXYvrSplTmvY9z69M42Z1BAEMI93JA6SQooZ1vBf/MNDUg7sC1DlhHLlOh+51xHKbzWYsfteYRaI9mhtDzXs8X5eK1MR1M+mSvk8QCGdFKeT6RLh/QuoRe5QbQRf/bZJlTvO0XmuJGZ8TB0iDGCu/zgBIs8dd+p0wANZg7B1qgY+r8Kc/wfF8Z5L3/SFz+YjvSkRK4SpmGIxmCZqkF/GECkecmwJjaCl6FvKDypewgPQ2btA3sC9YQbL2CD2OYvnxB7bxuZPQeWj6UzEdr9ZlQCmx6GliwSvQnsKZYTC9J4vuwsr+u3TkK+gpuCSJjxPdzDubwx3Wv93mbNOrJ8PDF/y1UYa7dqIQs0sAaXVh6HNqRrP56C7E41Tp4SJ1DqmMwlQ15v7hBrjwwgehFnZGI/seyYLjhXCZXIPBcro1bFgiVcXANFsOlQmM27zWOs7f07fV+xlMwH/tsGtEdT7gu7KF/7S1W8Mj2GffhgR7Uu+50+IjF95/V13bUNgfv6y5NZnwB77Nz+6CiQMTucFkrLZZqMlN3wm9uRssnUVfLiEL3ztAY5SXZNYI+QNfvwrKpmRnqbN7YvMH/6r4dAjJKkjIwPTCvCPT1RC8izB1PXcUSR6QVLxoDbVDUk17i8+RHqfwFG8txL7lG9IXGlVYE74XN75uhMuqsFnc6zjBhsVCdxl7cx5CcNEeFNo+BPl02fW6tVbhhTHVf8jGMiSymyUuWmTYCcDOz24zA7ltj+b8hvYHzRKRGZBZePzFyXMAbvaKqEeGIU6LI98L8u/3DItUs5Bxwo9vDNUEofbvWFK3uinP2VUDAQtruRxqp0cFlAPsBX5Rv9yD8rsPnFdCzeO5I09gxIFNy4wVmKr19omYK1cmOja89+p0rzfYFxIiL0KgyRv9IndzNLcuJu+QjJLL2hqQpH0smX4LZeWP3g9zVo6bT6TDpJeM61GjYz+71xSCnXtnpTupNy1C4EEwQW8Gv6SiGCkT732TqBN53urD0DyQ1ZacSo3uADgvffOu2xcwfq09JWrCaeseEj9FiEizAXaUoaZQpBJnLKKH/QDoy9R/WiFgk2zKKb5OZuqrnRoesMYVxoRdsetqbMKCFRX5kHssKi5IjQ58FESRSycjxCafD6wxohSece3Pl+7KV9c+qurNYbGfL2SsNi62Okc4rtDBXqJeGC8/I63OTNoFVfvgbbSrlJEpNKYFQphHgfPMQuoR77xO3Doks35bMa93oVs28joak1uH3usFz1F/E5ZtYWzz4B4hRadq+qVVteFjIkTne7Y0Kbqg4PxCjYc9eq8dlGAB7ngPR0F/xNzIweDUqDMhanD785Bbr+z4APBjP7mLu2IzFbYaat/WDsDkGEzSAnz6syANEg+cb/cb5SndD10IpYhYYlspK4SH4LCoeh2Dpkl+pW5BV5Hco251SnpvaKIJvliUSEekpxBQF6dw1jTWCX2myN7juO1iV3ZKMJmLIQgEUoezJUbVw1xEi0x7f5LsEV4IWAZ0gJRXDjKP/Dtlkuc6ZkzPPhtkfc01NwaI5gdAPQq4A4Xx59+2Vk6riW7aU/UWZWQZhwgJZLbHdzNZDCUXkeswY2QsckTlqfA6GOiK0gMhRO/+hJU08mUqWtU5uX8Dh6tYTGNrUo1BpQ8oJA+owMb313CJAoM3oVUPfwTwPEjRcxNOA7UgI0i/gQ9VkOGLFA92/MDOgM6wKz0NzqTTzoPNn6xoMgbmIBFBhIanunVJruhzYG5q13fai/pvvyCAbmxencxQ6d0mdKb5bPum/VNYEoQ+ci4Zv8r3aw4EouSJBqyzlTgfcElZbYVS2TdQ+wnMKPH5gGTXmPCFKg8COM8jssUYUc5F+Np/0p2stgKQCtRdGSSxuYfUxXPVTx4SDAbpLmmMvHvetOj77amG98tWhJbmBp1hT9/ZwIYeyiQH//sjzWotaFCRsvqlwUIp1F64xkxHL72Tgy4KFla1j+tke1JE5nnQNjwRhwR60hhG3OqJzbjmYSKEK4FXFMP5A+MSTkuw2HTVNuIo5yt4Xj3UFyTq4XyZBo1R7gIWdQCfSPdm17N+F0EyjrswXY59e8beehL4xrH/yKHrWNw3McjK6MCBQDZMdoRkTK30J7GBJkSN2unRYSXsmhoRBJyLluIUNTdF5SRszjz+TP2kAJuj7MG1wHKyRjSxOh4fYB/GPhH3SqUNCdHtbdBvgCJgVJjiWYZZGQuCbrSp+giteuyY3tIfFWuveiBZ6pbwpYs1O4w68EMVqgGlWKB8Uf60ybvQLzD5XwWKboN9mX3B+eGcE9zPCJ3n3D10jVU9aBSnTDZx8mAOuv+xJMBCsMaPpZtmqwEeBdej8JhLY2Crxa7KBTkmgWXF3ECY/IxAj8Khm+t6tNmj5+3QDEeSL7Z+12mKDAMkzQqmsQnJnT8kOwX4f8pDcyoKNGfiXHC61LGymOztVWBO6F9gxh1FZymvXj1QZFIdbiBCK1Gno9wCZWnikAk72CTjgsdCbXxyveIO3g3myzxhFXXnwLKgS3Il7KcPpNSA7LhMI+bnlKu0R3hE1fzbwT5INVrvgch4dRPUJ8Zw8NFf8wWPB1j+E/8PSWewaB6yE11oxnyMWPbpKQkl960NahHcq+5NU3CrabqstckX1gjQQ7k97g6IsKexXFmOMaaA7mUwP84kP+7vc9cpfKFejdL9yX6Agxa4AYw1dgKkkqwW1zvuPZmHXXPcxzziG1MwBhnPy5ZNGxo3aQUk3Ip4iWaK0tkFV9u1ikpWc9zkdvSFlbBLteTJd1+V/sn/vNb0SRPIzmWDgHmdK2OaND5ddL/NU3Ryfh/1gt7QOzHBUi0jCuM+KWVHeBU5UehB15qZBd+a82QI420jqIlD1gYpd3iYk3DMqiiKjZ7L40bc1TGs4GpszuMTXo+99zuEQuF//bnwgcT6h+i83TwyHclCbKhdVBwPVogCCkPsfjYBspz68H8vZ3XDt3ctOK+OL84DgC9RpXy7qGzKMOJjZmajZzGRKpH52y/XQwDWQQWCeYZIXRYqq+swq1FTfnV8dq7eZ9SA9+seT9f1Fd4TmqPobzNquUbB5l3aMRra9AT5Zfyxsm5pFAHCfHhqKXzHSbDnE6Xr2iLhnRge5vd/udtJvM1IoVDgeZ+aan2dhm/7VukhHXwKWjuSG++R1uTvQQBatqQ2EnnUnCOUS8W4sutuHooJJLVRYJqqG7nRZWfcKVG0wU8HUoRaxpA6v1jDig7xYE19D098HV2OKXisqbiAwKiV3OEtNYqm2lso7p4UOBdxA1bZgBY8oIWiWuOTvIJdVzSLpqUPaHoPfysNRKXAVhz61m2b/yiRXKlXx34rRfXS+/xvx2ncV+ENyiZoe31ysKt69lf/oryGxb1Q28noC4VS9DvhhJQGI+EgEt5PK/pYz8RqMXw4nsXgnIV+1WeQ5e+epa+Ej757SLPx/G8nxI9mAHICuFYeqg3MKJVqtLKIMTO2oP2ABAfUNcTJlnXHqtArSRKdWkUz4e9rtq2Wv9UjbQ7fKlLJ0BYw18Qo2UBNkOS2pImqq9xmvZWTLU0dRIiAJ4RMuS267rHzOxOlpH+HHHc+WonOqKasmqRABDPZo5/4rwBLeYim5hLrKhWgfYRu2K1/AF+p2DoiiCRm6bp7E2CGgYHwfGUYZpizShWL1lkB4DwrauqRx8oRxzeMJPXkNAPvw0KuBxwIU/oVpgPLCZPYLTXMopTq+E0/FvJM1hSQ89okptvAyZCXnNDxLMN+N8Nwt6JFpT0kpQDtK2RP8ryW31KgxmP8MbIZAdWkziYBhVixLOqH3Gh2eQueMxEe1hVgP/cv2vn9wda/by887O008dCxkJuI/srfFLyZ6UJYU8g9WaH54cqMRHho5BTgOAr9O9K0mYgLExoJKZFG/eTsm3F777e2NeWTzS0AeEAXEWKMyjJ14rb/fqbwRadynMHf3bLlgQhuNHyurb8+hXH2Uvdu4Um5q6vuF5tCyGwRav24PatvdngaMJx4SsIp7ICbg1em4/QIAYSksk68ic0mKEm2bZtqncCLA/Eve64fXO0zFgKkItbMS8lzVb/EqMqzmstlq0hDcK48/haqNk4c8iAAXH91G+1PDzSMDGWIJHTR50/leoJL+J/i8N2FmrJ/lv5NR1GO5KetYa325k+F2FbwlRiMTyzAO0FT3eDOuFbfFXNK/P2tlupEhNj8+wM231j+8v+6GG8expvxdqAaasPQF81pRd/AEdL4UFVfPvkUjkx7PVGuaGmzVMxzFwHNAiOXep2RrSSbjW3L/++iIRXLWKAb0sbGewmMrselQJbJXyUaDldC92indyIdh3lP5DccrsQiyG8zQD4MQVIGQhpXe2atOnf2ZeZsx1bvJ4BbSC6SO+Qodzmu8S2tqji8//BYuylGM27xaNrVKYiKUCLiXEdKY715m5EX1hqCpk9RNSEV2++ui/kGt1Wftj2cRbqKjTKCOs2FbPXSE9TJ+04MlEA0L+xoGDmDnwgJTENlwH1DbzxAkHwRKex4NKfh/T3GpQP/PiQEOEUtr0C412Wj4e6n6h1unYdNu63yJ17Gs6nsHEPvjtcAoT2Uk4M5O+V5WmA02B4h27OPjyD9JEWHsoAN14anDQKwUweZJe5seCmNS/lZWgy85yKpyJohjGCjYI7JWst3LGnvVSlcHzcz3mKxk8/Ts+/5DbI2TpevWg+fyZDW1LoLzA1/i0smAaHyuKRRJ1jB38okWGLJhAGFJi5hG/F5TbyiLAeDgsxK62y+QdZy3hSTofNV1QGOzHWw/FOWFf47DtogPv+YNdNm2Q/7Lj1PPhwxfKI4cLE3Y/Fb3ZolpvbXsS1p+26r3OJEYUIpaqpAf7MPee4dbaIgQPgOHQtdcPv5WFTnUu7MexHnhFHGAN0CNoO57dfjFsTNG2I1LceaM8yQdDnufSBX8gBdGChCVHUr+6uDeWtcIylrP2hJZexQcSKNpzS7DrxJXrDi2fKK6vrPYmyOIiyGSaFIx4EZCDEeFQFRRqR5BAGXacdDGqNO7ug2r81cX+c7Tvj+h+reHflSNtygeMCPOV1HhuCbHyy/4EcMTl3ud528AOC5vmmhTaMmEy/CnWgdPnLQ1zhofMtKDOBIhgpxGA+cH+kHl/U5De/R1kI43kbuPlFyecYfbtrxoKqb03WThuiu64TtnHQScV5EFXhxDJUe4EWfVKmwOD9+3L9X6+75S5k28W0DNG9cC+5U6VENzhDga0ufLRqaz/0wEkeKyWzb2ovClEo5PSJx7IW6LPyzeVvhv2FLQUERa8n0rv6hg4sTUWtKSm5VP0z1ZmoOWrcL3iGf+lvMQaP++CLtjPIEHioE0BhH6qkUgUd1k8c5xUx8mKzNSNGWVxccdstPgxCNgr4YkJN6/ZIrFiZAkzP+tUtdvswKuUflPfSR+fYq85DkViWAdoXhPgogWQ0BOJ5VIydZdULIZRMl3e75jzQ9dUhv/WOwaPi1y4s4cZhxnoUqmL0KhVlAglL2CpK7fgO7GZrKv1rgyQSqRsJpQRbdmQVAV2O35dAUp20AkHez99XHGSGsvGtAUEt3MNDtQSSASYq9f90ZA+W4act4itgxd7mehuLlgKC1ATwoTlyePtIclDZp1dSeIvOKD37QVdWtIJDlwkhUiWsT4G8PRvJFW3pYHaKuF6kiUE0Tc2DtaSfUDtnWvQlNOi/w8iBJ2WTsjf9NOlAHCC5kpzOp62/h3xiJ9NGJS/lA/rDKo5FLA1Y/CpjEDLHJgAWBeI4Mbv1w9LD2pzOsoN/Ks95l0pbBZGVOfW0xeYG5oXfA7RvUwpoMgmEbJqdVbw08rfbI9sLi0gZod8V4WbXs9Mkge/N42XO5cuvJ0AhzuB44/SVBHcTNJMilpUxSxttFNmtL6ssHDssIz0ZJzbACOLB0Qe/gPrVXFlLtjgEddkujnlRBWefIY1Xo+6MpBptiK0KqWB0HVVZ/W6/3muQpKGb/DNkpUTIBYAhr7EUA+AP8W+0XrWDlTvMHC6j765q9rs58sROYq8ESh0NbQtpX1FejN7/AuE2VwITUTZ0oyGXWzs5SdcZezMiSi91YjdL59Vc/M/v5EwedXMdyGYWBu68ym6vgbv30hDE5t3yXdUKFaC5GZL7x7mUBNDNhvdOmIUXYgen5GIXMDlRk2Nty1aYZhAHsq8SMKgXhWsPHJVn+CWWiWq0qgEhFqdw8Za6WO5lHmQRr1FojiW8PKZZAKQzTQ1sKpz2H/2d3jZU46E/2aNq69RCCR8XNFv12NkbR6XKkIQIVUusaXd9n7y9XGms7EW6QqJIHX/aWxbqo0XkxYn4cPuEiD3JeGfGXIQHfXDFjCC1oLgLnUXHXqpYkwi5iSuJLeWg07Eh5IlAeDFMRMSEJqZN7bM+lrjdtHIvcL8D+ldvJExOg/Lo2+TWmztUbPmYmPo4dGMYLZtxo7ShbEJmyf0ccIOArV85jqCpdFJ7b2XmROvJMUXPPHINJPhJMzHR/+aktWvhRTNoAYkqItyp+q4O8dvc90R+p9I+lD60lvlIXO/RpPmG11VB2i7kgk3tG5d2uXxG6t+5hnybRo49324W840rhHve7LBBA8Ez9zqu3BjlnUfBB2SL4x8pRp2nafL0x1h/eG7WvGuUUAAOr//WtifY8ystOXAB/2N49/HyBzxWlw97G89F4KIm3zMzJXxW688H0QZABRQc7tlQkTL+Uk/6/qYCE+8Bxz6Pepws/zy4OLOwCr0Oi5Sg9QROPuigXLGfKma5oXFfA8zmFAFQTlIMBNkxSKRqW+Ke2484zRFgTxk3w1XLxh1Ne62JKZ6j/rnXRLWtb4w9H6IfyIGSj8wgP4gTN3iLSHE4IMroIRbSmarKrI+fCoIK0ybPrLSsZOGIqY+87Z1wh/AIxj3so8DKsD4/hAfD9BfuB/C88GGnkh/VZsiOZGt1i1lbuiQYEZG03vknDLApnb1Pk/t/MHnLBY7JmtaI8C5wBp9XuKMG25Nkh0+cQ03Mwn2X16Wp0uvOo868eSYsiwTyOBKT0KaT3xkdDFm16SHyHZf94ENAUsDtb0vEw0q69VukSEDCH2kxJpxVfRCtGJUP9oJLFBCtu1OWw5Zrjnm0R+nrkFptlhbWOTyguE/x3y6XqvivebEJjcE0xQWC5GdzpO/wYgPCy/flk+E4HvoiRqFtSODay0Z+kqSNo6eZPdH7GeKzXhZ7u9jDztwpECHO9BDKRSvEF/mfiUu+1/xN1by8mXEZ4gin3nKQWDPTDZZzhVxToOEjcFOX3NM65qxzEXwSN7WHZG8To3IAc0jGPM3i7S007ep97/uOQg8vnYeN28c5rM/LydN/tRgxfLhSJnC075gIxoXuF98l1vl4IxOu22CuF04HtiCjXECaCADd++PHO/RrZXaeR2rSw6HBjcWlp70d098Pkesuy9wqu5RaygWhrgphW379Kpto+ucdel9PhGOU4TaiV3Gx+5O0QqE5K8I5Ti4E9ePeNu37R9d1MY0e6nqa57G0AbsB8scBXn/Bou9kZ5tREaUMXh5eg9UH4EvwS8= </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】记录2018年秋季校园招聘数字政通面试（Android开发工程师）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年秋季校园招聘中海达面试</title>
    <link href="https://www.wshunli.com/posts/c783f06d.html"/>
    <id>https://www.wshunli.com/posts/c783f06d.html</id>
    <published>2018-09-06T02:43:04.000Z</published>
    <updated>2018-09-10T11:53:44.831Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】记录2018年秋季校园招聘中海达面试（Android开发工程师）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（一）单例模式</title>
    <link href="https://www.wshunli.com/posts/d1c4534.html"/>
    <id>https://www.wshunli.com/posts/d1c4534.html</id>
    <published>2018-09-05T11:51:25.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p><strong>特点</strong>：<br>单例类只能有一个实例。<br>单例类必须自己创建自己的唯一实例。<br>单例类必须给所有其他对象提供这一实例。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式的其他几种实现方式：</p><p>1、饿汉模式，线程安全</p><pre><code class="lang-Java">public class Singleton {    private static final Singleton instance = new Singleton();    private Singleton() {    }    public static Singleton getInstance() {        return instance;    }}</code></pre><p>饿汉模式单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance() 方法。</p><p>2、懒汉模式，线程不安全</p><pre><code class="lang-Java">public class Singleton {    private static Singleton instance;    private Singleton() {    }    public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><p>3、懒汉模式、线程安全：</p><pre><code class="lang-Java">public class Singleton {    private static Singleton instance;    private Singleton() {    }    public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;    }}</code></pre><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。</p><p>因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。</p><p>4、双检锁/双重校验锁（DCL，即 double-checked locking）</p><pre><code class="lang-Java">public class Singleton {    private volatile static Singleton instance;    private Singleton() {    }    public static Singleton getInstance() {        if (instance == null) {            synchronized (Singleton.class) {                if (instance == null) {                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><p>5、静态内部类</p><pre><code class="lang-Java">public class Singleton {      private static class SingletonHolder {          private static final Singleton INSTANCE = new Singleton();      }      private Singleton (){}      public static final Singleton getInstance() {          return SingletonHolder.INSTANCE;     }  }</code></pre><p>6、枚举</p><pre><code class="lang-Java">public enum Singleton{    INSTANCE;}</code></pre><p><strong>总结</strong>：</p><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。</p><p>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p><blockquote><p>参考资料<br>1、单例模式 | 菜鸟教程：<br><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/singleton-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式（Singleton Pattern）确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;br&gt;单例类只能有一个实例。&lt;br&gt;单例类必须自己创建自己的唯一实例。&lt;br&gt;单例类必须给所有其他对象提供这
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（零）设计模式概述</title>
    <link href="https://www.wshunli.com/posts/af6d1ac0.html"/>
    <id>https://www.wshunli.com/posts/af6d1ac0.html</id>
    <published>2018-09-05T09:43:14.000Z</published>
    <updated>2018-09-10T11:53:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式也是比较欠缺的一方面，这次看的是 《设计模式之禅》 ，前面看了一点 《Head First 设计模式》感觉都是图片有点乱。</p><h1 id="第一部分-设计原则"><a href="#第一部分-设计原则" class="headerlink" title="第一部分 设计原则"></a>第一部分 设计原则</h1><p>单一职责原则：应该有且仅有一个原因引起类的变更，对于接口设计时要做到单一职责。</p><p>里氏替换原则：只要有父类出现的地方，替换为子类也不会产生任何问题或异常。<br>　　<br>依赖倒置原则：模块间的依赖关系是通过接口或抽象类产生的（面向接口编程）。</p><p>接口隔离原则：客户不应该依赖它不需要的接口；类间的依赖关系应建立在最小的接口上；尽量使用多个专门的接口。</p><p>迪米特法则：一个对象应对其他对象有最少的了解；只和直接朋友交流，朋友间也是有距离的；一个方法中尽量不引入类中不存在的对象；减少 public 方法和属性。</p><p>开闭原则：对扩展开放，对修改关闭；通过扩展来实现变化；不允许出现接口或抽象方法中不存在的 public 方法。</p><h1 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分 设计模式"></a>第二部分 设计模式</h1><p>设计模式根据目的可以分为三大类，分别是 <strong>创建型设计模式、行为型设计模式以及结构型设计模式</strong> 。</p><p>(一) <strong>创建型模式</strong> 涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解藕。</p><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p><p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p><p>1、单例模式(Singleton)</p><p><a href="https://www.wshunli.com/posts/d1c4534.html">https://www.wshunli.com/posts/d1c4534.html</a></p><p>2、简单工厂模式(Simple Factory)</p><p><a href="https://www.wshunli.com/posts/6ae09785.html">https://www.wshunli.com/posts/6ae09785.html</a></p><p>3、工厂方法模式(Factory Method)</p><p><a href="https://www.wshunli.com/posts/4982f93c.html">https://www.wshunli.com/posts/4982f93c.html</a></p><p>4、抽象工厂模式(Abstract Factory)</p><p><a href="https://www.wshunli.com/posts/4e3be4ad.html">https://www.wshunli.com/posts/4e3be4ad.html</a></p><p>5、建造者模式(Builder)</p><p><a href="https://www.wshunli.com/posts/325f89c7.html">https://www.wshunli.com/posts/325f89c7.html</a></p><p>6、原型模式(Prototype)</p><p><a href="https://www.wshunli.com/posts/b7ba42b9.html">https://www.wshunli.com/posts/b7ba42b9.html</a></p><p>(二) <strong>结构型模式</strong> 可以让你把类或对象组合到更大的结构中。</p><p>结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。</p><p>结构型模式可以分为 <strong>类结构型模式和对象结构型</strong> 模式：<br>(1) 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承和实现关系。<br>(2) 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。</p><p>7、适配器模式(Adapter)</p><p><a href="https://www.wshunli.com/posts/69ceed63.html">https://www.wshunli.com/posts/69ceed63.html</a></p><p>8、外观模式(Facade)</p><p><a href="https://www.wshunli.com/posts/82583d16.html">https://www.wshunli.com/posts/82583d16.html</a></p><p>9、装饰者模式(Decorator)</p><p><a href="https://www.wshunli.com/posts/d95b685e.html">https://www.wshunli.com/posts/d95b685e.html</a></p><p>10、代理模式(Proxy)</p><p><a href="https://www.wshunli.com/posts/b4b3761.html">https://www.wshunli.com/posts/b4b3761.html</a></p><p>11、组合模式(Composite)</p><p><a href="https://www.wshunli.com/posts/fb6e1df3.html">https://www.wshunli.com/posts/fb6e1df3.html</a></p><p>12、桥接模式(Bridge)</p><p><a href="https://www.wshunli.com/posts/f75ecf9a.html">https://www.wshunli.com/posts/f75ecf9a.html</a></p><p>13、享元模式(Flyweight)</p><p><a href="https://www.wshunli.com/posts/180f2df5.html">https://www.wshunli.com/posts/180f2df5.html</a></p><p>(三) <strong>行为型模式</strong> 涉及到类和对象如何交互及分配职责。</p><p>策略模式(Strategy)<br>状态模式(State)<br>责任链模式(Chain of Responsibility)<br>解释器模式(Interpreter)<br>命令模式(Command)<br>观察者模式(Observer)<br>备忘录模式(Memento)<br>迭代器模式(Iterator)<br>模板方法模式(Template Method)<br>访问者模式(Visitor)<br>中介者模式(Mediator)</p><blockquote><p>参考资料<br>1、图说设计模式 — Graphic Design Patterns<br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html#" rel="external nofollow noopener noreferrer" target="_blank">https://design-patterns.readthedocs.io/zh_CN/latest/index.html#</a><br>2、设计模式Java版<br><a href="https://quanke.gitbooks.io/design-pattern-java/" rel="external nofollow noopener noreferrer" target="_blank">https://quanke.gitbooks.io/design-pattern-java/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式也是比较欠缺的一方面，这次看的是 《设计模式之禅》 ，前面看了一点 《Head First 设计模式》感觉都是图片有点乱。&lt;/p&gt;&lt;h1 id=&quot;第一部分-设计原则&quot;&gt;&lt;a href=&quot;#第一部分-设计原则&quot; class=&quot;headerlink&quot; title=&quot;第一
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>图解数据结构-算法部分（Java语言实现）</title>
    <link href="https://www.wshunli.com/posts/444e2c0f.html"/>
    <id>https://www.wshunli.com/posts/444e2c0f.html</id>
    <published>2018-09-04T06:48:13.000Z</published>
    <updated>2018-09-10T11:53:44.831Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法一直是比较薄弱的地方，不仅在面试的时候会问相关问题、手写代码，而且在笔试的时候发挥重要作用。</p><p>前面一直学习的数据结构，下面排序、查找属于算法的范畴了。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>所谓 “排序” (Sorting) 就是指将一组数据，按特定规则调换位置，使数据具有某种顺序关系（递增或递减）。</p><p><strong>排序分类</strong>，可分为内部（内存中）和外部（外部存储器）排序两大类。</p><p>常见的内部排序法有：冒泡排序法、选择排序法、插入排序法、合并排序法、快速排序 法、堆积排序法、希尔排序法、基数排序法等。 至于比较常见的外部排序法有：直接合并排序法、K 路合并法、多相合并法等。</p><p><strong>排序算法分析</strong>：算法是否稳定、时间复杂度、空间复杂度。</p><p>稳定的排序是指数据在经过排序后，两个相同键值的记录仍然保待原来的次序。</p><h2 id="内部排序法"><a href="#内部排序法" class="headerlink" title="内部排序法"></a>内部排序法</h2><p>内部排序法的时间复杂度及键值整理。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/内部排序法.png" alt="内部排序法"></p><p>1、<strong>冒泡排序法</strong></p><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/冒泡排序法.gif" alt="冒泡排序法"></p><p>实现算法：</p><pre><code class="lang-Java">int i, j, tmp;int data[] = {6, 5, 9, 7, 2, 8};    //原始数据for (i = 5; i &gt; 0; i--)             //扫描次数{    for (j = 0; j &lt; i; j++)         //比较、交换次数    {        // 比较相邻两数，如第一数较大则交换        if (data[j] &gt; data[j + 1]) {            tmp = data[j];            data[j] = data[j + 1];            data[j + 1] = tmp;        }    }}</code></pre><p>但是这样如论如何都会执行 $ n(n-1)/2 $ 次，我们可以加一个判断在没有可替换的数据时终止程序。</p><pre><code class="lang-Java">public void bubble() {    int i, j, tmp, flag;    for (i = 5; i &gt;= 0; i--) {        flag = 0;           //flag用来判断是否有执行交换的动作        for (j = 0; j &lt; i; j++) {            if (data[j + 1] &lt; data[j]) {                tmp = data[j];                data[j] = data[j + 1];                data[j + 1] = tmp;                flag++;    //如果有执行过交换，则flag不为0            }        }        //当执行完一次扫描就判断是否做过交换动作，如果没有交换过数据，        //表示此时数组已完成排序，故可直接跳出循环        if (flag == 0) {            break;        }    }</code></pre><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近 n²/2 次, 时间复杂度为 O(n²) . 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n).</p><p>平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的 temp 变量需要内存空间, 因此空间复杂度为常量O(1).</p><p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p><p>2、<strong>选择排序法</strong></p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。</p><p>算法描述：</p><p>(1) 从待排序序列中，找到关键字最小的元素；<br>(2) 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>(3) 从余下的 N - 1 个元素中，找出关键字最小的元素，重复 (1)、(2) 步，直到排序结束。</p><pre><code class="lang-Java">void select() {    int i, j, tmp;    for (i = 0; i &lt; 5; i++) {            //扫描 5 次        for (j = i + 1; j &lt; 6; j++) {    //由 i+1 比较起，比较 5 次            if (data[i] &gt; data[j]) {     //比较第 i 及第 j 个元素                tmp = data[i];                data[i] = data[j];                data[j] = tmp;            }        }    }}</code></pre><p>选择排序的简单和直观名副其实，这也造就了它 “出了名的慢性子” ，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近 n²/2 次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><p>3、<strong>插入排序法</strong></p><p>将数组中的所有元素依次跟前面已经排好的元素相比较，再将数组元素插入合适的位置。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/插入排序法.gif" alt="插入排序法"></p><p>实现算法：</p><pre><code class="lang-Java">void insert() {    int i;     // i 为扫描次数    int j;     // j 来定位比较的元素    int tmp;   // tmp 用来暂存数据    for (i = 1; i &lt; size; i++) {  // 扫描循环次数为 SIZE-1        tmp = data[i];        j = i - 1;        while (j &gt;= 0 &amp;&amp; tmp &lt; data[j]) {  // 如果第二元素小于第一元素            data[j + 1] = data[j]; // 就把所有元素往后推一个位置            j--;        }        data[j + 1] = tmp;       // 最小的元素放到第一个元素    }}</code></pre><p>Tips: 由于直接插入排序每次只移动一个元素的位，并不会改变值相同的元素之间的排序，因此它是一种稳定排序。</p><p>4、<strong>希尔排序法</strong></p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><p>实现算法：</p><pre><code class="lang-Java">void shell() {    int i;        // i 为扫描次数    int j;        // j 来定位比较的元素    int k = 1;    // k 打印计数    int tmp;      // tmp 用来暂存数据    int jmp;      // 设定间隔位移量    jmp = size / 2;    while (jmp != 0) {        for (i = jmp; i &lt; size; i++) {            tmp = data[i];            j = i - jmp;            while (j &gt;= 0 &amp;&amp; tmp &lt; data[j])  //插入排序法            {                data[j + jmp] = data[j];                j = j - jmp;            }            data[jmp + j] = tmp;        }        jmp = jmp / 2;    //控制循环数    }}</code></pre><p>5、<strong>合并排序法</strong></p><p>合并排序算法是将两个（或两个以上）有序表合并成一个新的有序表；<br>即把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序子序列合并为整体有序序列。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/合并排序法.gif" alt="合并排序法"></p><p>6、<strong>快速排序法</strong></p><p>快速排序法又称分割交换排序法，是目前公认最佳的排序法。</p><p>它的原理和冒泡排序法一样都是用交换的方式，不过它会先在数据中找到一个虚拟的中间值，把小于中间值的数据放在左边，而大于中间值的数据放在右边，再以同样的方式分别处理左右两边的数据，直到完成为止。</p><p><img src="https://img.wshunli.com/数据结构与算法/排序/快速排序法.gif" alt="快速排序法"></p><p>7、<strong>堆积排序法</strong></p><p>堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p><p>8、<strong>基数排序法</strong></p><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h2 id="外部排序法"><a href="#外部排序法" class="headerlink" title="外部排序法"></a>外部排序法</h2><p>直接合井排序法 (Direct Merge Sort) 是外部存储设备最常用的排序方法。</p><p>它可以分为两个步骤：<br>步骤1: 将要排序的文件分为几个大小可以加载到内存空间的小文件，再使用内部排序法将各文件内的数据排序。<br>步骤2: 将第一步所建立的小文件每两个合并成一个文件。两两合井后，把所有文件合并成一个文件后就可以完成排序了。</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>所谓查找，就是从数据文件中，寻找符合某特定条件的记录。而用来查找的条件就称为 “键值” 。</p><p>一般来说，如果数据在查找前经过排序，将可大幅减少查找的时间。至于查找技巧中比 较常见的方法有顺序法、二分查找法、斐波那契法、插值法、哈希法、m 路查找树、B-tree 等。</p><p>数据结构：<a href="https://www.wshunli.com/posts/850e5c53.html">https://www.wshunli.com/posts/850e5c53.html</a><br>算法：<a href="https://www.wshunli.com/posts/444e2c0f.html">https://www.wshunli.com/posts/444e2c0f.html</a></p><blockquote><p>参考资料<br>1、八大排序算法总结与java实现 | iTimeTraveler<br><a href="https://itimetraveler.github.io/2017/07/18/八大排序算法总结与java实现/" rel="external nofollow noopener noreferrer" target="_blank">https://itimetraveler.github.io/2017/07/18/八大排序算法总结与java实现/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据结构与算法一直是比较薄弱的地方，不仅在面试的时候会问相关问题、手写代码，而且在笔试的时候发挥重要作用。&lt;/p&gt;&lt;p&gt;前面一直学习的数据结构，下面排序、查找属于算法的范畴了。&lt;/p&gt;&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.wshunli.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="算法" scheme="https://www.wshunli.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构与算法" scheme="https://www.wshunli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年秋季校园招聘数文科技面试</title>
    <link href="https://www.wshunli.com/posts/244dd89b.html"/>
    <id>https://www.wshunli.com/posts/244dd89b.html</id>
    <published>2018-08-31T12:46:52.000Z</published>
    <updated>2018-09-10T11:53:44.831Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】【Offer】记录2018年秋季校园招聘数文科技面试（Android开发工程师）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>记录2018年秋季校园招聘（GIS行业）</title>
    <link href="https://www.wshunli.com/posts/9aef7ef9.html"/>
    <id>https://www.wshunli.com/posts/9aef7ef9.html</id>
    <published>2018-08-31T09:10:41.000Z</published>
    <updated>2018-09-10T11:53:44.835Z</updated>
    
    <content type="html"><![CDATA[<div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/FHwF6zl5BkkChoYQtSLfJCtHxdd1sBK9mQ4lmkh8DbJ9lOAGaBMpF4xa5C/4RBXecDSKlLtCjee365ALkX4TbCcl7/UYutP0lzsQvLl4ATqFOr75BYBWmVQOwD3tY2YOjNuKrBWFJYR5I09pO9uo5gbJRsGNAQEAzZ4kKK1D9BLA8cuX+GwwDs/UAvO0woENir6XT9Oh46qoLX/pZHuqKCH25diBMGSWlQrW37i3Bk5nehJkYro8CiMu1dbVmbpsKExQcHIFvrsS7T5XquJCRG9o2SQHTSJWw6njmOedte2fcRH9ki4QwvrkGO858SDLS2SwyKKxaH49NMfSKSGJDyU7NL4zoN+9D1fSYdXPDTpF5ha+reyssvo5/KXkQMxdrMEBezpGeg/p1M/a8R0OyZnl5rGG53YYgZLvb5jXBySnrjEDyOLWXxk7CZFF1oad8+YXeZj00dI+AdBu3lHXvkCBsemsuMGi/tjHCRVZh0772aCXw/uA5urGKQWzFYofeeOUA+M1lZEVi6+PwvGF/LEQiI0HWs40iKP6rFgYn9BM/UYmMZPkgNiiJDrcd6VPLmMyjkBsoCz1wn8SdPLFJL4R1Y1K2k+/4U9tCBRwZXGLyOypEvksiiPP1F9LeCBuNEdfJ/WdRjyoQf/nPTNoJ04doHdJLS1woQFHGnd7CZVi1qZE7ZGyLx9PvKTHUFE9jwtEma4qsAV0UA/23johOXOLvPGG3TvfdR+dNk+cqaSfhpBCfgeKhf3o8PvDUV8WABbgb1tkSMTDZYM6a71XIScnDLzzZpyL4Ab2RYQLtXMCzAsYRrSspxNwi0mAn2eoZsH1AwXex3cpR7F3Ir88o936hxPOIPII4yJqEZMR3D083dmHhu9XGqmiTzpfM2ut7YuZTLg0YHWTYCkOjOxefoNJsFJzcT/PfmUogcS2AxmKr+nrR9JeW2yGkphKi3VGr5cTQcKm5RDF2Syo0qJ1Cu4SL2mB5QSVqISWxf+94EKkSOFTs5Q+rcZi5AGTQACtYUeQMOVJD+iLvf5X4GSFQ0auycoFHd3vAQjFnUO4vUDlSpkb/b0HzAfRNr+ZlJjsqcQXGkpCyLtpWM+rF08LPtHxtgnqoRtfb0WYLoT7zctGQ5jrsieJYzRqByuNEIcuGXApxuJcgOWY/E0DPt9P3GE0MOldiV+ML5YpcgM1F36x28UUpuo3Pg1qTPz1jVOgDTVLsx5eTLMBsayu7GVW0F8lDrUX9v9dHgUS3wBy0oaK/uPxvNSGy8OMrPEBiCYPbzMRmn58SGGOI/y160jh+LCG6w2os2pMzoWGBwKBxwe6FDtFLrWN30XI0Zmu9zuRUYneZ45JC4f3f45tRd5MyzuvkTDje0F5nKWgys0m/Fc4CD6hyd7Bcd1R7BoSSOx7D/+pPmS2DUCbegOsG/V5TSr/cVbV67waHhhXnVjj/scVcvHMR3Ot1yu/y1genPnR7JLTtu23BnAduma+nmnrAY7dbRweHei50+8HBWr2HjFo/23idiy9sbBFlRLBEO3nld874o2SoW3hovbNmDElCZYo2/3Xvo0nFx6hULrOcEiFKTFSr48wS/O9ejIo9Mq9BLtZkkJ9eTEsGaq4bSqVrFv13ayvhCS1BaIhOuCEICbD3caR00lLUuXAED+j1UElOGwh0G8CeH+rylApm4xlX2FX60ZdRU9ha7VqZaIRt3waUY+vmAMWeWq7wvniE90TSkJIqewIX8fABYrX2gbnffpOHw6K94MLaSZhuZLG8LQY1roNh0YZJMlbq+k2FXv/t8m4nG2KtTJFwntbQtkjLAkYLefLzgo/FKKW/zE/cVvfwgcwoj8w6MuILXMTS93LsAb7cOJYkfHpNYB7Bfh2IiFLUdQtGGaPK5bDaPBl8IIw+J9sSI/TlPvzYPkBtzAqhVu6ZRp+P3TWaSLzt/CG5waNGB6dPA2DjP4dB1Bg8A40P8v+TScBIJQKvsqQJIuDSuJE1PDWjKDeMMQO+DBL6FwH5/iNaYfQiUVr6BY/rivSzgq5mwnANFPE3yivKnfwmMZhPS8Ii5atDRReor5txWHyIFltCfTWGzQML043CUrKgygBELhe+6eh0L5V3vqO3dIYXEZb1FVu2SCzLYWVL9eqLwYsmBT+ZwinKXDcGvVh2lhfgAGE2o0wYqDEfgGT7nmZe/pm1ej7J+KiU9oNX9MUCKnJQ77Fr+RnRUVkJQY0dlhbD4yuyoO14CV7ZoCyNb88fJKeQlTGXTmpf68x57yQVnEEB6Rlzp2+CG5D6CMPglal/SlyRhHBO7UbJqB8ZIS+ZYhzzoUnuOIJWtA7JrNfZZp/Vu2DLvQTm4jgp6s2aRjpRqPCqfI6b9Cv4daNoZ/QMR+Ft/B6dCfwct6kH5q5AyEDbpfUQ/qta73mSXalniiivLtdL/TKrj2Es1ESnqRduuTebJFGkbGaUxVT+4AYUqrHo4zXdZ5aAZH0WoxYn759oLkfazM6DBgGSNvSjqjqK5M5c17rCxSLTiwUtHHzEcGZLn+pl3Rwm5T/RPyOkRVzWZQ15WOWH98RyYvYMqtE70xps/MBAPeNtgsHg7Kw1f3gPT/bvRn9Wo2NsuxnKyAHUnzKPrCTgJDoxO+SRnuBcYQrXCTgpCmfVmxBiOUAAmNWACTiK3/bDUo/2EBwTD7RYMtWtbqT+9BkNWut9vj7HXNszzzsfNJ7fGebT1eHWPs8lFMlu/xmF6NOvJ107MttghqUuBKmDXIp1PXxDjIUwlS9rEIP2K3NdAAuhuLigbBfJqr+97aNpLgd5+Spw2TYCWVYUXbAxNaYdU6OvmThn/TJuGQPAHw+q/iSTjkwosUNlJ/tyvX6CYb4ARvxtWLK9yD/eYtUbicMdHe6IHUpeJzMT83i2vUYjnb885iqmDPV4ncGk1zv/y0r8/LxgzzYIHkPEE9TN0c1US4v0bi9Y3PnVAkzfDSrbgJeneZDNdiRUKVBttjejY1xb5O6UGlrvue8ufDhb26DXY1HnZVn+dHHuf6pb7/0wNc5w2m+XTSVAPcp0D6wUmtXiswLNWz/cFiiLaL59TTP/yJfyKzezE+0V9GYm266Qnc7zmFTfqtmPTkhlVfasw+r88TAXj/EwjcYAm6W+uC1GhLatB8g4Kbqr31kHjUAiwK38y52pqufRFKQ7Dt5//av1YiqcoaForGYuU1XWOZP18EMVMft9Xs2I5+gVxeRhZ5U4DFx1x28smNq7KuUxDlsezlW2YvSd/bBcaJ4cOoAFA8VZrMZEIscl1NDBNWnyxOIrQRSx6xlhrhpGEoGmdMpA6dnIiNhxiUUNjV7Jo484z+YzFZoDbtPTiaWo5KtaTN+XQqfuY/TD7WM0HOtipUaazdlNj0TAkRXs5DaOqkr+xL88Tge304q9qY0ztMFkj0N+854Nf82Z8CML512gQtNntYd68xylN4aHcJMG6+iuqaZkubjh6EgS5E6knWJBRT5K3nJo39TbAjx/jVKw6j1EdGmnuCKKu2ENJjMaWzbaDm0TuCJ3M/EQ+NCJcnuItT8XtANM75B4sdZDYo+DgZziZ/B0++YKHnhrNvpve//i41L6UQcumOWsp70NtIKr8pSVPtiEbsIpL/OnwiH0jzjiyXgrH7YV4CNJWHIG3fKdglgJyi21rHhwIkpK7GI9qUwWF3phk+Nv+RyU5CtmJEr0EaIGZ2WoooFNu6iSngVV1kUSLBlJMFlRbyj+7VGCxBNjGTP7+m2YFL+XWjcXFKxmw8UZmXTXaz1fK1pRo5G1eTl6V4dRca267ykK8TQYbumjhX2LtV/GVIqYhVrHfmZPvPe52eGt1JSLEjC8LhIRF/iERoSARN+Ck/HcTDVuv8O4pluQb/vvDnsGJZSkXddgNB157eeMUVy8ZBlKblQkVVA5yHhDOx+CxLZJdYVIo5VlpL8vDABe+ZgkiEYx9JNMA7tziFDITGjIzmGXqZFDrTy1iW9fuZCQMInmiGskKxZ1hwQCopjMCp0/nFiQmRR1/6EtFpl0gkEk1YUn5bUfSj/sn/pIEI+H0vWjRnVSQ+PBTW+dBuwnj5S/Gk/DXjBLHLwd1urvk1yqDXH0RTfzbf4r9qa8SCjanQ/apcG7D0kEICYkBqB2cTtD6W+lGFEzbqjbGj1Xu2pC0LeCxA8Ksy/KghuKyo26S1F3cED/jCQeSLQwariWyrj1fQd1/Hn4XvmiprbTFiz9TsUI+XNlhuzd7AWjAVTW98Al0OwUWfjZR5Jud2tp27Ga5WGEoz6xRuYBu9mtXn855ZVHbIVkM6pg6GEFIniQpmK5AUFPUNMP97t83RzddBiH94kK8CdWG/98qyCq9mVKuGiE2zmtgc/J4Hndn1nKk0J4ctl2IgrPwmOLN+fMgWw8ptWsCi+mO1QBXQg2DoP9GwRLzUgiIF73B8QOy7YbAXPI2moOVDT12gmRdCP7chLvKoE7GAKdjNlc6GFGHHRAz3LYTz+ogfu1c/Yq2u+S4AWVXmJ9kQDpw4x4izkM3yxEduTXDOT0ikJoThlftHb136KDSP0+mQ6A35T76xlZb6NQoy0dFix/+OhtyQJNtLfhkCp494QY0+4weGm18oC7//0ruoImD5yvgJwhGhMSUgUiLGR4sJp4VQBzcVqVQK8LgWDGc3pA0Mc1UDaVMTiCZP+M9JrgFN9UY7Runln2fHgNXkne3K+kqphjWcf6qUyuInPgod+GGsV4IHKot2OSzgnganFidZuQ7qJ3es18nQGskXzKsy1k1YQvqsYG+LIEI0vZzx5Jc04DrL8Cki/cZSxtO/bu5LbkDMBw4ApXpp7wdfhowhcWrMdIN1ehdjCCnqEYp/KzMCCCMLwuSrRjOzPs+BcaMmD4RG1Kp+fR2b53YDoLsSdG479Cg1sCsYKFRCWZaJLYHyHGUiFhgQ9aBIeZp1qpsFUP04wrIn3jaJ3wzoTkNLrC+NmeWCPyMo+MvhhZbyzKsbQqeBkaNNKs5nFbzUKS/iI3Nbj8s6QFKt24B1i6wJq7+w9QiUTOrm+w6GABa9MrCsX7vC93rmlyuy2SoIrheqUU/cn2Bydbolk33iy5wBNpeFcH7tkL6lV4i7NSVjVYGykjPBLDbdRxh+oVHhS5RL0oYfIubOrOfBAh1jGD0zAD9uu8vEkfjHFQiK3QGHhO7b7SxEwN8M2cfYA5y0GK4njUCDggZEKfAWFjGTGx1jpglEdEcI5y9StP5nbCXz1xhq5G62guz5ajnLyPmCqeeCvWRomVUeOlO3LmQZ9x2kWL+n3mozVkxO/nufVIXPGsgBypm1Fs/6PoVQ2N5EemO2vRTbkjuqZA3e3cYyHDr1a+N3Aa3LFvg4UnSpimNcDaiEtcPJIRuFc+GiuY39SyCC3G5qZXeu/1ytfmgz/exWYkTjfQN/u6hhcG6UQfLnIvLQE6/cWg143yJIBsSCf6PPv/v3wjw5LtDuJBgIaBvJt5Es0AsI2aeUPaHRF4DB5kVRF0MNyTpwi64NnGrpMBQTMtIUH9Z7wygFG9uqglibtXjqCc9ZXN9vSq57iedRtN+CL1quILUdmTLGg+sPcCZdyfyf6X66TPtTI+v1f87TR+nSxmToT2xH/nqyuBdx+30iT30g65dGZbzm5+K0uuX8R9DM37sy8IJa7e14ltBRhCh+KKZmsihYPZaimxqse7ZU3AYBO3+09iKcQCiGOCQUVbSBLjS6S47mQ3IZELw/DDVpioSuYFDYBMirG+XvyFnwSFq5Cgu+78mZcvEvAbDJ7vKxLjcjbs2H8C4UWxyRUQLpd0jQEabT7pe7KIOfRbcZj+lsoLClxzR0MPizTqPT1k9d9dWwY476BI2k4UP9t4egyR2oYmAuTuy8rkDmSzWfwmhUdunvccwraybT3N8c3GpAVg6pR4A3JQdv2k1joXnrfPt7oaIpjOi4yTw6EDVtX1tnd6RKapTRcmEXyhkjYt/885YHCLmr7AqCdTMigRZvMgGaM2OZRi5mwWgwfdFFGGWfNVl1SIrqlJ1v25kBVuvj04uBfi83IUKfR8sUZ9CCyjab1nzpUP2Znk39sEdw1Ee81vNJL5UkhfkyHkaNI+4DGWww8qLdzTAVV+GS8VgWkOBXM+WAf4/cGVpacoFXpmiKHsKVy0o0HTHDNoBa7EoyRFBhUDUKRpSwNpyS8gIonxQrM9YQn0MEzIqHfBKk5NudoI6/Ps1bMkj/IclJn7Lm5KELOZ1edqM7PIpI4P9lEEu8UGJaB88ogRjtpp8jSEf74iQqdaeqXAim9mNP6vRbUlkDiiTf/m4m50WyNDnrk7B3J3kU8JmydXcev6xzxBQS6LEJm3r0pkxO76kyg+IcH4RQygABeZGg2oy/q4VBTET+aNos7ZODNXVbQtYK5FdpFcnkq5GL4tdAt6w9jpsoKNpu3U7ewuCm94zM+rNq0Fu3aR+w4vncUsC8BEfbW6Zw5DQhL+eRMrFCk0m5GFFCvzVcQ7wHK5y/jmu8+HpS8CAZ4TTrS5ewqIvk8GW7GIKX71oEUIKmBZg+jjzrj6UNG+6D3tJmhuWlQoO1UQJbkm1myRm1vdXjk675AM3gR5HkfOcpxrwECzzWcenzAsXtCpElX5xVT/l6dRTcUhdvn1t+maQE7uM8g2WH0lijWdT20j+8Zpu4hL8zWkQ/8bd+H1N5ROxlaYW5cZiC6r/4R94YsFjtX5vks7dd/269HrqSldPha0LzTWYCpRp8Au5yYs1C0Dllhsg2RCol9TyDZTJB2ZK+PSCp9rBlkBHVEpvE86C4WIbLfLRnBrcqlhDetpnLXPasOsvtp/QJaRJz4Cp5gkllV9WymZy8KWPPaHKDKntMncWlarGPJFIbe+0xLnRc2W9V6MX6v8r7Gufaywa2nFXilhAMPhqxxFd91D/EMQki6uV9DUxYxKe8IPaRhza9wFEsaUjmQ+IyYeyWWETTXVCYtXMyZE+jWLoy0gD70K8fOR0aaE9qAwqUBpNvzjzG8f94QWWDycmcCw250rr8y04Lnigwluqpd+64SgxZhS9P52HPNBVNh0d1cdQk7JhC6uaLYyr3fEb1Kndd2zV8PhtOR2a+260K5qiInQKO/C6MHFufF5xnCSyj4lBy8Q/vUnMGCKskNEwP5ikFdE6Z7/Qof457a7G2UTRims0jB2BNHjGq9ychd3UcTecFBYLc6H+6XJCZkgjnaR3Lehmgw34/NOxiuTu6w41Rwh7JA24dEACNvaBwWPV4i5HZZfEuuTt1/4zRAC5sICALXaCSjbbBjlR06cBojw3uk0FgSQSZ64tmSPSqT7nxK9R6NInQDjs72zPZUAXMJ9g+27KFgayPeVZvWrhna1bOp2fmkOgllm5k05vBbT/jx1zeN8m/VYXxsJKioPeS/U/3pv3rSpb17PB+57fjVvbJVPwdgkMzRwLloAojIHctrwUIAhq/VowuAr2KUgtbb1HmEQnA/ke+ngsN2+2UxuwrE6WD3SRZDmXH1hPTsswQ2Z5anFE3jCuGyoIv4qu3iz0aXX6S+o4IG6y2DqJeB3xg+B2FFRo8kprBHxDMeIeEuC+j+himuNcXA9KGWUjQUF8lnXxoXkdZ8CvoxOfgnIPU5YPdSjo3dbTcBtOQAinvf+AsTgqgAsEhot8GlfP1Gwf8+X41OsZHectI34/PfXpKzetyQDMRlbld1+bqn0pY4mNC91YupTVvQNYUGqSC7VPkx/uCvo1OrV+ijR7HkcWpAyjB1DZT+HEE17ku7mTtpS6aGrLrPTkkNZyPoBCinBIjVg74j1Ef6U9kXYYyKlRKaAGs5y6E7Qbw/7ltuSC2jCOuHFw8DXCeJH7mLREd8vn6bFc/WARNscwGS+a2Bs4hADZONfez3QSOdoC9uFD3GcZocD7SxTTh0YG8xoHHR4IxZuZIt923ghWoztBTvwrJk+dnH4y05ORIox8RcsWIqhIvT0Utksj7rJr2KnfIcp4dEgUKI1y5GndM5k/YQrdlOBshQPCHfMwHUXDIlcg196kxThZPNgCuwXcY/C6YgeoBIHs5PpAgeCCbamkGOgJAAmGLDWrfkokV8ODpqWt8szFsbpUnSSbjNiQQ1k5wgHAvUi5B+cgCJ/+uqgpD1nEoLQljqLOfOoKHnCmP5iA0jIDaGbyDA0aBxt4XSlpFEMXcy5PV6RcH54FAIH1NNJSLiBeJZD5wOnVaceRVHRgOGTTuj98oeJTrI8DsEIX5ENRy0ITg9HJ686PnQHA/h3epNW6h9X1XldfVsl9zgkJT7LOTruraI+37CjP2BVsoQjUiImmbApHoxLxVIdWZnLQG/epMCDJYgGe7FkTXKyBh9m1wtv3rrK91SbbTFWDnHqWStHlCfXX2YcdtZimAxaRpRnDZ6f3iNMqd6PKXVE93R8LlvJkh/QqrVsPpbBErdOAe8d+r1V9WBqwCh3Swa/ojHzMRoI9o1EW3hCdkOL4aA8SsCGo1Qd94oDkaG2rv6GsqXYvgz2/SCf+HuLO9oiMmO8C7xuQJ9z0NTI/G6O0MLiUEpq2zlykHFffJxmBLw4GNghTjTEc/1dItuprqfRXLkIcRxSyCpDIRfnmzU6F823JQAWN+EgFjGX32zG8b8Dh/SuTVB+ydQxcZtTck7WQymq6Mg/lrryPqV6wj3DFwWiX+t+RbIihf9HZLKp6y+AvqWi/cCxvCktgT0hI4EPr0i8xpRWJ+xf+s8CkffDlJN5kM5dM0NFVAnx03/RpZ8SpAlV1gJRSrkJa3vbMW8P7FONVfgAHM41t6YpNn5wX9ci/nwFQFPfoLSLm0FTiLZMtnqvdboV3lMCFouuJOSc6zWUz8YoFG3RL0ImBfCgzvVdC2VAW/r6wQhPvb2GtCxnxR6v8UU4iCYR/ie/UgAYazpqRd8VeOs77vaixAse/2jsgQb0co5La7ulmRgIwhpSAu32UTyKOmzutqP2G5Sn2hxvlmVczgYbls2Hayn7yqBBN0CNTro8Xn4mu6Iu5eqNoIDSsQuskI2QcyMqtixFIKPM0EvPZ42jD/ogz3ZzY1ZxCVEaDWoyIbLzDiSUFTYe6br552x/ip0hnAlXzPvhe7FTu70uoKlobL36+dfOsfS30RZjCsPT1hVplC5RaolNFfsHfWA4ZCD28WdXeW4/TYiBnRFBy6zF8Afgwgj7ToyMM1F4TKBXIlW4WexZEukNHjMKriyLUKG2Xn5DLOx6j+TRciOVYy/rYYq0A6oQZScOZ6M1s1zX2HzXwP8fa+aXDNsEaJQ+JC992Zzx1VP/o8LrFJlXOLVCQv24JbX6ZOAJKE8Rtdlw1SWJJp/evihpZ5CBSmy/KlPnyInth0FEbIm7DxT1f+2qx9gUVBOJP2uyODi38qYh//4noap3epJKhn+teAKTagkpzunpkLZvts/L3n0ORRLKcibh7fGn2hTdWddSbp1yhYqdjWA91dkSTUV1dQ0xzmQeLI0wzMrD0YEVaz/SdijJBUUiGHRj7WAr2wp3mpnEQ6ms8dFdIckH1boh6/Kfxcdz59SMIgKOoF6jf/b4sfkenwy+5t1Z4kQssvJFh39m7CrUltFAqYxAfXVfxqfh0nMOgouO85DxR1tXXSKtHt1H1efzXCwgaj/vhFZWYMyztQ5fUhmWfVS82WBiQSSXJ1hrGxOoeK9TSk15paYJcPm5WRDoyZGC8q/DfZlsH1ov8y0HPtjV4f5qRi1A3QEOj7Iq2zMWHeeOUjn5v0YAnxA4xe22jqAj4Nszd/14+lTX3hrHFNexJDoyPefifBVVYv8n4GbMYj6di3DxBB44FkbnTt8Ndmh1P+bE5pGgMhr5U3yVoJcY+Ljq3iSqoqtiKoQYfRCOxXRcL8E4i5HEA/bAzIR1shJ+DsL8fzseV5f4nsJ/B6R4ub8IZsGZsOphpj2nmsUAJzb8eH/hMhuvHDr2FJJjDRSt/cfaZJTzbBvuvUeTaeG198MpICOg+fq6g+ZYZLf7H08cmxwLpL4sOvZmm/mqUdhe8rIKtDzXQNxHaNWpYcrlQFsIik9+X9VSAuWPtIHtGFpgGgiqLduzOPyXIagJdLOmHY/aymtlbni7/nRxEddWYTdEwojD6cfsCFwlyw4xB5Wp0OTrjTJB5nw6U1EE8WPxRclDYE+lCvD/iZWwV7TtAe2SzCoIvBN5RHhtXcfFAEmVCzXoJZ1z1rnd1wF63dk76WqRzwXhVgQHCdNMFSSYhka5e8lC4geYDsIMvk9LIEowgzI/METxaBQ7+1LcbgT2SOJkbJ3IL2A2pQnK+x0fOu7y7tkK7wfDT76W9NLNKJz3cSJQ+qNFyHAAT6PNoym4qKonRrit34TT5a/acOnq0pFa2ISFE4XL8BGyvwA1mAvXW3tUBznPbGANTBumwVAxZao8RPzZ96K1bIqkpfZ2Ygkb5cCN5oouyng3mn0nkDY7AnMjUGtE9G9ruqPMX9hkIYjHInnKO67GuQdSs9VbGU3xp/YBThmcV3qcq2e7bRX3l9XqCMoCLDCE5Vz/dWlWy6JZvo6B0OGl9dNTvyOi9fSSKqe3W7t9OyUbfq/RXFSqAOiHDhGcsAZdQ+vIHLKYJLXnl4HYDdhjUApfoJ7BPUdFIsyJ1Rn10zF/jyGAQqBwEo7houWNKcEQeDJaVRN2Kt9b8Jt1TrhJiITY3srmEPZvNYtY9y/4ONwqEE7PIhj3e0aujyiwkDfPTd5nmaInuJfJjSzHCL/2JNGN/VTQTS+ABr0PXYSqPbuPyfMxq/k63xlL+Kf7inpbMx0tWGTOKsC0s9k27CIli+ryfQyWBQxOmixJ/L98JBIhZRrxkSm6dRbwXJcWLxsMnf0MvUTOJwLdhE0tnZeQJi7DykzoogUyFS2mL1n9Dv04pW8EvqK/628O8dT6eP8fk4Pjh/0guD19QtxTiTagj5Hg/LZthOkNntDbPNQiDmLj9tqjKs3tgdTLXcoz/pN71VElqfnUMOzM/YpNyn9zXb73iUYOoZWNUa88yg0aLUIQOJtSeNMwyswZjMCWxkfOnvvq0zeZr+mH6KRBSVemtQRZklmjjm6wAyV5dVmFQOtUxdkFRo7rULMOJpd34o5s6zh5xq1XweHCVNIhYPVncF1pMF8RBG6RbYqxuuBJnw2ZZVcnx/yzy5OIlsZc3SW3oRAU4tUtqWc13a3reW9oprrvmatOHClixff15OZ/yoq88KKMAT6vjMPMs44ROGnUgCAIBw7f8bmF3yXxH0EZYiPgQot9qS1lfBLpWrby3dxMRL2TwZKeR0brBhWcYE0P3BYECXfi54VZfrbWJcGk/xJX494Tju2JHXCPpOufyHdBtaPfaiCLRq6/lnxQclvyzCAVM5uwW5Z6zg2nubxjhTAsXI9ZGncR9k3wCKjZFUZwuuXv2p3FhgPqYcciP5n+nZGRGtMyE4QlA7ositTpI2hj7Byul8lF2gLca98pGUHPOGv8eoY1OQFchyJsvNeIDDR+NJDZEu4eEh3W+1sROOlJ2vuaVYJSyuCHbBdsF2jAQX/0MQontaFbvd5wGfHuSD+OtSC6f57CZE6YuONSCKumM8IXKDOdjqI0YglDxz1KQTqT2bqUabY8UKbiCOu2yEAz8YJkwm3dbM/nenCLXWpH/MQfrwkQRusQ3wHf979g8f1MMUStU6pFN3hCsgNbC74eQf5dj2uNQNdf41N131Y8+Gf81h8UWMgVr4rS9i3b5+8uB1tzx4QbzEHFj2Tc0Gwb/AvTljKNmdJXL3dIv2/QuRz8djcrI9k6xGmQceIeqlx+Y6BiRf/NslJRPigXCo3351EX861CSA8mF9tHxC+8F1HRoOW2OMalcHNEx5Iywl53yxNT9p8yA2m5WxuyMD5FqNq6iFVgvtCuGjIgFu2ygaHKaVUSK1S1BIiosQaLIQulYZH7GsoUh5GBa7bIiaUz+kVldRNqAnq0t2+fdf9oxGyk4ms7hrRsmBcjo6e3TmQPYoNSaIevhG+DA5ZyQWj8F6RSxbt+lrOItr5+Q1i6gd/xpNIg08AR9PAnSGUtNuOUTkl38Er5RFvbXCc6LaxkcREBt4pmWOG0ljO3/CJ9tT7PI1+Juj11pOdIhGx2qu5wZqYn6Aric2hrAQYE1vF/yCBFL9op1qKNOpdhXumk8XEE8BJSU/shzWjq4QWRLuqAtmXquId8UD5Bd5Ov/IVrrzLavtyG9pjSSKKf51JsUr+A5jnV+a7+z3au8CSzlBbxTF/ir7qLwp58wFXxAh9fkeITGGZXTTjXYblIjym58X3Ex7sE8P+EWgMOW/waS4zs7VH7D4EtrIQ0GGvIb7CL16mFMu9XYWW8z7wD7BUuJfYbwznIl54GoAD9n3Wi+tWLfWt1CgYD6Jru8R21jrFmFaj3nUUnBexG6iLupJ/iIXAEie3PsioH0f5xHMcd0DdSZqMlENz+9XxMvsEoqk2/4e4Fd7v59gNF01ue2zFKVnOI1OY4Pz0ugkrwW1dmcKrjhthMRSDpY4IYlViCMKS7+XEv6cDCdCzaqmEx18r7AC7DiQxHWbu+nuC8JP2OUVvQz62myfP7ueer3PgYcAmx2tvZQCV1YLWEMLE0K7zdWVWrcNjnnet4H+R+k2xp8dfagezfDE5b9jViBH8qZc04mBbWn4SOBP4+ybpJzlDFKOFY1JflYJMcRs7CZPvUYO8iWJ9UsJxVemuTRKmhaFgZei7M/2N4vG7UQ/tMzvzGJ0e/zcEz+W0Z4MBF/Gr/lyJLPiDvoI4Wa4yzZhzPv5zjZ++NOq0zYONWz2XDeDcnN3Pu0RVsj4wsUvng4fmKBFQsZ1fuon/8t+PKkuz67km4j1tJsZjIpM8S1wOtxRt5q6Zp4zD90g3FldWxwx0edWzdNfnCItPWfGbVZFOsiKhFOf58at94fprvf3eSwG6D7uuCuNS/vjQTMdX0uem0zuk0+9TlVMEapMczlvOQeVw948zKrmbKnjVNXCi5JMmJ855fChGCXrfUda+O1uBNM85KaWIKP52d1fU6RBr+gqFuYtKpQPcEkt+XRz4gztB1tHX+I9/pulaUDHHrpkvf/MbwaRPI73BOzKPYY7MBmHaP5TS3NroDsFhn3dX6XKqKDkujJwCLt8k5Jfv+4ykKEchRVK2mmLgM4UFPBxC5Xw1bqFA9T0HKZQvCeyjO5GgLgzXBNdXfbnpJbNoud4M6rwfpwlHsXekcCzDipXTvrHZZMwSDMZpGVfLYsnryl4FkkC+qJ0mMf4tmI7SosrQaRf/gvJmA4GAGpZoCVqt99TglExdee3Qtn0C2U3P8lAzmWWCqLXZEl5ZrWQKnmJYh1RniQ9h92v4mQPUsYlDZpnGKxpaSlHC5rx/TCDL+077Rh+YjJyQ+QaQv3JOtFaQcv9oTXkAwKFBG1JAsll6+2lPCG/a8IUlBTNCU5lgtKEv5uvkGM3jpR8ZY7lgdloXBKuzP7QBrbx7BK3FfyP/gDYZEjwTMCZaUdkhoaacZdrEx9GSR1CxLc8D2eKAv7rY4X+XBh0pgZXRhp1Q81429jRQ7VoY93VuSMXxlR0KPumxILQH0wAdExmLSEw3yMXi3EuVQh4kHesR9qByyJUsU4rVEkp22IntQEXU9/7+ZLuOMgES+uEBYbhy9KIR6a6keGmYcnL9pkgKRu1cBijMwZzbG6bBJnid1+orVWtUV78Dh0O6DN1j5hlYiGag50R92biUVJiNWJfTtHDI89GHU+TeeB34Q44EcrRvpAMn3tJQhtQYY+m5hWK+keapkU6zfuCJUh2HorZuYtAoqQswfibx1LoNqAYHniFsA3C/jnI/egdLabITBeGUPHx/0SSh+L/ZlRwRxHpUlU6NAbyOdNcjLdDZsJlP7yr0s/fUTJWPBRmTdHus1x2YZ9FEGbP4mBNm6EpA8XmPSNR6/g0rHrRIK7yCUXaIx0ZrK9/nNn1DYefGO+0/FIXtcPPWRC1rvFH40EnvMBh3dWOEFAG7TYS3ipZC0/xLkXanV7SxiTrsgFsNvnDJSXqAwd40Jhqh+i1cFW3jdtOofuync1bBeAe0y83WSPhbQSJcWRXvpRaMlhWW5Z4MM4a9/+Y+445YEWkYBEVYnJLKWqe+FewbYqwrt1SWkgEgcCM1AJCD7Zedsn9FXnwNkR5VrbWqWtc9JefxvYbGnlHAqUsYW+lP81Sz36HSWDcrh8lrmc2BkUofpuXV6b7vD5DPMqv6+vLYZfuzmZgirUGAaYc+5S8T2pNRROG2AJcCHerj+53ENUhMUf6PmPsLYyz0S4feWrTA4sGhavdzTpL14lCwJnOyhz5Y2kFz5L930imwRNkb00rQDIxdfY9jFW+BNJ6vBiOeiOgZqRdKV2cD/kWJTFWRVUKYcI2Jr2rdsEEygOCtYyQ+0uaE5kIs0glVlpFIcs6Mfk0O9uo9xNoqsjDjpt3zS2eTVuCt895z7QSjSznqbPyWh8QI0QDPSEZhKq7I3Etp/Ta3ECFXIyu6Bq46ShYTvbcbZU124NRJJ+IjCBGnjRsxt5jZ4IkE9vHHDf3WNAcj5gys5irEP4pV1+RbjzWYqNRNI6klCDuLMaiqy9k3/EvQJvmaqbqmkTKlvYFePOaamUj5p4n0NlFZHy9HnJP88OR2yK5PRh41e0mzTj0s/xQ29lIGTqxPZOeIFlDL6MDHq9w9OXpd5BYMH1/3yS686P1D+YjddlhGqzQZaoJlFDAFLosvaScpHTm9RzmtHTh+vXZM+Ev4bu3NuDVHVsxO+3PZJ7e41v8zV0bUpYebcaNIT4IvUOTBi8XyqPXUZkfBxXlq5QlRXammcNiDDxg1KCd5T8cUs0Bv0o/2sYM9XIO1VWNM+wSc1fYEuguH4EKB9+s0b5mOZO3JNIFdB+075qm9HV2YoOWuHy74wrCmancc7FRQaAjmFV51G2TOiWXCZ/54coNC1Gu/RyGN7iHAVLxNgsENEZDqwTC+Xzg8JbHi6yZclJEsEHOoIw6A0KXyWg/AcmMzUk4tib6Z7KKcj9/FVtba8GL8f9nio8LcQ0RXTmCBTkJnY18tYs1p+RJoQxt2bAbwngdPAKf8/85gcrg5DCMaoQTTWAi6E179z/76xDkH7b9AJ3Fn2AUvvqoJWtiaZNopDjqSYLBM76tdCeEfXjQM/MgZtH+QsWa1NK8UNFeSZUV0mlSdnbqx4wtahRlIEbmg7eUc+aviAgaEE0QGcUoPYaTTCJzZn0ilvXgEtnpiUGQnhITun6DCbwEJ7sDv3IxCjdecZHc5Nc3qpk/ZEyPWaJXstAlFXot+jKrTA4aQXr50eI5ajoMujDWfLNhCIR1IjlgNAxZKeTLkvS0gFwSBJGq/DynyM2QuStKEH75n9DDkYXcuIL0lSrnu32BtoV5ooH0Teag/CevgpC5RuzEAQfauIUILIZQ3J/omYCDjLdKmRTWMox7qiECJPW4C24gZHVxvPRAtS6mp/CpacOehGL+s/UzcCoZGJ9Lj6K07FW63shBSa3NQZm9F2Y6MW3yzinWmY3ojNwVowFgwcwApWiyGcHFLZJN2OBQGarQl0wvx0cA12Pg2SclzQ6y5PyC30TrXmDlUepRGn3zgXTUMQZ6GDdIcxiaJnGkCiocbdMILZzId571punztu6YNbk+QBmjGZLOy7RsG/ied/ujpQx/dqv8DSo5vbUswcjQa2HH70B7hsXW4cr0BYbExMPm5Jgz9PcOXb4GMNzCCCC6+jMU4ln4Hod1DX/7hGhrsfNeUA2xwLxATUGUDxDtuoLApZkrjBrwfWqmYWjPATr8rSUVOG9EO1c5H8zmPqa79ARh6vKWblO2Xo1ujkrRNXhn3PQoSrOmF9eDUGIvj0mVCm55+Qg8PGmKbht9v2/O6DvxULWXaftb6d4SHqKT/WVn53DKo7Cliex3aQdVWavbyEP69guVonbOYTDkNw3oHX6On7m1m60bDrNRviIHnsZFK7CXxFM23UH9Mgjc2lj+c9Jf/N04ahNLuK2P/Zf9UdR1HK5NyoN23JM4YP0IZqCd4OrLKYDQAwmTckL/noG+G7HdeyXvCDUnNzPD0i4SGUdJNwxeCVLs5QG0B8zHq/Du15puMhTJ/QelyRZTjHNukTiGKqbk9OL7r6z0YYSth3Mhy2bWPHCeYELPxw3r4idIuHMO5Omu9VYPtETM2ZiaGquj3zswB/4v68ezkkhuLmboU1JFBh2/v333jvx8HUbanXjBm6uegJzoetLjBQ/fla4XBI2Apm/ts3M+m6M66+VQHiu0bCe3skG7L9YkJrspnrfV6l0qTrC+2Da1YOSb+Q7tfhucwUBwvUYgb2Jq0nixWviBBJMhUQ639MY+LRmaJaqSIHXXggNwBlDtqVwO4rdlZuNe9DOWPiAAkytQTJJpCvyRwkglkSVHhffxUQnQ+5IAIx4GA75w09NtqhNA5glSXsejVjwr4mfiutmJ7aBf+vsRBbCnfWHXCwj34gXke6v/7yjxHDUYhKuK7m3fYvbNUW+d2tPcF5zo9RpDJiFGC2tVYbvVQQ/62nIHlZKjC+jyolmx+DQvH1Uk2kc6eAl9QwgLY2VPtpgeUpwJqe5Z/yM/Xi79XdaU9aDPqmuyY7BEu2CW8O4F1UjeUdM4oBcwfqQayrFq7utEkUO2jtIvSOkQvDHEIaT8y7eg4XsMHGiLqcAmxjNsh+5+pisUEskkQrFuEE3hwJXBTei8ZA9jOaAhjOSU39sS96+yqoaB5sfWPt15ok8KsB6WaKNVVztdPYRpVqTnzHxtxVApZaD1AKNn+Ot23T7L5+J1eSLCoX02p8Y2w4nkC6o0I4bl7/RJI4xr4RZwEVRyExUkCMspiOZcCL8JmnbO/DUb20gli9ak2FspBD+pwQa6/6n9HFwhpYBUAB/Ky8Bid01rbi270XdrPOrOXgWk0DHN70CVlZBjyHruggX/pqlZJa7Y1HpyMbATEbNTe8jRXra3EA3hugX4bU/9WmyK4T3Mo7gAoFGbJKDdfritQtPvG1IYm0f+YYC0vz6YkVT2gcHlanRmA1P+0GZWbUB5WEUxwvE4r7+dyZF4JYxO3n2emwn3yjeihoDQ008uThZBfu8/ycMeLDlfautW7f5xxj9EZKESWqTStTBbB0kFntl0PhO4o4epR7RWhqfB0thgegPZPMP0DNfpwqKcBcI4fsrqy5ujT28uwskM6ZYLQhMgM1KfCa3ba6RPHL+GoEcCdq8HbWk05ibras6D7sJw3oRNq/n7RZOHbz+HsZwAHZE25JzF2+5TSpyVxwl4Ege0/0cSkeTc8hjEPKAjXQjT5TChSK476m4EYtL8cBMcsi58B+XnAKvO9AwhRbRoAzLQwzlyr3VmYctVQpx506QUG5RXyJB5wKyfzSfYNzhwbWRZZdWSMOi/BN99e61kkdQsu9CmqZGUzoar0dvijAbmJ3CCenBGd0QVNwP6Humv6X9eZbwDEH0iWR/DKO6xouH7Dio8/J2TQS8Cq+mIJayJyWcqN7qLHgdMMdruuhnYc6cYrGHfZ5rqEJSdmQXmUQn70QLkk6C6OKTLsys0SufYwstgYL1sMHXf/ToaAlXqiHElp+lZ1uX8MbpvrlKI7MJGMM2+E5+fqDFfYvlavl9WvdWT/pihyEsL7oMG4A0UvDOcYVSY9qPKPuacaGRQz3Hp33lRyv7SUxMNjFnHYso4RUSqjhIZMjy024JLExirjq8g2f+YoHLrkTewoWoS+f6RJ8muy8nkTj3SqDB0GlOd0ztZt4MOGV/MYNuKnDnaJFfeLV55xzhOqvy5FEVOuxf1WG0maJ+dRsEFTFIpBCZ6cMFjH5Y20ZzyXabBqN609FO+jQ3S32tEUrtFikYnSh3RXSonG/n8Y6L5YYSu348EwRTRyUvwXvqi6uXN0q3DtOAp0mUZJZP/VJ2RSNR2C/sAf36PmWrDCKFGIdYZtAcgukVgI1GjGpShIy2IYVUjzA+c7VZsQhC1o8eYIbSVE5oUFX5eJvtFcSIhscETkv3bqERJyR7Ue9pqdQQ9Xso81Zh9OhsnaczHkt9oiGjBsetyqCy03xkFrNnjGFpp7opVuhx4qBIlgRqGKEGtpV0jEVYugaWiA1Wxk0vwnQl7uowq4FdkjMty97V4z7q7xI3lO8Q6qFXqcNySbnzhw01cQ+U+bIJfYqnNxjGjStW6Mg1OZa+UH3w7/7J4VS8wnCokwEy6qH50HIxgy/qgbHC57hUAb6vW2DQTxz6GzBbZJBQ+glhLyvwisRMLEBiI10wXku/dMjS1l0rXpz1WARqfOpIfew6hwRnMiWZ4KY31Isrme38eEOYDMoU4AFvP3+QQ1vxv1RhPDf/mbT2sOBTl0pGpdxC9FxdTpaL3hymx8kMkH1iqnEHuepoK0nf26ZnWgMU+JTXZLtJGVffcC8gSwtkf1plCaaIZgnyyxic7zHw5VxSD/IjdPvye/hlIgU1nvXQV1mc+bLIfmc18ONcF+RLxoB3+oWYezKCua8Qj/EsOoQFzVlKKbXmhp1BJ1IQAIHfLnRwkeCWCWxViX/LEYvvSZgnYCxv2CjrTxgA/7xORTjZ45TRRfaJK3I8JYghLzIxVMrrp5/CftmwovydbU3hk7jfvYE3rEzceRkeRff50TbRSXLiZ0IEFVDNoztOxzR8Mun0P4M8FMb6weTGJxt8g1mOLwjgNvu9JJ43CeUt8vY704WJkJ987iSHQdv7FF4fmHHDVzRRm9MTiivnND6natXidyyjGKokHK8hNb8QEnfVs0S2LP6qBlz/B2tJY3Ymaos7bkXlAe5jIz2H1ZemBjtAnbcjDKSZs1SWo+BVeyhNLwpG+/vYcv1otraKsgMXy89HdJtVXtenDc7Ta373skaQQ9M7ELgVqrAY5KAdYA/OmHobSTkpQTGBlUg2WqmTSnJHJYZ0PIpSocCFgETK+kF1syXqhOqnT2Mv9pAQ9w7b7Hb4r6oAuszKd+Ce5EZL1Ska8ePBzvL4jWow42PBdTvlfWnoa1iigTWY6N9SfenBqj5qaChP6ohDtoO40epbphWFzu+jT32LJyPH5Vo4Ge6c6JKe5FsS11zFS/ThdsyFcFP9PS/kle71pstCOMtNdtk+z26dfspwQB9Q8Fie1t8Z7W+aMYVw5kfbEG539GRLdmKKo+aqUGmkoQ73V8mg5ETbWYoaSx700eTygcqp/YW/UQzLqBzqhuJHe/+NL3YJB7nJy9m+q00NORfH7LM9W6esOFGGyaiAKyb77RArzYD3oGrmR6Vd5uF6CsZdVMe/F3x1NXIy/+wFlKXF4Z0mNsjySZvqQfGg+AY5XRU3msLg3BWdi9Kke+iZvfHqExZnmq05yQ48kb58acoRYDP2M9dqRN5uk4UVqZmYXLmXWjP6lUujzbUzaQwWtS8Tb0d3JnA0thHVVn0JDCk5jxKnXQmYqDMR5VaerrTHhdCG+YOTER5t6Ajn+7HjGva4tNPnKbG36HBMPUcIzKyGnkC3w6GdsYkPqbUBtlZkcbqKdFV3q2Uog+PhksTGPsaBmYOstlr/ceqbMBwa8LszTJ7eoLCY+5f7UDcEOmsxtHPm+gs9vVBbStbz0dglncyte/vC478cVGA2m5+RlbX5FzCDz/aOiPXcVaPvCC5S1QhgjHX4aMALZr2Pn7s8Ot1C3lGK6j4uu5Lsj1qvZYuXRMMaqvpq005rFiCXqrcxMmH04pVgWOw64bTnx8OgKT4A/LCiXDa0zl7l09SBoqi0/EwJgXSRcwusDOxaS9XTBi5OMkFHE6VBDBFMuwsshDy+TLegt0VbX+Gxxghnj61li8baWnyoBX/L3g4oveyIUrGHzowjxMuGOdNgNmX2wnO+jJsZJFMDGhUX5GKlxVfSt6bPq/ilqrtaD2Dl3d7AXsKnPxOkguR9BcOmO6i/LzYK124k2ZkZ6ZA170sUXwzrXSXP32W67nSMORneQAJnKeeWJTBo1VdVuiWQJ9rOWfp04nLbMUfbNE9n1miNZ7Rcgsd0mN5UJgzcUNvx+AxFqdIhmk6F97pySf/OP0X+/Ra2sbvehiYPG1s/xwRnT39yINZMUnz/eDibaUF2yhbFUrM2uxnlTHH/tzUeV+zsFWXOrpWk9gCQgNmVy2IwB+tzQx6UsH0BI3rTJSh0q56Up1+ArtiE+QBslKTvOEXE0MS2eKkOkmWmDa6xzVjaRI02qSKE7Pjzhkqh18LTohkmcFc3//nymFysYQRhK+iC5cekVIkiXaohMxpKQPnnk/s5aQPh4dneHG/OrSYxcFcHFo3Os4koQsFYIbVOyRsCPPuIBsD6X/LIgIuerGgI3KHONB7vItUQII63MK8u8i39dZejDqNNtnJO2256zG5X9CXsMAqOCL2hVJ650Jb655LoF305KY7Zw1oystdnnPFn8kt+tWM16t//Ig9o0Cm48RbnvhnLx9qLPA6ksAyUhXmfiIW3OuPWh+m/IAqKRbzCxAs7MfjszJXpBw8JStmhwsSt5f0TrjC0sqpjMI4EV/18xoyzC+z0n+0pyclTSBgi8NoMxIEvvpm3Z1bNMYoiJ5yYxNDJqnZxSEBAt7Bpgy4kyDDvdL/HMq+UD95oKRYtnoDZoablzPWKxMn4KqLfbHMpwdnR9xBDNFJg0L/cp6oGmiFYkMJNm8gUiDLca2vzIqViTQNwNxLs/Ugs/saVmMTdHwbFwhRtZQfFqrvBf69HP3oZJKJwGaMU5+kmzkLK3ZmKwemV9eJZ3oj92SWR5BWa3qk3do3rfHa9QAFzB1qoelyRmL3DpGry31Odg5++bPaECc0fvZ5QB5vnPDC3ocfxdN4Nuw0gVvuw/bgSdCNohYuFOZ4tQHM5zPu9A8ZYlDWA/rrwpjuP9vSOqavQ5E2wIRxkl/d185xLIdpERlgXfrYXGh4rg8p5Bjfi+ns7gl3YR3iQaskazS9zvy9Cjl2oSLlhC5e90u6k7vsLDHAQtSbQRmpKFxXTVsBKi8/yJ3+4qFSpoSO8B9L5gb1CxRfcSBSWNX6hBZ+3vNLEOLeg4ECTsGSKIHJ7MstSF0ThXfqdt73tnO6gAgrxDCIkJqjaUqpU52/6XJV9y/lcSZNofiB97kR+BLyKE9OZpE0JyDUjGOKN0mWQ623BZco4591LsVjErDpONr0JlF5MZE7HVtW+vDGgZZzr6i13dvBDrL1tPzjICVMXCAR/xyT4t8LemrlNVASLE+hKiSX0TUmWWVJcxi4TENj07v9go+KD75MaFDuToj7z8Edp0gGpndifO6BQMfk6yPnoE8Vo99KWirdKd6ytNfLMurooHDKyguePlPJ5DyhAgdNHByjOPbct+qkG5fTxPpEJlovjTLeV/OwhO2h3QNEoUS10JP5kbyBi1Zho9C2GFlKTnHYzvdaCHUZvT/twuUlB0Ir0IBbEuPAagJBPUQYiMM/0TKL7IgNRnk+v3PxmlrgQYJMcniXMRvcR3fTz8xl/9/UDm66x5jNXfab8T1sHw0Qqy+cd/S3Z7BRiNTw/3oRbjyfqSrgcDWsXhBjQBhopjMYEQJ7Qq5CfyZtr1MHHlVd/OQS2BBd3lq5gojrtuPltSkIL4I56Vlvzx4g2Zz3/scrvMgnrFZ39t/VB2W2gioKnOoYLy+dm2cJ2tH1jHjn4CTzy2ro6vVb5iW8El/8uOtcnN02YFHzdh3Po+ZgtG2wEKEdRRlS+OxglquSaD+IIC+yEdKkDGTV2rGhDPXWmom/SjIV3+r5fYXvSo0Rgtw83/wxMAj+OaQQ+LXBG06bP4NLdED3Jz0TmiXC0nZgx2xm7U8v1WePhMXVy8hDURd4FF+Sooc/9OiS8pvN2UKrFv+XE2IdjrnvfaNPf0Lvx18mpZm96Mp+YSrRh0zfVIVYYA6XP8b7tEG180KXnU6QI6lLhUISPaTXFreiarYmFZVkKlbB9n/9cymR8p8vxPkYeKJEj9i1Q3mFAP9mgAhtwRxiYlo3aFw2nn+Wruct2fTCXxKMIO2QDhIkq8CoVW05IvR0iiPkDUemMOVvSd21Wd9gaYgJ+y2hQivHaTZyAdSsKLJjLabe+ED4wMdsPGusrt0n/9yzdO2fQWYWP/cmAAvAhKmh66/aAFc5qXp/JOlkWIZgT2d5ZW/zY7S00/Toh/ItIdBj7Xl41suZRsqLY3eBRjwtXjvtoGp8Wruyzqswo8wqEEuDfgPWmy5WhNt7uPWREWUV9gPDUeAumVCpxYfkJjKCi+MuI1Upx0k46K/PZBwwYQ+/w+gGArg8IEOQm9DhFcwpGwWkSc2HRNe9z28sLgaICXVdmlK9Nki6cqIFCBhvMq0hKBOr4KNSgnym2ROplmpSAC121GF+s1WjCV8OfPblj1SGKqwV1znZWaIyg0WTykudPclToI2ILIH1tWZx4/3Tyc4x3nLZErl6tP+yvf7uAlv+fzxOVNCxd7EmalFEqb271WP1Zcnc1sF97n/Dft+nmD9KiyqZhYyD5CqJga25nhXVGwyH7wDkWyQTI9/jnAP8howXSVx7tFI1NlmbXS5rZbrST9pahX129JjhjS4oYt/Wu4Bya1SDgRFLXh536bg= </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】记录2018年秋季（2019届应届生）校园招聘（GIS行业）。
    
    </summary>
    
      <category term="卖身记" scheme="https://www.wshunli.com/categories/%E5%8D%96%E8%BA%AB%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="https://www.wshunli.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>图解数据结构（Java语言实现）</title>
    <link href="https://www.wshunli.com/posts/850e5c53.html"/>
    <id>https://www.wshunli.com/posts/850e5c53.html</id>
    <published>2018-08-29T12:41:03.000Z</published>
    <updated>2018-09-10T11:53:44.831Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法一直是比较薄弱的地方，不仅在面试的时候会问相关问题、手写代码，而且在笔试的时候发挥重要作用。</p><p>这次选择看的书籍是 《图解数据结构-使用Java》 ，先入门，后面再深入学习。</p><p>算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小 n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。</p><p>线性表是 n 个元素的有限序列（n &gt;= 0），是计算机科学中一种相当基础的数据结构。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组</strong> 其实是一排紧密相邻的可读内存，并提供一个能够 <strong>直接访问</strong> 单一数据内容的计算方法。</p><p>这样能够直接通过计算，并访问任一位置的数据，即所谓的数组的 <strong>随机读取</strong> 。</p><p>当 Java 数组声明时会在内存中分配一定的暂存空间，空间大小以数据类型和数组数量为依据。</p><p>一维数据、二维数组、三维数组、n 维数组。</p><p>数组可用于矩阵、多项式等的运算。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><strong>链表</strong> 是由许多相同数据类型的元素按照特定顺序排列而成的线性表，其在内存中是不连续与随机存储的。</p><p>这样就不能像数组那样随机读取数据，而要 <strong>按照顺序</strong> 找到所需数据。</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表是由节点组成，指针方向相同的链表。其中节点由数据字段和链接字段组成。</p><p>在 Java 中，声明节点：</p><pre><code class="lang-Java">public class Node {    int data;    Node next;    public Node(int data) {        this.data = data;        this.next = null;    }}</code></pre><p>而 Java 中没有指针的概念，我们声明两个对象分别指向第一个和最后一个节点：</p><pre><code class="lang-Java">public class LinkedList {    private Node first;    private Node last;    ...}</code></pre><p>1、<strong>单向链表的创建</strong></p><p>下面创建简单单向链表类：</p><pre><code class="lang-Java">public class LinkedList {    private Node first;    private Node last;    public boolean isEmpty() {        return first == null;    }    public void insert(int data) {        Node node = new Node(data);        if (this.isEmpty()) {            first = node;            last = node;        } else {            last.next = node;            last = node;        }    }    public void print() {        Node current = first;        while (current != null) {            System.out.println(&quot;current.data=&quot; + current.data);            current = current.next;        }    }}</code></pre><p>然后实例化链表对象即可：</p><pre><code class="lang-Java">public class Main {    public static void main(String[] args) {        LinkedList linkedList = new LinkedList();        linkedList.insert(99);        linkedList.insert(90);        linkedList.insert(95);        linkedList.print();    }}</code></pre><p>这样所有节点都知道下个节点在哪里，只要有首节点的存在，就可以对整个列表进行遍历、插入及删除节点等动作。</p><p>2、<strong>单向链表节点的删除</strong></p><p>将欲删除节点的前一个节点的指针指向欲删除节点的下一个节点即可。</p><p>如果删除 <strong>首节点</strong>，将首节点的下个节点设置为首节点；如果删除 <strong>末节点</strong>，将前一个节点指向 null 即可。</p><pre><code class="lang-Java">  public void delete(Node node) {      Node newNode;      Node temp;      if (first.data == node.data) {          first = first.next;      } else if (last.data == node.data) {          temp = first;          while (temp.next != last) {              temp = temp.next;          }          temp.next = last.next; // temp.next = null;          last = temp; // 设置末节点      } else {          newNode = first;          temp = first;          while (temp.data != node.data) {              newNode = temp;              temp = temp.next;          }          newNode.next = temp.next;      }  }</code></pre><p>这样删除有点弊端，根据 node 节点的值判断是否是同一节点，并且没有对节点是否存在做判断。</p><p>3、<strong>单向链表节点的添加</strong></p><p>添加节点和删除节点有点类似，将前一个节点指向新添加的节点，然后将新添加节点指向下一个节点即可。</p><p>如果添加为 <strong>首节点</strong> ，将欲添加节点指向首节点；如果添加为 <strong>末节点</strong> ，将原末节点指向新节点即可。</p><pre><code class="lang-Java">public void insert(Node node) {    Node newNode;    Node temp;    if (node.next == first) {        node.next = first;        first = node;    } else if (node.next == null) {        last.next = node;        node.next = null;    } else {        newNode = first;        temp = first;        while (node.next != newNode.next) {            temp = newNode;            newNode = newNode.next;        }        temp.next = node;        node.next = newNode;    }}</code></pre><p>这样在节点位置的判断上还是有弊端的。</p><p>4、<strong>单向链表的反转</strong></p><p>面试有时候会让手写这个代码。</p><p><strong>遍历法</strong>: 从链表头部开始，逐个反转节点。</p><pre><code class="lang-Java">public Node reverse(Node head) {    if (head == null) return null;      // 空链表    if (head.next == null) return head; // 一个元素的链表    Node preNode = null;    Node nowNode = head;    while (nowNode != null) {        Node nextNode = nowNode.next;   // 保存下一个结点        nowNode.next = preNode;         // 当前结点指向前一个结点        preNode = nowNode;              // 前任结点 到现任节点        nowNode = nextNode;             // 现任节点到下一结点    }    return preNode;}</code></pre><p><strong>递归法</strong>：从链表尾部开始，逐个反转节点。</p><pre><code class="lang-Java">public Node reverse(Node node) {    if (node == null || node.next == null) return node;    Node headNode = reverse(node.next);    node.next.next = node;    node.next = null;    return headNode;}</code></pre><p>以上算法都需要传入链表的头部节点，打印时需要注意头部和尾部节点引用。</p><p>5、<strong>单向链表的串联</strong></p><p>将列表的首位节点相连即可。</p><pre><code class="lang-Java">public LinkedList connect(LinkedList list1, LinkedList list2) {    LinkedList list = list1;//  while (list.last.next != null) {//     list.last = list.last.next;//  }    list.last.next = list2.first;    return list;}</code></pre><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>我们把单向链表的尾部指向头部，整个链表就成为单向环形结构。</p><p>这里创建链表、插入节点、删除节点、链表串联都很类似。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表基本结构和单项连链表类似，至少一个节点存放数据，另外它有两个字段存放指针。</p><h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><p>堆栈是一种抽象的数据结构：只能从堆栈的 <strong>顶端</strong> 访问数据；数据访问符合 <strong>后进先出</strong> 的原则。</p><h2 id="堆栈的数组实现"><a href="#堆栈的数组实现" class="headerlink" title="堆栈的数组实现"></a>堆栈的数组实现</h2><pre><code class="lang-Java">class StackByArray { //以数组模拟堆栈的类声明    private int[] stack; //在类中声明数组    private int top;  //指向堆栈顶端的索引    //StackByArray类构造函数    public StackByArray(int stack_size) {        stack = new int[stack_size]; //建立数组        top = -1;    }    //类方法：push    //存放顶端数据，并更正新堆栈的内容    public boolean push(int data) {        if (top &gt;= stack.length) { //判断堆栈顶端的索引是否大于数组大小            System.out.println(&quot;堆栈已满，无法再加入&quot;);            return false;        } else {            stack[++top] = data; //将数据存入堆栈            return true;        }    }    //类方法：empty    //判断堆栈是否为空堆栈，是则返回true，不是则返回false    public boolean empty() {        if (top == -1) return true;        else return false;    }    //类方法：pop    //从堆栈取出数据    public int pop() {        if (empty()) //判断堆栈是否为空，如果是则返回-1值            return -1;        else            return stack[top--]; //先将数据取出后，再将堆栈指针往下移    }}</code></pre><h2 id="堆栈的链表实现"><a href="#堆栈的链表实现" class="headerlink" title="堆栈的链表实现"></a>堆栈的链表实现</h2><pre><code class="lang-Java">class Node //链接节点的声明{    int data;    Node next;    public Node(int data) {        this.data = data;        this.next = null;    }}class StackByLink {    public Node front; //指向堆栈底端的指针    public Node rear;  //指向堆栈顶端的指针    //类方法：isEmpty()    //判断堆栈如果为空堆栈,则front==null;    public boolean isEmpty() {        return front == null;    }    //打印堆栈内容    public void output_of_Stack() {        Node current = front;        while (current != null) {            System.out.print(&quot;[&quot; + current.data + &quot;]&quot;);            current = current.next;        }        System.out.println();    }    //在堆栈顶端加入数据    public void insert(int data) {        Node newNode = new Node(data);        if (this.isEmpty()) {            front = newNode;            rear = newNode;        } else {            rear.next = newNode;            rear = newNode;        }    }    //在堆栈顶端删除数据    public void pop() {        Node newNode;        if (this.isEmpty()) {            System.out.print(&quot;===目前为空堆栈===\n&quot;);            return;        }        newNode = front;        if (newNode == rear) {            front = null;            rear = null;            System.out.print(&quot;===目前为空堆栈===\n&quot;);        } else {            while (newNode.next != rear)                newNode = newNode.next;            newNode.next = rear.next;            rear = newNode;        }    }}</code></pre><h2 id="堆栈的应用"><a href="#堆栈的应用" class="headerlink" title="堆栈的应用"></a>堆栈的应用</h2><p>二叉树及森林的遍历；图形的深度优先遍历；递归程序的调用及返回等等。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种抽象的数据结构：只能从队列的 <strong>两端</strong> 访问数据；数据访问符合 <strong>先进先出</strong> 的原则。</p><h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><pre><code class="lang-Java">public class ArrayQueue {    private int[] data;    private int size;//元素个数    private int front;//队列中第一个对象的位置    private int rear;//队列中当前对象的位置    public ArrayQueue() {        data = new int[10];        size = 0;        front = 0;        rear = 0;    }    public void add(int t) {        if (isFull()) {            resize();            front = 0;        }        rear = (front + size) % data.length;        System.out.println(rear);        data[rear] = t;        size++;    }    public int remove() {        if (isEmpty()) {            throw new RuntimeException(&quot;队列为空!&quot;);        }        int tempData = data[front];        data[front] = 0;        front = (front + 1) % (data.length);        size--;        return tempData;    }    public int size() {        return size;    }    public boolean isEmpty() {        return size == 0;    }    public boolean isFull() {        return size == data.length;    }    public void resize() {        /*注意重新扩容的时候并不需要去设置size         * 队列的大小并不能通过数组的大小直观的显示出来。         * 但是栈就可以直观的通过数组的大小显示出来*/        int[] tmp = new int[data.length * 2];        System.arraycopy(data, 0, tmp, 0, data.length);        data = tmp;        tmp = null;//引用置为空，便于gc处理      }}</code></pre><h2 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h2><pre><code class="lang-Java">class QueueNode                 // 队列节点类{    int data;                    // 节点数据    QueueNode next;              // 指向下一个节点    //构造函数    public QueueNode(int data) {        this.data = data;        next = null;    }}class Linked_List_Queue { //队列类    public QueueNode front; //队列的前端指针    public QueueNode rear;  //队列的尾端指针    //构造函数    public Linked_List_Queue() {        front = null;        rear = null;    }    //方法enqueue:队列数据的存入    public boolean enqueue(int value) {        QueueNode node = new QueueNode(value); //建立节点        //检查是否为空队列        if (rear == null)            front = node; //新建立的节点成为第一个节点        else            rear.next = node; //将节点加入到队列的尾端        rear = node; //将队列的尾端指针指向新加入的节点        return true;    }    //方法dequeue:队列数据的取出    public int dequeue() {        int value;        //检查队列是否为空队列        if (!(front == null)) {            if (front == rear) rear = null;            value = front.data; //将队列数据取出            front = front.next; //将队列的前端指针指向下一个            return value;        } else return -1;    }} //队列类声明结束</code></pre><p>环形队列、优先队列、双向队列</p><h1 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h1><p>树是一种用来表述有 <strong>分支</strong> 的数据结构，是由一个或者一个以上的节点组成的有限集合。</p><p><strong>树的专有名词</strong>：</p><p>结点度：结点子树的个数；树的度：树中最大的结点度。</p><p>叶子节点：没有子节点的节点，即度为 0 的节点。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树最多有两个子节点，即度 &lt;= 2 的树。</p><p><strong>特殊的二叉树</strong>：</p><p>1、满二叉树，树的高度为 h 树的节点为 $2^h-1$ 我们称为满二叉树。</p><p>2、完全二叉树，树的高度为 h 树的节点小于 $2^h-1$ ，但是其节点和满二叉树从左到右，从上到下的顺序一一对应。</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/二叉树-特殊的二叉树.png" alt="特殊的二叉树"></p><p>3、歪二叉树，当一个二叉树完全没有右节点/左节点时。</p><p>4、严格二叉树，每个二叉树都有非空的左右子树。成为严格二叉树。</p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p>1、<strong>数组表示法</strong></p><p>首先将二叉树想象为满二叉树，然后依次存放入数组中，空位为 null 即可。</p><blockquote><p>以数组建立二叉树，要求小于父节点的值放在左子节点，反之放在右边。</p></blockquote><pre><code class="lang-Java">public class CH06_01 {    public static void main(String args[]) throws IOException    {        int i, level;        int data[] = {6, 3, 5, 9, 7, 8, 4, 2}; /*原始数组*/        int btree[] = new int[16];        for (i = 0; i &lt; 16; i++) btree[i] = 0;        System.out.print(&quot;原始数组内容: \n&quot;);        for (i = 0; i &lt; 8; i++)            System.out.print(&quot;[&quot; + data[i] + &quot;] &quot;);        System.out.println();        for (i = 0; i &lt; 8; i++)                    /*把原始数组中的值逐一对比*/ {            for (level = 1; btree[level] != 0; )   /*比较树根及数组内的值*/ {                if (data[i] &gt; btree[level])        /*如果数组内的值大于树根，则往右子树比较*/                    level = level * 2 + 1;                else                               /*如果数组内的值小于或等于树根，则往左子树比较*/                    level = level * 2;            }                                      /*如果子树节点的值不为0，则再与数组内的值比较一次*/            btree[level] = data[i];                /*把数组值放入二叉树*/        }        System.out.print(&quot;二叉树内容：\n&quot;);        for (i = 1; i &lt; 16; i++)            System.out.print(&quot;[&quot; + btree[i] + &quot;] &quot;);        System.out.print(&quot;\n&quot;);    }}</code></pre><p>2、链表表示法</p><p>二叉链表结构主要由一个数据域和两个分别指向左、右孩子的结点组成，其结构如下：</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/二叉树-链表表示法.png" alt="链表表示法"></p><p>TreeNode 及 BinaryTree 声明如下：</p><pre><code class="lang-Java">class TreeNode {    int value;    TreeNode left_Node;    TreeNode right_Node;    // TreeNode构造函数    public TreeNode(int value) {        this.value = value;        this.left_Node = null;        this.right_Node = null;    }}//二叉树类声明class BinaryTree {    public TreeNode rootNode; //二叉树的根节点    //构造函数:利用传入一个数组的参数来建立二叉树    public BinaryTree(int[] data) {        for (int i = 0; i &lt; data.length; i++)            Add_Node_To_Tree(data[i]);    }    //将指定的值加入到二叉树中适当的节点    void Add_Node_To_Tree(int value) {        TreeNode currentNode = rootNode;        if (rootNode == null) { //建立树根            rootNode = new TreeNode(value);            return;        }        //建立二叉树        while (true) {            if (value &lt; currentNode.value) { //在左子树                if (currentNode.left_Node == null) {                    currentNode.left_Node = new TreeNode(value);                    return;                } else currentNode = currentNode.left_Node;            } else { //在右子树                if (currentNode.right_Node == null) {                    currentNode.right_Node = new TreeNode(value);                    return;                } else currentNode = currentNode.right_Node;            }        }    }}</code></pre><p>这样增删很容易，但是不容易找到父节点，除非增加字段。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历：即“访问树中所有节点各一次”。按照二叉树特性，一律从左向右。</p><p>根据访问根节点的顺序，二叉树的遍历规则主要有四种，先根次序遍历，中根次序遍历，后根次序遍历以及层次遍历。</p><pre><code class="lang-Java">// 中序遍历public void InOrder(TreeNode node) {    if (node != null) {        InOrder(node.left_Node);        System.out.print(&quot;[&quot; + node.value + &quot;] &quot;);        InOrder(node.right_Node);    }}// 前序遍历public void PreOrder(TreeNode node) {    if (node != null) {        System.out.print(&quot;[&quot; + node.value + &quot;] &quot;);        PreOrder(node.left_Node);        PreOrder(node.right_Node);    }}// 后序遍历public void PostOrder(TreeNode node) {    if (node != null) {        PostOrder(node.left_Node);        PostOrder(node.right_Node);        System.out.print(&quot;[&quot; + node.value + &quot;] &quot;);    }}</code></pre><h1 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h1><p>图形结构是用来探讨两个顶点间是否相连的关系图，若在边上加权值，这类图成为“网络”。</p><h2 id="图形介绍"><a href="#图形介绍" class="headerlink" title="图形介绍"></a>图形介绍</h2><p>图形有两种：有向图、无向图。</p><p>图形的专业术语：</p><p>度：一个顶点所拥有边的总数。<br>入/出度：在有向图中，定点为箭头终点的边的个数为入度；出度为起点边的个数。</p><h2 id="图形的表示法"><a href="#图形的表示法" class="headerlink" title="图形的表示法"></a>图形的表示法</h2><p>1、邻接矩阵法/相邻表法</p><p>2、相邻多元列表法/索引表格法</p><h2 id="图形的遍历"><a href="#图形的遍历" class="headerlink" title="图形的遍历"></a>图形的遍历</h2><p>图形的遍历方法有两种：深度优先遍历、广度优先遍历。</p><p>1、深度优先使用递归与 <strong>堆栈</strong> 的技巧</p><p>从图形的某一顶点开始遍历，被访问过的顶点就做上已访问的记号，接着遍历此顶点的所有相邻且未访问过的顶点中的任意一个顶点，并做上已访问的记号，再以该点为新的起点继续进行先深后广的搜索。</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/图形-图的遍历.png" alt="图形-图的遍历"></p><p>（1）从起点 1 开始，将相邻的 2 3 放入堆栈</p><p>3 2</p><p>（2）将 2 取出，并将与 2 相邻且未访问的 4 5 放入堆栈</p><p>3 5 4</p><p>（3）将 4 取出，并将与 4 相邻且未访问的 8 放入堆栈</p><p>3 5 8</p><p>（4）将 8 取出，并将与 8 相邻且未访问的 5 放入堆栈</p><p>3 5 5</p><p>（5）将 5 取出，发现与 5 相邻的节点都访问过了，这里就舍去</p><p>3</p><p>（6）将 3 取出，并将与 3 相邻且未访问的 6 7 放入堆栈</p><p>7 6</p><p>（7）最后将堆栈的节点逐个判断即可。</p><p>7 7</p><p>最终遍历顺序为：1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p><pre><code class="lang-Java">public static void dfs(int current){    run[current] = 1;    System.out.print(&quot;[&quot; + current + &quot;]&quot;);    while ((Head[current].first) != null) {        if (run[Head[current].first.x] == 0) //如果顶点尚未遍历，就进行dfs的递归调用            dfs(Head[current].first.x);        Head[current].first = Head[current].first.next;    }}</code></pre><p>2、广度优先使用递归与 <strong>队列</strong> 的技巧</p><p>从图形的某顶点开始遍历，被访问过的顶点就做上已访问的记号，接着遍历此顶点的所有相邻且未访问过的顶点中的任意个顶点，并做上已访问的记号，再以该点为新的起点继续进行先广后深的搜索。</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/图形-图的遍历.png" alt="图形-图的遍历"></p><p>（1）从起点 1 开始，将相邻的 2 3 放入堆栈</p><p>2 3</p><p>（2）将 2 取出，并将与 2 相邻且未访问的 4 5 放入堆栈</p><p>3 4 5</p><p>（3）将 3 取出，并将与 3 相邻且未访问的 6 7 放入堆栈</p><p>4 5 6 7</p><p>（4）将 4 取出，并将与 4 相邻且未访问的 8 放入堆栈</p><p>5 6 7 8</p><p>（5）将 5 取出，并将与 5 相邻且未访问的 8 放入堆栈</p><p>6 7 8 8</p><p>（6）将 6 取出，并将与 6 相邻且未访问的 7 放入堆栈</p><p>7 8 8 7</p><p>（7）将 7 取出，发现与 7 相邻的节点都访问过了，这里就舍去</p><p>8 8 7</p><p>（8）最后将队列的节点逐个判断即可。</p><p>8 7</p><p>最终遍历顺序为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8</p><pre><code class="lang-Java">public void bfs(int current) {    Node tempnode; //临时的节点指针    enqueue(current); //将第一个顶点存入队列    run[current] = 1; //将遍历过的顶点设定为1    System.out.print(&quot;[&quot; + current + &quot;]&quot;); //打印该遍历过的顶点    while (front != rear) { //判断目前是否为空队列        current = dequeue(); //将顶点从队列中取出        tempnode = Head[current].first; //先记录目前顶点的位置        while (tempnode != null) {            if (run[tempnode.x] == 0) {                enqueue(tempnode.x);                run[tempnode.x] = 1; //记录已遍历过                System.out.print(&quot;[&quot; + tempnode.x + &quot;]&quot;);            }            tempnode = tempnode.next;        }    }}</code></pre><h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>一个图形的生成树以最少的边来连接图形中所有的顶点，且不造成回路(Cycle)的树状结构。</p><p>深度优先生成树、广度优先生成树。</p><p>MST 生成树，即在加权图（网络）上，计算路径成本最小的的生成树。有 Peim 算法和 Kruskal 算法等。</p><blockquote><p>前面一直学习的数据结构，下面排序、查找属于算法的范畴了。</p></blockquote><p>数据结构：<a href="https://www.wshunli.com/posts/850e5c53.html">https://www.wshunli.com/posts/850e5c53.html</a><br>算法：<a href="https://www.wshunli.com/posts/444e2c0f.html">https://www.wshunli.com/posts/444e2c0f.html</a></p><blockquote><p>参考资料<br>1、《图解数据结构-使用Java》<br>2、（数据结构）十分钟搞定时间复杂度（算法的时间复杂度） - 简书<br><a href="https://www.jianshu.com/p/f4cca5ce055a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f4cca5ce055a</a><br>3、单链表反转的两种实现（Java） - CSDN博客<br><a href="https://blog.csdn.net/acquaintanceship/article/details/73011169" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/acquaintanceship/article/details/73011169</a><br>4、data structures - Reversing a linked list in Java, recursively - Stack Overflow<br><a href="https://stackoverflow.com/questions/354875/reversing-a-linked-list-in-java-recursively" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/354875/reversing-a-linked-list-in-java-recursively</a><br>5、【算法】如何判断链表有环 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/78896293" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/78896293</a><br>6、队列的实现(JAVA) - CSDN博客<br><a href="https://blog.csdn.net/lcore/article/details/8868078" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lcore/article/details/8868078</a><br>7、树和二叉树定义、基本术语和性质 - CSDN博客<br><a href="https://blog.csdn.net/lsh_2013/article/details/43121373" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lsh_2013/article/details/43121373</a><br>8、java数据结构与算法之树基本概念及二叉树（BinaryTree）的设计与实现 - CSDN博客<br><a href="https://blog.csdn.net/javazejian/article/details/53727333" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/javazejian/article/details/53727333</a><br>9、data structures - Difference between “Complete binary tree”, “strict binary tree”,”full binary Tree”? - Stack Overflow<br><a href="https://stackoverflow.com/questions/12359660/difference-between-complete-binary-tree-strict-binary-tree-full-binary-tre" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/12359660/difference-between-complete-binary-tree-strict-binary-tree-full-binary-tre</a><br>10、数据结构 - 图的基本术语 - CSDN博客<br><a href="https://blog.csdn.net/wangzi11322/article/details/45417081" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/wangzi11322/article/details/45417081</a><br>11、《图论》——图的存储与遍历（Java） - CSDN博客<br><a href="https://blog.csdn.net/Gamer_gyt/article/details/51498546" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/Gamer_gyt/article/details/51498546</a><br>12、Java 与图 - 简书<br><a href="https://www.jianshu.com/p/a47a147ec92c" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/a47a147ec92c</a><br>13、DFS（深度优先搜索）和BFS(广度优先搜索) - 简书<br><a href="https://www.jianshu.com/p/b086986969e6" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b086986969e6</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据结构与算法一直是比较薄弱的地方，不仅在面试的时候会问相关问题、手写代码，而且在笔试的时候发挥重要作用。&lt;/p&gt;&lt;p&gt;这次选择看的书籍是 《图解数据结构-使用Java》 ，先入门，后面再深入学习。&lt;/p&gt;&lt;p&gt;算法的时间复杂度，用来度量算法的运行时间，记作: T(n) =
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.wshunli.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="数据结构与算法" scheme="https://www.wshunli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://www.wshunli.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
