<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS 博客</title>
  
  <subtitle>wshunli`s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2019-08-14T18:34:57.850Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 语言入门</title>
    <link href="https://www.wshunli.com/posts/fa771b3.html"/>
    <id>https://www.wshunli.com/posts/fa771b3.html</id>
    <published>2019-06-23T08:03:51.000Z</published>
    <updated>2019-08-14T18:34:57.850Z</updated>
    
    <content type="html"><![CDATA[<p>Python 在各领域的应用已经非常广泛了，尤其是最近热门的人工智能等领域。</p><p>现在开始学习 Python 语言基础，后面利用强大的工具库，想必事半功倍。</p><h2 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h2><p>1、Python 的注释：</p><pre><code class="lang-python"># 单行注释print (&quot;Hello, Python!&quot;) # 单行注释&#39;&#39;&#39;多行注释多行注释&#39;&#39;&#39;&quot;&quot;&quot;多行注释多行注释&quot;&quot;&quot;</code></pre><p>单行注释使用 <code>#</code> 号，多行注释使用 <code>&#39;&#39;&#39;</code> 和 <code>&quot;&quot;&quot;</code>。</p><p>2、Python 的行与缩进</p><p>Python 中使用缩进表示代码块，不使用 <code>{}</code>。</p><pre><code class="lang-python">if True:    print (&quot;True&quot;)else:    print (&quot;False&quot;)</code></pre><p>如果缩进不一致，会导致错误。</p><p>Python 中一条语句换行需要使用反斜杠（<code>\</code>）表示：</p><pre><code class="lang-python">total = item_one + \        item_two + \        item_three</code></pre><p>3、end 关键字</p><pre><code class="lang-python"># Fibonacci series: 斐波纳契数列a, b = 0, 1while b &lt; 1000:    print(b, end=&#39;,&#39;)    a, b = b, a+b# 1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</code></pre><p>关键字 end 可以用于将结果输出到同一行，或者在末尾添加不同的字符。</p><h2 id="Python-基本数据类型"><a href="#Python-基本数据类型" class="headerlink" title="Python 基本数据类型"></a>Python 基本数据类型</h2><p>Python 中的变量不需要声明。</p><p>Python3 中有六个标准的数据类型：</p><p>Number（数字）、String（字符串）、Tuple（元组）、List（列表）、Set（集合）、Dictionary（字典）。</p><p>其中前三个为不可变数据类型，后三个为可变数据类型。</p><p>1、Number（数字）：Python3 支持 int、float、bool、complex（复数）。</p><p>其中 在 Python3 中 True 和 False 为关键字，值分别为 1 和 0，可以和数字相加。</p><p>2、String（字符串）：使用单引号 <code>&#39;</code> 或双引号 <code>&quot;</code> 括起来，使用反斜杠 <code>\</code> 转义特殊字符。</p><pre><code class="lang-python">str = &#39;wshunli&#39;print(str)           # 输出字符串print(str[0])        # 输出字符串第一个字符print(str[2:4])      # 输出第三个开始到第四个的字符print(str[0:-1])     # 输出第一个到倒数第二个的所有字符print(str[2:])       # 输出从第三个开始的后的所有字符print(str * 2)       # 输出字符串两次print(str + &quot;.com&quot;)  # 连接字符串# wshunli# w# hu# wshunl# hunli# wshunliwshunli# wshunli.com</code></pre><p>Python 三引号：一个字符串跨多行。</p><pre><code class="lang-python">para_str = &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \t )。也可以使用换行符 [ \n ]。&quot;&quot;&quot;print(para_str)# 这是一个多行字符串的实例# 多行字符串可以使用制表符# TAB (      )。# 也可以使用换行符 [ #  ]。</code></pre><p>3、List（列表）：列表可以完成大多数集合类的数据结构实现。方括号 <code>[]</code> 表示。</p><p>列表中元素的类型可以不同，支持数字，字符串以及列表（嵌套）。</p><p>列表的索引和截取和字符串类似；但是支持第3个参数表示截取步长。</p><pre><code class="lang-python">letters = [&#39;w&#39;,&#39;s&#39;,&#39;h&#39;,&#39;u&#39;,&#39;n&#39;,&#39;l&#39;,&#39;i&#39;]letters[1:4:2]# [&#39;s&#39;,&#39;u&#39;]</code></pre><p>4、Tuple（元组）：元素不能修改的列表。小括号 <code>()</code> 表示。</p><p>虽然 Tuple 的元素不可改变，但可以包含可变的对象，比如 List 列表。</p><p>String、List 和 Tuple 都属于 Sequence（序列）。</p><p>5、Set（集合）：集合元素之间不相同、不可变、无序。大括号 <code>{}</code> 表示。</p><p>集合运算：</p><pre><code class="lang-python">a = set(&#39;abracadabra&#39;)b = set(&#39;alacazam&#39;)print(a)print(a - b)     # a 和 b 的差集print(a | b)     # a 和 b 的并集print(a &amp; b)     # a 和 b 的交集print(a ^ b)     # a 和 b 中不同时存在的元素# {&#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;}# {&#39;b&#39;, &#39;d&#39;, &#39;r&#39;}# {&#39;l&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;z&#39;, &#39;m&#39;, &#39;b&#39;, &#39;d&#39;}# {&#39;a&#39;, &#39;c&#39;}# {&#39;l&#39;, &#39;r&#39;, &#39;z&#39;, &#39;m&#39;, &#39;b&#39;, &#39;d&#39;}</code></pre><p>6、Dictionary（字典）：无序的 <code>键(key) : 值(value)</code> 的集合。大括号 <code>{}</code> 表示。</p><p>其中 键(key) 为不可变类型。在同一个字典中，键(key) 必须是唯一的。</p><pre><code class="lang-python">tinydict = {&#39;name&#39;: &#39;wshunli&#39;, 2: 1, &#39;site&#39;: &#39;wshunli.com&#39;}print (tinydict)          # 输出完整的字典print (tinydict[&#39;name&#39;])  # 输出键为 &#39;one&#39; 的值print (tinydict[2])       # 输出键为 2 的值print (tinydict.keys())   # 输出所有键print (tinydict.values()) # 输出所有值# {&#39;name&#39;: &#39;wshunli&#39;, 2: 1, &#39;site&#39;: &#39;wshunli.com&#39;}# wshunli# 1# dict_keys([&#39;name&#39;, 2, &#39;site&#39;])# dict_values([&#39;wshunli&#39;, 1, &#39;wshunli.com&#39;])</code></pre><p>基本数据类型的创建：</p><pre><code class="lang-python">list = []    # 构造 0 个的列表tup1 = ()    # 构造 0 个的元组tup2 = (20,) # 构造 1 个的元组set = set()  # 构造 0 个的集合dirt = []    # 构造 0 个的字典</code></pre><h2 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h2><p>（1）Python 算术运算符：+、-、<em>、/、%、*</em>、//</p><p><code>**</code> 幂 - 返回 x 的 y 次幂</p><pre><code class="lang-bash">a**b       # a 的 b 次方</code></pre><p><code>//</code> 取整除 - 向下取接近除数的整数</p><pre><code class="lang-bash">&gt;&gt;&gt; 9//2   # 4&gt;&gt;&gt; -9//2  # -5</code></pre><p>（2）Python 比较运算符：==、!=、&gt;、&gt;=、&lt;、&lt;=</p><p>（3）Python 赋值运算符：=、+=、-=、<em>=、/=、%=、*</em>、//=</p><p>（4）Python 位运算符：&amp;、|、^ 、~ 、&lt;&lt;、&gt;&gt;</p><p>（5）Python 逻辑运算符：and、or、not</p><p>（6）Python 成员运算符：in、not in</p><p>（7）Python 身份运算符：is、is not</p><p>is 是判断两个标识符是不是引用自一个对象；</p><p>is not 是判断两个标识符是不是引用自不同对象</p><h2 id="Python-条件控制"><a href="#Python-条件控制" class="headerlink" title="Python 条件控制"></a>Python 条件控制</h2><pre><code class="lang-python">if condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3</code></pre><p>在 Python 中没有 <code>switch – case</code> 语句。</p><h2 id="Python-循环语句"><a href="#Python-循环语句" class="headerlink" title="Python 循环语句"></a>Python 循环语句</h2><p>1、While 循环</p><p>在 <code>while … else</code> 在条件语句为 <code>false</code> 时执行 <code>else</code> 的语句块：</p><pre><code class="lang-python">count = 0while count &lt; 3:   print (count, &quot; 小于 3&quot;)   count = count + 1else:   print (count, &quot; 大于或等于 3&quot;)# 0  小于 3# 1  小于 3# 2  小于 3# 3  大于或等于 3</code></pre><p>2、For 循环：遍历任何序列的项目，如列表、字符串。</p><pre><code class="lang-python">for &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;</code></pre><p>3、range() 函数</p><p>range() 函数用于生成数列：</p><pre><code class="lang-python">for i in range(5):    print(i, end=&#39;,&#39;)for i in range(5, 9):    print(i, end=&#39;,&#39;)for i in range(0, 10, 3):    print(i, end=&#39;,&#39;)for i in range(-1, -10, -3):    print(i, end=&#39;,&#39;)list(range(5))# 0,1,2,3,4,# 5,6,7,8,# 0,3,6,9,# -1,-4,-7,# [0, 1, 2, 3, 4]</code></pre><p>结合 range() 和 len() 函数遍历一个序列的索引：</p><pre><code class="lang-python">a = [&#39;Google&#39;, &#39;Baidu&#39;, &#39;Runoob&#39;, &#39;Taobao&#39;, &#39;QQ&#39;]for i in range(len(a)):     print(i, a[i])# 0 Google# 1 Baidu# 2 Runoob# 3 Taobao# 4 QQ</code></pre><p>4、pass 语句</p><p>Python pass是空语句，是为了保持程序结构的完整性。</p><pre><code class="lang-python">while True:    pass  # 等待键盘中断 (Ctrl+C)for letter in &#39;wshunli&#39;:    if letter == &#39;n&#39;:        pass        print(&#39;执行 pass 块&#39;)    print(&#39;当前字母 :&#39;, letter)print(&quot;Good bye!&quot;)# 当前字母 : w# 当前字母 : s# 当前字母 : h# 当前字母 : u# 执行 pass 块# 当前字母 : n# 当前字母 : l# 当前字母 : i# Good bye!</code></pre><h2 id="Python-迭代器与生成器"><a href="#Python-迭代器与生成器" class="headerlink" title="Python 迭代器与生成器"></a>Python 迭代器与生成器</h2><p>1、迭代器：用于遍历集合元素。</p><p>（1）迭代器的使用</p><p>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</p><pre><code class="lang-python">list = [1, 2, 3, 4]it = iter(list)             # 创建迭代器对象print(next(it), end=&#39;,&#39;)    # 输出迭代器的下一个元素print(next(it), end=&#39;,&#39;)    # 输出迭代器的下一个元素# 1,2,</code></pre><p>迭代器可以使用 for 语句进行遍历：</p><pre><code class="lang-python">list=[1, 2, 3, 4]it = iter(list)    # 创建迭代器对象for x in it:    print(x, end=&quot;,&quot;)# 1,2,3,4,</code></pre><p>（2）迭代器的创建</p><p>在类中实现 <code>__iter__()</code> 与 <code>__next__()</code> 两个方法。</p><pre><code class="lang-python">class MyIter:    def __iter__(self):        self.a = 1        return self    def __next__(self):        x = self.a        self.a += 1        return xmyIter = MyIter()iter = iter(myIter)print(next(iter), end=&quot;,&quot;)print(next(iter), end=&quot;,&quot;)print(next(iter), end=&quot;,&quot;)print(next(iter), end=&quot;,&quot;)print(next(iter), end=&quot;,&quot;)# 1,2,3,4,5,</code></pre><p>（3）StopIteration 异常</p><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况。</p><pre><code class="lang-python">class MyIter:    def __iter__(self):        self.a = 1        return self    def __next__(self):        if self.a &lt;= 10:            x = self.a            self.a += 1            return x        else:            raise StopIterationmyIter = MyIter()iter = iter(myIter)for x in iter:    print(x, end=&quot;,&quot;)# 1,2,3,4,5,6,7,8,9,10,</code></pre><p>2、生成器</p><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><pre><code class="lang-python">import sysdef fibonacci(n):  # 生成器函数 - 斐波那契    a, b, counter = 0, 1, 0    while True:        if (counter &gt; n):            return        yield a        a, b = b, a + b        counter += 1f = fibonacci(10)  # f 是一个迭代器，由生成器返回生成while True:    try:        print(next(f), end=&quot; &quot;)    except StopIteration:        sys.exit()# 0 1 1 2 3 5 8 13 21 34 55</code></pre><p>每次调用生成器函数都会在 <code>yield</code> 处暂停并保存运行状态，返回 <code>yield</code> 结果；在下次执行 <code>next()</code> 函数时从暂停位置继续运行。</p><h2 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h2><p>1、函数的定义</p><pre><code class="lang-python">def hello() :   print(&quot;Hello World!&quot;)hello()# Hello World!</code></pre><p>2、函数的参数及其传递</p><p>Python 参数类型：必需参数、关键字参数、默认参数、不定长参数</p><pre><code class="lang-python">def printinfo(arg1, arg2, arg3=&quot;默认值&quot;, *arg4, **arg5):    print(arg1, end=&quot;;&quot;)    print(arg2, end=&quot;;&quot;)    print(arg3, end=&quot;;&quot;)    print(arg4, end=&quot;;&quot;)    print(arg5)# printinfo();printinfo(&quot;欢迎&quot;, &quot;wshunli&quot;)printinfo(arg2=&quot;欢迎&quot;, arg1=&quot;wshunli&quot;)printinfo(&quot;欢迎&quot;, &quot;wshunli&quot;, &quot;访问&quot;)printinfo(&quot;欢迎&quot;, &quot;wshunli&quot;, &quot;访问&quot;, &quot;wshunli&quot;, &quot;.com&quot;)printinfo(&quot;欢迎&quot;, &quot;wshunli&quot;, &quot;访问&quot;, &quot;wshunli&quot;, &quot;.com&quot;, domain=&quot;wshunli&quot;, suffix=&quot;.com&quot;)# 欢迎;wshunli;默认值;();{}# wshunli;欢迎;默认值;();{}# 欢迎;wshunli;访问;();{}# 欢迎;wshunli;访问;(&#39;wshunli&#39;, &#39;.com&#39;);{}# 欢迎;wshunli;访问;(&#39;wshunli&#39;, &#39;.com&#39;);{&#39;domain&#39;: &#39;wshunli&#39;, &#39;suffix&#39;: &#39;.com&#39;}</code></pre><p>其中 <code>arg1</code>, <code>arg2</code> 属于必需参数，通过关键字传递时可以交换顺序；<br><code>arg3</code> 属于默认参数，在没有传值时使用默认值；<br><code>arg4</code>, <code>arg5</code> 属于可变参数，<code>*</code> 元祖形式，<code>**</code> 字典形式</p><p>声明函数时，参数中星号 <code>*</code> 可以单独出现，例如:</p><pre><code class="lang-python">def f(a, b, *, c):    return a + b + cf(1, 2, 3)    # 报错f(1, 2, c=3)  # 正常</code></pre><p>星号 <code>*</code> 后的参数必须用关键字传入。</p><p>不可变类型类似于<strong>传值</strong>传递；可变类型类似于<strong>传址</strong>传递。</p><p>3、匿名函数</p><p>Python 使用 <code>lambda</code> 来创建匿名函数。</p><pre><code class="lang-python">sum = lambda arg1, arg2: arg1 + arg2# 调用 sum 函数print(&quot;相加后的值为 : &quot;, sum(10, 20))print(&quot;相加后的值为 : &quot;, sum(20, 20))</code></pre><p>4、变量作用域</p><p>Python 的作用域一共有 4 种：局部作用域、闭包函数外的函数中、全局作用域、内置作用域（内置函数所在模块的范围）</p><pre><code class="lang-python">g_count = 0  # 全局作用域def outer():    o_count = 1  # 闭包函数外的函数中    def inner():        i_count = 2  # 局部作用域</code></pre><p>内置作用域是通过一个名为 builtin 的标准模块来实现的：</p><pre><code class="lang-python">import builtinsdir(builtins)</code></pre><p>改变变量的作用域：使用 <code>global</code> 和 <code>nonlocal</code> 关键字。</p><pre><code class="lang-python">num1 = 1num2 = 2def outer():    global num1        # global 关键字    print(&quot;outer&gt;&gt;num1=&quot;, num1)    num1 = 123    print(&quot;outer&gt;&gt;num1=&quot;, num1)    num2 = 20    def inner():        nonlocal num2  # nonlocal 关键字        print(&quot;inner&gt;&gt;num2=&quot;, num2)        num2 = 456        print(&quot;inner&gt;&gt;num2=&quot;, num2)    inner()    print(&quot;outer&gt;&gt;num2=&quot;, num2)outer()print(&quot;num1=&quot;, num1)print(&quot;num2=&quot;, num2)# outer&gt;&gt;num1= 1# outer&gt;&gt;num1= 123# inner&gt;&gt;num2= 20# inner&gt;&gt;num2= 456# outer&gt;&gt;num2= 456# num1= 123# num2= 2</code></pre><p>其中 <code>global</code> : 局部作用域 -&gt; 全局作用域；<code>nonlocal</code> : 局部作用域 -&gt; 闭包函数外的函数中</p><h2 id="Python-模块"><a href="#Python-模块" class="headerlink" title="Python 模块"></a>Python 模块</h2><p>在 Python 中将一些方法和变量保存在文件中以供其他程序使用。</p><p>1、import 语句</p><pre><code class="lang-python">import module1[, module2[,... moduleN]</code></pre><p>2、from … import 语句：仅导入指定的部分（函数、变量）到当前命名空间中。</p><pre><code class="lang-python">from modelname import name1[, name2[, ... nameN]]</code></pre><p><code>__name__</code> 属性：值为 <code>&#39;__main__&#39;</code> 代表模块自身在运行，否则是被引入的。</p><p><code>dir()</code> 函数：列出模块内定义的所有名称。</p><h2 id="Python-异常处理"><a href="#Python-异常处理" class="headerlink" title="Python 异常处理"></a>Python 异常处理</h2><p>Python 中使用 <code>try</code> 及 <code>except</code> 处理异常：</p><pre><code class="lang-python">while True:    try:        x = int(input(&quot;Please enter a number: &quot;))        break    except ValueError:        print(&quot;Oops!  That was no valid number.  Try again   &quot;)# Please enter a number: w# Oops!  That was no valid number.  Try again   # Please enter a number: 1</code></pre><p>同时处理多个异常，可使用元组元组表示：</p><pre><code class="lang-python">except (RuntimeError, TypeError, NameError):        pass</code></pre><p>Python 使用 <code>raise</code> 语句抛出一个指定的异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 在各领域的应用已经非常广泛了，尤其是最近热门的人工智能等领域。&lt;/p&gt;&lt;p&gt;现在开始学习 Python 语言基础，后面利用强大的工具库，想必事半功倍。&lt;/p&gt;&lt;h2 id=&quot;Python-基础语法&quot;&gt;&lt;a href=&quot;#Python-基础语法&quot; class=&quot;
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="https://www.wshunli.com/tags/Python/"/>
    
      <category term="Python3" scheme="https://www.wshunli.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>基于 Flarum  搭建论坛网站实践</title>
    <link href="https://www.wshunli.com/posts/c628f26d.html"/>
    <id>https://www.wshunli.com/posts/c628f26d.html</id>
    <published>2019-01-09T02:01:41.000Z</published>
    <updated>2019-08-14T18:34:57.854Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍在 Nginx 服务器下基于 Flarum 搭建论坛网站。</p><p>Flarum 是一款现代的，优雅的，简洁的，强大的论坛软件。Flarum 让在线交流变得更加轻松愉快。</p><p>官网地址：<a href="http://flarum.org" rel="external nofollow noopener noreferrer" target="_blank">http://flarum.org</a></p><p>中文网：<a href="http://flarum.org.cn" rel="external nofollow noopener noreferrer" target="_blank">http://flarum.org.cn</a></p><p>Flarumchina：<a href="https://flarumchina.org" rel="external nofollow noopener noreferrer" target="_blank">https://flarumchina.org</a></p><h1 id="安装部署-Flarum"><a href="#安装部署-Flarum" class="headerlink" title="安装部署 Flarum"></a>安装部署 Flarum</h1><p>1、官方推荐使用 Composer 安装，</p><p>这里需要安装 Composer 工具</p><pre><code class="lang-bash">curl -sS https://getcomposer.org/installer | phpsudo mv composer.phar /usr/local/bin/composercomposer config -g repo.packagist composer https://packagist.phpcomposer.com # 替换中国镜像源</code></pre><p>然后执行如下命令即可安装，注意需要在空目录下执行</p><pre><code class="lang-bash">composer create-project flarum/flarum . --stability=beta</code></pre><p>2、这里推荐使用 Flarumchina 的中文版安装包</p><p>源码地址 <a href="https://github.com/skywalker512/FlarumChina" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/skywalker512/FlarumChina</a></p><p>我们把源文件上传到服务器，解压即可完成安装。</p><p>针对 Nginx 服务器，需要配置写规则。</p><pre><code class="lang-bash">location / {    index  index.php index.html index.htm;    try_files $uri $uri/ /index.php?$query_string;}location ~ .php$ {    fastcgi_split_path_info ^(.+.php)(/.+)$;    fastcgi_pass unix:/var/run/php5-fpm.sock;    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    fastcgi_index index.php;    include fastcgi_params;}location /api {         try_files $uri $uri/ /api.php?$query_string; }location /admin {        try_files $uri $uri/ /admin.php?$query_string; }location /flarum {        deny all;        return 404;}</code></pre><h2 id="配置-HTTPS-访问"><a href="#配置-HTTPS-访问" class="headerlink" title="配置 HTTPS 访问"></a>配置 HTTPS 访问</h2><p>在根目录下 config.php 文件中，将 url 修改为 https 协议即可。</p><p>最后，欢迎访问我搭建的论坛 <a href="http://bbs.wshunli.com" rel="external nofollow noopener noreferrer" target="_blank">http://bbs.wshunli.com</a></p><blockquote><p>参考资料<br>1、轻论坛：Flarum 程序安装指南<br><a href="https://jsthon.com/flarum-installation-guide/" rel="external nofollow noopener noreferrer" target="_blank">https://jsthon.com/flarum-installation-guide/</a><br>2、遇见最美社区——Flarum | MIKELIN<br><a href="https://mikelin.cn/740.html" rel="external nofollow noopener noreferrer" target="_blank">https://mikelin.cn/740.html</a><br>3、Installation | Flarum Documentation<br><a href="https://flarum.org/docs/install.html#installing" rel="external nofollow noopener noreferrer" target="_blank">https://flarum.org/docs/install.html#installing</a><br>4、Installation<br><a href="https://www.flarumchina.org/docs/installation/" rel="external nofollow noopener noreferrer" target="_blank">https://www.flarumchina.org/docs/installation/</a><br>5、Ubuntu 16.04 &amp; Nginx 下配置 Flarum | Homulilly<br><a href="https://homulilly.com/post/install-flarum-on-ubuntu-16-04-with-nginx.html" rel="external nofollow noopener noreferrer" target="_blank">https://homulilly.com/post/install-flarum-on-ubuntu-16-04-with-nginx.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍在 Nginx 服务器下基于 Flarum 搭建论坛网站。&lt;/p&gt;&lt;p&gt;Flarum 是一款现代的，优雅的，简洁的，强大的论坛软件。Flarum 让在线交流变得更加轻松愉快。&lt;/p&gt;&lt;p&gt;官网地址：&lt;a href=&quot;http://flarum.org&quot; rel=&quot;e
      
    
    </summary>
    
      <category term="前端技术" scheme="https://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flarum" scheme="https://www.wshunli.com/tags/Flarum/"/>
    
      <category term="论坛" scheme="https://www.wshunli.com/tags/%E8%AE%BA%E5%9D%9B/"/>
    
  </entry>
  
  <entry>
    <title>Cesium 相关资料汇总</title>
    <link href="https://www.wshunli.com/posts/9f50f2b3.html"/>
    <id>https://www.wshunli.com/posts/9f50f2b3.html</id>
    <published>2019-01-08T01:39:51.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>【公开全文】汇总 Cesium 相关框架及其数据组织处理资料。</p><a id="more"></a><p>Cesium 是一个用于显示三维地球和地图的开源 JS 库。<br>它可以用来显示海量三维模型数据、影像数据、地形高程数据、矢量数据等等。</p><h1 id="Cesium-相关开源库"><a href="#Cesium-相关开源库" class="headerlink" title="Cesium 相关开源库"></a>Cesium 相关开源库</h1><h2 id="Cesium-官方资料"><a href="#Cesium-官方资料" class="headerlink" title="Cesium 官方资料"></a>Cesium 官方资料</h2><p>1、Cesium 官网(包含三维引擎 + 云服务)</p><p><a href="https://cesium.com/" rel="external nofollow noopener noreferrer" target="_blank">https://cesium.com/</a></p><p>2、Cesiumjs 三维引擎官网</p><p>官方主页 <a href="https://cesiumjs.org/" rel="external nofollow noopener noreferrer" target="_blank">https://cesiumjs.org/</a></p><p>官方教程 <a href="https://cesiumjs.org/tutorials/" rel="external nofollow noopener noreferrer" target="_blank">https://cesiumjs.org/tutorials/</a></p><p>API 参考 <a href="https://cesiumjs.org/refdoc/" rel="external nofollow noopener noreferrer" target="_blank">https://cesiumjs.org/refdoc/</a></p><p>示例代码 <a href="https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/index.html</a></p><p>3、Cesium 源码仓库</p><p>官方仓库 <a href="https://github.com/AnalyticalGraphicsInc/cesium" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/cesium</a></p><p>3D Tiles <a href="https://github.com/AnalyticalGraphicsInc/3d-tiles" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/3d-tiles</a></p><p>glTF <a href="https://github.com/KhronosGroup/glTF" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/KhronosGroup/glTF</a></p><h2 id="Cesium-国内移植"><a href="#Cesium-国内移植" class="headerlink" title="Cesium 国内移植"></a>Cesium 国内移植</h2><p>1、SuperMap</p><p>官方主页 <a href="http://support.supermap.com.cn:8090/webgl/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://support.supermap.com.cn:8090/webgl/index.html</a></p><p>API 参考 <a href="http://support.supermap.com.cn:8090/webgl/WebGL_API/webgl_chm.html" rel="external nofollow noopener noreferrer" target="_blank">http://support.supermap.com.cn:8090/webgl/WebGL_API/webgl_chm.html</a></p><p>API 参考（包含 Cesium） <a href="http://support.supermap.com.cn:8090/webgl/Build/Documentation/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://support.supermap.com.cn:8090/webgl/Build/Documentation/index.html</a></p><p>示例代码 <a href="http://support.supermap.com.cn:8090/webgl/examples/examples.html#layer" rel="external nofollow noopener noreferrer" target="_blank">http://support.supermap.com.cn:8090/webgl/examples/examples.html#layer</a></p><p>2、MarsGIS</p><p>官方主页 <a href="http://cesium.marsgis.cn/docs/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://cesium.marsgis.cn/docs/index.html</a></p><p>官方教程翻译 <a href="http://cesium.marsgis.cn/docs/go.html?id=12" rel="external nofollow noopener noreferrer" target="_blank">http://cesium.marsgis.cn/docs/go.html?id=12</a></p><p>相关链接 <a href="http://cesium.marsgis.cn/docs/friendlylink.html" rel="external nofollow noopener noreferrer" target="_blank">http://cesium.marsgis.cn/docs/friendlylink.html</a></p><p>3、Wish3D</p><p>官方主页 <a href="http://www.wish3d.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.wish3d.com/</a></p><p>4、Cesiumlab</p><p>官方主页 <a href="https://www.cesiumlab.com/" rel="external nofollow noopener noreferrer" target="_blank">https://www.cesiumlab.com/</a></p><p>5、Skyline</p><p>官方示例 <a href="http://skylineglobe.com/sg/TerraExplorerWeb/TerraExplorer.html" rel="external nofollow noopener noreferrer" target="_blank">http://skylineglobe.com/sg/TerraExplorerWeb/TerraExplorer.html</a></p><p>6、其他</p><p>鸿业科技 <a href="http://www.hongye.com.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.hongye.com.cn/</a><br>圣伟合众 <a href="http://www.swhztech.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.swhztech.com/</a><br>Holo3DForWeb <a href="https://forweb.gbim360.com/" rel="external nofollow noopener noreferrer" target="_blank">https://forweb.gbim360.com/</a></p><h2 id="WebGL-相关开源库"><a href="#WebGL-相关开源库" class="headerlink" title="WebGL 相关开源库"></a>WebGL 相关开源库</h2><p>1、threejs</p><p>官方主页 <a href="https://threejs.org/" rel="external nofollow noopener noreferrer" target="_blank">https://threejs.org/</a></p><p>2、ArcGIS</p><p>官方主页 <a href="https://developers.arcgis.com/javascript/" rel="external nofollow noopener noreferrer" target="_blank">https://developers.arcgis.com/javascript/</a></p><p>3、luma.gl</p><p>官方主页 <a href="https://luma.gl/" rel="external nofollow noopener noreferrer" target="_blank">https://luma.gl/</a></p><p>4、Maptalks</p><p>官方主页 <a href="http://maptalks.org/" rel="external nofollow noopener noreferrer" target="_blank">http://maptalks.org/</a></p><h1 id="Cesium-相关教程"><a href="#Cesium-相关教程" class="headerlink" title="Cesium 相关教程"></a>Cesium 相关教程</h1><h2 id="相关社区网站"><a href="#相关社区网站" class="headerlink" title="相关社区网站"></a>相关社区网站</h2><p>1、Cesium中文网</p><p><a href="http://cesiumcn.org/" rel="external nofollow noopener noreferrer" target="_blank">http://cesiumcn.org/</a></p><h2 id="学习教程博客"><a href="#学习教程博客" class="headerlink" title="学习教程博客"></a>学习教程博客</h2><p>1、Cesium教程系列汇总 - fu*k - 博客园</p><p><a href="http://www.cnblogs.com/fuckgiser/p/5706842.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/fuckgiser/p/5706842.html</a></p><p>2、cesium中文网 | 学习cesiumjs 的好地方—伐罗密</p><p><a href="http://cesium.xin/" rel="external nofollow noopener noreferrer" target="_blank">http://cesium.xin/</a></p><p>3、kamijawa的个人空间 - 开源中国</p><p><a href="https://my.oschina.net/u/1585572" rel="external nofollow noopener noreferrer" target="_blank">https://my.oschina.net/u/1585572</a></p><p>4、Cesium学习笔记汇总<em>cumtzheNo1</em>新浪博客</p><p><a href="http://blog.sina.com.cn/s/blog_15e866bbe0102xu2f.html" rel="external nofollow noopener noreferrer" target="_blank">http://blog.sina.com.cn/s/blog_15e866bbe0102xu2f.html</a></p><h2 id="源码分析汇总"><a href="#源码分析汇总" class="headerlink" title="源码分析汇总"></a>源码分析汇总</h2><p>1、Cesium - 标签 - 自由战士 - 博客园</p><p><a href="https://www.cnblogs.com/webgl-angela/tag/Cesium/" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/webgl-angela/tag/Cesium/</a></p><p>2、cesium 归档 - GIS开发者</p><p><a href="https://www.giserdqy.com/gis/opengis/3d/cesium" rel="external nofollow noopener noreferrer" target="_blank">https://www.giserdqy.com/gis/opengis/3d/cesium</a></p><h2 id="视频投放源码分析"><a href="#视频投放源码分析" class="headerlink" title="视频投放源码分析"></a>视频投放源码分析</h2><p>1、Cesium源码剖析—-视频投影 - 自由战士 - 博客园</p><p><a href="https://www.cnblogs.com/webgl-angela/p/9809307.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/webgl-angela/p/9809307.html</a></p><p>2、Cesium开发：在平面上播放视频 - 知乎</p><p><a href="https://zhuanlan.zhihu.com/p/41862445" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/41862445</a></p><p><a href="https://chaossoong.github.io/2017/01/13/cesium图形添加视频/" rel="external nofollow noopener noreferrer" target="_blank">https://chaossoong.github.io/2017/01/13/cesium图形添加视频/</a></p><p>3、Clamping to 3D Tiles by lilleyse · Pull Request #6934 · AnalyticalGraphicsInc/cesium</p><p><a href="https://github.com/AnalyticalGraphicsInc/cesium/pull/6934" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/cesium/pull/6934</a></p><p>5、Cesium 1.50重量级新功能测评 - 知乎</p><p><a href="https://zhuanlan.zhihu.com/p/46190355" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/46190355</a></p><p>6、Cesium(三) 几何图形与外观 - 多多 - CSDN博客</p><p><a href="https://blog.csdn.net/happyduoduo1/article/details/51868042" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/happyduoduo1/article/details/51868042</a></p><p>7、AnalyticalGraphicsInc/cesium-materials-pack: A Cesium plugin with procedurally-shaded materials such as bricks, wood, and noise patterns</p><p><a href="https://github.com/AnalyticalGraphicsInc/cesium-materials-pack" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/cesium-materials-pack</a></p><p><a href="https://github.com/MikesWei/CesiumMeshVisualizer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/MikesWei/CesiumMeshVisualizer</a></p><p><a href="http://52.4.31.236/plugins/" rel="external nofollow noopener noreferrer" target="_blank">http://52.4.31.236/plugins/</a></p><p>8、Fabric · AnalyticalGraphicsInc/cesium Wiki</p><p><a href="https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric</a></p><p>9、Drawing on Terrain - Cesium Sandcastle</p><h1 id="数据组织处理"><a href="#数据组织处理" class="headerlink" title="数据组织处理"></a>数据组织处理</h1><h2 id="glTF-相关工具"><a href="#glTF-相关工具" class="headerlink" title="glTF 相关工具"></a>glTF 相关工具</h2><p>1、COLLADA2GLTF</p><p>官方 三维模型 转 glTF 的插件</p><p><a href="https://github.com/KhronosGroup/COLLADA2GLTF" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/KhronosGroup/COLLADA2GLTF</a></p><p>2、obj2gltf</p><p><a href="https://github.com/AnalyticalGraphicsInc/obj2gltf" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/obj2gltf</a></p><h2 id="3D-Tiles-相关工具"><a href="#3D-Tiles-相关工具" class="headerlink" title="3D Tiles 相关工具"></a>3D Tiles 相关工具</h2><p>1、3d-tiles-tools</p><p>官方 3d tiles 转换工具</p><p><a href="https://github.com/AnalyticalGraphicsInc/3d-tiles-tools" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AnalyticalGraphicsInc/3d-tiles-tools</a></p><p>2、Cesiumlab</p><p><a href="https://www.cesiumlab.com/" rel="external nofollow noopener noreferrer" target="_blank">https://www.cesiumlab.com/</a></p><blockquote><p>参考资料<br>1、Cesium资料大全 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/34217817" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/34217817</a><br>2、MarsGIS for Cesium|三维地图<br><a href="http://cesium.marsgis.cn/docs/friendlylink.html" rel="external nofollow noopener noreferrer" target="_blank">http://cesium.marsgis.cn/docs/friendlylink.html</a><br>3、CZM6.com – Cesium相关资料和产品收集<br><a href="https://www.czm6.com/" rel="external nofollow noopener noreferrer" target="_blank">https://www.czm6.com/</a><br>4、cesium编程入门(十)优秀资源 | cesium中文网<br><a href="http://cesium.xin/wordpress/archives/130.html" rel="external nofollow noopener noreferrer" target="_blank">http://cesium.xin/wordpress/archives/130.html</a></p></blockquote><p><strong>2019年06月23日公开全文</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【公开全文】汇总 Cesium 相关框架及其数据组织处理资料。&lt;/p&gt;
    
    </summary>
    
      <category term="三维技术" scheme="https://www.wshunli.com/categories/%E4%B8%89%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Cesium" scheme="https://www.wshunli.com/tags/Cesium/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入 cPlayer 播放器</title>
    <link href="https://www.wshunli.com/posts/hexo-tag-mplayer.html"/>
    <id>https://www.wshunli.com/posts/hexo-tag-mplayer.html</id>
    <published>2019-01-04T03:08:24.000Z</published>
    <updated>2019-08-14T18:34:57.854Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍在 Hexo 中插入 cPlayer 播放器</p><center><div id="mplayer7465"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer7465"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"},{src:"https://img.wshunli.com/about/童话镇.mp3",poster:"https://img.wshunli.com/about/童话镇.jpg",name:"童话镇",artist:"陈一发儿",lyric:"[00:00.00]童话镇\n[00:05.00]演唱：陈一发\n[00:10.00]作曲:暗杠\n[00:15.00]作词:竹君\n[00:22.93]听说白雪公主在逃跑\n[00:26.43]小红帽在担心大灰狼\n[00:29.83]听说疯帽喜欢爱丽丝\n[00:33.17]丑小鸭会变成白天鹅\n[00:36.34]听说彼得潘总长不大\n[00:40.23]杰克他有竖琴和魔法\n[00:43.56]听说森林里有糖果屋\n[00:46.82]灰姑娘丢了心爱的玻璃鞋\n[00:50.39]只有睿智的河水知道\n[00:53.68]白雪是因为贪玩跑出了城堡\n[00:57.31]小红帽有件抑制自己\n[01:00.73]变成狼的大红袍\n[01:03.80]总有一条蜿蜒在童话镇里七彩的河\n[01:11.00]沾染魔法的乖张气息\n[01:14.42]却又在爱里曲折\n[01:17.76]川流不息扬起水\n[01:20.87]又卷入一帘时光入水\n[01:24.68]让全部很久很久以前\n[01:28.12]都走到幸福结局的时刻\n[01:33.18]music....\n[01:47.00]听说睡美人被埋藏\n[01:50.44]小人鱼在眺望金殿堂\n[01:53.79]听说阿波罗变成金乌\n[01:57.12]草原有奔跑的剑齿虎\n[02:00.73]听说匹诺曹总说着谎\n[02:04.16]侏儒怪拥有宝石满箱\n[02:07.57]听说悬崖有颗长生树\n[02:10.80]红鞋子不知疲倦地在跳舞\n[02:14.43]只有睿智的河水知道\n[02:17.84]睡美人逃避了生活的煎熬\n[02:21.14]小人鱼把阳光抹成眼影\n[02:24.58]投进泡沫的怀抱\n[02:27.77]总有一条蜿蜒在童话镇里七彩的河\n[02:35.06]沾染魔法的乖张气息\n[02:38.43]却又在爱里曲折\n[02:41.82]川流不息扬起水花\n[02:44.87]又卷入一帘时光入水\n[02:48.69]让全部很久很久以前\n[02:52.00]都走到幸福结局的时刻\n[02:55.46]总有一条蜿蜒在童话镇里梦幻的河\n[03:02.47]分隔了理想分隔现实\n[03:05.82]又在前方的山口汇合\n[03:09.22]川流不息扬起水花\n[03:12.36]又卷入一帘时光入水\n[03:16.23]让全部很久很久以前\n[03:19.38]都走到幸福结局的时刻\n[03:22.72]又陌生\n[03:24.52]啊~~啊~~啊~~啊~~"}],autoplay:!0,volume:.75,big:!0,dark:!1,zoomOutKana:!1,playmode:"listloop",point:0,showPlaylist:!1,dropDownMenuMode:"bottom"})</script></center><h1 id="cPlayer-介绍"><a href="#cPlayer-介绍" class="headerlink" title="cPlayer 介绍"></a>cPlayer 介绍</h1><p>A beautiful and clean WEB Music Player by HTML5. <a href="http://cplayer.js.org/" rel="external nofollow noopener noreferrer" target="_blank">http://cplayer.js.org/</a></p><h1 id="Hexo-中使用-cPlayer"><a href="#Hexo-中使用-cPlayer" class="headerlink" title="Hexo 中使用 cPlayer"></a>Hexo 中使用 cPlayer</h1><p><a href="https://github.com/wshunli/hexo-tag-mplayer" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-mplayer</a> 是一款在 Hexo 中使用 cPlayer 的插件。</p><p>插件的安装和使用非常的简单，只需要进入 Hexo 博客根目录，然后安装：</p><pre><code class="lang-bash">$ npm install hexo-tag-mplayer --save</code></pre><p>之后在文章内使用 <code>mplayer</code> 的 tag 就可以了：</p><pre><code class="lang-JavaScript">{% mplayer %}{    // TODO mplayer options goes here}{% endmplayer %}</code></pre><p>其中：<br><code>mplayer</code> 和 <code>endmplayer</code> 是 Hexo 的标签，不需要修改；<br><code>options</code> 部分是图表的配置。</p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>可参考如下配置，使用 <code>hexo-tag-mplayer</code> 插件。</p><pre><code class="lang-JavaScript">{% mplayer %}    playlist: [        {            src: '歌曲资源链接...',            poster: '封面链接...',            name: '歌曲名称...',            artist: '歌手名称...',            lyric: '歌词...',            sublyric: '副歌词，一般为翻译...',            album: '专辑，唱片...'        },        {            ...        },        ...    ],    autoplay: true,    volume: 0.75,    playmode: "listloop",    big: true,    dark: false{% endmplayer %}</code></pre><p>更详细配置可参考官方文档：<a href="https://github.com/MoePlayer/cPlayer#option" rel="external nofollow noopener noreferrer" target="_blank">cPlayer Option</a></p><h1 id="实例参考"><a href="#实例参考" class="headerlink" title="实例参考"></a>实例参考</h1><p>下面我们来看插件的一些使用样例：</p><p>1、默认样式</p><div id="mplayer5542"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer5542"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!1,dark:!1})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落'        }    ],    autoplay: false,    volume: 0.75,    big: false,    dark: false{% endmplayer %}</code></pre><p>2、暗黑样式</p><div id="mplayer8343"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer8343"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!1,dark:!0})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '省略歌词...'        }    ],    autoplay: false,    volume: 0.75,    big: false,    dark: true{% endmplayer %}</code></pre><p>3、大图样式</p><div id="mplayer7977"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer7977"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!0,dark:!1})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '省略歌词...'        }    ],    autoplay: false,    volume: 0.75,    big: true,    dark: false{% endmplayer %}</code></pre><p>4、大图暗黑样式</p><div id="mplayer2710"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer2710"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!0,dark:!0})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '省略歌词...'        }    ],    autoplay: false,    volume: 0.75,    big: true,    dark: true{% endmplayer %}</code></pre><p>非常感谢 <a href="https://github.com/MoePlayer/cPlayer" rel="external nofollow noopener noreferrer" target="_blank">cPlayer</a> 及 <a href="https://github.com/EYHN/hexo-tag-cplayer" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-cplayer</a> 作者。</p><font color="red">最后欢迎 star 或者提交 PR 到本仓库。</font><p><a href="https://github.com/wshunli/hexo-tag-mplayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/hexo-tag-mplayer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍在 Hexo 中插入 cPlayer 播放器&lt;/p&gt;&lt;center&gt;&lt;div id=&quot;mplayer7465&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer
      
    
    </summary>
    
      <category term="前端技术" scheme="https://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://www.wshunli.com/tags/Hexo/"/>
    
      <category term="mplayer" scheme="https://www.wshunli.com/tags/mplayer/"/>
    
      <category term="cPlayer" scheme="https://www.wshunli.com/tags/cPlayer/"/>
    
      <category term="hexo-tag-mplayer" scheme="https://www.wshunli.com/tags/hexo-tag-mplayer/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结，我这一年的点点滴滴</title>
    <link href="https://www.wshunli.com/posts/f5281e38.html"/>
    <id>https://www.wshunli.com/posts/f5281e38.html</id>
    <published>2019-01-03T08:46:00.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security"> <div class="hbe-input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】 花开花谢，月圆月缺。
    
    </summary>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="年终总结" scheme="https://www.wshunli.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Drone持续集成服务私有部署</title>
    <link href="https://www.wshunli.com/posts/b9adca20.html"/>
    <id>https://www.wshunli.com/posts/b9adca20.html</id>
    <published>2018-12-31T09:44:59.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍基于 Github 的 Drone 持续集成服务单机部署。</p><h1 id="Docker-环境"><a href="#Docker-环境" class="headerlink" title="Docker 环境"></a>Docker 环境</h1><p>首先应该安装 Docker 及 docker-compose 环境。</p><p><a href="https://www.wshunli.com/posts/89bfe8.html">https://www.wshunli.com/posts/89bfe8.html</a></p><h1 id="Github-应用注册"><a href="#Github-应用注册" class="headerlink" title="Github 应用注册"></a>Github 应用注册</h1><p>打开 <a href="https://github.com/settings/applications/new" rel="external nofollow noopener noreferrer" target="_blank">Github New OAuth Application</a> 注册应用程序。</p><p><img src="https://img.wshunli.com/qnap/drone/github_application_create.png" alt="github_application_create"></p><p>创建完成，查看相应的 <code>Client ID</code> 及 <code>Client Secret</code> 值。</p><p><img src="https://img.wshunli.com/qnap/drone/github_application.png" alt="github_application"></p><h1 id="创建-Drone-服务"><a href="#创建-Drone-服务" class="headerlink" title="创建 Drone 服务"></a>创建 Drone 服务</h1><p>直接执行以下明命令即可</p><pre><code class="lang-Shell">docker run \  --volume=/var/run/docker.sock:/var/run/docker.sock \  --volume=/var/lib/drone:/data \  --env=DRONE_GITHUB_SERVER=https://github.com \  --env=DRONE_GITHUB_CLIENT_ID=xxx \  --env=DRONE_GITHUB_CLIENT_SECRET=xxxxxx \  --env=DRONE_RUNNER_CAPACITY=2 \  --env=DRONE_SERVER_HOST=drone.wshunli.com \  --env=DRONE_SERVER_PROTO=http \  --env=DRONE_GIT_ALWAYS_AUTH=true \  --env=DRONE_TLS_AUTOCERT=true \  --publish=30080:80 \  --publish=30443:443 \  --restart=always \  --detach=true \  --name=drone \  drone/drone:1.0.0-rc.3</code></pre><p>其中<br>DRONE_GITHUB_CLIENT_ID 替换为自己应用的 <code>Client ID</code> 值；<br>DRONE_GITHUB_CLIENT_SECRET 替换为 <code>Client Secret</code> 值；<br>DRONE_SERVER_HOST 替换为欲解析的域名。</p><h1 id="Drone-服务的使用"><a href="#Drone-服务的使用" class="headerlink" title="Drone 服务的使用"></a>Drone 服务的使用</h1><p>1、打开域名地址，授予权限</p><p><img src="https://img.wshunli.com/qnap/drone/github_authorize_application.png" alt="github_authorize_application"></p><p>2、点击中间的 ACTICVE 按钮，即可开启持续集成服务。</p><p><img src="https://img.wshunli.com/qnap/drone/drone_active_repositories.png" alt="drone_active_repositories"></p><p>3、然后在 Github 源码仓库中，添加 <code>.drone.yml</code> 文件</p><pre><code class="lang-YML">kind: pipelinename: defaultsteps:- name: test  image: node  commands:  - npm install  - npm test</code></pre><p>具体可参考官方文档。</p><p>4、以下是持续集成结果示例</p><p><img src="https://img.wshunli.com/qnap/drone/drone_continuous_integration.png" alt="drone_continuous_integration"></p><blockquote><p>参考资料<br>1、Drone Single Machine<br><a href="https://docs.drone.io/installation/github/single-machine/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.drone.io/installation/github/single-machine/</a><br>2、如何在Ubuntu上安装Drone持续集成环境 - 云+社区 - 腾讯云<br><a href="https://cloud.tencent.com/developer/article/1180481" rel="external nofollow noopener noreferrer" target="_blank">https://cloud.tencent.com/developer/article/1180481</a><br>3、Drone安装指南 - 怡红院落<br><a href="https://imnerd.org/drone-installation.html" rel="external nofollow noopener noreferrer" target="_blank">https://imnerd.org/drone-installation.html</a><br>4、基于Gogs+Drone搭建的私有CI/CD平台 | DongSheng’s Blog<br><a href="http://www.mdslq.cn/archives/1a623683.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.mdslq.cn/archives/1a623683.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍基于 Github 的 Drone 持续集成服务单机部署。&lt;/p&gt;&lt;h1 id=&quot;Docker-环境&quot;&gt;&lt;a href=&quot;#Docker-环境&quot; class=&quot;headerlink&quot; title=&quot;Docker 环境&quot;&gt;&lt;/a&gt;Docker 环境&lt;/h1&gt;&lt;p&gt;首先
      
    
    </summary>
    
      <category term="后端技术" scheme="https://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="qnap" scheme="https://www.wshunli.com/tags/qnap/"/>
    
      <category term="drone" scheme="https://www.wshunli.com/tags/drone/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境搭建从入门到放弃</title>
    <link href="https://www.wshunli.com/posts/89bfe8.html"/>
    <id>https://www.wshunli.com/posts/89bfe8.html</id>
    <published>2018-12-31T08:47:28.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于 CentOS 搭建 Docker CE 环境，并完成 docker-compose 的安装。</p><h1 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h1><p>1、安装一些必要的依赖</p><pre><code class="lang-Shell">sudo yum install -y yum-utils \  device-mapper-persistent-data \  lvm2</code></pre><p>2、添加 Docker 存储库</p><pre><code class="lang-Shell">sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>因为众所周知的原因，这里推荐使用阿里云的镜像。</p><pre><code class="lang-Shell">sudo yum-config-manager \    --add-repo \    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>3、安装 Docker CE 环境</p><pre><code class="lang-Shell">sudo yum install docker-ce</code></pre><p>4、启动 Docker 服务</p><pre><code class="lang-Shell">sudo systemctl start docker</code></pre><p>设置 Docker 服务为开机自启</p><pre><code class="lang-Shell">sudo systemctl enable docker.service</code></pre><p>5、测试 Docker 安装</p><p>查看 Docker 信息,执行如下命令</p><pre><code class="lang-Shell">docker version</code></pre><p><img src="https://img.wshunli.com/qnap/docker/docker-version.png" alt="version"></p><p>Hello World Docker ! ,执行如下命令</p><pre><code class="lang-Shell">sudo docker run hello-world</code></pre><p><img src="https://img.wshunli.com/qnap/docker/docker-hello.png" alt="hello"></p><h1 id="使用安装脚本一键安装-Docker"><a href="#使用安装脚本一键安装-Docker" class="headerlink" title="使用安装脚本一键安装 Docker"></a>使用安装脚本一键安装 Docker</h1><p>官方提供了一键安装脚本</p><pre><code class="lang-Shell">curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh</code></pre><p>同样众所周知的原因，这里推荐使用阿里云的镜像。</p><pre><code class="lang-Shell">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></pre><p>这样安装的 Docker 没有灵魂，哈哈。</p><h1 id="配置阿里云镜像加速器"><a href="#配置阿里云镜像加速器" class="headerlink" title="配置阿里云镜像加速器"></a>配置阿里云镜像加速器</h1><p>直接从仓库拉取可能会比较慢，这里配置阿里云镜像加速。</p><p>登陆 <a href="https://cr.console.aliyun.com/" rel="external nofollow noopener noreferrer" target="_blank">容器镜像服务控制台</a> ，左侧 镜像加速器 。</p><pre><code class="lang-Shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;{  &quot;registry-mirrors&quot;: [&quot;https://xxxxxx.mirror.aliyuncs.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h1 id="安装-docker-compose-服务启动器"><a href="#安装-docker-compose-服务启动器" class="headerlink" title="安装 docker-compose 服务启动器"></a>安装 docker-compose 服务启动器</h1><pre><code class="lang-Shell">pip install docker-compose</code></pre><blockquote><p>参考资料<br>1、Get Docker CE for CentOS | Docker Documentation<br><a href="https://docs.docker.com/install/linux/docker-ce/centos/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/install/linux/docker-ce/centos/</a><br>2、安装Docker - 快速入门| 阿里云<br><a href="https://www.alibabacloud.com/help/zh/doc-detail/60742.htm" rel="external nofollow noopener noreferrer" target="_blank">https://www.alibabacloud.com/help/zh/doc-detail/60742.htm</a><br>3、如何在Ubuntu上安装使用Docker - 云+社区 - 腾讯云<br><a href="https://cloud.tencent.com/developer/article/1167995" rel="external nofollow noopener noreferrer" target="_blank">https://cloud.tencent.com/developer/article/1167995</a><br>4、Docker CE 镜像源站-云栖社区-阿里云<br><a href="https://yq.aliyun.com/articles/110806/" rel="external nofollow noopener noreferrer" target="_blank">https://yq.aliyun.com/articles/110806/</a><br>5、镜像加速器 · Docker —— 从入门到实践镜像加速器 · Docker —— 从入门到实践<br><a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" rel="external nofollow noopener noreferrer" target="_blank">https://yeasy.gitbooks.io/docker_practice/install/mirror.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文基于 CentOS 搭建 Docker CE 环境，并完成 docker-compose 的安装。&lt;/p&gt;&lt;h1 id=&quot;安装-Docker-环境&quot;&gt;&lt;a href=&quot;#安装-Docker-环境&quot; class=&quot;headerlink&quot; title=&quot;安装 Docker 
      
    
    </summary>
    
      <category term="后端技术" scheme="https://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="qnap" scheme="https://www.wshunli.com/tags/qnap/"/>
    
      <category term="docker" scheme="https://www.wshunli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>阿婆说</title>
    <link href="https://www.wshunli.com/posts/eb2a7b89.html"/>
    <id>https://www.wshunli.com/posts/eb2a7b89.html</id>
    <published>2018-12-09T10:00:00.000Z</published>
    <updated>2019-08-14T18:34:57.858Z</updated>
    
    <content type="html"><![CDATA[<p>阿婆说</p><a id="more"></a><center><div id="mplayer7340"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer7340"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!0,volume:.75,big:!0,dark:!1})</script></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿婆说&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于 frp 的内网穿透实践</title>
    <link href="https://www.wshunli.com/posts/be4c3c8c.html"/>
    <id>https://www.wshunli.com/posts/be4c3c8c.html</id>
    <published>2018-11-09T12:41:15.000Z</published>
    <updated>2019-08-14T18:34:57.854Z</updated>
    
    <content type="html"><![CDATA[<p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>1、利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。<br>2、对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。<br>3、利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务。</p><p>frp 搭建需要一台具有公网 IP 的服务器，并且访问效果和服务器的带宽和内网的上行带宽有关系。</p><h1 id="内网穿透实现方法"><a href="#内网穿透实现方法" class="headerlink" title="内网穿透实现方法"></a>内网穿透实现方法</h1><p>内网穿透有很多商业的软件比如花生壳、NATAPP 等，这里不多介绍。</p><p>还有一些半开源的工具比如 ZeroTier ，配置简单，但是需要额外安装软件。</p><p>再者就是 frp 、ngrok 等开源工具，利用具有公网 IP 的服务器搭建。</p><h1 id="frp-内网穿透实践"><a href="#frp-内网穿透实践" class="headerlink" title="frp 内网穿透实践"></a>frp 内网穿透实践</h1><p>frp：<a href="https://github.com/fatedier/frp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp</a></p><p>中文文档：<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>做内网穿透前需要提前准备一些东西的</p><p>1、一台公网服务器，建议国外的 VPS ，带宽大一些；<br>2、一台内网服务器，我这里是 QNAP 的 NAS ，Linux 系统；<br>3、域名，用于解析，访问内网；<br>4、内网服务，访问的主要内容。</p><h2 id="frp-的安装配置"><a href="#frp-的安装配置" class="headerlink" title="frp 的安装配置"></a>frp 的安装配置</h2><p>这里 具有公网 IP 的机器称为服务端，处于内网环境的机器称为客户端。</p><p>1、下载 frp 文件</p><p>在 <a href="https://github.com/fatedier/frp/releases" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp/releases</a> 下载最新版即可。</p><p>下载并解压文件</p><pre><code class="lang-bash"> cd usr/local/wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gztar -zxvf  frp_0.21.0_linux_amd64.tar.gzcd frp_0.21.0_linux_amd64</code></pre><p>这里主要有 4 个文件，分别是 frpc、frpc.ini 和frps、frps.ini 。</p><p>将 frps 及 <strong>frps.ini</strong> 放到具有公网 IP 的机器上。<br>将 frpc 及 <strong>frpc.ini</strong> 放到处于内网环境的机器上。</p><p>2、配置具有公网 IP 的机器，也就是 frps.ini 文件</p><p>使用 <code>vim frps.ini</code> 命令修改配置文件</p><pre><code class="lang-TXT">[common]bind_port = 7000            # 内网穿透服务端口bind_udp_port = 7001        # 点对点内网穿透vhost_http_port = 10080     # 外部访问的 http 端口vhost_https_port = 10443    # 外部访问的 https 端口dashboard_port = 7500       # 管理面板端口dashboard_user = admin      # 管理面板用户名dashboard_pwd = admin       # 管理面板密码token = asdfgh              # 身份验证</code></pre><p>更多内容参考：<a href="https://github.com/fatedier/frp/blob/master/conf/frps_full.ini" rel="external nofollow noopener noreferrer" target="_blank">frps 完整配置文件</a></p><p>启动 frps 服务</p><pre><code class="lang-bash">./frps -c ./frps.ini</code></pre><p>后台启动方法</p><pre><code class="lang-bash">nohup ./frps -c ./frps.ini &amp;</code></pre><p>3、配置处于内网环境的机器，也就是 frpc.ini 文件</p><p>使用 <code>vim frpc.ini</code> 命令修改配置文件</p><pre><code class="lang-TXT">[common]server_addr = X.X.X.X           # 内网穿透服务地址server_port = 7000              # 内网穿透服务端口token = asdfgh                  # 身份验证，与服务端一致[qnap-web]type = httplocal_ip = 127.0.0.1            # 内网服务地址local_port = 8080               # 内网服务端口use_encryption = true           # 加密传输use_compression = true          # 压缩传输custom_domains = x.wshunli.com  # 访问域名</code></pre><p>这里 <code>custom_domains</code> 是外网服务器解析的域名，否则无法访问；可根据 <code>vhost_http_port</code> 端口反向代理解析。</p><p>更多内容参考：<a href="https://github.com/fatedier/frp/blob/master/conf/frpc_full.ini" rel="external nofollow noopener noreferrer" target="_blank">frpc 完整配置文件</a></p><p>启动 frpc 服务方法与 frps 类似。</p><p>前台启动：<code>./frpc -c ./frpc.ini</code></p><p>后台启动：<code>nohup ./frpc -c ./frpc.ini &amp;</code></p><p>4、frp 控制面板的使用</p><p>这里需要根据公网 IP 服务器访问，即 <code>http://{server_addr}:{dashboard_port}</code></p><p>更多内容参考 <a href="https://github.com/fatedier/frp/blob/master/README_zh.md" rel="external nofollow noopener noreferrer" target="_blank">frp 中文文档</a></p><h1 id="Linux-服务进程停止命令"><a href="#Linux-服务进程停止命令" class="headerlink" title="Linux 服务进程停止命令"></a>Linux 服务进程停止命令</h1><p>1、查找被占用的端口</p><pre><code class="lang-Shell">[root@localhost ~]# netstat -tln | grep 30080tcp6       0      0 :::30080                :::*                    LISTEN</code></pre><p>2、查看被占用端口的PID</p><pre><code class="lang-Shell">[root@localhost ~]# lsof -i:30080COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEdocker-pr 4390 root    4u  IPv6  36195      0t0  TCP *:30080 (LISTEN)docker-pr 4390 root    7u  IPv6 170434      0t0  TCP localhost:30080-&gt;localhost:42162 (ESTABLISHED)frpc      4509 root    6u  IPv4 170433      0t0  TCP localhost:42162-&gt;localhost:30080 (ESTABLISHED)</code></pre><p>3、杀掉相关进程</p><pre><code class="lang-Shell">[root@localhost ~]# kill -9 4509</code></pre><p><img src="https://img.wshunli.com/qnap/frp/linux.png" alt="服务停止启动"></p><blockquote><p>参考资料<br>1、一分钟实现内网穿透（ngrok服务器搭建） - 学习笔记 - CSDN博客<br><a href="https://blog.csdn.net/zhangguo5/article/details/77848658" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhangguo5/article/details/77848658</a><br>2、十分钟教你配置frp实现内网穿透 - 诗雨远方的博客 - CSDN博客<br><a href="https://blog.csdn.net/u013144287/article/details/78589643" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u013144287/article/details/78589643</a><br>3、突破电信局域网：frp内网穿透教程（客户端：lede/win） - 电脑讨论 - Chiphell - 分享与交流用户体验<br><a href="https://www.chiphell.com/thread-1853360-1-1.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.chiphell.com/thread-1853360-1-1.html</a><br>4、使用frp进行内网穿透入门 - ＱＱ小冰 - CSDN博客<br><a href="https://blog.csdn.net/weixin_36241363/article/details/78457359" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/weixin_36241363/article/details/78457359</a><br>5、威联通折腾篇二：使用 frp 内网穿透 | Verne in GitHub<br><a href="https://blog.einverne.info/post/2018/06/qnap-frp-usage.html" rel="external nofollow noopener noreferrer" target="_blank">https://blog.einverne.info/post/2018/06/qnap-frp-usage.html</a><br>6、nohup和&amp;后台运行，进程查看及终止 - 弥尘 - 博客园<br><a href="https://www.cnblogs.com/baby123/p/6477429.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/baby123/p/6477429.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。&lt;/p&gt;&lt;p&gt;1、利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。&lt;br&gt;2、对于 http, https 服务支持基于域名的虚拟主机，
      
    
    </summary>
    
      <category term="后端技术" scheme="https://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="qnap" scheme="https://www.wshunli.com/tags/qnap/"/>
    
      <category term="frp" scheme="https://www.wshunli.com/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>基于 WinSW 将 Java 程序部署为 Windows 自启动服务</title>
    <link href="https://www.wshunli.com/posts/762f39b0.html"/>
    <id>https://www.wshunli.com/posts/762f39b0.html</id>
    <published>2018-10-20T03:22:36.000Z</published>
    <updated>2019-08-14T18:34:57.854Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍基于 WinSW 将 Java 程序部署 为 Windows 自启动服务。</p><p>我们使用 Java -jar file.jar 将 Java 程序运行，起来，但是窗口关闭，服务就停止了。</p><p>WinSW 可以将 Windows 上的任何一个程序注册为服务，如果不需要，也可以方便的卸载服务。</p><p><a href="https://github.com/kohsuke/winsw" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kohsuke/winsw</a></p><p>1、下载 winsw 文件</p><p>下载 winsw-2.1.2-bin.exe 文件</p><p><a href="http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/" rel="external nofollow noopener noreferrer" target="_blank">http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/</a></p><p>最好修改下文件名称，本文修改为 <code>winsw-ai-server</code></p><p>2、添加配置文件</p><p>根据 winsw 文件名，新建相同名称的 xml 文件</p><pre><code class="lang-XML">&lt;service&gt;    &lt;id&gt;phcj-ai-server&lt;/id&gt;    &lt;name&gt;phcj-ai-server&lt;/name&gt;    &lt;description&gt;系统 AI 后台服务&lt;/description&gt;    &lt;executable&gt;java&lt;/executable&gt;        &lt;onfailure action=&quot;restart&quot; delay=&quot;10 sec&quot;/&gt;    &lt;arguments&gt; -jar &quot;D:\PHCJ\phcj-ai-server\target\phcj-ai-server-0.0.1-SNAPSHOT.jar&quot;&lt;/arguments&gt;    &lt;log mode=&quot;roll-by-size&quot;&gt;        &lt;sizeThreshold&gt;20480&lt;/sizeThreshold&gt;        &lt;keepFiles&gt;8&lt;/keepFiles&gt;    &lt;/log&gt;&lt;/service&gt;</code></pre><p>3、安装并启动服务</p><p>注意以管理员身份运行</p><p>安装服务 <code>./winsw-ai-server.exe install</code></p><p>启动服务 <code>net start phcj-ai-server</code></p><p>停止服务 <code>net stop phcj-ai-server</code></p><p>卸载服务 <code>./winsw-ai-server.exe uninstall</code></p><blockquote><p>参考资料：<br>1、winsw将可运行的jar文件做成后台服务 - qq_31451471的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_31451471/article/details/79298665" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_31451471/article/details/79298665</a><br>2、用winsw让任何Windows程序都能运行为服务 - 简书<br><a href="https://www.jianshu.com/p/fc9e4ea61e13" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/fc9e4ea61e13</a><br>3、使用WinSW将SpringBoot程序安装成Windows自启动服务 - blvyoucan的专栏 - CSDN博客<br><a href="https://blog.csdn.net/blvyoucan/article/details/81131234" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/blvyoucan/article/details/81131234</a><br>4、Spring Boot项目生成jar包，并在windows服务器中注册成服务，开机启动 - LiveYourLife - 博客园<br><a href="https://www.cnblogs.com/LiveYourLife/p/8681137.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/LiveYourLife/p/8681137.html</a><br>5、springboot解决第三方依赖jar包的问题 - 浅夏丶未央 - 博客园<br><a href="https://www.cnblogs.com/xiaosiyuan/p/6894766.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/xiaosiyuan/p/6894766.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍基于 WinSW 将 Java 程序部署 为 Windows 自启动服务。&lt;/p&gt;&lt;p&gt;我们使用 Java -jar file.jar 将 Java 程序运行，起来，但是窗口关闭，服务就停止了。&lt;/p&gt;&lt;p&gt;WinSW 可以将 Windows 上的任何一个程序注册为
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="WinSW" scheme="https://www.wshunli.com/tags/WinSW/"/>
    
  </entry>
  
  <entry>
    <title>Java 调用 Matlab 程序（Java 和 Matlab 混合编程）</title>
    <link href="https://www.wshunli.com/posts/45399dc2.html"/>
    <id>https://www.wshunli.com/posts/45399dc2.html</id>
    <published>2018-10-20T01:24:10.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Java 调用 Matlab 程序（Java 和 Matlab 混合编程）流程方法。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>1、 Java 环境，建议使用如下版本 。</p><p>Java™ SE Development Kit 8, Update 151 (JDK 8u151)</p><p>2、Matlab 工具（开发环境）</p><p>编写 Mattlab 代码，本文以最新版 Matlab 2018b 为例。</p><p>3、MATLAB Runtime（部署环境）</p><p>已经安装过 Matlab 就不需要再安装了，用来执行编译后的 Matlab 程序。</p><p>从以下网址下载即可，本文以 R2018b (9.5) 为例。</p><p><a href="https://ww2.mathworks.cn/products/compiler/matlab-runtime.html" rel="external nofollow noopener noreferrer" target="_blank">https://ww2.mathworks.cn/products/compiler/matlab-runtime.html</a></p><p>MATLAB Runtime 相比 Matlab 更加轻量级，免费。</p><p><strong>环境确认：</strong></p><p>本文建议 Java 版本和 Matlab 自带 JVM 保持一致。</p><p>在 Matlab 命令中输入 <code>version -java</code> 查看机器 Matlab 版本。</p><p><img src="https://img.wshunli.com/Java/Matlab/matlab-version.png" alt="java-version"></p><p>在 CMD 中执行 <code>java -version</code> 查看机器 Java 版本，</p><p><img src="https://img.wshunli.com/Java/Matlab/java-version.png" alt="java-version"></p><h1 id="Matlab-程序打包"><a href="#Matlab-程序打包" class="headerlink" title="Matlab 程序打包"></a>Matlab 程序打包</h1><p>Matlab 支持 C++ 、Java 、.Net 等语言的打包。</p><p>我们将 .m 文件打包为 Java 支持的库，如下图：</p><p><img src="https://img.wshunli.com/Java/Matlab/matlab-package.png" alt="matlab-package"></p><p>感觉和 JVM 虚拟机很类似，Matlab 提供基础环境，我们编写 Matlab 代码即可。</p><h1 id="Java-调用-Matlab-方法"><a href="#Java-调用-Matlab-方法" class="headerlink" title="Java 调用 Matlab 方法"></a>Java 调用 Matlab 方法</h1><p>在 Java 中调用 Matlab 的方法时，有三种方式。</p><p>1、functionName(int arg0, Object… agr1): Object[]</p><p>其中 arg0 表示返回数据的个数，agr1 为数组；返回值也是数组。</p><p>2、functionName(List arg0, List agr1): void</p><p>其中 arg0 、agr1 为列表；返回值为空。</p><p>3、functionName(Object[] arg0, Object[] agr1): void</p><p>其中 arg0 、agr1 为数组；返回值为空。</p><h2 id="方式一，输入返回个数"><a href="#方式一，输入返回个数" class="headerlink" title="方式一，输入返回个数"></a>方式一，输入返回个数</h2><pre><code class="lang-Java">// 定义输出结果  Object[] results = null;  Magic magic = new Magic(); // 实例化 // &#39;2&#39; 表示 2 个输出结果，类似 results=new Object[2];  // &#39;5&#39; 表示输入的参数 results = magic.makesqr(2, 5);  // 输出第一个返回内容  System.out.println(results[0]);  // 输出第二个返回内容  System.out.println(results[1]);</code></pre><h2 id="方式二，列表参数"><a href="#方式二，列表参数" class="headerlink" title="方式二，列表参数"></a>方式二，列表参数</h2><pre><code class="lang-Java">// 定义结果List  List&lt;Object&gt; results = new ArrayList&lt;Object&gt;(2);  // 定义参数List  List&lt;Object&gt; inputs = new ArrayList&lt;Object&gt;(1);  Magic magic = null;  magic = new Magic();  // 注意:结果List要预先加入内容，Null即可  results.add(null);  results.add(null);  // 输入的参数  inputs.add(5);  // 调用方法  magic.makesqr(results, inputs);  // 显示结果  System.out.println(results.get(0));  System.out.println(results.get(1));</code></pre><h2 id="方式三，数组参数"><a href="#方式三，数组参数" class="headerlink" title="方式三，数组参数"></a>方式三，数组参数</h2><pre><code class="lang-Java">// 注意：定义输出结果的时候，要定义数组大小  Object[] results = new Object[2];  Magic magic = null;  magic = new Magic();  // 这种方式，第二参数必须为数组，而不能为可变数组  Object[] inputs = new Object[]{5};  magic.makesqr(results, inputs);  // 输出第一个返回内容  System.out.println(results[0]);  // 输出第二个返回内容  System.out.println(results[1]);</code></pre><h1 id="Java-与-Matlab-数据转换"><a href="#Java-与-Matlab-数据转换" class="headerlink" title="Java 与 Matlab 数据转换"></a>Java 与 Matlab 数据转换</h1><p>数据转换内容比较多，这里主要介绍<strong>数组</strong>的转换。</p><p>1、将 Java 数据转化为 Matlab 数据</p><p>这里以输入 <a href="https://ww2.mathworks.cn/help/javabuilder/MWArrayAPI/com/mathworks/toolbox/javabuilder/MWNumericArray.html" rel="external nofollow noopener noreferrer" target="_blank">MWNumericArray</a> 数据为例</p><p>使用 newInstance 方法实例化</p><pre><code class="lang-Java">//new int[]{11,2} 代表矩阵为 11 行 2 列的矩阵//MWClassID.DOUBLE 代表矩阵中数为 double 类型，MWComplexity.REAL 代表矩阵中是实数MWNumericArray f = MWNumericArray.newInstance(new int[]{11,2}, MWClassID.DOUBLE, MWComplexity.REAL);MWNumericArray f = MWNumericArray.newInstance(new int[]{11,2}, data, MWClassID.DOUBLE);</code></pre><p>另外一种方式：</p><pre><code class="lang-Java">int[] dims = {3, 6};double[] Adata = {1, 7, 13, 2, 8, 14, 3, 9, 15, 4, 10, 16, 5, 11, 17, 6, 12, 18};MWNumericArray A = MWNumericArray.newInstance(dims, Adata, MWClassID.DOUBLE);System.out.println(&quot;A = &quot;);System.out.println(A);</code></pre><p>2、将 Matlab 数据转化为 Java 数据</p><p>这里以返回 <a href="https://www.mathworks.com/help/javabuilder/MWArrayAPI/com/mathworks/toolbox/javabuilder/MWCellArray.html" rel="external nofollow noopener noreferrer" target="_blank">MWCellArray</a> 数据为例</p><pre><code class="lang-Java">MWCellArray cellArray = (MWCellArray) result[0];double[] output = new double[cellArray.numberOfElements()];for (int i = 1; i &lt;= cellArray.numberOfElements(); i++) {    output[i - 1] = ((double[][]) cellArray.get(i))[0][0];}System.out.print(&quot;输出数据：&quot;);System.out.println(Arrays.toString(output));</code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>输入数据为 <code>17行1列</code> 的 MWNumericArray 数据，返回 <code>1行15列</code> 的 MWCellArray 数据。</p><pre><code class="lang-Java">System.out.println(&quot;Running the JAVA client application!!&quot;);AiNet cls = null; // 调用对象MWNumericArray input = null; // 输入Object[] result = new Object[1]; // 输出结果double[] data = new double[]{ // 初始数据        3.43300000000000,        3.40500000000000,        3.37200000000000,        3.35700000000000,        3.34800000000000,        3.31500000000000,        3.28800000000000,        3.28000000000000,        3.26800000000000,        3.24600000000000,        3.23900000000000,        3.24600000000000,        3.25800000000000,        3.27100000000000,        3.28200000000000,        3.28600000000000,        3.30000000000000};input = MWNumericArray.newInstance(new int[]{17, 1}, data, MWClassID.DOUBLE);System.out.print(&quot;输入数据：&quot;);System.out.println(Arrays.toString(input.getDoubleData()));try {    cls = new AiNet();    result = cls.Net(1, input);    MWCellArray cellArray = (MWCellArray) result[0];    double[] output = new double[cellArray.numberOfElements()];    for (int i = 1; i &lt;= cellArray.numberOfElements(); i++) {        output[i - 1] = ((double[][]) cellArray.get(i))[0][0];    }    System.out.print(&quot;输出数据：&quot;);    System.out.println(Arrays.toString(output));    MWArray.disposeArray(output);} catch (MWException e) {    e.printStackTrace();} finally {    MWArray.disposeArray(input);    MWArray.disposeArray(result);    if (cls != null) {        cls.dispose();    }}</code></pre><p>注意使用 MWArray.disposeArray() 方法释放资源。</p><blockquote><p>参考资料<br>1、Java调用MATLAB - 窃·格瓦拉 - CSDN博客<br><a href="https://blog.csdn.net/golden1314521/article/details/43526581" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/golden1314521/article/details/43526581</a><br>2、Java调用Matlab方法的三种方式 - 非技术流 - ITeye博客<br><a href="http://xiaolongfeixiang.iteye.com/blog/1893621" rel="external nofollow noopener noreferrer" target="_blank">http://xiaolongfeixiang.iteye.com/blog/1893621</a><br>3、ML02<em>09_calling_java_from_MATLAB_CH.ppt<br><a href="http://read.pudn.com/downloads85/doc/329263/matlab%E8%AE%B2%E4%B9%89/ML02(11-28)/ML02_09_calling_java_from_MATLAB_CH.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://read.pudn.com/downloads85/doc/329263/matlab%E8%AE%B2%E4%B9%89/ML02(11-28)/ML02_09_calling_java_from_MATLAB_CH.pdf</a><br>4、Java调用Matlab程序 - 移动的天坑的个人空间 - 开源中国<br><a href="https://my.oschina.net/pierrecai/blog/829641" rel="external nofollow noopener noreferrer" target="_blank">https://my.oschina.net/pierrecai/blog/829641</a><br>5、JAVA调用matlab程序 输入输出数据转换 - 简书<br><a href="https://www.jianshu.com/p/c008bd9d5a25" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c008bd9d5a25</a><br>6、(1)在java中使用matlab的函数</em>东东-forest_新浪博客<br><a href="http://blog.sina.com.cn/s/blog_86aea377010171yq.html" rel="external nofollow noopener noreferrer" target="_blank">http://blog.sina.com.cn/s/blog_86aea377010171yq.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Java 调用 Matlab 程序（Java 和 Matlab 混合编程）流程方法。&lt;/p&gt;&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;1、 Java 
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="Matlab" scheme="https://www.wshunli.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Glide 图片加载框架源码解析</title>
    <link href="https://www.wshunli.com/posts/c47606cc.html"/>
    <id>https://www.wshunli.com/posts/c47606cc.html</id>
    <published>2018-09-17T05:18:23.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。<strong>本文内容基于 Glide 4.7.1 版本</strong>。</p><p>Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、可扩展的图片解码管道，以及自动的资源池技术。<a href="https://muyangmin.github.io/glide-docs-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://muyangmin.github.io/glide-docs-cn/</a></p><p>Glide 支持拉取，解码和展示视频快照，图片，和 GIF 动画。Glide 的 API 是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide 使用的是一个定制化的基于 HttpUrlConnection 的栈，但同时也提供了与 Google Volley 和 Square OkHttp 快速集成的工具库。</p><h1 id="Glide-的简单使用"><a href="#Glide-的简单使用" class="headerlink" title="Glide 的简单使用"></a>Glide 的简单使用</h1><p>前面有比较详细的介绍，这里不再赘述。</p><p>Android 图片加载框架 Glide 简单使用 | CirGIS</p><p><a href="https://www.wshunli.com/posts/d82d8606.html">https://www.wshunli.com/posts/d82d8606.html</a></p><h1 id="Glide-的源码解析"><a href="#Glide-的源码解析" class="headerlink" title="Glide 的源码解析"></a>Glide 的源码解析</h1><p>1、我们先看 Glide 的 with() 方法</p><pre><code class="lang-Java">  @NonNull  public static RequestManager with(@NonNull Context context) {    return getRetriever(context).get(context);  }  @NonNull  public static RequestManager with(@NonNull Activity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull FragmentActivity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull Fragment fragment) {    return getRetriever(fragment.getActivity()).get(fragment);  }  @NonNull  public static RequestManager with(@NonNull View view) {    return getRetriever(view.getContext()).get(view);  }</code></pre><p>未完待续。。</p><blockquote><p>参考资料<br>1、Glide源码分析 | lightSky’Blog<br><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" rel="external nofollow noopener noreferrer" target="_blank">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br>2、Android Glide源码解析 - 简书<br><a href="https://www.jianshu.com/p/0c383eaa5675" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c383eaa5675</a><br>3、Android Glide源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/10/10/android-glide/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/10/10/android-glide/</a><br>4、Android源码分析：手把手带你分析 Glide的缓存功能 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/79256892" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/79256892</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Glide 4.7.1 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、可
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Glide" scheme="https://www.wshunli.com/tags/Glide/"/>
    
      <category term="图片加载" scheme="https://www.wshunli.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/2bda06ba.html"/>
    <id>https://www.wshunli.com/posts/2bda06ba.html</id>
    <published>2018-09-16T01:38:40.000Z</published>
    <updated>2019-08-14T18:34:57.850Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 Retrofit 2.4.0 版本</strong>。</p><p>Type-safe HTTP client for Android and Java by Square, Inc. <a href="http://square.github.io/retrofit/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/retrofit/</a></p><p>前面介绍过 OkHttp ，Retrofit 是对 OkHttp 网络请求框架的封装，前者专注于接口的封装，后者专注于真正的网络请求。</p><p><img src="https://img.wshunli.com/Android/Retrofit/Retrofit_OkHttp.png" alt="封装流程图"></p><p>应用程序通过 Retrofit 请求网络，实际上是由 Retrofit 接口层封装请求参数、Header、Url 等信息，由 OkHttp 完成实际的请求操作；在服务端返回数据后，OkHttp 将原始的结果交给 Retrofit，Retrofit 根据用户的需求对结果进行解析。</p><h1 id="Retrofit-的简单使用"><a href="#Retrofit-的简单使用" class="headerlink" title="Retrofit 的简单使用"></a>Retrofit 的简单使用</h1><p>参考官网的介绍：</p><p>1、创建 HTTP API 接口</p><pre><code class="lang-Java">public interface GitHubService {  @GET(&quot;users/{user}/repos&quot;)  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><p>2、创建 Retrofit 实例，并实现接口实例</p><pre><code class="lang-Java">Retrofit retrofit = new Retrofit.Builder()    .baseUrl(&quot;https://api.github.com/&quot;)    .build();GitHubService service = retrofit.create(GitHubService.class);</code></pre><p>3、创建请求实例</p><pre><code class="lang-Java">Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;wshunli&quot;);</code></pre><p>4、发送网络请求</p><pre><code class="lang-Java">// 同步请求call.execute();// 异步请求call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {    @Override    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) {    }    @Override    public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) {        Log.d(TAG, &quot;onFailure: &quot;);    }});</code></pre><p>和 OkHttp 流程差不多，特别是发送请求方法名字都没有变。</p><h1 id="Retrofit-的源码分析"><a href="#Retrofit-的源码分析" class="headerlink" title="Retrofit 的源码分析"></a>Retrofit 的源码分析</h1><p>Retrofit 网络请求完整的流程图如下：</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_full_process.min.png" alt="Retrofit 流程图"></p><p>下面详细介绍。</p><h2 id="创建-Retrofit-实例"><a href="#创建-Retrofit-实例" class="headerlink" title="创建 Retrofit 实例"></a>创建 Retrofit 实例</h2><p>Retrofit 实例化，也是使用的建造者模式。</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_builder.png" alt="retrofit_builder"></p><p>我们先看 Builder 成员变量的含义：</p><pre><code class="lang-Java">// Retrofit#Builderpublic static final class Builder {// 当前系统环境private final Platform platform;// 网络请求器的工厂private @Nullable okhttp3.Call.Factory callFactory;// 网络请求地址private HttpUrl baseUrl;// 数据转换器工厂集合private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();// 网络请求适配器工厂集合private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();// 回调方法执行器private @Nullable Executor callbackExecutor;// 标志位private boolean validateEagerly;</code></pre><p>1、首先构造函数中通过 <code>Platform.get()</code> 初始化了平台参数</p><pre><code class="lang-Java">Builder(Platform platform) {    this.platform = platform;}public Builder() {    this(Platform.get());}Builder(Retrofit retrofit) {    platform = Platform.get();    callFactory = retrofit.callFactory;    baseUrl = retrofit.baseUrl;    converterFactories.addAll(retrofit.converterFactories);    // Remove the default BuiltInConverters instance added by build().    converterFactories.remove(0);    callAdapterFactories.addAll(retrofit.callAdapterFactories);    // Remove the default, platform-aware call adapter added by build().    callAdapterFactories.remove(callAdapterFactories.size() - 1);    callbackExecutor = retrofit.callbackExecutor;    validateEagerly = retrofit.validateEagerly;}</code></pre><p>我们可以看下判断方法：</p><pre><code class="lang-Java">// Platformclass Platform {  private static final Platform PLATFORM = findPlatform();  static Platform get() {    return PLATFORM;  }  private static Platform findPlatform() {    try {      Class.forName(&quot;android.os.Build&quot;);      if (Build.VERSION.SDK_INT != 0) {        return new Android();      }    } catch (ClassNotFoundException ignored) {    }    try {      Class.forName(&quot;java.util.Optional&quot;);      return new Java8();    } catch (ClassNotFoundException ignored) {    }    return new Platform();  }  /* 省略部分无关代码 */}</code></pre><p>后面如果有需要，我们也可以直接拷贝。</p><p>2、然后设置 Retrofit 所需的参数即可</p><pre><code class="lang-Java">public Builder baseUrl(String baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    HttpUrl httpUrl = HttpUrl.parse(baseUrl);    if (httpUrl == null) {    throw new IllegalArgumentException(&quot;Illegal URL: &quot; + baseUrl);    }    return baseUrl(httpUrl);}public Builder baseUrl(HttpUrl baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    List&lt;String&gt; pathSegments = baseUrl.pathSegments();    if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) {    throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl);    }    this.baseUrl = baseUrl;    return this;}/** Add converter factory for serialization and deserialization of objects. */public Builder addConverterFactory(Converter.Factory factory) {    converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}public Builder addCallAdapterFactory(CallAdapter.Factory factory) {    callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}</code></pre><p>3、最后是 build() 方法</p><pre><code class="lang-Java">public Retrofit build() {    if (baseUrl == null) {    throw new IllegalStateException(&quot;Base URL required.&quot;);    }    okhttp3.Call.Factory callFactory = this.callFactory;    if (callFactory == null) {    callFactory = new OkHttpClient();    }    Executor callbackExecutor = this.callbackExecutor;    if (callbackExecutor == null) {    callbackExecutor = platform.defaultCallbackExecutor();    }    // Make a defensive copy of the adapters and add the default Call adapter.    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);    callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));    // Make a defensive copy of the converters.    List&lt;Converter.Factory&gt; converterFactories =        new ArrayList&lt;&gt;(1 + this.converterFactories.size());    // Add the built-in converter factory first. This prevents overriding its behavior but also    // ensures correct behavior when using converters that consume all types.    converterFactories.add(new BuiltInConverters());    converterFactories.addAll(this.converterFactories);    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);}</code></pre><h2 id="创建-API-实例"><a href="#创建-API-实例" class="headerlink" title="创建 API 实例"></a>创建 API 实例</h2><p>获取 API 实例使用 Retrofit 的 <code>create()</code> 方法</p><pre><code class="lang-Java">// Retrofit#create()public &lt;T&gt; T create(final Class&lt;T&gt; service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {        eagerlyValidateMethods(service);    }    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },        new InvocationHandler() {            private final Platform platform = Platform.get();            @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)                throws Throwable {            // If the method is a method from Object then defer to normal invocation.            if (method.getDeclaringClass() == Object.class) {                return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {                return platform.invokeDefaultMethod(method, service, proxy, args);            }            ServiceMethod&lt;Object, Object&gt; serviceMethod =                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);            return serviceMethod.adapt(okHttpCall);            }        });}</code></pre><p>创建 API 实例使用的是 <strong>动态代理</strong> 设计模式。</p><h2 id="创建请求实例"><a href="#创建请求实例" class="headerlink" title="创建请求实例"></a>创建请求实例</h2><p>创建请求实例，跟钱买你的动态代理有关。</p><pre><code class="lang-Java">// Retrofit#create()ServiceMethod&lt;Object, Object&gt; serviceMethod =    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.adapt(okHttpCall);</code></pre><p>1、<code>loadServiceMethod()</code> 方法</p><p>一个 <code>ServiceMethod</code> 对应于一个 API 接口的一个方法，<code>loadServiceMethod()</code> 方法负责加载 <code>ServiceMethod</code></p><pre><code class="lang-Java">// Retrofit#loadServiceMethod()ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) {    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) {        result = serviceMethodCache.get(method);        if (result == null) {        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();        serviceMethodCache.put(method, result);        }    }    return result;}</code></pre><p>2、<code>OkHttpCall</code> 类</p><p><code>OkHttpCall</code> 实现了 <code>retrofit2.Call</code> ，我们通常会使用它的 <code>execute()</code> 和 <code>enqueue()</code> 接口。</p><pre><code class="lang-Java">OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) {    this.serviceMethod = serviceMethod;    this.args = args;}</code></pre><p>构造方法也没有什么好看的。</p><h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>发送网络请求其实也就是 <code>OkHttpCall</code> 类中的方法。</p><p>1、<strong>同步请求</strong> 使用 <code>execute()</code> 方法</p><pre><code class="lang-Java">// OkHttpCall#execute()@Override public Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        if (creationFailure != null) {            if (creationFailure instanceof IOException) {                throw (IOException) creationFailure;            } else if (creationFailure instanceof RuntimeException) {                throw (RuntimeException) creationFailure;            } else {                throw (Error) creationFailure;            }        }        call = rawCall;        if (call == null) {            try {                call = rawCall = createRawCall();            } catch (IOException | RuntimeException | Error e) {                throwIfFatal(e); //  Do not assign a fatal error to creationFailure.                creationFailure = e;                throw e;            }        }    }    if (canceled) {        call.cancel();    }    return parseResponse(call.execute());}</code></pre><p>这里就是 Retrofit 和 OkHttp 交互的核心了，分为三步：</p><p>（1）创建 <code>okhttp3.Call</code> ，包括构造参数</p><pre><code class="lang-Java">private okhttp3.Call createRawCall() throws IOException {    okhttp3.Call call = serviceMethod.toCall(args);    if (call == null) {        throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    }    return call;}</code></pre><p>（2）执行网络请求，也就是 OkHttp 的同步网络请求</p><pre><code class="lang-Java">call.execute()</code></pre><p>（3）解析返回的结果</p><pre><code class="lang-Java">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {    ResponseBody rawBody = rawResponse.body();    // Remove the body&#39;s source (the only stateful object) so we can pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))        .build();    int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) {        try {        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);        } finally {        rawBody.close();        }    }    if (code == 204 || code == 205) {        rawBody.close();        return Response.success(null, rawResponse);    }    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);    try {        T body = serviceMethod.toResponse(catchingBody);        return Response.success(body, rawResponse);    } catch (RuntimeException e) {        // If the underlying source threw an exception, propagate that rather than indicating it was        // a runtime exception.        catchingBody.throwIfCaught();        throw e;    }}</code></pre><p>2、<strong>异步请求</strong> 使用 <code>enqueue()</code> 方法</p><pre><code class="lang-Java">@Override public void enqueue(final Callback&lt;T&gt; callback) {    checkNotNull(callback, &quot;callback == null&quot;);    okhttp3.Call call;    Throwable failure;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        call = rawCall;        failure = creationFailure;        if (call == null &amp;&amp; failure == null) {        try {            call = rawCall = createRawCall();        } catch (Throwable t) {            throwIfFatal(t);            failure = creationFailure = t;        }        }    }    if (failure != null) {        callback.onFailure(this, failure);        return;    }    if (canceled) {        call.cancel();    }    call.enqueue(new okhttp3.Callback() {        @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {        Response&lt;T&gt; response;        try {            response = parseResponse(rawResponse);        } catch (Throwable e) {            callFailure(e);            return;        }        try {            callback.onResponse(OkHttpCall.this, response);        } catch (Throwable t) {            t.printStackTrace();        }        }        @Override public void onFailure(okhttp3.Call call, IOException e) {        callFailure(e);        }        private void callFailure(Throwable e) {        try {            callback.onFailure(OkHttpCall.this, e);        } catch (Throwable t) {            t.printStackTrace();        }        }    });}</code></pre><p>我们可以看到和同步请求是一致的，实际请求交给了 <code>okhttp3.Call#enqueue(Callback responseCallback)</code> 来实现，并在它的 <code>callback</code> 中调用 <code>parseResponse()</code> 解析响应数据，并转发给传入的 <code>callback</code> 。</p><p>Retrofit 源码就先介绍到这里了，后面有机会再详细介绍。</p><blockquote><p>参考资料<br>1、Retrofit分析-漂亮的解耦套路 - 简书<br><a href="https://www.jianshu.com/p/45cb536be2f4" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/45cb536be2f4</a><br>2、Android：手把手带你 深入读懂 Retrofit 2.0 源码 - 简书<br><a href="https://www.jianshu.com/p/0c055ad46b6c" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c055ad46b6c</a><br>3、Retrofit源码分析（超详细） - 简书<br><a href="https://www.jianshu.com/p/097947afddaf" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/097947afddaf</a><br>4、拆轮子系列：拆 Retrofit - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/06/25/Understand-Retrofit/</a><br>5、Retrofit源码解析 | mundane的幻想空间<br><a href="https://mundane799699.github.io/2018/03/13/retrofit-analysis/" rel="external nofollow noopener noreferrer" target="_blank">https://mundane799699.github.io/2018/03/13/retrofit-analysis/</a><br>6、Retrofit源码解析 - 掘金<br><a href="https://juejin.im/post/5acee62c6fb9a028df22ffee" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5acee62c6fb9a028df22ffee</a><br>7、Retrofit源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="https://yuqirong.me/2017/08/03/Retrofit源码解析/" rel="external nofollow noopener noreferrer" target="_blank">https://yuqirong.me/2017/08/03/Retrofit源码解析/</a><br>8、android-cn/android-open-project-analysis<br><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit</a><br>9、【Android】Retrofit源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79933220" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79933220</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Retrofit 2.4.0 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Type-safe HTTP client for Android and Java by Square, In
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Retrofit" scheme="https://www.wshunli.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/5bd2f229.html"/>
    <id>https://www.wshunli.com/posts/5bd2f229.html</id>
    <published>2018-09-13T08:28:11.000Z</published>
    <updated>2019-08-14T18:34:57.850Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 OkHttp 3.11.0 版本</strong>。</p><p>网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。</p><p>只是停留在应用层面，会使用一些框架是不行的，还需要深入源码、剖析结构。</p><p>An HTTP+HTTP/2 client for Android and Java applications. <a href="http://square.github.io/okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/okhttp/</a></p><blockquote><p>支持 HTTP/2 协议，允许连接到同一个主机地址的所有请求共享 Socket 。<br>在 HTTP/2 协议不可用的情况下，通过连接池减少请求的延迟。<br>支持 GZip 透明压缩，减少传输的数据包大小。<br>支持响应缓存，避免同一个重复的网络请求。</p></blockquote><h1 id="OkHttp-的简单使用"><a href="#OkHttp-的简单使用" class="headerlink" title="OkHttp 的简单使用"></a>OkHttp 的简单使用</h1><p>一般情况下，对于网络框架有两种常见的使用场景，同步请求和异步请求。</p><p><strong>同步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();Log.d(TAG, &quot;onCreate: &quot; + response.body().string());</code></pre><p><strong>异步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {        Log.d(TAG, &quot;onCreate: &quot; + response.body().string());    }});</code></pre><p>同步请求和异步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><h1 id="OkHttp-的源码分析"><a href="#OkHttp-的源码分析" class="headerlink" title="OkHttp 的源码分析"></a>OkHttp 的源码分析</h1><p>OkHttp 网络请求完整的流程图如下：</p><div align="center"><img src="https://img.wshunli.com/Android/OkHttp/okhttp_full_process.min.png" title="OkHttp 流程图" alt="OkHttp 流程图"></div><p>下面详细介绍。</p><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步请求，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，最后执行 execute() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();</code></pre><h3 id="创建-OkHttpClient-对象"><a href="#创建-OkHttpClient-对象" class="headerlink" title="创建 OkHttpClient 对象"></a>创建 OkHttpClient 对象</h3><p>我们先看 OkHttp 的构造函数：</p><pre><code class="lang-Java">public OkHttpClient() {  this(new Builder());}</code></pre><p>这里是直接实例化，实质上是使用 <strong>建造者模式</strong> 构建 OkHttpClient 实例。</p><p>下面是 OkHttpClient 内部类 Builder 的构造方法：</p><pre><code class="lang-Java">public Builder() {  dispatcher = new Dispatcher();  protocols = DEFAULT_PROTOCOLS;  connectionSpecs = DEFAULT_CONNECTION_SPECS;  eventListenerFactory = EventListener.factory(EventListener.NONE);  proxySelector = ProxySelector.getDefault();  cookieJar = CookieJar.NO_COOKIES;  socketFactory = SocketFactory.getDefault();  hostnameVerifier = OkHostnameVerifier.INSTANCE;  certificatePinner = CertificatePinner.DEFAULT;  proxyAuthenticator = Authenticator.NONE;  authenticator = Authenticator.NONE;  connectionPool = new ConnectionPool();  dns = Dns.SYSTEM;  followSslRedirects = true;  followRedirects = true;  retryOnConnectionFailure = true;  connectTimeout = 10_000;  readTimeout = 10_000;  writeTimeout = 10_000;  pingInterval = 0;}public OkHttpClient build() {  return new OkHttpClient(this);}</code></pre><p>这里 <code>OkHttpClient.Builder</code> 有很多参数，后面再介绍。</p><h3 id="创建-Request-对象"><a href="#创建-Request-对象" class="headerlink" title="创建 Request 对象"></a>创建 Request 对象</h3><p>和 OkHttpClient 类似，Request 也是是使用 <strong>建造者模式</strong> 创建实例。</p><pre><code class="lang-Java">public Builder() {  this.method = &quot;GET&quot;;  this.headers = new Headers.Builder();}public Request build() {  if (url == null) throw new IllegalStateException(&quot;url == null&quot;);  return new Request(this);}</code></pre><p>其中配置默认请求方法为 <code>GET</code> ，还有一些头部的默认参数。</p><h3 id="创建-Call-对象"><a href="#创建-Call-对象" class="headerlink" title="创建 Call 对象"></a>创建 Call 对象</h3><p>OkHttpClient 实现了 <code>Call.Factory</code> ，负责根据请求创建新的 Call 对象。</p><pre><code class="lang-Java">@Override public Call newCall(Request request) {  return RealCall.newRealCall(this, request, false /* for web socket */);}</code></pre><p>Call 只是个接口，实际是实例化的 RealCall 对象。</p><pre><code class="lang-Java">private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  this.client = client;  this.originalRequest = originalRequest;  this.forWebSocket = forWebSocket;  this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);}static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  // Safely publish the Call instance to the EventListener.  RealCall call = new RealCall(client, originalRequest, forWebSocket);  call.eventListener = client.eventListenerFactory().create(call);  return call;}</code></pre><h3 id="发送同步网络请求"><a href="#发送同步网络请求" class="headerlink" title="发送同步网络请求"></a>发送同步网络请求</h3><p>发送请求也是在 <code>RealCall</code> 的 <code>execute()</code> 方法中执行的。</p><pre><code class="lang-Java">// RealCall#execute()@Override public Response execute() throws IOException {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  try {    client.dispatcher().executed(this);    Response result = getResponseWithInterceptorChain();    if (result == null) throw new IOException(&quot;Canceled&quot;);    return result;  } catch (IOException e) {    eventListener.callFailed(this, e);    throw e;  } finally {    client.dispatcher().finished(this);  }}</code></pre><p>在这里主要做了四件事：</p><p>1、检查 Call 是否执行过，没有执行将 <code>executed</code> 赋值为 true ，保证每个请求只执行一次；<br>2、使用 <code>client.dispatcher().executed(this)</code> 来进行实际的请求；<br>3、调用 <code>getResponseWithInterceptorChain()</code> 方法，获取请求响应的结果；<br>4、最后 <code>dispatcher</code> 结束自己。</p><pre><code class="lang-Java">// Dispatcher#executed()/** Used by {@code Call#execute} to signal it is in-flight. */synchronized void executed(RealCall call) {  runningSyncCalls.add(call);}</code></pre><p>在同步请求中 <code>dispatcher</code> 只是负责判断请求执行的状态，在异步请求中参与内容过多。</p><p>下面我们来看 <code>getResponseWithInterceptorChain()</code> 方法：</p><pre><code class="lang-Java">Response getResponseWithInterceptorChain() throws IOException {  // Build a full stack of interceptors.  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();  interceptors.addAll(client.interceptors()); // 加入用户自定义的拦截器  interceptors.add(retryAndFollowUpInterceptor); // 重试和重定向拦截器  interceptors.add(new BridgeInterceptor(client.cookieJar())); // 加入转化请求响应的拦截器  interceptors.add(new CacheInterceptor(client.internalCache())); // 加入缓存拦截器  interceptors.add(new ConnectInterceptor(client)); // 加入连接拦截器  if (!forWebSocket) {      interceptors.addAll(client.networkInterceptors()); // 加入用户自定义的网络拦截器  }  interceptors.add(new CallServerInterceptor(forWebSocket)); // 加入请求响应的拦截器  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,          originalRequest, this, eventListener, client.readTimeoutMillis());  // 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象  return chain.proceed(originalRequest);}</code></pre><p>我们都知道，拦截器是 OkHttp 的精髓。</p><p>1、<code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；<br>2、<code>RetryAndFollowUpInterceptor</code> 是用来重试和重定向的拦截器，在下面我们会讲到；<br>3、<code>BridgeInterceptor</code> 是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；<br>4、<code>CacheInterceptor</code> 是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；<br>5、<code>ConnectInterceptor</code> 用来建立连接的拦截器；<br>6、<code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ；<br>7、<code>CallServerInterceptor</code>是真正向服务器发出请求且得到响应的拦截器；</p><p>最后在聚合了这些拦截器后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器，利用的就是 <strong>责任链模式</strong> 。</p><font font size="3" color="#FF0000">下面介绍 OkHttp 中的 拦截器</font><p>拦截器 <code>Interceptor</code> 是 OkHttp 的核心，<strong>实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来</strong>，每一个功能都只是一个 <code>Interceptor</code>，它们再连接成一个 <code>Interceptor.Chain</code>，环环相扣，最终圆满完成一次网络请求。</p><div align="center"><img src="https://img.wshunli.com/Android/OkHttp/okhttp_interceptors.jpg" title="OkHttp 拦截器" alt="OkHttp 拦截器"></div><p>1、<code>RealInterceptorChain</code> 拦截器链</p><p>拦截器链 <code>RealInterceptorChain</code> 是真正把这些拦截器串起来的一个角色，调用 <code>proceed()</code> 方法</p><pre><code class="lang-Java">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,    RealConnection connection) throws IOException {  if (index &gt;= interceptors.size()) throw new AssertionError();  calls++;  // If we already have a stream, confirm that the incoming request will use it.  if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must retain the same host and port&quot;);  }  // If we already have a stream, confirm that this is the only call to chain.proceed().  if (this.httpCodec != null &amp;&amp; calls &gt; 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must call proceed() exactly once&quot;);  }  // Call the next interceptor in the chain.  // 得到下一次对应的 RealInterceptorChain  RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,      connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,      writeTimeout);  // 当前次数的 interceptor  Interceptor interceptor = interceptors.get(index);  // 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法  Response response = interceptor.intercept(next);  // Confirm that the next interceptor made its required call to chain.proceed().  // 确认下一次的 interceptor 调用过 chain.proceed()  if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptor        + &quot; must call proceed() exactly once&quot;);  }  // Confirm that the intercepted response isn&#39;t null.  if (response == null) {    throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);  }  if (response.body() == null) {    throw new IllegalStateException(        &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);  }  return response;}</code></pre><p>在代码中是一次次链式调用拦截器。</p><p>2、<code>RetryAndFollowUpInterceptor</code> 重试和重定向的拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request request = chain.request();  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Call call = realChain.call();  EventListener eventListener = realChain.eventListener();  StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),      createAddress(request.url()), call, eventListener, callStackTrace);  this.streamAllocation = streamAllocation;  int followUpCount = 0;  Response priorResponse = null;  while (true) {    // 如果取消，就释放资源    if (canceled) {      streamAllocation.release();      throw new IOException(&quot;Canceled&quot;);    }    Response response;    boolean releaseConnection = true;    try {      // 调用下一个拦截器      response = realChain.proceed(request, streamAllocation, null, null);      releaseConnection = false;    } catch (RouteException e) {      // The attempt to connect via a route failed. The request will not have been sent.      // 路由连接失败，请求将不会被发送      if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {        throw e.getFirstConnectException();      }      releaseConnection = false;      continue;    } catch (IOException e) {      // An attempt to communicate with a server failed. The request may have been sent.      // 服务器连接失败，请求可能已被发送      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);      if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;      releaseConnection = false;      continue;    } finally {      // We&#39;re throwing an unchecked exception. Release any resources.      // 抛出未检查的异常，释放资源      if (releaseConnection) {        streamAllocation.streamFailed(null);        streamAllocation.release();      }    }    // Attach the prior response if it exists. Such responses never have a body.    if (priorResponse != null) {      response = response.newBuilder()          .priorResponse(priorResponse.newBuilder()                  .body(null)                  .build())          .build();    }    // 如果不需要重定向，那么 followUp 为空，会根据响应码判断    Request followUp;    try {      followUp = followUpRequest(response, streamAllocation.route());    } catch (IOException e) {      streamAllocation.release();      throw e;    }    // 释放资源，返回 response    if (followUp == null) {      if (!forWebSocket) {        streamAllocation.release();      }      return response;    }    // 关闭 response 的 body    closeQuietly(response.body());    if (++followUpCount &gt; MAX_FOLLOW_UPS) {      streamAllocation.release();      throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);    }    if (followUp.body() instanceof UnrepeatableRequestBody) {      streamAllocation.release();      throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());    }    // response 和 followUp 比较是否为同一个连接    // 若为重定向就销毁旧连接，创建新连接    if (!sameConnection(response, followUp.url())) {      streamAllocation.release();      streamAllocation = new StreamAllocation(client.connectionPool(),          createAddress(followUp.url()), call, eventListener, callStackTrace);      this.streamAllocation = streamAllocation;    } else if (streamAllocation.codec() != null) {      throw new IllegalStateException(&quot;Closing the body of &quot; + response          + &quot; didn&#39;t close its backing stream. Bad interceptor?&quot;);    }    // 将重定向操作得到的新请求设置给 request    request = followUp;    priorResponse = response;  }}</code></pre><p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p><p>3、<code>BridgeInterceptor</code> 桥街和适配拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request userRequest = chain.request();  Request.Builder requestBuilder = userRequest.newBuilder();  // 将用户友好的 request 构造为发送给服务器的 request  RequestBody body = userRequest.body();  // 若有请求体，则构造  if (body != null) {    MediaType contentType = body.contentType();    if (contentType != null) {      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());    }    long contentLength = body.contentLength();    if (contentLength != -1) {      requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);    } else {      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);      requestBuilder.removeHeader(&quot;Content-Length&quot;);    }  }  if (userRequest.header(&quot;Host&quot;) == null) {    requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));  }  if (userRequest.header(&quot;Connection&quot;) == null) {    requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);  }  // If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing  // the transfer stream.  // 使用 gzip 压缩  boolean transparentGzip = false;  if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {    transparentGzip = true;    requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);  }  // 设置 cookie  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());  if (!cookies.isEmpty()) {    requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));  }  // 设置 UA  if (userRequest.header(&quot;User-Agent&quot;) == null) {    requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());  }  // 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse  Response networkResponse = chain.proceed(requestBuilder.build());  // 保存 networkResponse 的 cookie  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());  // 将 networkResponse 构造为对用户友好的 response  Response.Builder responseBuilder = networkResponse.newBuilder()      .request(userRequest);  // 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体  if (transparentGzip      &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))      &amp;&amp; HttpHeaders.hasBody(networkResponse)) {    GzipSource responseBody = new GzipSource(networkResponse.body().source());    Headers strippedHeaders = networkResponse.headers().newBuilder()        .removeAll(&quot;Content-Encoding&quot;)        .removeAll(&quot;Content-Length&quot;)        .build();    responseBuilder.headers(strippedHeaders);    String contentType = networkResponse.header(&quot;Content-Type&quot;);    responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));  }  return responseBuilder.build();}</code></pre><p>在 <code>BridgeInterceptor</code> 这一步，先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</p><p>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</p><p>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</p><p>4、<code>CacheInterceptor</code> 缓存拦截器</p><p>分析 <code>CacheInterceptor</code> 拦截器 <code>intercept()</code> 方法的源代码</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {    // 得到 request 对应缓存中的 response    Response cacheCandidate = cache != null            ? cache.get(chain.request())            : null;    // 获取当前时间，会和之前缓存的时间进行比较    long now = System.currentTimeMillis();    // 得到缓存策略    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();    Request networkRequest = strategy.networkRequest;    Response cacheResponse = strategy.cacheResponse;    // 追踪缓存，其实就是计数    if (cache != null) {        cache.trackResponse(strategy);    }    // 缓存不适用，关闭    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&#39;t applicable. Close it.    }    // If we&#39;re forbidden from using the network and the cache is insufficient, fail.    // 禁止网络并且没有缓存的话，返回失败    if (networkRequest == null &amp;&amp; cacheResponse == null) {        return new Response.Builder()                .request(chain.request())                .protocol(Protocol.HTTP_1_1)                .code(504)                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)                .body(Util.EMPTY_RESPONSE)                .sentRequestAtMillis(-1L)                .receivedResponseAtMillis(System.currentTimeMillis())                .build();    }    // If we don&#39;t need the network, we&#39;re done.    // 不用网络请求，返回缓存    if (networkRequest == null) {        return cacheResponse.newBuilder()                .cacheResponse(stripBody(cacheResponse))                .build();    }    Response networkResponse = null;    try {        // 交给下一个拦截器，返回 networkResponse        networkResponse = chain.proceed(networkRequest);    } finally {        // If we&#39;re crashing on I/O or otherwise, don&#39;t leak the cache body.        if (networkResponse == null &amp;&amp; cacheCandidate != null) {            closeQuietly(cacheCandidate.body());        }    }    // 如果我们同时有缓存和 networkResponse ，根据情况使用    if (cacheResponse != null) {        if (networkResponse.code() == HTTP_NOT_MODIFIED) {            Response response = cacheResponse.newBuilder()                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())                    .cacheResponse(stripBody(cacheResponse))                    .networkResponse(stripBody(networkResponse))                    .build();            networkResponse.body().close();            // 更新原来的缓存至最新            // Update the cache after combining headers but before stripping the            // Content-Encoding header (as performed by initContentStream()).            cache.trackConditionalCacheHit();            cache.update(cacheResponse, response);            return response;        } else {            closeQuietly(cacheResponse.body());        }    }    Response response = networkResponse.newBuilder()            .cacheResponse(stripBody(cacheResponse))            .networkResponse(stripBody(networkResponse))            .build();    // 保存之前未缓存的缓存    if (cache != null) {        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {            // Offer this request to the cache.            CacheRequest cacheRequest = cache.put(response);            return cacheWritingResponse(cacheRequest, response);        }        if (HttpMethod.invalidatesCache(networkRequest.method())) {            try {                cache.remove(networkRequest);            } catch (IOException ignored) {                // The cache cannot be written.            }        }    }    return response;}</code></pre><p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p><p>5、<code>ConnectInterceptor</code> 拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Request request = realChain.request();  StreamAllocation streamAllocation = realChain.streamAllocation();  // We need the network to satisfy this request. Possibly for validating a conditional GET.  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);  HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);  RealConnection connection = streamAllocation.connection();  return realChain.proceed(request, streamAllocation, httpCodec, connection);}</code></pre><p>实际上建立连接就是创建了一个 <code>HttpCodec</code> 对象，它是对 <code>HTTP</code> 协议操作的抽象，有两个实现：<code>Http1Codec</code> 和 <code>Http2Codec</code>，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。</p><p>6、<code>CallServerInterceptor</code> 拦截器，发送和接收数据</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  HttpCodec httpCodec = realChain.httpStream();  StreamAllocation streamAllocation = realChain.streamAllocation();  RealConnection connection = (RealConnection) realChain.connection();  Request request = realChain.request();      long sentRequestMillis = System.currentTimeMillis();  // 整理请求头并写入  httpCodec.writeRequestHeaders(request);  Response.Builder responseBuilder = null;  // 检查是否为有 body 的请求方法  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {      // If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100      // Continue&quot; response before transmitting the request body. If we don&#39;t get that, return what      // we did get (such as a 4xx response) without ever transmitting the request body.      // 如果有 Expect: 100-continue 在请求头中，那么要等服务器的响应      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {          httpCodec.flushRequest();          responseBuilder = httpCodec.readResponseHeaders(true);      }      if (responseBuilder == null) {          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.          // 写入请求体          Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);          request.body().writeTo(bufferedRequestBody);          bufferedRequestBody.close();      } else if (!connection.isMultiplexed()) {          // If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP/1 connection from          // being reused. Otherwise we&#39;re still obligated to transmit the request body to leave the          // connection in a consistent state.          streamAllocation.noNewStreams();      }  }  httpCodec.finishRequest();  // 得到响应头  if (responseBuilder == null) {      responseBuilder = httpCodec.readResponseHeaders(false);  }  // 构造 response  Response response = responseBuilder          .request(request)          .handshake(streamAllocation.connection().handshake())          .sentRequestAtMillis(sentRequestMillis)          .receivedResponseAtMillis(System.currentTimeMillis())          .build();  int code = response.code();  // 如果为 web socket 且状态码是 101 ，那么 body 为空  if (forWebSocket &amp;&amp; code == 101) {      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.      response = response.newBuilder()              .body(Util.EMPTY_RESPONSE)              .build();  } else {      // 读取 body      response = response.newBuilder()              .body(httpCodec.openResponseBody(response))              .build();  }  // 如果请求头中有 close 那么断开连接  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))          || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {      streamAllocation.noNewStreams();  }  // 抛出协议异常  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {      throw new ProtocolException(              &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());  }  return response;}</code></pre><p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>和同步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {    }});</code></pre><p>异步请求在 <code>Callback</code> 回调中获取响应，有 <code>onResponse()</code> 、 <code>onFailure()</code> 两个方法。</p><h3 id="发送异步网络请求"><a href="#发送异步网络请求" class="headerlink" title="发送异步网络请求"></a>发送异步网络请求</h3><p>前面三个步骤完全一致，我们从发送异步网络请求开始，异步请求是调用 <code>RealCall</code> 实例的 <code>enqueue()</code> 方法。。</p><pre><code class="lang-Java">// RealCall#enqueue()@Override public void enqueue(Callback responseCallback) {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  client.dispatcher().enqueue(new AsyncCall(responseCallback));}</code></pre><p>这里使用 <code>Dispatcher</code> 分发器我来处理请求。</p><pre><code class="lang-Java">// Dispatcher#enqueue()synchronized void enqueue(AsyncCall call) {  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {    runningAsyncCalls.add(call);    executorService().execute(call);  } else {    readyAsyncCalls.add(call);  }}</code></pre><p>实质上异步网络请求是在 <code>Dispatcher</code> 中做到任务调度。</p><font font size="3" color="#FF0000">下面介绍 OkHttp 中的 任务调度</font><p>我们来看 <code>Dispatcher</code> 类的源代码。</p><pre><code class="lang-Java">public final class Dispatcher {  private int maxRequests = 64;  private int maxRequestsPerHost = 5;  private @Nullable Runnable idleCallback;  /** Executes calls. Created lazily. */  // 线程池的实现  private @Nullable ExecutorService executorService;  /** Ready async calls in the order they&#39;ll be run. */  // 就绪等待网络请求的异步队列  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running asynchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的异步队列  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running synchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的同步队列  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();  public Dispatcher(ExecutorService executorService) {    this.executorService = executorService;  }  public Dispatcher() {  }  // 创建线程池  public synchronized ExecutorService executorService() {    if (executorService == null) {      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));    }    return executorService;  }  /* 省略部分无关代码*/  synchronized void enqueue(AsyncCall call) {    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {      runningAsyncCalls.add(call);      executorService().execute(call);    } else {      readyAsyncCalls.add(call);    }  }  /* 省略部分无关代码*/}</code></pre><p>异步请求是放在线程池中执行的，如果最大异步请求数小于 64 并且 单个 HOST 的异步请求数小于 5 ，将请求添加到 <code>runningAsyncCalls</code> 中，否则添加到 <code>readyAsyncCalls</code> 中。</p><p>我们来看添加进线程池的 <code>AsyncCall</code> 类，实际上 <code>AsyncCall</code> 是继承自 <code>NamedRunnable</code> 的 <code>RealCall</code> 内部类。<code>NamedRunnable</code> 是实现了 <code>Runnable</code> 接口的抽象类。</p><pre><code class="lang-Java">final class AsyncCall extends NamedRunnable {  private final Callback responseCallback;  AsyncCall(Callback responseCallback) {    super(&quot;OkHttp %s&quot;, redactedUrl());    this.responseCallback = responseCallback;  }  String host() {    return originalRequest.url().host();  }  Request request() {    return originalRequest;  }  RealCall get() {    return RealCall.this;  }  @Override protected void execute() {    boolean signalledCallback = false;    try {      // 和同步请求相同，调用拦截器，得到响应      Response response = getResponseWithInterceptorChain();      if (retryAndFollowUpInterceptor.isCanceled()) {        signalledCallback = true;        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));      } else {        signalledCallback = true;        responseCallback.onResponse(RealCall.this, response);      }    } catch (IOException e) {      if (signalledCallback) {        // Do not signal the callback twice!        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);      } else {        eventListener.callFailed(RealCall.this, e);        responseCallback.onFailure(RealCall.this, e);      }    } finally {      // 在 runningAsyncCalls 中移除      client.dispatcher().finished(this);    }  }}</code></pre><p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p><p>不同的是在得到 <code>Response</code> 后，进行结果的回调。</p><p>在 <code>AsyncCall</code> 的最后调用了 <code>Dispatcher</code> 的 <code>finished()</code> 方法。</p><pre><code class="lang-Java">// Dispatcher#finished()/** Used by {@code AsyncCall#run} to signal completion. */void finished(AsyncCall call) {  finished(runningAsyncCalls, call, true);}/** Used by {@code Call#execute} to signal completion. */void finished(RealCall call) {  finished(runningSyncCalls, call, false);}private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) {  int runningCallsCount;  Runnable idleCallback;  synchronized (this) {    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#39;t in-flight!&quot;);    // 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中    if (promoteCalls) promoteCalls();    runningCallsCount = runningCallsCount();    idleCallback = this.idleCallback;  }  if (runningCallsCount == 0 &amp;&amp; idleCallback != null) {    idleCallback.run();  }}</code></pre><p>这里所做的工作就是把执行过的 Call 移除，然后将 <code>readyAsyncCalls</code> 中的 Call 移动到 <code>runningAsyncCalls</code> 中并加入线程池中。</p><blockquote><p>基本上 OkHttp 的请求响应的流程就介绍完了，主要是关于 OkHttp 的 <strong>拦截器链</strong> 和 <strong>任务调度</strong> 原理。</p></blockquote><p>还有很多细节没有涉及，需要花费很大的精力，才能理解分析透彻，后面有机会再介绍。</p><blockquote><p>参考资料：<br>1、拆轮子系列：拆 OkHttp - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/07/11/Understand-OkHttp/</a><br>2、OkHttp源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="http://yuqirong.me/2017/07/25/OkHttp源码解析/" rel="external nofollow noopener noreferrer" target="_blank">http://yuqirong.me/2017/07/25/OkHttp源码解析/</a><br>3、OkHttp源码分析 - 掘金<br><a href="https://juejin.im/post/5af4482951882567286064e6" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5af4482951882567286064e6</a><br>4、okhttp源码分析（一）——基本流程（超详细） - 简书<br><a href="https://www.jianshu.com/p/37e26f4ea57b" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/37e26f4ea57b</a><br>5、OKHttp源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/03/12/android-okhttp/</a><br>6、OkHttp 源码解析（一）：基本流程 - Coding - SegmentFault 思否<br><a href="https://segmentfault.com/a/1190000012656606" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000012656606</a><br>7、【Android】OkHttp源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79175824" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79175824</a><br>8、深入浅出 OkHttp 源码 - DiyCode<br><a href="https://www.diycode.cc/topics/640" rel="external nofollow noopener noreferrer" target="_blank">https://www.diycode.cc/topics/640</a><br>9、Okhttp框架源码分析 - 简书<br><a href="https://www.jianshu.com/p/18a4861600d1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/18a4861600d1</a><br>10、OkHttp 3.7源码分析（一）——整体架构 - CSDN博客<br><a href="https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320</a><br>11、okhttp网络框架源码解析 - CSDN博客<br><a href="https://blog.csdn.net/fanguangjun123/article/details/78621585" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/fanguangjun123/article/details/78621585</a><br>12、OKHttp网络框架源码解析（一）okHttp框架同步异步请求流程和源码分析 - CSDN博客<br><a href="https://blog.csdn.net/qq_24675479/article/details/79483193" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_24675479/article/details/79483193</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 OkHttp 3.11.0 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。&lt;/p&gt;&lt;p&gt;只是停留在应用
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="OkHttp" scheme="https://www.wshunli.com/tags/OkHttp/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》编程题目 Java 实现（01-10）</title>
    <link href="https://www.wshunli.com/posts/25842bb5.html"/>
    <id>https://www.wshunli.com/posts/25842bb5.html</id>
    <published>2018-09-11T13:07:05.000Z</published>
    <updated>2019-08-14T18:34:57.854Z</updated>
    
    <content type="html"><![CDATA[<p>《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。</p><p>笔试中的重要性不必多说，面试官还总是喜欢让手写代码。</p><p>1、赋值运算函数</p><p>2、单例设计模式</p><p>在设计模式中有详细的介绍，这里不再赘述，请移步：</p><p><a href="https://www.wshunli.com/posts/d1c4534.html">https://www.wshunli.com/posts/d1c4534.html</a></p><p>3、二维数组中查找目标值</p><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>（1）直接暴力查找</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    for (int[] anArray : array) {        for (int anAnArray : anArray) {            if (anAnArray == target) return true;        }    }    return false;}</code></pre><p>（2）从右上角/左下角的元素出发</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    int row = array.length;    int col = array[0].length;    for (int i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0; ) {        int value = array[i][j];        if (value == target) return true;        if (value &lt; target) i++;        if (value &gt; target) j--;    }    return false;}</code></pre><p>4、替换字符串中的空格</p><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成 “%20” 。</p></blockquote><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;);}</code></pre><p>这个太偷懒了，不那么偷懒：</p><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    StringBuilder builder = new StringBuilder();    String string = str.toString();    for (int i = 0; i &lt; string.length(); i++) {        char charAt = string.charAt(i);        if (charAt == &#39; &#39;) {            builder.append(&quot;%20&quot;);        } else {            builder.append(charAt);        }    }    return builder.toString();}</code></pre><p>5、从尾到头打印链表</p><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList 。</p></blockquote><p>（1）借助堆栈的“后进先出”实现</p><pre><code class="lang-Java">/***    public class ListNode {*        int val;*        ListNode next = null;*        ListNode(int val) {*            this.val = val;*        }*    }*/public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    Stack&lt;Integer&gt; integers = new Stack&lt;&gt;();    while (listNode != null) {        integers.push(listNode.val);        listNode = listNode.next;    }    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (!integers.isEmpty()) {        arrayList.add(integers.pop());    }    return arrayList;}</code></pre><p>（2）借助递归实现</p><pre><code class="lang-Java">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    if (listNode != null) {        this.printListFromTailToHead(listNode.next);        arrayList.add(listNode.val);    }    return arrayList;}</code></pre><p>（3）使用 Collections 的 reverse 方法</p><pre><code class="lang-Java">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (listNode != null) {        arrayList.add(listNode.val);        listNode = listNode.next;    }    Collections.reverse(arrayList);    return arrayList;}</code></pre><p>6、由前序和中序遍历重建二叉树</p><p>7、用两个栈实现队列<br>8、求旋转数组的最小数字<br>9、斐波那契数列的第n项（青蛙跳台阶）<br>10、二进制中1的个数<br>11、数值的整数次方<br>12、打印1到最大的n位数<br>13、O(1)时间删除链表节点<br>14、使数组中的奇数位于偶数前面<br>15、找链表中倒数第K个节点<br>16、输出反转后的链表<br>17、合并两个有序链表<br>18、判断二叉树A中是否包含子树B<br>19、二叉树的镜像<br>20、顺时针打印矩阵<br>21、包含min函数的栈<br>22、判断一个栈是否是另一个栈的弹出序列<br>23、层序遍历二叉树<br>24、后序遍历二叉搜索树<br>25、二叉树中和为某值的路径<br>26、复杂链表的复制<br>27、二叉搜索树转换为双向链表<br>28、打印字符串中所有字符的排列<br>29、数组中出现次数超过一半的数字<br>30、找出最小的K个数<br>31、连续子数组的最大和<br>32、从1到整数n中1出现的次数<br>33、把数组中的数排成一个最小的数<br>34、求第N个丑数<br>35、第一个出现一次的字符<br>36、数组中逆序对的个数<br>37、两个链表的第一个公共节点<br>38、数字在排序数组中出现的次数<br>39、二叉树的深度<br>40、数组中只出现一次的两个数，而其他数都出现两次。<br>41、和为s的连续整数序列<br>42、翻转字符串<br>43、n个骰子的点数及出现的概率44. 扑克牌的顺子<br>44、圆圈中最后剩下的数<br>45、1+2+3+…+n的和<br>46、不用加减乘除做加法<br>47、不能被继承的类<br>48、字符串转换为整数<br>49、树中两个节点的最低公共祖先<br>50、找出重复的数<br>51、构建乘积数组<br>52、正则表达式匹配<br>53、表示数值的字符串<br>54、字符流中第一个不重复的字符<br>55、链表中环的入口节点<br>56、删除链表中重复的节点<br>57、二叉树的下一个节点<br>58、对称的二叉树<br>59、按之字形顺序打印二叉树<br>60、把二叉树打印成多行<br>61、序列化二叉树<br>62、二叉搜索树的第K个节点<br>63、数据流中的中位数<br>64、滑动窗口的最大值<br>65、矩阵中的路径<br>66、机器人的运动范围</p><blockquote><p>参考资料<br>1、剑指Offer<em>编程题</em>牛客网<br><a href="https://www.nowcoder.com/ta/coding-interviews" rel="external nofollow noopener noreferrer" target="_blank">https://www.nowcoder.com/ta/coding-interviews</a><br>2、【剑指offer】Java版代码（完整版） - CSDN博客<br><a href="https://blog.csdn.net/baiye_xing/article/details/78428561" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/baiye_xing/article/details/78428561</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。&lt;/p&gt;&lt;p&gt;笔试中的重要性不必多说，面试官还总是喜欢让手写代码。&lt;/p&gt;&lt;p&gt;1、赋值运算函数&lt;/p&gt;&lt;p&gt;2、单例设计模式&lt;/p&gt;&lt;p&gt;在设计模式中有详细的介绍，这里不再赘述，请移
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指Offer》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十四）观察者模式</title>
    <link href="https://www.wshunli.com/posts/58b1d741.html"/>
    <id>https://www.wshunli.com/posts/58b1d741.html</id>
    <published>2018-09-10T12:19:14.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/14.Observer.png" title="观察者模式" alt="观察者模式"></div><p>观察者模式所涉及的角色有：</p><p>(1) 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>(2) 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>(3) 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>(4) 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers(String newState) {        for (Observer observer : list) {            observer.update(newState);        }    }}</code></pre><p>2、具体主题角色类</p><pre><code class="lang-Java">public class ConcreteSubject extends Subject {    private String state;    public String getState() {        return state;    }    public void change(String newState) {        state = newState;        System.out.println(&quot;ConcreteSubject：&quot; + state);        this.nodifyObservers(state);//状态发生改变，通知各个观察者    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(String state);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    private String observerState;//观察者的状态    @Override    public void update(String state) {        /**         * 更新观察者的状态，使其与目标的状态保持一致         */        observerState = state;        System.out.println(&quot;ConcreteObserver：&quot; + observerState);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p>当主题对象的状态改变时，将通知所有观察者，观察者接收到主题对象的通知后，将可以进行其他操作，进行响应。</p><p><strong>推模型和拉模型</strong>：</p><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><p>（1）推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><p>（2）拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把 <strong>主题对象自身</strong> 通过 update() 方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><p>前面就是典型的推模型，下面介绍拉模型。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers() {        for (Observer observer : list) {            observer.update(this);        }    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(Subject subject);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    @Override    public void update(Subject subject) {        String state = ((ConcreteSubject) subject).getState();        System.out.println(&quot;ConcreteObserver：&quot; + state);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p><strong>两种模式的比较</strong>：</p><p>（1）推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</p><p>（2）推模型可能会使得观察者对象难以复用，因为观察者的 update() 方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的 update() 方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update() 方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p><p><strong>观察者模式的优缺点</strong>：</p><p>优点：观察者和被观察者是抽象耦合的；建立一套触发机制。<br>缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch14" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch14</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之观察者模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。&lt;/p&gt;&lt;h1 id=&quot;观
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十三）享元模式</title>
    <link href="https://www.wshunli.com/posts/180f2df5.html"/>
    <id>https://www.wshunli.com/posts/180f2df5.html</id>
    <published>2018-09-10T10:43:03.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/13.Flyweight.png" title="享元模式" alt="享元模式"></div><p>享元模式所涉及到的角色如下：</p><p>(1) 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p><p>(2) 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p><p>(3) 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p><p>1、创建一个接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、创建实现接口的实体类</p><pre><code class="lang-Java">public class Circle implements Shape {    private String color;    private int x;    private int y;    private int radius;    public Circle(String color) {        this.color = color;    }    public void setX(int x) {        this.x = x;    }    public void setY(int y) {        this.y = y;    }    public void setRadius(int radius) {        this.radius = radius;    }    @Override    public void draw() {        System.out.println(&quot;Circle: Draw() [Color : &quot; + color                + &quot;, x : &quot; + x + &quot;, y :&quot; + y + &quot;, radius :&quot; + radius);    }}</code></pre><p>3、创建一个工厂，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();    public static Shape getCircle(String color) {        Circle circle = (Circle) circleMap.get(color);        if (circle == null) {            circle = new Circle(color);            circleMap.put(color, circle);            System.out.println(&quot;Creating circle of color : &quot; + color);        }        return circle;    }}</code></pre><p>4、享元模式的使用</p><pre><code class="lang-Java">public class FlyweightPatternMain {    private static final String colors[] =            {&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot;};    public static void main(String[] args) {        for (int i = 0; i &lt; 20; ++i) {            Circle circle =                    (Circle) ShapeFactory.getCircle(getRandomColor());            circle.setX(getRandomX());            circle.setY(getRandomY());            circle.setRadius(100);            circle.draw();        }    }    private static String getRandomColor() {        return colors[(int) (Math.random() * colors.length)];    }    private static int getRandomX() {        return (int) (Math.random() * 100);    }    private static int getRandomY() {        return (int) (Math.random() * 100);    }}</code></pre><p><strong>享元模式的优缺点</strong>：</p><p>优点：系统有大量相似对象；需要缓冲池的场景。<br>缺点：注意划分外部状态和内部状态，否则可能会引起线程安全问题，这些类必须有一个工厂对象加以控制。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch13" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch13</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之享元模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html</a><br>2、设计模式读书笔记——享元模式 - chenssy - 博客园<br><a href="https://www.cnblogs.com/chenssy/p/3330555.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chenssy/p/3330555.html</a><br>3、享元模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/flyweight-pattern.html</a><br>4、JAVA设计模式-享元模式（Flyweight） - 简书<br><a href="https://www.jianshu.com/p/f88b903a166a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f88b903a166a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;&lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;he
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十二）桥接模式</title>
    <link href="https://www.wshunli.com/posts/f75ecf9a.html"/>
    <id>https://www.wshunli.com/posts/f75ecf9a.html</id>
    <published>2018-09-10T09:09:30.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/12.Bridge.png" title="桥接模式" alt="桥接模式"></div><p>桥接模式包含如下角色：</p><p>(1) Abstraction：抽象类，抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。Shape<br>(2) RefinedAbstraction：扩充抽象类，扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。Circle<br>(3) Implementor：实现类接口，定义实现部分的接口，这个接口不用和 Abstraction 里面的方法一致，通常是由 Implementor 接口提供基本的操作，而 Abstraction 里面定义的是基于这些基本操作的业务方法，也就是说 Abstraction 定义了基于这些基本操作的较高层次的操作。DrawAPI<br>(4) ConcreteImplementor：具体实现类，真正实现 Implementor 接口的对象。GreenCircle、RedCircle</p><p>1、创建桥接实现接口</p><pre><code class="lang-Java">public interface DrawAPI {    void drawCircle(int radius, int x, int y);}</code></pre><p>2、创建实现了 DrawAPI 接口的实体桥接实现类</p><pre><code class="lang-Java">public class GreenCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}public class RedCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}</code></pre><p>3、使用 DrawAPI 接口创建抽象类 Shape</p><pre><code class="lang-Java">public abstract class Shape {    protected DrawAPI drawAPI;    protected Shape(DrawAPI drawAPI) {        this.drawAPI = drawAPI;    }    public abstract void draw();}</code></pre><p>4、创建实现了 Shape 接口的实体类</p><pre><code class="lang-Java">public class Circle extends Shape {    private int x, y, radius;    public Circle(DrawAPI drawAPI, int x, int y, int radius) {        super(drawAPI);        this.x = x;        this.y = y;        this.radius = radius;    }    @Override    public void draw() {        drawAPI.drawCircle(radius, x, y);    }}</code></pre><p>5、使用 Shape 和 DrawAPI 类画出不同颜色的圆</p><pre><code class="lang-Java">public class BridgePatternMain {    public static void main(String[] args) {        Shape redCircle = new Circle(new RedCircle(), 100, 100, 10);        Shape greenCircle = new Circle(new GreenCircle(), 100, 100, 10);        redCircle.draw();        greenCircle.draw();    }}</code></pre><p><strong>桥接模式的优缺点</strong>：</p><p>优点：抽象和实现的分离；优秀的扩展能力；实现细节对客户透明。<br>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch12" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch12</a></p><blockquote><p>参考资料<br>1、Java设计模式之十五（桥接模式） - CSDN博客<br><a href="https://blog.csdn.net/shaopeng5211/article/details/8827507" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/shaopeng5211/article/details/8827507</a><br>2、JAVA设计模式之 桥接模式【Bridge Pattern】 - CSDN博客<br><a href="https://blog.csdn.net/janice0529/article/details/44102637" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/janice0529/article/details/44102637</a><br>3、java中的桥接模式 - 简书<br><a href="https://www.jianshu.com/p/c71562c98258" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c71562c98258</a><br>4、讲故事，学（Java）设计模式—桥接模式 - ImportNew<br><a href="http://www.importnew.com/6857.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.importnew.com/6857.html</a><br>5、桥接模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/bridge-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/bridge-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。&lt;/p&gt;&lt;h1 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十一）组合模式</title>
    <link href="https://www.wshunli.com/posts/fb6e1df3.html"/>
    <id>https://www.wshunli.com/posts/fb6e1df3.html</id>
    <published>2018-09-10T08:40:17.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/11.Composite.png" title="组合模式" alt="组合模式"></div><p>组合模式的包含角色：</p><p>(1) Component 抽象构件角色，定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>(2) Leaf 叶子构件，叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>(3) Composite 树枝构件，树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</p><p>1、抽象构件角色</p><pre><code class="lang-Java">public abstract class Component {    public void operation() {        System.out.println(&quot;Component.operation()&quot;);    }}</code></pre><p>2、树枝构件</p><pre><code class="lang-Java">public class Composite extends Component {    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;&gt;();    public void add(Component component) {        componentArrayList.add(component);    }    public void remove(Component component) {        componentArrayList.remove(component);    }    public ArrayList&lt;Component&gt; getChildren() {        return this.componentArrayList;    }}</code></pre><p>3、树叶构件</p><pre><code class="lang-Java">public class Leaf extends Component {    @Override    public void operation() {        System.out.println(&quot;Leaf.operation()&quot;);    }}</code></pre><p>4、组合模式的使用</p><pre><code class="lang-Java">public class CompositeMain {    public static void main(String[] args) {        Composite root = new Composite();        root.operation();        Composite branch = new Composite();        root.add(branch);        Leaf leaf1 = new Leaf();        Leaf leaf2 = new Leaf();        branch.add(leaf1);        branch.add(leaf2);        display(root);    }    public static void display(Composite root) {        for (Component component : root.getChildren()) {            if (component instanceof Leaf) {                component.operation();            } else {                display((Composite) component);            }        }    }}</code></pre><p><strong>组合模式的优缺点</strong>：</p><p>优点：高层模块调用简单；节点自由增加。<br>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch11" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch11</a></p><blockquote><p>参考资料<br>1、JAVA设计模式十七—Composite(组合模式) - CSDN博客<br><a href="https://blog.csdn.net/hfmbook/article/details/7693069" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hfmbook/article/details/7693069</a><br>2、Java设计模式—组合模式 - CSDN博客<br><a href="https://blog.csdn.net/qq_25827845/article/details/52496522" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_25827845/article/details/52496522</a><br>3、组合模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/composite-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/composite-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。&lt;/p&gt;&lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十）代理模式</title>
    <link href="https://www.wshunli.com/posts/b4b3761.html"/>
    <id>https://www.wshunli.com/posts/b4b3761.html</id>
    <published>2018-09-10T08:12:52.000Z</published>
    <updated>2019-08-14T18:34:57.846Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p>代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/10.Proxy.png" title="代理模式" alt="代理模式"></div><p>代理模式一般涉及到的角色有：</p><p>(1) 抽象角色：声明真实对象和代理对象的共同接口；<br>(2) 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装；<br>(3) 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p><p>1、抽象对象角色</p><pre><code class="lang-Java">public abstract class AbstractObject {    public abstract void operation();}</code></pre><p>2、目标对象角色</p><pre><code class="lang-Java">public class RealObject extends AbstractObject {    @Override    public void operation() {        System.out.println(&quot;RealObject.operation()&quot;);    }}</code></pre><p>3、代理对象角色</p><pre><code class="lang-Java">public class ProxyObject extends AbstractObject {    RealObject realObject = new RealObject();    @Override    public void operation() {        //调用目标对象之前可以做相关操作        System.out.println(&quot;before&quot;);        realObject.operation();        //调用目标对象之后可以做相关操作        System.out.println(&quot;after&quot;);    }}</code></pre><p>4、代理模式的使用</p><pre><code class="lang-Java">public class ProxyMain {    public static void main(String[] args) {        AbstractObject object = new ProxyObject();        object.operation();    }}</code></pre><p><strong>代理模式的优缺点</strong>：</p><p>优点：给对象增加了本地化的扩展性，增加了存取操作控制。<br>缺点：会产生多余的代理类。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch10" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch10</a></p><blockquote><p>参考资料<br>1、Java设计模式之代理模式(Proxy) - CSDN博客<br><a href="https://blog.csdn.net/liangbinny/article/details/18656791" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/liangbinny/article/details/18656791</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。&lt;/p&gt;&lt;p&gt;代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。&lt;/p&gt;&lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
</feed>
