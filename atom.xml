<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2017-10-29T14:18:10.318Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>CirGIS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（一）</title>
    <link href="http://www.wshunli.com/2017/10/29/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/</id>
    <published>2017-10-29T09:51:02.000Z</published>
    <updated>2017-10-29T14:18:10.318Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 22:19:39 GMT+0800 (中国标准时间) --><p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p>从今天开始阅读 《JavaScript高级程序设计》（第三版）。</p><p>按照图灵社区推荐的阅读规划：</p><pre><code class="HTML"> 1-7 章 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。 8-14章 熟悉JavaScript运行的环境，深刻理解DOM，熟习DOM提供给JS的原生API。15-16章 学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。  17 章 学习在浏览器中进行实际开发时的错误调试技巧。18-21章 学习JS对各数据载体的操作方法（如JSON、XML），学会Ajax的使用方法。22-25章 学习JS的一些高级技巧及实践方案。</code></pre><h1 id="第一章-JavaScript-简介"><a href="#第一章-JavaScript-简介" class="headerlink" title="第一章 JavaScript 简介"></a>第一章 JavaScript 简介</h1><p>一个完整的 JavaScript 实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。</p><p>ECMAScript：提供核心语言功能；<br>DOM：提供访问和操作网页内容的方法和接口；<br>BOM：提供与浏览器交互的方法和接口。</p><h1 id="第二章-在-HTML-中使用-JavaScript"><a href="#第二章-在-HTML-中使用-JavaScript" class="headerlink" title="第二章 在 HTML 中使用 JavaScript"></a>第二章 在 HTML 中使用 JavaScript</h1><p>HTML 4.0 为 <code>&lt;script&gt;</code> 元素定义了6个属性：async、charset、defer、language（废弃）、src、type 。</p><p>在不存在 defer 和 async 属性时，浏览器都会按照不同<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它们依次进行解析。</p><p>标签的位置：为了避免浏览器在呈现页面时出现明显的延迟，现代Web应用程序一般都把全部 JavaScript 引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p><p>延迟脚本：defer 属性表明脚本在执行时不会影响页面的构造，告诉浏览器立即下载文件，但脚本会被延迟到整个页面都解析完毕后再运行；只适用于外部脚本文件。</p><pre><code class="JavaScript">&lt;script defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></pre><p>异步脚本：async 属性表示当前脚本不必等待其他脚本，也不必阻塞文档呈现，告诉浏览器立即下载文件，且并不保证标记为 async 的脚本按照他们的先后顺序执行；只适用于外部脚本文件。</p><pre><code class="JavaScript">&lt;script async src=&quot;example1.js&quot;&gt;&lt;/script&gt;&lt;script async src=&quot;example2.js&quot;&gt;&lt;/script&gt;</code></pre><p>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p><blockquote><p>页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载；而 load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded)。</p></blockquote><h1 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h1><p>本章内容：语法、数据类型、控制流语句、函数。<br>其中大部分内容和 Java 类似，不再记笔记。</p><p>ECMAScript 5 引入严格模式。<br>在整个脚本中启用严格模式，在顶部添加 <code>&quot;use strict&quot;;</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 22:19:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://www.wshunli.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript DOM 编程艺术》读书笔记</title>
    <link href="http://www.wshunli.com/2017/10/22/%E3%80%8AJavaScript-DOM-%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.wshunli.com/2017/10/22/《JavaScript-DOM-编程艺术》读书笔记/</id>
    <published>2017-10-22T01:58:31.000Z</published>
    <updated>2017-10-29T09:52:18.343Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p>《JavaScript DOM 编程艺术》读书笔记<br><a id="more"></a></p><p>本科的时候也有看前端的内容但是没有系统地学习，现在有 WebGIS 相关的项目，并且发现 Android 开发也发生了一些变化: 很多应用不再单单是一个简单的原生 Android 应用，用到了跨平台技术，比如说 React Native 、 Ionic 等等，这都需要 Javascript 基础。所以打算系统地学习下 Javascript 。</p><p>其实有这个想法很久了，包括暑假来到也有意学习前端技术，最开始是在慕课网看 <a href="http://www.imooc.com/course/list?c=fe&amp;sort=pop" rel="external nofollow noopener noreferrer" target="_blank">前端基础</a> 相关视频，然后也简单地在 <a href="http://www.runoob.com/html/html-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">菜鸟教程</a> 看了相关文字内容，最后在廖雪峰的网站看 <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" rel="external nofollow noopener noreferrer" target="_blank">JavaScript全栈教程</a>，这部分对后来 Node.js 后端开发很有帮助。</p><p>但是现在发现 Javascript 水品还不行，没有接近实战的水平，所以打算再系统学习下。<br>按照知乎 <a href="https://www.zhihu.com/question/19713563" rel="external nofollow noopener noreferrer" target="_blank">如何循序渐进、有效地学习JavaScript？</a> 问题的回答，决定先学习 《JavaScript DOM 编程艺术》（第二版），后面再学习 《JavaScript高级程序设计》，最后再刷 <a href="http://es6.ruanyifeng.com/" rel="external nofollow noopener noreferrer" target="_blank">《ECMAScript 6 入门》</a> 学习 ES6 。</p><h1 id="第1章-JavaScript-简史"><a href="#第1章-JavaScript-简史" class="headerlink" title="第1章 JavaScript 简史"></a>第1章 JavaScript 简史</h1><p>本章主要介绍了 JavaScript 的起源、浏览器之间的战争、DOM 的演变史。</p><p>DOM (Document Object Model,文档对象模型) 是一套对文档的内容进行抽象和概念化的方法。<br>感觉和类的说法很类似。</p><h1 id="第2章-JavaScript-语法"><a href="#第2章-JavaScript-语法" class="headerlink" title="第2章 JavaScript 语法"></a>第2章 JavaScript 语法</h1><p>程序设计语言分为解释型和编译型两大类。Java或者C++等语言需要一个编译器，把用Java等高级语言编写出来的源代码翻译为计算机能直接执行的文件。<br>解释型语言不需要编译器–它们仅需要解释器，对于JavaScript而言，Web浏览器负责完成有关解释和执行工作。<br>浏览器的JavaScript解释器将直接读取源代码并执行，相关错误也只能在此时才能发现。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JavaScript 语法基本上和 Java 或者 C++ 类似，下面主要介绍不同点。</p><p>JavaScript 是一种弱类型语言，变量使用前不需要进行类型声明，但不建议这样做。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript 中的数据类型主要包括 字符串、数值、布尔值 三种。</p><ul><li>字符串：单引号双引号都可以，最好根据字符内容选择。</li><li>数值：不单单是整数，允许任意位小数。</li><li>布尔值：true 或 false 。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JavaScript 数组声明不必指出数组长度：</p><pre><code class="JavaScript">var car = Array(5);var car = Array();var car = [];</code></pre><p>声明数组的同时也可以进行填充（向数组添加元素）：</p><pre><code class="JavaScript">var cars = new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);var cars = [&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];</code></pre><p>数组元素类型不必相同，甚至可以是数组或者对象：</p><pre><code class="JavaScript">var cars = new Array(&quot;Saab&quot;,2017,true);var beatles = [];beatles[0] = cars;// beatles[0][1] 的值为 2017 。</code></pre><h3 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h3><p>对象的声明使用 Object 关键字：</p><pre><code class="JavaScript">var car = new Object();var car = {};var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};</code></pre><p>对象属性取值赋值方法：</p><pre><code class="JavaScript">var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};person.lastname = &quot;Wang&quot;;var name = person.lastname;var name = person[&quot;lastname&quot;];</code></pre><h2 id="算数操作符、条件语句、循环语句"><a href="#算数操作符、条件语句、循环语句" class="headerlink" title="算数操作符、条件语句、循环语句"></a>算数操作符、条件语句、循环语句</h2><p>和 Java、C++ 基本一致，不再赘述。</p><p>比较操作符不太一样:<br><strong>==</strong> : 表示类型转换后值是否相等；<br><strong>===</strong> ：严格相等，类型必须相同。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数声明及调用方法：</p><pre><code class="JavaScript">function myFunction(a, b) {    return a * b;}// 调用函数myFunction(2,5);</code></pre><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>全局变量：可以在脚本的任意位置引用，包括函数内部。<br>局部变量：在函数内部声明，只在函数内部有效。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是自包含的数据集合，包含在对象里的数据可通过 属性（property） 和 方法（method） 访问。</p><ul><li>属性是隶属于某个特定对象的变量</li><li>方法是只有某个特定对象才能调用的函数</li></ul><p>对象分类：</p><ul><li>自定义对象：利用 JavaScript 创建的自己的对象；</li><li>内建对象：JavaScript提供的一系列预先定义好的对象。数组也可以看做是 JavaScript 的内建对象的一种。常见的还有Data对象；</li><li>宿主对象：由浏览器提供的预定义对象。常见的有 windows，document 等。</li></ul><h1 id="第3章-DOM"><a href="#第3章-DOM" class="headerlink" title="第3章 DOM"></a>第3章 DOM</h1><p>DOM 三个字母的具体含义:<br>D 是基础，没有文档（Document）DOM 也就无从谈起；<br>O 是对象（Object），JavaScript 本身就可以看做是由对象构成的语言，其重要性不言而喻；<br>M 是模型（Model），其含义是某种事物的表现形式。<br>具体的说 DOM 把文档表示成了一颗家谱树（DOM 使用 parent、child，sibling 等记号来表明家庭成员之间的关系。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>DOM 由许多不同的节点（node）组成，节点可分为三类：<br>元素节点：DOM 的原子是元素节点，可以包含其他元素。<br>文本节点：元素节点的内容。<br>属性节点：元素节点的描述。</p><pre><code class="JavaScript">&lt;p title=&quot;Paragraph&quot;&gt;This is a paragraph.&lt;/p&gt;/*** 元素节点：p* 文本节点：This is a paragraph.* 属性节点：title=&quot;Paragraph&quot;*/</code></pre><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>有三种方法可以获取元素节点，分别通过 id、标签名、class 。</p><pre><code class="JavaScript">// document 特有函数，返回一个元素var x = document.getElementById(&quot;intro&quot;);// getElementsByTagName、getElementsByClassName 返回元素数组var y = document.getElementsByTagName(&quot;p&quot;);var y = x.getElementsByTagName(&quot;p&quot;);// 允许使用通配符var y = x.getElementsByTagName(&quot;*&quot;);var z = document.getElementsByClassName(&quot;intro&quot;);var z = x.getElementsByClassName(&quot;intro&quot;);// 允许查找带有多个类名的元素，并且类名顺序不重要var z = x.getElementsByClassName(&quot;import intro&quot;);</code></pre><h2 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h2><p>获取和设置属性的方法如下：<br>getAttribute()：该方法只能通过元素节点对象调用；<br>setAttribute():该方法允许我们对属性节点的值做出修改。</p><pre><code class="JavaScript">var img = document.getElementById(&quot;image&quot;)；img.getAttribute(&quot;src&quot;);img.src;img.setAttribute(&quot;src&quot;,&quot;landscape.jpg&quot;);img.src = &quot;landscape.jpg&quot;;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;</code></pre><p>通过浏览器查看源代码，其属性并不会改变，也就是说 setAttribute 做出的修改不会反映到文档本身的源码里。这种“表里不一”的的现象源自 DOM 的工作模式：<br>先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。</p><h1 id="第4章-案例研究：JavaScript图片库"><a href="#第4章-案例研究：JavaScript图片库" class="headerlink" title="第4章 案例研究：JavaScript图片库"></a>第4章 案例研究：JavaScript图片库</h1><h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>事件处理函数的作用是，在特定事件发生时调用特定的代码。</p><pre><code class="HTML"> &lt;a href=&quot;images/fireworks.jpg&quot; title=&quot;A fireworks display&quot; onclick=&quot;showPic(this); return false;&quot;&gt;Fireworks&lt;/a&gt;</code></pre><p>事件处理函数的工作机制：在给某元素添加事件处理函数后，一旦事件发生相应的 JavaScript 代码就会执行。<br>被调用的 JavaScript 代码可以返回一个值，这个值将被传递至事件处理函数。</p><p>例如：我们给某链接添加一个 onclick 事件处理函数，并把这个事件处理函数所触发的 JavaScript 代码返回 true 或 false 。<br>这样一来，当这个链接被点击时，JavaScript 代码返回值是 true ，onclick 事件处理函数就认为 这个链接被点击了；反之，认为没有被点击。</p><p>所以在 onclick 事件处理函数所触发的 JavaScript 代码里增加一条 <code>return false;</code> 语句，屏蔽掉链接的默认行为。</p><h2 id="对函数进行拓展"><a href="#对函数进行拓展" class="headerlink" title="对函数进行拓展"></a>对函数进行拓展</h2><h3 id="childNodes-属性"><a href="#childNodes-属性" class="headerlink" title="childNodes 属性"></a>childNodes 属性</h3><p>childNodes 属性可以获取任一元素的所有子元素。</p><pre><code class="JavaScript">var body_element = document.getElementById(&quot;body&quot;)[0];// 得到 body 的所有子元素、数组body_element.childNodes;</code></pre><h3 id="nodeType-属性"><a href="#nodeType-属性" class="headerlink" title="nodeType 属性"></a>nodeType 属性</h3><p>childNodes 属性返回的数组包括所有类型的节点，而不仅仅是元素节点。<br>事实上，文档里的每样东西都是一个节点，设置连空格和换行符都被解释为节点。</p><p>可通过节点的 nodeType 属性区分不同的节点。</p><p><code>node.nodeType</code></p><p>返回值是一个数字。</p><p>nodeType 共有 12 种取值，其中仅 3 种具有实用价值。</p><p>元素节点：1.<br>属性节点：2.<br>文本节点：2.</p><h3 id="nodeValue-属性"><a href="#nodeValue-属性" class="headerlink" title="nodeValue 属性"></a>nodeValue 属性</h3><p>若改变 文本节点 的值，可通过 DOM 提供的 nodeValue 属性。</p><p><code>node.nodeValue</code></p><p>注意：对于元素节点而言，<code>element.nodValue</code> 得到的值并不是元素的文本值。</p><p>正确的做法的先得到元素节点的文本节点，再取 nodeValue 属性：</p><p><code>element.childNodes[0].nodeValue</code></p><h3 id="firstChild-和-lastChild-属性"><a href="#firstChild-和-lastChild-属性" class="headerlink" title="firstChild 和 lastChild 属性"></a>firstChild 和 lastChild 属性</h3><p>firstChild：元素的第一个子元素。<br>lastChild：元素的最后一个元素。</p><pre><code class="JavaScript">function showPic(whichPic) {    var source = whichPic.getAttribute(&quot;href&quot;);//获取资源路径    var placeholder = document.getElementById(&quot;placeholder&quot;);    placeholder.setAttribute(&quot;src&quot;,source);    var text = whichPic.getAttribute(&quot;title&quot;);//获取内容    var description = document.getElementById(&quot;description&quot;);    description.firstChild.nodeValue = text;}</code></pre><h1 id="第5章-最佳实践"><a href="#第5章-最佳实践" class="headerlink" title="第5章 最佳实践"></a>第5章 最佳实践</h1><p>1、在使用任何一句JavaScript代码时，都应该想想，对这个网页是否有用；<br>2、平稳退化（graceful degradation)：如果正确使用了 JavaScript 脚本，可以让访问者在他们的浏览器不支持 JavaScript 的情况下仍能顺利地浏览你网站。<br>虽然某些功能无法使用，但是最基本的操作仍能顺利完成；<br>3、渐进加强：用额外的信息层去包裹原始数据；使 CSS 代码负责提供关于“表示”的信息，JavaScript 代码负责提供关于“行为”的信息。<br>4、分离 JavaScript：在 HTML 文档中使用诸如 onclick 之类的属性也是一种没有效率又容易引发问题的做法。<br>如果利用像 CSS 中的 class 和 id 属性那样，把JavaScript 代码调用行为与 HTML 文档内容和结构分离，网页就会健壮不少。<br>5、向后兼容：对象检测：检测浏览器对 JavaScript 的支持程度。<br>用一个 if 语句的条件表达式看求值结果是 true 还是 false 来采取不同的行动。<br>如在代码前加上 <code>if(!getElementById) return false</code>;<br>6、性能考虑：<br>尽量少访问DOM和尽量减少标记，不管什么时候只要是查询DOM中的某些元素，浏览器就会搜索整个DOM树，从中查找可能匹配的元素。<br>在多个函数都会取得一组类似元素的情况下，可以考虑重新构建代码，把搜索结果保存在一个全局变量里，或者把一组元素以参数形式传递给函数。<br>减少标记数量的目的在于，过多的不必要的元素只会增加DOM树的规模。<br>7、合并和放置脚本：减少请求数量是在性能优化时首先要考虑的；<br>把所以的<code>&lt;script&gt;</code>标签都放在文档的末尾，<code>&lt;/body&gt;</code>标记之前，就可以让页面变得更快。<br>8、压缩脚本：指的是把脚本文件中的不必要的字节，比如空格和注释，统统删除，从而达到“压缩”文件的目的；<br>多数情况下应该有两个版本，一个是工作副本，可以修改代码并添加注释，另一个是精简副本，用于放在站点上，通常在精简副本的文件名上加上 min 字样。</p><h1 id="第6章-案例研究：图片库改进版"><a href="#第6章-案例研究：图片库改进版" class="headerlink" title="第6章 案例研究：图片库改进版"></a>第6章 案例研究：图片库改进版</h1><p>本章主要是第5章内容在 图片库 上的实践。</p><p>共享onload事件：</p><p>假如有两个函数 firstFunction 和 secondFunction 需要在页面加载时执行：</p><pre><code class="JavaScript">window.onload = firstFunction;window.onload = secondFunction;</code></pre><p>这样做的话实际上只有后一个可以执行。</p><pre><code class="JavaScript">window.onload = function(){　　firstFunction();　　secondFunction();}</code></pre><p>这样做创建了一个匿名函数，在需要绑定的函数不是很多的场合的确很实用.</p><p>最佳解决方案,使用 addLoadEvent 函数。<br>这个方案需要额外添加一些代码，但一旦有了这些代码，绑定函数到 onload 就很方便。</p><pre><code class="JavaScript">function addLoadEvent(func){   //将现有的 window.onload 处理函数保存到 oldonload　　var oldonload = window.onload;    //如果现有的 window.onload 上没有处理函数，将 func 添加给它　　if(typeof oldonload != &#39;function&#39;)　　{　　　　window.onload = func;　　}　　else{　　　　window.onload function()　　　　{　　　　　　oldload();　　　　　　func();　　　　}　　}}</code></pre><h1 id="第7章-动态创建标记"><a href="#第7章-动态创建标记" class="headerlink" title="第7章 动态创建标记"></a>第7章 动态创建标记</h1><p>JavaScript 可以通过创建新元素和修改现有元素改变网页的结构。</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><h3 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h3><p>document 的 write() 方法可以方便快速地将字符串插入到文档内。</p><pre><code class="JavaScript">&lt;body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    document.write(&quot;&lt;p&gt;This is inserted.&lt;/p&gt;&quot;);  &lt;/script&gt;&lt;/body&gt;</code></pre><blockquote><p>缺点就是违背了”行为与表现分离的原则”,<br>即使把这句语句挪到外部，还是需要在<code>&lt;body&gt;</code>里边添加<code>&lt;script&gt;</code>标签才可以调用。</p></blockquote><h3 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h3><p>innerHTML 属性可以用来读写某给定元素里地 HTML 元素。</p><pre><code class="JavaScript">&lt;body&gt;  &lt;div id=&quot;testdiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;window.onload = function(){  var testdiv = document.getElementById(&quot;testdiv&quot;);  testdiv.innerHTML=&quot;&lt;p&gt;I inserted &lt;em&gt;this&lt;/em&gt; content.&lt;/p&gt;&quot;;}</code></pre><p>利用此技术无法区分“插入一段内容”还是“替换一段内容”。</p><h2 id="DOM-方法"><a href="#DOM-方法" class="headerlink" title="DOM 方法"></a>DOM 方法</h2><h3 id="createElement-方法"><a href="#createElement-方法" class="headerlink" title="createElement 方法"></a>createElement 方法</h3><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);</code></pre><p>创建元素节点，只创建会出现一个文档碎片（document fragment）。<br>本身并不影响页面表现，它是游荡在JavaScript世界里的一个孤儿。<br>但是它已经有 nodeType 和 nodeName 属性。</p><h3 id="appendChild-方法"><a href="#appendChild-方法" class="headerlink" title="appendChild 方法"></a>appendChild 方法</h3><p>把新创建的节点插入文档的节点树最简单方法是：让其成为某个现有节点的一个子节点。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);</code></pre><h3 id="createTextNode-方法"><a href="#createTextNode-方法" class="headerlink" title="createTextNode 方法"></a>createTextNode 方法</h3><p>创建文本节点填充元素节点的内容。<br>把文本节点插入为元素节点的子节点。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);var txt = document.createTextNode(&quot;Hello World&quot;);para.appendChild(txt);</code></pre><p>改变顺序，二者结果相同。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var txt = document.createTextNode(&quot;Hello World&quot;);para.appendChild(txt);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);</code></pre><h2 id="重回图片库"><a href="#重回图片库" class="headerlink" title="重回图片库"></a>重回图片库</h2><h3 id="在已有元素前插入元素"><a href="#在已有元素前插入元素" class="headerlink" title="在已有元素前插入元素"></a>在已有元素前插入元素</h3><p>DOM 提供了 insertBefore() 方法，把一个元素插入到现有元素之前。</p><p><code>parentElement.insertBefore(newElement,targetElement);</code></p><p>其中：<br>parentElement：目标元素的父元素，<br>newElement：想插入的元素，<br>targetElement：想插入哪个元素之前。</p><pre><code class="JavaScript">var gallery = document.getElementById(&quot;imagegallery&quot;);gallery.parentNode.insertBefore(placeholder,gallery);</code></pre><h3 id="在已有元素后插入元素"><a href="#在已有元素后插入元素" class="headerlink" title="在已有元素后插入元素"></a>在已有元素后插入元素</h3><p>DOM 并没有提供了 insertAfter() 方法，下面编写：</p><pre><code class="JavaScript">function insertAfter (newElement,targetElement){  var parent = targetElement.parentNode;  if(parent.lastChild == targetElement){    parent.appendChild(newElement);  }else{    parent.insertBefore(newElement,targetElement.nextSibling);  }}var gallery = document.getElementById(&quot;imagegallery&quot;);insertAfter(placeholder,gallery);</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax 可以做到只更新页面中的一小部分，其它内容不用重新加载。<br>Ajax 的主要优势是对页面的请求以异步方式发送到服务器。</p><h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>Ajax 的核心是 XMLHttpRequest 对象，XMLHttpRequest 充当浏览器脚本与服务器之间的中间人的角色。<br>JavaScript 可以通过这个对象自己发送请求，同时自己处理响应。</p><pre><code class="JavaScript">function getnewContent (){  var request = new XMLHttpRequest();  if(request){    request.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);    request.onreadystatechange = function(){      if(request.readyState == 4){        var para = document.createElement(&quot;p&quot;);        var txt = document.createTextNode(request.responseText);        para.appendChild(txt);        var testdiv = document.getElementById(&quot;testdiv&quot;);        testdiv.appendChild(para);      }    };    request.send(null);  }}</code></pre><p>其中 readyState 属性的值，有5个可能值：<br>0 表示未初始化<br>1 表示正在加载<br>2 表示加载完毕<br>3 表示正在交互<br>4 表示完成</p><p>访问服务器返回的数据要通过两个属性完成。<br>responseText：保存文本字符串形式的数据。<br>responseXML：保存 Content-Type 头部指定为 “text/xml” 的数据。</p><p>注意 异步请求，脚本在发送 XMLHttpRequest 请求之后仍然会继续执行，不会等待响应返回。</p><h3 id="HIjax"><a href="#HIjax" class="headerlink" title="HIjax"></a>HIjax</h3><p>HIjax 意思是渐进增强地使用 Ajax 。</p><h1 id="第8章-充实文档内容"><a href="#第8章-充实文档内容" class="headerlink" title="第8章 充实文档内容"></a>第8章 充实文档内容</h1><p>JavaScript 脚本只应该用来充实文档内容，要避免使用 DOM 技术来创建核心内容。</p><pre><code class="JavaScript">function displayAbbreviations() {  if (!document.getElementsByTagName || !document.createElement || !document.createTextNode) return false;// 得到所有链接  var abbreviations = document.getElementsByTagName(&quot;abbr&quot;);  if (abbreviations.length &lt; 1) return false;  var defs = new Array();// 遍历链接  for (var i=0; i&lt;abbreviations.length; i++) {    var current_abbr = abbreviations[i];    if (current_abbr.childNodes.length &lt; 1) continue;    var definition = current_abbr.getAttribute(&quot;title&quot;);    var key = current_abbr.lastChild.nodeValue;    defs[key] = definition;  }// 创建列表  var dlist = document.createElement(&quot;dl&quot;);// 遍历访问键  for (key in defs) {    var definition = defs[key];    var dtitle = document.createElement(&quot;dt&quot;);    var dtitle_text = document.createTextNode(key);    dtitle.appendChild(dtitle_text);    var ddesc = document.createElement(&quot;dd&quot;);    var ddesc_text = document.createTextNode(definition);    ddesc.appendChild(ddesc_text);// 添加列表项到列表中    dlist.appendChild(dtitle);    dlist.appendChild(ddesc);  }  if (dlist.childNodes.length &lt; 1) return false;// 创建标题  var header = document.createElement(&quot;h2&quot;);  var header_text = document.createTextNode(&quot;Abbreviations&quot;);  header.appendChild(header_text);// 把标题添加到页面主体  document.body.appendChild(header);// 把列表添加到页面主体  document.body.appendChild(dlist);}addLoadEvent(displayAbbreviations);</code></pre><blockquote><p>我的理解就是把原本 HTML 的内容通过 JavaScript 操作提取出来摘要，再加到 HTML 中充实文档内容。</p></blockquote><h1 id="第9章-CSS-DOM"><a href="#第9章-CSS-DOM" class="headerlink" title="第9章 CSS-DOM"></a>第9章 CSS-DOM</h1><p>我们在浏览器看到的网页其实有三部分构成：</p><ul><li>结构层(structural layer) 由 XHTML 或者 HTML 等标记语言创建。</li><li>表示层(presentation layer) 由 CSS 负责创建。</li><li>行为层(behavior layer) 负责内容应该如何响应事件这一动作，这主要是由 javaScript 和 DOM 负责。</li></ul><h2 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h2><p>在文档中每个人元素都是一个对象，每个元素都有一个 style 属性，他们也是一个对象。</p><h3 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h3><pre><code class="javaScript">element.style.color;// 中间带连字符的 CSS 属性要使用驼峰写法element.style.fontFamily;</code></pre><p>获取样式属性的返回值与设置值采用同样的单位。<br>如我们在 CSS font-size 属性时以 em 为单位，相应的 DOM fontSize 属性也以 em 为单位。</p><blockquote><p>注意 通过 style 获取属性的局限性，即只能返回 <strong>内联样式</strong>。</p></blockquote><p><code>&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;</code></p><p>通过 link 元素引入的 CSS 文件样式不能用 DOM style 属性检索出来。</p><p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></p><p>通过 <code>&lt;head&gt;</code> 部分引入的 <code>&lt;style&gt;</code> 标签里也不能用 DOM style 属性检索出来。</p><pre><code class="HTML">&lt;head&gt;  &lt;style&gt;  hr {color:sienna;}  p {margin-left:20px;}  &lt;/style&gt;&lt;/head&gt;</code></pre><h3 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h3><p>style 对象的各个属性都是可读写的，可以通过元素的 style 属性获取样式，也可以通过它更新样式。</p><pre><code class="JavaScript">element.style.property = value;// 例如：para.style.color = &quot;black&quot;;</code></pre><h2 id="何时该用-DOM-脚本设置样式"><a href="#何时该用-DOM-脚本设置样式" class="headerlink" title="何时该用 DOM 脚本设置样式"></a>何时该用 DOM 脚本设置样式</h2><p>在绝大多数场合还是应该使用 CSS 声明样式。<br>在使用 CSS 不方便的场合，可以利用 DOM 对文档的样式做一些小的增强。</p><p>通过 CSS 设置样式方式：</p><pre><code class="CSS">// 1.通过标签元素p {  font-size: 1em;}// 2.通过class属性.fineorint {  font-size: 1em;}// 3.通过id属性#fineorint {  font-size: 1em;}</code></pre><p>通过 DOM 脚本设置样式的情况：</p><ul><li>根据元素在节点数的位置来设置样式</li><li>根据某种条件反复设置某种样式</li><li>响应事件，即事件发生时设置有关元素的样式</li></ul><h2 id="className-属性"><a href="#className-属性" class="headerlink" title="className 属性"></a>className 属性</h2><p>前面一直在使用 DOM 直接设置或者修改元素的样式，这种让行为层干表示层的活，并不是理想的工作方式。</p><p>与其使用 DOM 直接改变某个元素的样式，倒不如通过 JavaScript 代码修改元素的 class 属性。</p><p>通过修改 DOM 直接改变元素样式：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.style.fontWeight = &quot;bold&quot;;    elem.style.fontSize = &quot;1.2em&quot;;  }}</code></pre><p>通过修改 class 属性：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.setAttribute(&quot;class&quot;,&quot;intro&quot;);  }}</code></pre><p>当然需要提前引入 CSS 样式：</p><pre><code class="CSS">.intro {  font-weight: bold;  font-size: 1.2em;}</code></pre><p>更简单的是通过 className 属性。<br>className 属性是一个可读/可写的属性，凡是元素节点都有这个属性。</p><p>获得元素的 class 属性：<br><code>element.className</code><br>修改元素的 class 属性：<br><code>element.className = value</code></p><p>通过 className 属性修改样式：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.className = &quot;intro&quot;;  }}</code></pre><blockquote><p>缺点：通过 className 属性设置元素的 class 属性将替换原有 class 设置。</p></blockquote><p>可以通过 字符串拼接 解决(注意 intro 前的空格)：</p><p><code>elem.className += &quot; intro&quot;;</code></p><h1 id="第10章-用JavaScript实现动画效果"><a href="#第10章-用JavaScript实现动画效果" class="headerlink" title="第10章 用JavaScript实现动画效果"></a>第10章 用JavaScript实现动画效果</h1><p>JavaScript 能够按照预定的时间间隔重复调用一个函数，而这意味着我们可以随着时间的推移而不断地改变某个元素地样式。</p><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>位置通常是由 CSS 负责设置的：</p><pre><code class="CSS">element {  position: absolute;  top: 50px;  left: 100px;}</code></pre><ul><li><strong>static</strong>: 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li><strong>relative</strong>: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li><li><strong>absolute</strong>: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li><strong>fixed</strong>: 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li><strong>inherit</strong>: 规定应该从父元素继承 position 属性的值。</li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>JavaScript 函数 setTimeout 能让某个函数在经过一段预定的时间后才开始执行。</p><p><code>variable = setTimeout(&quot;function&quot;,interval);</code></p><p>第一个参数为函数名字，第二个参数为间隔时间。若想取消执行：</p><p><code>clearTimeout(variable)</code></p><p>本章主要是定义的一个位置随时间运动的函数：</p><pre><code class="JavaScript">function moveElement(elementID,final_x,final_y,interval) {  if (!document.getElementById) return false;  if (!document.getElementById(elementID)) return false;  var elem = document.getElementById(elementID);  var xpos = parseInt(elem.style.left);  var ypos = parseInt(elem.style.top);  if (xpos == final_x &amp;&amp; ypos == final_y) {    return true;  }  if (xpos &lt; final_x) {    xpos++;  }  if (xpos &gt; final_x) {    xpos--;  }  if (ypos &lt; final_y) {    ypos++;  }  if (ypos &gt; final_y) {    ypos--;  }  elem.style.left = xpos + &quot;px&quot;;  elem.style.top = ypos + &quot;px&quot;;  var repeat = &quot;moveElement(&#39;&quot;+elementID+&quot;&#39;,&quot;+final_x+&quot;,&quot;+final_y+&quot;,&quot;+interval+&quot;)&quot;;  movement = setTimeout(repeat,interval);}</code></pre><h1 id="第11章-HTML5"><a href="#第11章-HTML5" class="headerlink" title="第11章 HTML5"></a>第11章 HTML5</h1><p>本章介绍了 HTML5 的新特性，包括 <code>&lt;canvas&gt;</code>、 <code>&lt;audio&gt;</code>、 <code>&lt;video&gt;</code> 元素及新的表单控件。</p><h1 id="第12章-综合示例"><a href="#第12章-综合示例" class="headerlink" title="第12章 综合示例"></a>第12章 综合示例</h1><p>结合前面的知识实现了一个综合示例，对前面的知识进行了很好的回顾。</p><blockquote><p>这本书看下来，感受最大的是 HTML 和 CSS 基础太差，JavaScript 部分还好。<br>原来计划上个周末看完呢，中间又催文档啥的，这个周末（2017.10.29）才看完。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;《JavaScript DOM 编程艺术》读书笔记&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.wshunli.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript编程艺术" scheme="http://www.wshunli.com/tags/JavaScript%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（三）</title>
    <link href="http://www.wshunli.com/2017/10/19/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF%EF%BC%8C%E4%B8%8D%E5%8F%AF%E8%87%AA%E6%8B%94%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/19/沉迷学术，不可自拔（三）/</id>
    <published>2017-10-19T03:36:38.000Z</published>
    <updated>2017-10-19T04:21:16.969Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p>或许这就是研究僧生活吧<a id="more"></a> 。专硕也就两年，是时候为未来打算了。</p><p>前阵老师找谈话，问将来的打算，去事业单位还是企业公司等等。</p><p>“打算去互联网公司，做 Android 开发，最好能跟 GIS 有点关系，不想把整个 GIS 都丢掉。”</p><p>回来就查了下阿里巴巴对 Android 工程师的要求：</p><ul><li>熟悉iOS/Android平台原理机制,具备客户端性能优化的经验有一定软件架构设计能力，熟悉常见的异步、同步、多线程、跨进程、组件、容器的设计方法</li><li>具备扎实的数据结构和计算机系统基础，编码功底扎实</li><li>具备C++跨平台开发经验，熟悉NDK开发优先</li><li>具备创新业务技术攻关和落地能力者优先（不限于算法、生物识别、图形图像、3D建模、AR、多媒体等领域）</li></ul><p>也有查 Android 工程师的技术栈。总体来说包括以下几个方面：</p><ul><li>计算机基础，包括计算机网络、操作系统、数据库</li><li>数据结构与算法</li><li>Java 语言基础及设计模式</li><li>Android 技术栈</li><li>C++ 语言，使用 NDK 可加分</li><li>React Native 、Ionic 等跨平台技术</li></ul><p>在国庆前基本上在拿着 《Java编程思想》 啃，学到了不少新的知识点，非常遗憾没有笔记。</p><p>国庆假期在看 《计算机网络(第七版)》 谢希仁，基本上过了一遍，并写了阅读笔记 <a href="https://www.wshunli.com/tags/计算机网络/">计算机网络阅读笔记</a> ，对付面试应该没问题吧。</p><p>基本上国庆后就在抓紧时间做 Node.js 后端的项目，现在已经完成了所有的单元测试，除了逻辑性的错误，问题不大。<br>然后就是 WebGIS 项目，现在在写文档阶段，打算这段时间学习下 Javascript ，尤其是 ES6 。<br>论文外审没过，改投的 计算机应用与软件 ，今天交的审稿费，这次应该能过，感觉上面的论文跟我的差不多水。</p><p>后面模型和视频叠加的技术尽快做完吧。<br>打算简单地过一遍操作系统，然后看 Java 语言。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;或许这就是研究僧生活吧
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（六）</title>
    <link href="http://www.wshunli.com/2017/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/10/计算机基础-计算机网络（六）/</id>
    <published>2017-10-10T13:47:27.000Z</published>
    <updated>2017-10-13T04:32:03.880Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --><p><strong>计算机网络-应用层</strong> 部分读书笔记<a id="more"></a></p><p>运输层为应用进程提供了端到端的通信服务，但不同的网络应用的应用进程之间，还需要有不同的通信规则，因此在运输层协议之上，还需要有 <strong>应用层协议</strong>。</p><h1 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h1><p>域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p>域名存储：</p><ul><li>理论上：我们可以只使用一个域名服务器存储所有的域名和与之对应的IP地址。因为互联网的规模巨大，这个域名服务器一定会因为过负荷而无法正常工作。而且如果出现故障，整个互联网将进入瘫痪状态。</li><li>实际上：DNS被设计成联机分布式数据库系统，并采用C/S方式。因此即使单个计算机出现故障也不会影响整个互联网的正常运行。</li></ul><h2 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h2><p>如今互联网域名采用层次树状的命名方法。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-DNS结构.png-hexo.png" alt="应用层-DNS结构"></p><h3 id="顶级域名："><a href="#顶级域名：" class="headerlink" title="顶级域名："></a>顶级域名：</h3><p><strong>1.国家顶级域名</strong> nTLD<br>cn（中国)　　us(美国)　　uk(英国) ···</p><p><strong>2.通用顶级域名</strong> gTLD<br>com(公司企业)　　　　　　net(网络服务机构)　　　　　org(非营利性组织)　　　　int(国际组织)<br>edu(美国专用的教育机构)　gov(美国的政府部门)　　　　mil(美国的军事部门)　　　name(个人)<br>aero(航空运输企业)　　　 asia(亚太地区)　　　　　　 biz(公司和企业)　　　　　travel(旅游业)<br>coop(合作团体)　　　　　 info(各种情况)　　　　　　 jobs(人力资源管理者)<br>museum(博物馆) 　　　　　pro(有证书的专业人员)　　　tel(Telnic股份有限公司)<br>mobi(移动产品与服务的用户和提供者)</p><p><strong>3.基础结构域名</strong><br>arpa(反向域名) 用于反向域名解析</p><h3 id="二级域名（我国）"><a href="#二级域名（我国）" class="headerlink" title="二级域名（我国）"></a>二级域名（我国）</h3><p><strong>1.类别域名</strong><br>com(工、商、金融等企业)　　　　ac(科研机构)　　　　edu(中国教育机构　　gov(中国政府机构)<br>net(提供互联网络服务的机构)　　mil(中国国防机构)　　 org(非营利性的组织)</p><p><strong>2.行政区域名</strong><br>bj(北京) js(江苏) sx(山西) ···</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><h3 id="域名服务器结构"><a href="#域名服务器结构" class="headerlink" title="域名服务器结构"></a>域名服务器结构</h3><p>理论上：在理论上来说，按照上面的域名的结构可以对照出域名服务器的结构，但是如果这样的话会有许多的域名服务器，这样导致了效率变低。<br>实际上：实际上DNS采用了划分区的方法来解决效率低的问题。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-域名服务器分区.png-hexo.png" alt="应用层-域名服务器分区"></p><p>DNS服务器管辖的范围是 <strong>区</strong> 而不是 域 ，每一个区设置相应的权限域名服务器来保存该区中所有主机的域名到IP地址的映射。区可能等于或者小于域，但一定不能大于域。</p><h3 id="域名服务器的分类和作用"><a href="#域名服务器的分类和作用" class="headerlink" title="域名服务器的分类和作用"></a>域名服务器的分类和作用</h3><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-域名服务器结构.png-hexo.png" alt="应用层-域名服务器结构"></p><p><strong>1. 根域名服务器</strong></p><ul><li>知道所有顶级域名服务器的域名和IP地址。</li><li>只有13个域名，多台服务器使用同一个IP地址。</li><li>本地域名服务器无法解析时，首先要求助根域名服务器。</li></ul><p><strong>2. 顶级域名服务器</strong></p><ul><li>管理所有在该顶级域名服务器中注册的二级域名。</li><li>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</li></ul><p><strong>3. 权限域名服务器</strong></p><ul><li>负责一个区的域名服务器。</li><li>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</li></ul><p><strong>4. 本地域名服务器</strong></p><ul><li>不属于域名服务器层级结构</li><li>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li><li>每一个互联网服务提供者ISP，或者一个大学，甚至一个大学里的一个系，都可以拥有一个本地域名服务器。</li></ul><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>对于用户来说，域名解析过程只有一步，将域名向本地域名服务器查询，本地域名服务器返回查询结果。但是对于本地域名服务器来说就没这么简单了，查询方法有如下两种：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-域名解析过程.png-hexo.png" alt="应用层-域名解析过程"></p><p><strong>1. 迭代查询</strong></p><p>1 用户向本地域名服务器查询。<br>2 本地域名服务器向根域名服务器查询。<br>3 根域名服务器告诉本地域名服务器下一次查询的顶级域名服务器的IP地址。<br>4 本地域名服务器向顶级域名服务器查询。<br>5 顶级域名服务器告诉本地域名服务器下一次查询的权限域名服务器的IP地址。<br>6 本地域名服务器向权限域名服务器查询。<br>7 权限域名服务器将最终的IP地址告诉本地域名服务器。<br>8 本地域名服务器将最终的IP地址告诉用户。</p><p><strong>2. 递归查询</strong></p><p>1 用户向本地域名服务器查询。<br>2 本地域名服务向根域名服务器查询。<br>3 根域名服务器向顶级域名服务器查询。<br>4 顶级域名服务器向权限域名服务器查询。<br>5 权限域名服务器将IP地址告诉顶级域名服务器。<br>6 顶级域名服务器将IP地址告诉根域名服务器。<br>7 根域名服务器将IP地址告诉本地域名服务器。<br>8 本地域名服务器将IP地址告诉用户。</p><h3 id="提高域名服务器可靠性"><a href="#提高域名服务器可靠性" class="headerlink" title="提高域名服务器可靠性"></a>提高域名服务器可靠性</h3><p>DNS服务器把数据复制到几个域名服务器来保存，其中一个是主域名服务器 其他是辅助域名服务器 ，当主域名服务器出现故障，辅助域名服务器可以保证DNS查询工作的正常运行。主域名服务器会定期把数据复制到辅助域名服务器中。而修改数据只需要在主域名服务器操作即可保证数据的一致性。</p><h3 id="提高查询效率"><a href="#提高查询效率" class="headerlink" title="提高查询效率"></a>提高查询效率</h3><p>在域名服务器中使用高速缓存（高速缓存域名服务器） 用来存放最近查询过的域名以及从何处获取域名映射信息的记录。例如：<br>如果不久前已经查询过 www.baidu.com 的IP地址，那么再次向本地域名服务器发出查询申请的时候，本地域名服务器并不需要向根域名服务器发出查询申请，而是直接把高速缓存中上次查询的结果告诉用户。</p><h1 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h1><p>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。<br>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。<br>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求。</p><p>主进程的工作步骤如下:<br>1.打开熟知端口（端口号为 21），使客户进程能够连接上。<br>2.等待客户进程发出连接请求。<br>3.启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。<br>4.回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。</p><p>在进行文件传输时，FTP 客户端和服务器之间会建立两个并行的 TCP 连接。控制进程和数据传输进程为从属进程。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-FTP两个TCP连接.png-hexo.png" alt="应用层-FTP两个TCP连接"></p><p>控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。<br>实际用于传输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。<br>数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p><p>FTP 若存取一个文件，就行必须先获取一个本地文件副本。如果要修改文件，只能对文件的副本进行修改，然后再对修改后的文件副本传回原节点。</p><p><strong>网络文件系统</strong> NFS(Network File System)<br>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。<br>NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。<br>对于上述例子，计算机 A 的 NFS 客户软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 的 NFS 服务器。NFS 服务器更新文件后返回应答信息。在网络上传送的只是少量的修改数据。</p><p><strong>简单文件传送协议</strong> TFTP(Trivial File Transfer Protocol)<br>1.TFTP 是一个很小且易于实现的文件传送协议。<br>2.TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。<br>3.TFTP 只支持文件传输而不支持交互。<br>4.TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p>TFTP 的 <strong>主要特点</strong><br>(1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。<br>(2) 数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。<br>(3) 支持 ASCII 码或二进制传送。<br>(4) 可对文件进行读或写。<br>(5) 使用很简单的首部。</p><h1 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h1><p>TELNET 是一个简单的远程终端协议，也是因特网的正式标准。<br>用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。<br>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。</p><p>TELNET 使用网络虚拟终端 NVT 格式<br>客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。<br>服务器软件把收到的数据和命令，从 NVT 格式转换成远地系统所需的格式。<br>向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式。</p><h1 id="万维网-WWW"><a href="#万维网-WWW" class="headerlink" title="万维网 WWW"></a>万维网 WWW</h1><p>万维网是一个大规模的、联机式的信息储藏所。</p><p>客户程序向服务器发出请求，服务器程序返回客户所需的万维网文档。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-万维网工作过程.png-hexo.png" alt="应用层-万维网工作过程"></p><h2 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符 URL"></a>统一资源定位符 URL</h2><p>统一资源定位符 URL是用来表示从互联网上获取资源位置和访问这些资源的方法。</p><h2 id="超文本传送协议-HTTP"><a href="#超文本传送协议-HTTP" class="headerlink" title="超文本传送协议 HTTP"></a>超文本传送协议 HTTP</h2><p>HTTP使用TCP作为其运输层协议，面向事务的应用层协议；<br>服务器在向客户机发送被请求的文件时，并不存储任何关于该客户机的状态信息，即HTTP是一个无状态协议；<br>有时为了能够使Web站点识别用户，可以使用 Cookie。</p><h3 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h3><p>非持久连接：至多一个对象经过一个TCP连接发送。<br>持久连接：多个对象能够经过客户机和服务器之间的单个TCP连接发送。</p><p>HTTP既可以使用非持久连接，也可以使用持久连接，默认方式下HTTP使用持久连接。</p><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>HTTP 有两类报文：<br>请求报文——从客户向服务器发送请求报文。<br>响应报文——从服务器到客户的回答。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-HTTP报文.png-hexo.png" alt="应用层-HTTP报文"></p><p>由于HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p><p>HTTP <strong>请求报文</strong></p><pre><code class="text">GET  /somedir/page.html  HTTP/1.1Host:  www.someschool.eduConnection:  closeUser-agent:  Mozilla/4.0Accept-language:  fr</code></pre><p>HTTP 请求报文的第一行叫做请求行，其后继的行叫做首部行；</p><p>请求行有3个字段：方法字段、URL字段和 HTTP 协议版本字段；<br>方法字段可以取值GET、POST、HEAD、 PUT和DELETE。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-HTTP请求报文方法.png-hexo.png" alt="应用层-HTTP请求报文方法"></p><p>Host 首部行定义了目标所在的主机（Web代理缓存需要）；<br>Connection 首部行值为close表示HTTP使用非持久连接 ；<br>User-agent 首部行用来定义用户代理（即浏览器类型）；<br>Accept-language 首部行表示用户想要得到该对象什么语言版本.</p><p>HTTP <strong>响应报文</strong></p><pre><code class="text">HTTP/1.1  200  OKConnection:  CloseData: Thu,  03  Jul  2003  12:00:15   GMTServer:  Apache/1.3.0 (Unix)Last-Modified:  Sun,  6  May  2007  09:23:24  GMTContent-Length:  6821Content-Type:  text/html(data data data data data)</code></pre><p>该响应报文同样分成3个部分：一个初始状态行，6个首部行，然后是实体主体；<br>实体主体部分是报文的主体，包含了所请求的对象本身；<br>状态行有3个字段：协议版本、状态码和相应状态信息。</p><p>状态码：<br>1xx 表示通知信息，如请求收到了或正在进行处理。<br>2xx 表示成功，如接受或知道了。<br>3xx 表示重定向，如要完成请求还必须采取进一步行动。<br>4xx 表示客户的差错，如请求中有错误的语法或者不能完成。<br>5xx 表示服务器的差错，如服务器失效无法完成请求。<br>更多信息：<a href="http://blog.csdn.net/u014345282/article/details/49101245" rel="external nofollow noopener noreferrer" target="_blank">计算机网络（三）http状态码大全</a></p><p>Date 首部行表示服务器产生并发送该响应报文的日期和时间；<br>Server 首部行表示该报文是由什么服务器产生的（类似请求报文里的User-agent）；<br>Last-Modified 首部行表示对象创建或者最后修改的日期和时间；<br>Content-Length 首部行表明了被发送对象的字节数；<br>Content-Type 首部行表示实体主体中的对象类型.</p><h3 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h3><p>Web缓存器也叫代理服务器，是能够代表初始Web服务器来满足HTTP请求的网络实体；<br>Web缓存器有自己的磁盘存储空间，并在该存储空间中保存最近请求过的对象的拷贝；<br>Web缓存器可以大大减少对客户机请求的响应时间。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-代理服务器.png-hexo.png" alt="应用层-代理服务器"></p><h3 id="在服务器上存放用户的信息"><a href="#在服务器上存放用户的信息" class="headerlink" title="在服务器上存放用户的信息"></a>在服务器上存放用户的信息</h3><p>1.万维网站点使用 Cookie 来跟踪用户。<br>2.Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。<br>3.使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。</p><h2 id="万维网文档"><a href="#万维网文档" class="headerlink" title="万维网文档"></a>万维网文档</h2><h3 id="超文本标记语言-HTML"><a href="#超文本标记语言-HTML" class="headerlink" title="超文本标记语言 HTML"></a>超文本标记语言 HTML</h3><p>HTML 并不是应用层协议，而是一种制作网页的语言。<br>XML 可扩展标记语言，主要是传输数据。<br>XHTML 可扩展超文本标记语言，更严格版本的HTML。</p><h3 id="动态万维网文档"><a href="#动态万维网文档" class="headerlink" title="动态万维网文档"></a>动态万维网文档</h3><p>静态文档是指文档在创建完毕之后就存放在万维网服务器中，就不会改变了。静态文档的最大优点就是简单，可以由不懂程序设计的人员来创建。但是缺点是不够灵活。<br>动态文档（dynamic document）是指文档的内容是在浏览器访问万维网服务器的时候才由应用程序动态创建。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-动态万维网文档.png-hexo.png" alt="应用层-动态万维网文档"></p><p><strong>通用网关接口</strong> CGI</p><p>CGI 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。<br>万维网服务器与 CGI 的通信遵循 CGI 标准。<br>“通用”：CGI 标准所定义的规则对其他任何语言都是通用的。<br>“网关”：CGI 程序的作用像网关。<br>“接口”：有一些已定义好的变量和调用等可供其他 CGI 程序使用。</p><h3 id="活动万维网文档"><a href="#活动万维网文档" class="headerlink" title="活动万维网文档"></a>活动万维网文档</h3><p>活动文档(active document)技术把所有的工作都转移给浏览器端。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-活动万维网文档.png-hexo.png" alt="应用层-活动万维网文档"></p><p>每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。<br>活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。<br>由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>因特网电子邮件系统有3个主要组成部分：用户代理、邮件服务器和简单邮件传输协议；<br>用户代理允许用户阅读、回复、转发和撰写报文；<br>邮件服务器组成了电子邮件体系结构的核心；<br>SMTP则是因特网电子邮件中的主要应用层协议（使用TCP传输）；</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-电子邮件.png-hexo.png" alt="应用层-电子邮件"></p><p>一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器（使用SMTP协议），再传输到接收方的邮件服务器（使用SMTP协议），然后在这里被分发到接收方的邮箱里（POP3或IMAP）。</p><h2 id="简单邮件传送协议-SMTP"><a href="#简单邮件传送协议-SMTP" class="headerlink" title="简单邮件传送协议 SMTP"></a>简单邮件传送协议 SMTP</h2><p>SMTP 通信的三个阶段<br>1.连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。<br>2.邮件传送<br>3.连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。</p><h2 id="邮件读取协议POP3-和-IMAP"><a href="#邮件读取协议POP3-和-IMAP" class="headerlink" title="邮件读取协议POP3 和 IMAP"></a>邮件读取协议POP3 和 IMAP</h2><p>POP 也使用客户服务器的工作方式。<br>在接收邮件的用户 PC 机中必须运行 POP 客户程序，而在用户所连接的 ISP 的邮件服务器中则运行 POP 服务器程序。</p><h2 id="IMAP-协议"><a href="#IMAP-协议" class="headerlink" title="IMAP 协议"></a>IMAP 协议</h2><p>IMAP (Internet Message Access Protocol）也是按客户服务器方式工作，现在较新的是版本 4，即 IMAP4。<br>用户在自己的 PC 机上就可以操纵 ISP 的邮件服务器的邮箱，就像在本地操纵一样。<br>因此 IMAP 是一个联机协议。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。</p><p>IMAP 的特点:<br>1.IMAP最大的好处就是用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。<br>2.IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像附件（此文件可能很大）的邮件。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。<br>3.IMAP 的缺点是如果用户没有将邮件复制到自己的 PC 机上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。</p><h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h1><p>动态主机配置协议 DHCP 提供了即插即用连网(plug-and-play networking)的机制。<br>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p><p>DHCP <strong>使用客户服务器方式</strong><br>1.需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。<br>2.本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。<br>3.DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池(address pool)中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文（DHCPOFFER）。</p><p>DHCP <strong>中继代理</strong>(relay agent)<br>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。<br>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p><p><strong>租用期</strong>(lease period)<br>DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/6/应用层-DHCP工作过程.png-hexo.png" alt="应用层-电子邮件"></p><p>DHCP 协议的<strong>工作过程</strong>：<br>1.DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。<br>2.DHCP 客户从 UDP 端口 68发送 DHCP 发现报文。<br>3.凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文。<br>4.DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文。<br>5.被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。<br>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。<br>6.租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租用期。<br>7.DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。<br>8.DHCP 服务器若不同意，则发回否认报文DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2）。<br>若DHCP服务器不响应步骤6的请求报文DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。<br>9.DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</p><h1 id="应用进程跨越网络的通信"><a href="#应用进程跨越网络的通信" class="headerlink" title="应用进程跨越网络的通信"></a>应用进程跨越网络的通信</h1><p>两个端系统进行通信，真正进行通信的其实是进程而不是程序。<br>不同端系统上的进程通过跨越计算机网络交换报文而相互通信。</p><h2 id="客户机和服务器进程"><a href="#客户机和服务器进程" class="headerlink" title="客户机和服务器进程"></a>客户机和服务器进程</h2><p>网络应用程序是由成对的进程组成的，对每对通信进程，通常将进程分为客户机和服务器，在Web中，浏览器是一个客户机进程，Web服务器是一个服务器进程；对于P2P文件共享，下载文件的对等方被视为客户机，上传文件的对等方被视为服务器；其具体定义为：在给定的一对进程之间的通信会话中，发起通信的进程被视为客户机，在会话开始时等待联系的进程是服务器</p><h2 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h2><p>对于一对通信进程，进程通过被称为套接字的软件接口在网络上发送和接收报文；套接字是同一台主机内应用层与运输层之间的接口；由于该套接字是在网络上建立网络应用程序的可编程接口，因此也将该套接字称为应用程序和网络之间的应用程序编程接口（API）；应用程序开发者可以控制套接字在应用层端的所有东西，但是对该套接字的运输层端几乎没有控制；应用程序开发者对于运输层的控制仅限于：1.选择运输层协议；2.设置一些运输层参数（如最大缓存，最大报文长度）</p><h1 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h1><p>大多数流量密集型应用程序都是基于P2P体系的，例如文件分发、文件搜索/共享、因特网电话等等；P2P体系最突出的特性是其自扩展性；例如，在一个P2P文件共享应用中，尽管每个对等方都由请求文件产生负载，但每个对等方向其他对等方分发文件也为系统增加了服务能力；P2P通常不需要庞大的服务器基础设施和带宽</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;计算机网络-应用层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（五）</title>
    <link href="http://www.wshunli.com/2017/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/07/计算机基础-计算机网络（五）/</id>
    <published>2017-10-07T01:20:20.000Z</published>
    <updated>2017-10-12T02:32:59.132Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --><p><strong>计算机网络-运输层</strong> 部分读书笔记<a id="more"></a></p><h1 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h1><p>运输层提供应用进程间的逻辑通信。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-运输层和网络层.png-hexo.png" alt="运输层-运输层和网络层"></p><p>网络层为主机之间提供逻辑通信（网络核心部分），运输层为应用进程之间提供端到端的逻辑通信（网络边缘部分）。<br>从运输层来看，通信是两主机应用进程之间相互通信。不同进程可以使用同一运输层协议传输数据。</p><p>运输层要对收到的报文进行差错检测。<br>在网络层，IP数据报首部的检验和字段，只检验首部而不检查数据部分。</p><p><strong>传输层</strong>的两个主要协议</p><p>(1) 用户数据报协议 UDP （User Datagram Protocol）<br>(2) 传输控制协议 TCP （Transmission Control Protocol）</p><p>在 OSI 中，两个对等实体在通信时传达的数据单元叫做传输协议数据单元 TPDU 。<br>在 TCP/IP 中，根据协议不同分别称之为TCP报文段、UDP数据段 。</p><p>UDP 传输数据之前不需要先建立连接，不提供可靠交付。<br>TCP 提供面向连接的服务，传输之前先建立连接，结束后要释放连接。不提供广播或者多播服务。</p><p><strong>运输层</strong>的端口</p><p>为了使运行在不同操作系统的计算机应用程序能够相互通信，使用统一的方法（在运输层使用协议端口号）对 TCP/IP 体系的应用进程进行标志。</p><p>在运输层使用协议端口使软端口，软件端口使应用层的各协议进程与传输实体进行层间交互的一种地址。<br>硬件端口使不同硬件设备进行交互的接口。</p><h1 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h1><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p><p>UDP 的主要特点：</p><ul><li>UDP 是无连接的，即发送数据之前不需要建立连接。</li><li>UDP 使用尽最大努力交付，即不保证可靠交付。</li><li>UDP 是面向报文的，对应用层交下来的报文、IP层交上来的UDP数据报，不合并也不拆分。</li><li>UDP 没有拥塞控制，很适合多媒体通信的要求。</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP 的首部开销小，只有 8 个字节。</li></ul><p>UDP 的首部格式：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-UDP报文段.png-hexo.png" alt="运输层-UDP报文段"></p><ul><li>源端口字段：源端口是一个大于1023的16位数字，由基于UDP应用程序的用户进程随机选择。</li><li>目的端口字段：目的端口号，在终点交付报文使用。</li><li>长度字段：指明了包括首部在内的UDP报文段长度。UDP长字段的值是UDP报文头的长度(8字节)与UDP所携带数据长度的总和。</li><li>校验和字段：指整个UDP报文头和UDP所带的数据的校验和（也包括伪报文头）。</li></ul><p>伪首部不包括在真正的UDP报文头中，但是它可以保证UDP数据被正确的主机收到了。因在校验和中加入了伪头标，故ICMP除能防止单纯数据差错之外，对IP分组也具有保护作用。</p><h1 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h1><p><strong>TCP</strong> 的主要特点：</p><ul><li>TCP 是面向连接的运输层协议。使用之前先建立建立连接，使用后释放。</li><li>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。</li><li>TCP 提供可靠交付的服务，使用 TCP 连接传达的数据，无差错、不丢失、不重复，并且按序到达。</li><li>TCP 提供全双工通信。TCP 连接的两端都设有缓存，允许通信双方的应用进程在任何时候都能发送数据。</li><li>面向字节流。TCP 把应用程序交下来的数据仅仅看成一串无结构的字节流。不保证接收方和发送方的数据块具有对应的大小关系，但是字节流完全一样，由接收方应用程序还原成有意义的应用层数据。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP面向字节流.png-hexo.png" alt="运输层-TCP面向字节流"></p><ul><li>TCP 连接是一条虚连接（逻辑连接）而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。</li><li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li><li>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li></ul><p><strong>TCP</strong> 的连接</p><p>TCP 把<strong>连接</strong>作为最基本的抽象。<br>一条 TCP 连接有两个端点，又叫嵌套字（socket）或插口，由端口号拼接IP地址组成。</p><p>嵌套字 socket = IP地址 ： 端口号</p><p>每条 TCP 连接唯一地被通信两端的两个端点所确定。即：</p><p>TCP 连接 = {socket1，socket2} = {（IP1：port1），（IP2：port2）}</p><p>TCP 连接的端点是个很抽象的嵌套字。同一 IP 地址可以有多个 TCP 连接，同一端口号也可以出现在不同的 TCP 连接中。</p><p>TCP 与 UDP 的<strong>区别</strong>：</p><ul><li>TCP 提供面向连接的服务。</li><li>TCP 不提供广播或多播服务。</li><li>TCP 协议数据单元的首部增大很多，还要占用许多的处理机资源。</li><li>UDP 在传送数据之前不需要先建立连接。</li><li>对方收到 UDP 报文后，不需要给出任何确认。</li><li>在某些情况下 UDP 是一种最有效的工作方式。</li></ul><h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><p>TCP 发送的报文段是交给 IP 层传递的，但是 IP 层只能提供尽最大努力服务。也就是说，TCP下面的网络所提供的是不可靠的传输。</p><p>理想状态下的传输条件有两个特点：</p><ul><li>传输信道不产生差错。</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li></ul><h2 id="停止等地协议-ARQ"><a href="#停止等地协议-ARQ" class="headerlink" title="停止等地协议 ARQ"></a>停止等地协议 ARQ</h2><p>ARQ 协议（自动重传请求）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用 <strong>确认和超时</strong> 这两个机制，在不可靠服务的基础上实现可靠的信息传输。</p><p>1、无差错情况<br>“停止等待” 即每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-停止等待协议.png-hexo.png" alt="运输层-停止等待协议"></p><p>2、出错情况<br>B 接收分组使检测出差错就丢弃，其他什么也不做（不通知A收到有差错的分组），也可能发送过程中丢失了。<br>A 超过一段时间没有收到确认就认为分组丢失了，因而重传前面发送过的分组。</p><p>3、确认丢失和确认迟到<br>B 发送的确认丢失，A 又重传分组，此时B放弃重复的分组并再次向 A 发送确认。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-停止等待协议-确认迟到和重复.png-hexo.png" alt="运输层-停止等待协议-确认迟到和重复"></p><p>A 收到重复的确认分组就放弃。</p><p>为了提高传输效率，发送方可以连续发送多个分组，不必每发完一个分组就停下来等待确认，即流水线传输。</p><p>流水线传输使用 连续ARQ协议和滑动窗口协议。</p><h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><p>接收方采用累计确认的方式。即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按需到达的最后一个分组确认，这就表示：到这分组为止的所有分组都已正确收到了。</p><h1 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h1><p>TCP（Transmission Control Protocol）传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP报文段.png-hexo.png" alt="运输层-TCP报文段"></p><ul><li>源端口和目标端口：和 UDP 类似，源端口号和目的端口号实现分用功能；</li><li>序号：本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而起数据共100字节，则下一个报文段的序号就是400。</li><li>确认号：是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号。例如，B收到报文段序号字段是501，数据长度为200（字节的序号501-700），则表明B收到了A发送的到700为止的数据。因此B期望的数据序号是701，在确认报文段中确认号置为701。</li><li>数据偏移：数据起始处离TCP报文段的起始处有多远。实际上是TCP报文段首部的长度，因为首部长度不固定，所以数据偏移字段是必要的。数据偏移的单位是4个字节，即首部最大长度为 4*15。</li><li>保留字段： 供今后使用，目前置为0。</li></ul><p>控制位，用来说明本报文的性质：</p><ul><li>紧急URG（URGent）：当URG=1时，此报文应尽快传送，而不要按本来的列队次序来传送。与 “紧急指针” 字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长；</li><li>确认ACK（ARKnowledge）：只有当ACK=1时，确认序号字段才有意义</li><li>推送PSH（PuSH）：当PSH=1时，希望接收方T尽快将本报文段传送给其应用层，而不要比及全部缓存都填满了之后再向上交付。</li><li>复位RST（ReSeT）：当RST=1时，表明TCP连接呈现严重错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接；</li><li>同步比特SYN（SYNchronization）：在建立连接时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若接受建立连接，在响应的报文段中使SYN=1和ACK=1。所以，SYN=1默示这是一个连接请求或连接接受报文，而ACK的值用来区分是哪一种报文；</li><li>终止FIN（FINis）：用来释放一个连接，当FIN=1时，表示发送方的字节串已经发完，并请求释放传输连接；</li></ul><p>其他：</p><ul><li>窗口：指出现在允许对方发送的数据量，窗口值从本报文段的确认号算起，总是动态变化着。</li><li>检验和：检验和覆盖了整个的TCP报文段： TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</li><li>紧急指针：参考标志字段的URG位。</li><li>选项：为了适合复杂网络环境和更好地服务于应用层设计的。TCP选项最长是40字节。</li><li>数据：无任何数据的TCP段也是合法的，通常用于确认和控制信息。</li></ul><p>TCP 报文段的 <strong>选项</strong> 字段。</p><p>最大报文段长度 MSS ：TCP报文段中的 <strong>数据字段</strong> 的最大长度。<br>窗口扩大：就是为了建立TCP连接时协商扩大窗口。<br>时间戳：包含时间戳值和时间戳回送回答字段。计算往返时间、防止序号重复使用时序号绕回。<br>选择确认：见下节。</p><h1 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h1><p><strong>TCP 可靠传输</strong> 的实现：确认和重传、数据校验、数据合理分片和排序、流量控制、拥塞控制。</p><p>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。<br>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP可靠传输.png-hexo.png" alt="运输层-TCP可靠传输"></p><p>发送过的数据未收到确认之前必须保留，以便超时重传时使用。</p><p>发送窗口<strong>后沿</strong>变化有两种可能：发送窗口不动(没收到确认)和前移(收到新的确认)。<br><strong>前沿</strong>通常时不断向前移动，但也有可能不动（没有收到新的确认；收到确认但对方通知的窗口变小了）。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP缓存与窗口.png-hexo.png" alt="运输层-TCP缓存与窗口"></p><p>发送缓存用来暂时存放： 发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。<br>接收缓存用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据； 不按序到达的数据。</p><p>必须强调三点：</p><ul><li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li><li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li></ul><h2 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h2><p>TCP 采用一种自适应算法。<br>TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。但是由于TCP的下层互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同，因此注定超时重传时间要动态变化。</p><h2 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h2><p>选择确认是针对没有出错但是未按序到达的报文段，如果中间只是缺少一些报文段，那么发送方就可以不重传已发送的所有数据，而只是重传缺少的数据。</p><h1 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h1><p>流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制就可以实施流量控制。<br>原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP流量控制.png-hexo.png" alt="运输层-TCP流量控制"></p><p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。<br>解决这个问题，TCP为每一个连接设置一个<strong>持续计时器</strong>（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口<strong>探测报文段</strong>。对方就在确认这个报文的时候给出现在的窗口大小。</p><p>注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。</p><h1 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h1><p>在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这种情况叫做拥塞。</p><h2 id="拥塞控制设计"><a href="#拥塞控制设计" class="headerlink" title="拥塞控制设计"></a>拥塞控制设计</h2><p>拥塞控制是很难设计的，因为它是一个动态的问题，许多情况下，甚至正式拥塞控制机制本身成为引起网络性能恶化甚至死锁的原因。<br>从控制理论的角度来看拥塞控制这个问题，可以分为 <strong>开环控制和闭环控制</strong> 两种方法。</p><p><strong>开环控制</strong> 就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。</p><p><strong>闭环控制</strong> 是基于反馈环路的概念，包括如下措施：</p><ol><li>监测网路系统以便检测拥塞在何时何地发生；</li><li>把拥塞发生的信息传送到可采取行动的地方；</li><li>调整网络系统的行动以解决出现的问题。</li></ol><h2 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h2><p>TCP 拥塞控制的算法有四种，即慢开始（Slow-start)，拥塞避免（Congestion Avoidance)，快重传（Fast Restrangsmit)和快恢复（Fast Recovery）。</p><p>我们假定：<br>1）数据是单方向传送，而另外一个方向只传送确认。<br>2）接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。</p><p><strong>1.</strong> 慢开始和拥塞避免</p><p>发送方维持一个拥塞窗口(cwnd)的状态变量。其大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口小于或等于拥塞窗口。</p><p>慢开始原理：</p><p>当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞。比较好的方法是试探一下，即从小到达逐渐增大发送端的拥塞控制窗口数值。通常在刚刚开始发送报文段时可先将拥塞窗口cwnd(拥塞窗口)设置为一个最大报文段的MSS的数值。</p><p>在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind（接收窗口）足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量– <strong>慢开始门限</strong> ssthresh。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-慢开始和拥塞避免.png-hexo.png" alt="运输层-慢开始和拥塞避免"></p><p>拥塞避免算法的思路是：让拥塞窗口cwnd线性缓慢增长。</p><p><strong>2.</strong> 快重传和快恢复</p><p>快重传的算法思路是：</p><ul><li>要求接收方每收到一个时序的报文段后就立即发出重复确认，而不是等待发送数据时才进行捎带确认</li><li>发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期</li></ul><p>快恢复的算法思路是：</p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始阀值ssthresh减半</li><li>接着不执行慢开始，而是从新阀值ssthresh开始执行拥塞避免算法(加法增大)</li></ul><h2 id="TCP拥塞控制和流量控制的差别"><a href="#TCP拥塞控制和流量控制的差别" class="headerlink" title="TCP拥塞控制和流量控制的差别"></a>TCP拥塞控制和流量控制的差别</h2><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。<br>拥塞控制是一个全局过程，涉及所有主机、所有路由器，以及降低网络传输性能有关的所有因素。</p><p>流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p><h1 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h1><p>TCP是面向连接的协议，运输连接是用来传送TCP报文段的。运输连接有三个阶段：<strong>连接建立、数据传送、连接释放</strong>。</p><p>在TCP连接建立过程中要解决三个问题：</p><ul><li>要使每一方知道对方的存在。</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ul><p>TCP连接的建立是采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），而被动等待连接建立的应用进程叫做服务器（sever）。</p><h2 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h2><p>假定主机A运行的是TCP客户程序，而B运行的是TCP服务器程序。最初两端的TCP都是处于CLOSED状态。A主动打开连接，B被动打开连接。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP连接建立.png-hexo.png" alt="运输层-TCP连接建立"></p><p>B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程A的请求。然后服务器出于LISTEN状态，等待客户A的连接请求。</p><ul><li>A的客户端进程首先创建TCB，然后向B发送连接请求报文段。这时首部中的同不好SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN（SYN = 1）报文段不能携带数据，但是要消耗一个序号。这时客户机A进入同步已发送状态（SYN-SENT）。</li><li>B收到连接请求的报文段后，如果同意建立连接，则向A发送确认。在确认报文段中应当把SYN和ACK的值都置为1，确认号是ack = x + 1，同时也为自己初始化一个序号seq = y。注意该报文也不能携带数据，但是需要消耗掉一个序号。此时TCP服务器进程进入同步收到状态（SYN-RCVD）。</li><li>TCP客户进程收到服务器端的确认后，还要想B发送确认。报文段的ACK置为1，确认号ack = y + 1，而自己的序号为seq = x + 1。TCP的标准规定，ACK报文段可以携带数据，如果不携带数据则不消耗序号，在这种情况下，下一个报文段的序号仍是seq = x + 1.这时TCP连接已经建立，此时A已经进入ESTABLISHED状态。当B收到确认后，也进入ESTABLISHED状态。</li></ul><p>至此，A与B已经建立连接，我们称作“三报文握手”或者“三次握手”。</p><h2 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h2><p>当数据传输结束后，通信的上方都可以释放连接。现在A和B都处于ESTABLISHED状态。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP连接释放.png-hexo.png" alt="运输层-TCP连接释放"></p><ul><li>A的应用进程先向其TCP发出连接释放报文段，然后停止发送数据，主动关闭TCP连接。A的连接释放报文段把FIN置为1，其序号为seq = u，它等于前面已传送过的最后一个字节的序号加1。此时A进入FIN-WAIT-1状态，等待B的确认。TCP规定，FIN不携带数据，但是要消耗掉一个序号。</li><li>B收到连接释放报文段后向A发出确认，确认号是ack = u + 1,这个报文段自己的序号是v，等于B前面已传送数据的最后一个字节的序号加1。然后B进入CLOSE-WAIT状态。TCP服务器进程这时通知高层应用进程，因而从A到B这个方向的连接就释放了，这时TCP的连接处于半关闭状态，即A已经没有数据向B发送了，但是若B仍要发送数据，A依旧要接受。也就是说从B到A这个方向的连接并未关闭。</li><li>A收到来自B的报文段后进入FIN-WAIT-2状态，等待B的连续释放报文。</li><li>如果B已经没有数据向A发送了，其应用进程就会通知TCP释放连接。这时B发送连续确认报文段必须使FIN = 1，现在B的序号为w（在半关闭状态，B可能又发送了一段数据）B还必须重复已经发送过的确认号ack = u + 1。这时B进入了LAST-ACK状态，等待A的确认。</li><li>A在收到B的报文段后进行确认，其确认号为w + 1（TCP规定，FIN报文段需要消耗一个序号），其自己的序号为seq = u + 1。然后进入到TIME-WAIT状态。这时需要注意的是TCP连接还没有释放掉，必须经过时间等待计时器（TIME-WAIT timer）设置的2MSL（Maximum Segment Lifetime）,A才进入关闭状态。MSL叫做最大报文段寿命。</li></ul><p>上述的TCP的释放过程我们称为“四报文握手”或者“四次挥手”。</p><h2 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h2><p><img src="https://img.wshunli.com/计算机基础-计算机网络/5/运输层-TCP有限状态机.png-hexo.png" alt="运输层-TCP有限状态机"></p><p>可以非常清楚地看出 TCP 连接各种状态之间的关系。</p><ul><li>粗实线箭头表示客户机进程的正常变迁。</li><li>粗虚线箭头表示服务器进程的正常变迁。</li><li>细虚线表示异常变迁。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;计算机网络-运输层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（四）</title>
    <link href="http://www.wshunli.com/2017/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/06/计算机基础-计算机网络（四）/</id>
    <published>2017-10-06T12:00:33.000Z</published>
    <updated>2017-10-09T13:46:31.568Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --><p><strong>计算机网络-网络层</strong> 部分读书笔记<a id="more"></a></p><p>网络层向上只提供简单灵活的、无连接、尽最大努力交付的数据报（IP数据报或分组）服务。</p><h1 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议 IP"></a>网际协议 IP</h1><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP （Address Resolution Protocol）</li><li>网际控制报文协议 ICMP （Internet Control Message Protcol）</li><li>网际组管理协议 IGMP （Internet Group Management Protcol）</li></ul><p>逆地址转换协议 RARP（Reverse Address Resolution Protocol），已淘汰。</p><h2 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h2><p>虚拟互联网就是各种异构的网络逻辑上的互联网络。</p><p>具体连接各异构网络的中间设备如下:<br>物理层：网卡，网线，集线器，中继器，调制解调器<br>链路层：网桥，交换机<br>网络层：路由器<br>运输层及其以上：网关</p><h2 id="IP地址的编址方法"><a href="#IP地址的编址方法" class="headerlink" title="IP地址的编址方法"></a>IP地址的编址方法</h2><p>IP地址的编址方法经历了三个阶段：分类的 IP 地址、子网的划分、构成超网。</p><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><p>IP地址 = 网络号 + 主机号</p><p>IP 地址分为五类：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-IP地址分类.png-hexo.png" alt="网络层-IP地址分类"></p><ul><li>A 类 网络号总数：2^7 - 2 主机号总数：2^24 - 2</li><li>B 类 网络号总数：2^14 - 1 主机号总数：2^16 - 2</li><li>C 类 网络号总数：2^21 - 1 主机号总数：2^8 - 2</li></ul><p>注意：</p><ul><li>主机号全为 0 代表本主机所在的网络地址，全为 1 代表该网络的所有主机所有主机。</li><li>A 类网络号全为 0 为保留地址，意思是本网络，网络号 127 (例如 127.0.0.1) 为本地软件环回测试地址。</li><li>B类、C类网络号全为 0 (128.0.0.0、192.0.0.0) 不指派，主机号要减去全为 0 ，全为 1 的。</li></ul><h3 id="子网的划分"><a href="#子网的划分" class="headerlink" title="子网的划分"></a>子网的划分</h3><p><strong>1.</strong> 从二级 IP 地址到三级 IP 地址</p><p>IP地址 = 网络号 + 主机号 》》 IP地址 = 网络号 + 子网号 + 主机号</p><p><strong>划分子网的思路</strong>：</p><ol><li>可将物理网络划分为若干子网，对外仍然表现为一个网络</li><li>划分方法是从主机号借用若干位作为子网号</li><li>从其他网络发到路由器过程没有变化，但是路由器收到 IP 数据报后，再按照目的网络号和子网号，把 IP 数据报交付目的主机。</li></ol><p><strong>2.</strong>子网掩码</p><p>路由器根据子网掩码把 IP 数据报转发到子网。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-子网掩码.png-hexo.png" alt="网络层-子网掩码"></p><p>子网掩码和 IP 地址逐位“与”运算，得到子网的 IP 地址。</p><p><strong>默认</strong>子网掩码</p><p>在不划分子网时，该网络的子网掩码就是默认网掩码。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-默认子网掩码.png-hexo.png" alt="网络层-默认子网掩码"></p><p>以 B 类地址为例，子网号没有 0、1、15、16 长度，划分子网要全为 0 和全为 1 的情况。</p><h3 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h3><p>无分类编址 CIDR （构造超网）</p><p><strong>1.</strong> 取消传统 A、B、C 类地址及划分子网的概念<br>IP 地址 = 网络前缀 + 主机号</p><p><strong>2.</strong> CIRD 把网络前缀相同的连续 IP 地址组成一个 <strong>CIRD地址块</strong> 。<br>CIRD 记法： 128.14.35.7/20<br><strong>/20</strong> 代表网络前缀位数20位。</p><p>CIRD 使用32位的地址掩码（子网掩码），在CIRD记法中，<strong>/20</strong> 代表子网掩码 1 的个数。</p><h2 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h2><p>IP 数据报的完整格式</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-IP数据报.png-hexo.png" alt="网络层-IP数据报"></p><p>IP 数据报 = 首部 （固定长度+可选字段）+ 数据</p><p>更多信息查看百度百科: <a href="https://baike.baidu.com/item/IP%E6%95%B0%E6%8D%AE%E6%8A%A5" rel="external nofollow noopener noreferrer" target="_blank">IP数据报</a></p><h2 id="IP-层转发分组流程"><a href="#IP-层转发分组流程" class="headerlink" title="IP 层转发分组流程"></a>IP 层转发分组流程</h2><p>转发分组研究的是分组怎样从一个路由器到另一个路由器的问题。</p><ul><li>IP数据报最终一定可以找到目的主机所在目的网络上的路由器(可能要通过多次的间接交付)。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ul><p>在互联网上转发分组时，是从一个路由器转发到下一个路由器。在路由表中，对每一条路由最主要的是以下两个信息：（目的网络地址，下一跳地址）。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-路由表.png-hexo.png" alt="网络层-路由表"></p><h3 id="转发分组算法"><a href="#转发分组算法" class="headerlink" title="转发分组算法"></a>转发分组算法</h3><p>(1) 从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。<br>(2) 若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付给目的主机（这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧）；否则就要执行(3)进行间接交付。<br>(3) 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(4)。<br>(4) 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(5)。<br>(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(6)。<br>(6) 报告转发分组出错。</p><p>由此可见，在IP数据报的首部并没有指明下一跳路由器的IP地址，在IP数据报的首部只有源IP地址和目的IP地址。<br>转发分组是基于目的主机所在的网络，路由表也没有具体指明到某个网络的完整路径。</p><h3 id="划分子网后的分组转发"><a href="#划分子网后的分组转发" class="headerlink" title="划分子网后的分组转发"></a>划分子网后的分组转发</h3><p>划分子网后，路由表中包含：目的网络地址、子网掩码、下一跳地址。</p><p>(1) 从收到的分组的首部提取目的IP地址 D。<br>(2) 先用各网络的子网掩码和D逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。<br>(3) 若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4)。<br>(4) 对路由表中的每一行的子网掩码和D逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)。<br>(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。<br>(6) 报告转发分组出错。</p><h1 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h1><h2 id="IP-地址与-MAC-地址"><a href="#IP-地址与-MAC-地址" class="headerlink" title="IP 地址与 MAC 地址"></a>IP 地址与 MAC 地址</h2><p>MAC 地址是链路层和物理层使用的地址。<br>IP 地址是网络层积以上各层使用的地址。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-IP地址和MAC地址.png-hexo.png" alt="网络层-IP地址和MAC地址"></p><h2 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h2><p>地址解析协议 ARP 根据 IP 地址寻找相应的硬件地址。</p><p>ARP 的原理是 每台主机都有一个 ARP 高速缓存，存储本局域网的所有主机的IP地址和硬件地址的映射表。</p><ul><li>当主机A向局域网内的其他主机B发送 IP 数据报时，从ARP高速缓存中取出B的物理地址即可。</li><li>如果缓存中不存在B的物理地址，则发送ARP请求分组（广播），B接收到分组发送ARP响应分组（单播），并在B的高速缓存中存储A的IP地址和物理地址。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-ARP工作原理.png-hexo.png" alt="网络层-ARP工作原理"></p><p>ARP 解决的是<strong>局域网</strong>上主机或者路由器 IP 与物理地址的映射问题。如果两主机在同一局域网，则通过路由器解决。</p><p>RARP 逆地址解析协议，根据硬件地址查询 IP 地址。现在被包含在 DHCP 中。</p><h1 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h1><p>为了更有效地转发 IP 数据报和提高交付成功的机会。</p><p>ICMP 报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去。<br><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-ICMP数据报.png-hexo.png" alt="网络层-ICMP数据报"></p><p>类型分为 ICMP 差错报告报文和 ICMP 询问报文。<br><img src="https://img.wshunli.com/计算机基础-计算机网络/4/网络层-ICMP数据报分类.png-hexo.png" alt="网络层-ICMP数据报分类"></p><p>用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，令管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。它与传输协议最大的不同：它一般不用于在两点间传输数据，而常常用于返回的错误信息或是分析路由。</p><p>ICMP控制的内容包括但不仅限于：echo响应（ping）、目标网络不可达、目标端口不可达、禁止访问的网络、拥塞控制、重定向、TTL超时…</p><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><p>在Internet的概念中，将整个互联网划分为许多个小的自治系统（AS）。<br>AS的最主要的特征：一个AS对其他AS表现出的是一个单一和一致的路由选择策略。</p><p>路由选择协议分为两类：</p><ul><li>内部网关协议 IGP：在一个AS内部使用的路由选择协议，而这与互联网中其他AS选用什么路由协议无关。例如：RIP、OSPF协议。</li><li>外部网关协议 EGP：若源主机和目的主机不再同一个AS中，就需要使用一种协议将路由选择信息传递到另一个AS中，这就是EGP。例如：BGP协议。</li></ul><h2 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h2><p>RIP （路由信息协议）属于内部网关协议（IGP）的一种，是一种基于距离向量的路由选择协议。<br>RIP 仅和相邻路由、按固定时间、交换本路由知道的所有信息。</p><h2 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h2><p>OSPF 属于内部网关协议（IGP）的一种，基于 Dijkstra 提出的最短路径算法。</p><p>OSPF提出了“区域（Area）”的概念，一个网络可以由单一区域或者多个区域组成。<br>其中，一个特别的区域被称为骨干区域（Backbone Area），该区域是整个OSPF网络的核心区域，并且所有其他的区域都与之直接连接。<br>所有的内部路由都通过骨干区域传递到其他非骨干区域。<br>所有的区域都必须直接连接到骨干区域，如果不能创建直接连接，那么可以通过虚拟链路（Virtual-link）和骨干区域创建虚拟连接。</p><h2 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h2><p>BGP 属于外部网关协议（EGP）的一种。</p><p>由于BGP是工作在AS之间的协议，并且各个AS的情况复杂，所以 BGP只是力求找到一个可以到达目的网络且比较好的路由，而并不是寻找一条最佳路由。<br>每一个AS都应该有一个“BGP发言人”，一般来说，两个BGP发言人是通过一个共享网络连接在一起的，BGP发言人往往是BGP边界路由，但也可以不是。<br>一个BGP发言人与其他AS的BGP发言人要交换路由信息，首先要建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话。当BGP发言人交换了路由信息后，就构造自治系统连通图，最后通过该图来进行路由选择。</p><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>IPv6二进位制下为128位长度，以16位为一组，每组以冒号“:”隔开，可以分为8组，每组以4位十六进制方式表示。<br>例如：2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的IPv6地址。</p><p>IPv6 地址分为：</p><ul><li>单播：点对点通信</li><li>多播：一对多通信，数据发送到一组计算机的每一个。</li><li>任播：终点是一组计算机，但数据只发给其中的一个，通常是最近的一个。</li></ul><p>IPv4向IPv6过渡采用双协议栈、隧道技术等。</p><h1 id="地址转换协议-NAT"><a href="#地址转换协议-NAT" class="headerlink" title="地址转换协议 NAT"></a>地址转换协议 NAT</h1><p>NAT 是一种在 IP数据报 通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。<br>这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。</p><h1 id="多协议标记交换-MPLS"><a href="#多协议标记交换-MPLS" class="headerlink" title="多协议标记交换 MPLS"></a>多协议标记交换 MPLS</h1><p>MPLS是利用标记（label）进行数据转发的。当分组进入网络时，要为其分配固定长度的短的标记，并将标记与分组封装在一起，在整个转发过程中，交换节点仅根据标记进行转发。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;计算机网络-网络层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（三）</title>
    <link href="http://www.wshunli.com/2017/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/05/计算机基础-计算机网络（三）/</id>
    <published>2017-10-05T06:55:39.000Z</published>
    <updated>2017-10-07T13:13:20.770Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p><strong>计算机网络-数据链路层</strong> 部分读书笔记<a id="more"></a></p><h1 id="链路层的基本概念"><a href="#链路层的基本概念" class="headerlink" title="链路层的基本概念"></a>链路层的基本概念</h1><p>数据链路层属于计算机网络的低层。链路层使用的信道可分为<strong>点对点信道（PPP）</strong>和<strong>广播信道（CSMA/CD）</strong>两种。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层的地位.png-hexo.png" alt="数据链路层的地位"></p><h1 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h1><p><strong>链路</strong> 是两结点间的一段物理线路，中间没有其他交换结点。物理链路。<br><strong>数据链路</strong> 是链路 + 通信协议。逻辑链路。</p><p><strong>帧</strong> – 点对点信道的数据链路层的协议数据单元。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-三层简化模型.png-hexo.png" alt="数据链路层-三层简化模型"></p><p>数据链路层把网络层交换来的数据构成帧发送到链路上，以及把接受的帧中的数据上交给网络层。</p><p>点对点信道的数据链路层进行通信的主要步骤如下：</p><ol><li>结点A的数据链路层把网络层下发的IP数据报添加首部和尾部封装成帧；</li><li>结点A把封装好的帧发给结点B的数据链路层；</li><li>结点B收到的帧若无差错，则提取出IP数据报给网络层，否则丢弃这个帧。</li></ol><h2 id="链路层基本问题"><a href="#链路层基本问题" class="headerlink" title="链路层基本问题"></a>链路层基本问题</h2><ul><li>封装成帧</li></ul><p>链路层将网络层传下来的IP数据报添加首部（SOH）和尾部（EOH）封装成帧，这样接收端在收到物理层上交的比特流后就能根据首尾标记知道帧的开始与结束。首位和尾部的主要作用就是进行帧定界（确定帧的界限），同时还包含一些控制信息。</p><ul><li>透明传输</li></ul><p>表示无论什么样比特组合的数据都能够通过这个数据链路层，而不会因为比特流中还有特定的帧结束或开始标志而发生传输差错。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-透明传输.png-hexo.png" alt="数据链路层-透明传输"></p><p>防止因传输的数据（EOT）中出现尾部控制字符而提前结束。解决办法是添加转义字符（ESC）。</p><ul><li>差错检测</li></ul><p>现实的通信链路不可避免会产生比特差错，即会有一定误码率（BER），这个和信道的信噪比有关系。为了保证数据传输可靠性，加入了一些差错检测措施，例如循环冗余检错技术（CRC）。</p><p>在数据链路层进行差错校验就需要将数据划分为帧，每一帧都加上冗余码，一帧一帧地传送和校验。但是这样只能保证帧无差错传输（无比特差错），无法保证帧丢失、重复或失序等（无传输差错）情况发生。</p><h1 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h1><p>用户通常要连接到某个ISP（Internet Service Provider）才能接入因特网。PPP协议则是用户与ISP通信时使用的数据链路层协议。</p><p>PPP协议主要由三个部分组成：</p><ol><li>一个将IP数据报封装到串行链路的方法。</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议 LCP（Link Control Protocol）。</li><li>一套网络控制协议 NCP（Network Control Protocol），其中每个协议支持不同的网络层协议。</li></ol><p>PPP协议的工作状态：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-PPP协议状态.png-hexo.png" alt="数据链路层-PPP协议状态"></p><h1 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h1><p>广播信道可以进行一对多的通信。</p><h2 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h2><p>局域网为一个单位所有，并且地理范围和站点数量有限。按照网络拓扑分类如下：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-局域网网络拓扑分类.png-hexo.png" alt="数据链路层-局域网网络拓扑分类"></p><p>局域网的总线网中以太网最为著名。</p><p>适配器负责计算机与外界局域网通信，即“网卡”。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-网络适配器.png-hexo.png" alt="数据链路层-网络适配器"></p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection)。<br>这个协议有几个要点：</p><ul><li>多点接入：总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是载波监听和碰撞检测。</li><li>载波监听：发送前监听。即不管是在发送前，还是在发送中，每个站总是不停地检测总线上是否有其他站在发送数据，等信道空闲才发送。</li><li>碰撞检测：适配器边发送边监听。以便判断自己发送数据时，是否也有其他站在发送数据。如果同时多个站发送数据，总线上的传输信号会电压会增大。发生碰撞时，适配器就会立即停止发送，等一段随机时间后再次发送。</li></ul><h2 id="使用集线器的星型拓扑"><a href="#使用集线器的星型拓扑" class="headerlink" title="使用集线器的星型拓扑"></a>使用集线器的星型拓扑</h2><p>集线器的特点如下：</p><ul><li>使用集线器的以太网在逻辑上仍是个总线网，各站共享逻辑上的总线，各站使用的还是CSMA/CD协议。</li><li>一个集线器有许多接口，像一个多接口的转发器。</li><li>集线器工作在物理层，每个接口仅简单的转发比特，不进行碰检测。</li><li>自适用串音回波抵消，即接口转发的较强信号对接收的较弱信号没有干扰。</li></ul><h2 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h2><p>MAC 层的硬件地址</p><p>硬件地址又叫物理地址、MAC地址，是主机中固化在适配器 ROM 中的地址。</p><p>适配器有过滤功能。当适配器收到 MAC 帧的时会先检查帧中的目的地址，是发往本站的就接收，否则就丢弃。</p><p>发往本站的帧有三种：单播（一对一）、广播（一对全部）、多播（一对多）。</p><p>MAC 帧的格式</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-MAC帧格式.png-hexo.png" alt="数据链路层-MAC帧格式"></p><p>首部没有帧长度、尾部是帧检验序列 FCS 。</p><h1 id="拓展的以太网"><a href="#拓展的以太网" class="headerlink" title="拓展的以太网"></a>拓展的以太网</h1><ul><li>在物理层拓展以太网</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/3/数据链路层-物理层拓展以太网.png-hexo.png" alt="数据链路层-物理层拓展以太网"></p><p>优点是扩大了以太网覆盖的地理范围，缺点是当某个系的两站通信时所传送的数据会通过所有的集线器转发，其他系内部在这时都不能通信。</p><ul><li>在链路层拓展以太网</li></ul><p>通过以太网交换机实现，实质是多接口的网桥。<br>具有并行性，相互通信的主机都是独占传输媒体，无碰撞得传输数据。<br>通过自学习建立帧交换表，按照帧目的 MAC 转发，即插即用。</p><ul><li>虚拟局域网</li></ul><p>虚拟局域网 VLAN，是由一些网段构成的与物理位置无关的逻辑组。在 VLAN 中的帧都有明确的标识符，指明该帧属于哪个 VLAN。</p><h1 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h1><ul><li>100BASE-T 以太网（百兆以太网）</li><li>吉比特以太网（千兆以太网）</li><li>10吉比特以太网（万兆以太网）</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;计算机网络-数据链路层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（二）</title>
    <link href="http://www.wshunli.com/2017/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/04/计算机基础-计算机网络（二）/</id>
    <published>2017-10-04T12:58:39.000Z</published>
    <updated>2017-10-07T13:19:05.830Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p><strong>计算机网络-物理层</strong> 部分读书笔记<a id="more"></a></p><h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是具体的传输媒体。<br>物理层的作用就是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这种差异。<br>物理层的主要任务是确定与传输媒体接口相关的一些特性，即：</p><ul><li>机械特性，指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li><li>电气特性，指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性，指明某条线上出现的某一电平的电压表示何意。</li><li>过程特性，规程特性 指明对于不同功能的各种可能事件的出现顺序。</li></ul><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><p><strong>信道</strong> 是向某一方向发送信息的媒体。可分为三种基本方式：</p><ul><li>单向通信，单工，只能从一个方向到另一个方向。</li><li>双向交替通信，半双工，双方都可以接收和发送，但不能同时发送。</li><li>双向同时通信，全双工，可以同时发送信息，也可以同时接受信息。</li></ul><p>单项通信只需要一条信道，其余两种需要两条信道。</p><h2 id="物理层下的传输媒体"><a href="#物理层下的传输媒体" class="headerlink" title="物理层下的传输媒体"></a>物理层下的传输媒体</h2><p>传输媒体也称传输媒介或传输介质，数据传输系统中在发送器和接收器之间的物理通路。</p><ul><li>引导型传输媒体：双绞线、同轴电缆、光纤等</li><li>非引导型传输媒体：无线电微波、卫星通信等</li></ul><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p><strong>信道复用技术</strong>就是使用复用器和分用器将原本需要多个信道传输的信息通过单个信道传输。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-信道复用技术.png-hexo.png" alt="物理层-信道复用技术"></p><ul><li>频分复用（FDM）：不同的用户分配不同的频带。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-频分复用.png-hexo.png" alt="物理层-频分复用"></p><ul><li>时分复用（TDM）及统计时分复用（STDM）：</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-时分复用.png-hexo.png" alt="物理层-时分复用"></p><p>TDM 每个用户周期性占用信道。但是用户暂无数据时，信道利用率不高：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-时分复用弊端.png-hexo.png" alt="物理层-时分复用弊端"></p><p>STDM 用户没有数据就跳过，动态分配时序。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-统计时分复用.png-hexo.png" alt="物理层-统计时分复用"></p><ul><li>波分复用（WDM）：针对光纤的频分复用。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-波分复用.png-hexo.png" alt="物理层-波分复用"></p><ul><li>码分复用（CDM）：码分多址，不同的用户采用不同的码型。</li></ul><p><img src="https://img.wshunli.com/计算机基础-计算机网络/2/物理层-码分复用.png-hexo.png" alt="物理层-码分复用"></p><p>感觉前两种侧重于模拟信号，后两种侧重于数字信号。</p><h1 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h1><ul><li>ADSL 技术，非对称数字用户线。模拟电话用户线基础上。</li><li>HFC 网，光纤同轴混合网。有线电视网基础上。</li><li>FTTx 技术，包括光纤到路边（FTTC）、光纤到大楼（FTTB）及光纤到户（FTTH）等等。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;计算机网络-物理层&lt;/strong&gt; 部分读书笔记
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础-计算机网络（一）</title>
    <link href="http://www.wshunli.com/2017/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/10/03/计算机基础-计算机网络（一）/</id>
    <published>2017-10-03T06:43:34.000Z</published>
    <updated>2017-10-09T12:57:29.131Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p><strong>具备扎实的数据结构和计算机系统基础，编码功底扎实</strong><a id="more"></a></p><p>现在应该为找工作做准备了，先打好计算机基础吧。<br>这也算是《计算机网络》的读书笔记吧。</p><h1 id="互联网相关概念"><a href="#互联网相关概念" class="headerlink" title="互联网相关概念"></a>互联网相关概念</h1><p><strong>网络</strong>分为电信网络、有线电视网络、计算机网络。<br><strong>互联网</strong>（Internet）是一个专有名词，指当今世界上最大的计算机网络。<br><strong>互连网</strong>（internet）是一个通用名词，泛指多个计算机网络互连而形成的计算机网路，即“网络的网络”。</p><p><strong>计算机网络</strong>由若干结点和链路组成。经历了三个发展阶段：</p><ul><li>第一分阶段是从单一网络 ARPANET 向互连网发展的过程；</li><li>第二个阶段是建成了三级结构的互联网，分为主干网、地区网和校园网（或企业网）；</li><li>第三个阶段是多层次 ISP （网络服务提供商） 结构的互联网。</li></ul><h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><p>互联网从工作方式上来看，客户分为两部分：</p><ul><li>边缘部分，用户直接使用的；</li><li>核心部分，为边缘部分提供服务的。</li></ul><p><strong>互联网的边缘部分</strong>就是连接到互联网上的所有主机，又称为端系统。</p><p>计算机之间的通信，即主机A的某个进程和主机B的另一个进程进行通信，进程就是指运行着的程序。<br>在网络边缘的端系统之间的通讯方式分为两类，客户/服务器方式（C/S方式）和对等方式（P2P方式），<br>认为浏览器/服务器方式（B/S）是C/S的一种特例。</p><p><strong>互联网的核心部分</strong>向网络边缘的主机提供连通性，使任何一台主机都能向其他主机通信。</p><p>分组交换采用存储转发技术，把一个报文划分为几个分组后再进行传送。<br>在发送整块数据之前，先把整块数据分为等长的数据段，在每段数据段前加上由一些必要信息组成的首部，就构成了一个分组。 报文（message）是发送的整块数据；分组（packet）又称为包，分组的首部也叫包头。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/1/分组交换.png" alt="互联网的组成-分组交换"></p><h1 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h1><p>从网的作用范围来看，可分为：</p><ul><li>广域网（Wide Area Network，WAN）</li><li>城域网（Metropolitan Area Network，MAN）</li><li>局域网（Local Area Network，LAN）</li><li>个人区域网（Personal Area Network，PAN）</li></ul><h1 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h1><p>1.<strong>速率</strong>，数据的传送速率，或称数据率、比特率,单位 bit/s。<br>比特（binary digit，bit），二进制数字的 0 或 1 。<br>字节（byte，B），通常 1B = 8bit 。</p><p>2.<strong>带宽</strong>（bandwidth），即速率。</p><p>3.<strong>吞吐量</strong>（throughup），单位时间通过某网络（或信道、接口）的实际数据量。</p><p>吞吐量受网络的带宽和网络的额定速率的限制。</p><p>4.<strong>时延</strong> ，数据从网络的一端传送到另一端的时间，也称为延迟、迟延。<br>由以下几部分组成：</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/1/计算机网络性能-时延.png" alt="计算机网络性能-时延"></p><ul><li>发送延时，主机或者路由器发送数据帧所需要的时间。</li><li>传播时延，电磁波在信道中传播一段距离所需要的时间。</li><li>处理时延，主机或路由器收到分组后的处理时间。</li><li>排队时延，分组进入路由器后要在输入队列中排队等待处理。</li></ul><p><strong>总时延 = 发送延时 + 传播延时 + 处理延时 + 排队延时。</strong></p><p>5.<strong>时延带宽积</strong>，传播时延和带宽的乘积，代表链路的容纳多少比特。</p><p>6.<strong>往返时间</strong> RTT ，数据双向交互一次所需的时间。</p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><strong>OSI/RM</strong> (Open System Interconnect 简称OSI) 开放系统互连参考模型 是国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><p><strong>TCP/IP</strong> (Transmission Control Protocol/Internet Protocol，简称TCP/IP) 传输控制协议/因特网互联协议 是四层结构。它从低到高分别是：网络接口层、网际层、传输层和应用层。</p><p>学习计算机网络采用折中的方法，具有五层协议的体系结构。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/1/计算机网络体系结构.png-hexo.png" alt="计算机网络体系结构"></p><p><strong>(1)应用层</strong> 是应用进程间通信交互的规则。对于不同的网络应用采用不同的协议，如 DNS、HTTP、SMTP 等。</p><p><strong>(2)运输层</strong> 是两主机进程间通信的通用数据传输服务。“通用”指不针对某个特定网络应用，多种应用可以使用同一个运输层服务。运输层具有复用和分用的功能。传输层有两种协议：</p><p><strong>传输控制协议</strong> TCP（Transmission Control Protocol）提供面向链接的、可靠的数据传输服务，传输单位是报文段（Segment）。<br><strong>用户数据报协议</strong> UDP（User Datagram Protocol）提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），传输单位是用户数据报。</p><p><strong>(3)网络层</strong> 负责为分组交换网上的不同主机提供通信服务。在发送数据时将网络层的数据封装成分组或包进行传送。在 TCP/IP 协议中，网络层使用IP协议，因此分组也叫 IP 数据报，简称数据报。无论在哪层传送的数据单元，都可成为分组。</p><p><strong>(4)数据链路层</strong> 数据在链路上传送的协议。两节点传递数据时，链路层将网络层的 IP 数据报组装成帧（framing），在两个相邻节点间的链路上传递帧（frame）。</p><p><strong>(5)物理层</strong> 传递数据的单位是比特。例如考虑多大电压是 1 或 0 ，以及如何识别，电线插头的引脚数以及引脚如何连接等属于物理层的范围。传递信息的媒介，如双绞线、光纤等不在物理层，有人称之为 0 层。</p><p><strong>TCP/IP 的体系结构</strong> 并不是严格遵守 OSI 分层的概念。</p><p><img src="https://img.wshunli.com/计算机基础-计算机网络/1/TCP_IP体系结构.png-hexo.png" alt="TCP/IP体系结构"></p><p>TCP/IP 可以为各式各样的应用提供服务，同时也允许协议在各式各样的网络构成的互联网上运行。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;具备扎实的数据结构和计算机系统基础，编码功底扎实&lt;/strong&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://www.wshunli.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机网络" scheme="http://www.wshunli.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（二）</title>
    <link href="http://www.wshunli.com/2017/09/19/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF%EF%BC%8C%E4%B8%8D%E5%8F%AF%E8%87%AA%E6%8B%94%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/09/19/沉迷学术，不可自拔（二）/</id>
    <published>2017-09-19T12:18:43.000Z</published>
    <updated>2017-10-07T14:01:31.896Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p>&nbsp;&nbsp;&nbsp;&nbsp;这阵子应该是比较消极的一阵了<a id="more"></a>，八月底放假了但是没回家，基本还是学习为主。基本刷了一遍 jQuery 的教程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Android 方面尝试了 Google VR SDK for Android 做全景应用，也开发了 Demo 。本来是希望能用在壁纸上，但是遇到问题了。后面打算用 GLWallpaperService 用 OpenGL ES 渲染，不过感觉可能性不大。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;开学事情挺多的，报道、开学典礼、选课挺折腾人的。论文没过又投了下，希望能过。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;现在干活基本没什么动力了，每天上课心力憔悴，基本都是摄影测量遥感相关的课程。宿舍距离学校又有段距离，每次上课都不想来，来了不想回宿舍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;感觉还是本科好点，干的都是自己喜欢想做的事。现在这都跟打杂差不多，啥都干。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这阵子应该是比较消极的一阵了
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>NullPointerException</title>
    <link href="http://www.wshunli.com/2017/09/01/NullPointerException/"/>
    <id>http://www.wshunli.com/2017/09/01/NullPointerException/</id>
    <published>2017-09-01T11:03:25.000Z</published>
    <updated>2017-09-19T12:22:03.613Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>NullPointerException</strong>是 java.lang.NullPointerException 的简称<a id="more"></a>，是 Java 语言中的一个异常类，位于 java.lang 包中，父类是 java.lang.RuntimeException ，该异常在源程序中可以不进行捕获和处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当应用程序试图在需要对象的地方使用 null 时，抛出该异常。这种情况包括：</p><ul><li>调用 null 对象的实例方法。</li><li>访问或修改 null 对象的字段。</li><li>如果一个数组为 null，试图用属性 length 获得其长度时。</li><li>如果一个数组为 null，试图访问或修改其中某个元素时。</li><li>在需要抛出一个异常对象，而该对象为 null 时。</li><li>应用程序将会抛出 NullPointerException 类的实例，表明其他对 null 对象的非法使用。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;NullPointerException&lt;/strong&gt;是 java.lang.NullPointerException 的简称
    
    </summary>
    
    
      <category term="NullPointerException" scheme="http://www.wshunli.com/tags/NullPointerException/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（一）</title>
    <link href="http://www.wshunli.com/2017/08/20/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF%EF%BC%8C%E4%B8%8D%E5%8F%AF%E8%87%AA%E6%8B%94%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.wshunli.com/2017/08/20/沉迷学术，不可自拔（一）/</id>
    <published>2017-08-20T02:59:23.000Z</published>
    <updated>2017-10-06T06:50:17.371Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p>“城外的人想冲进去，城里的人想逃出来。”<br><a id="more"></a></p><p>来武汉一个月了，相比较而言可能我还算比较幸运，至少没有到“帮老师办签证订机票”的地步。</p><p>刚来到做的是前端的项目，其实真是没有一点经验，前面只是能看懂一点代码，并没怎么系统地学习。<br>做Javastript也是可以的，后面做Rect Native等跨平台开发也是有帮助的。</p><p>前端的东西太多了，现在还没学好，实际帮助也不多。</p><p>后来又写了一点Node.js的东西，主要是利用Egg.js对Mongodb进行增删查改 CURD 操作，现在反正已经趟了一趟浑水了。最大的收获就是对网络的一些基础知识的理解，虽然考了计算机三级，然而并没有什么卵用。</p><p>中间写了一篇论文投到测绘科技了，感觉中的可能性不大，太简单了。<br>使用DataV做了一点可视化，但是感觉限制太多，字段太少了。</p><p>现在还有一点时间，在学 Android ,希望能进阶下。</p><p>武汉的空气不错，蓝蓝的天下白云飘。</p><p>有时候在想，是读研好还是工作好呢。这个问题似乎也没有什么意义了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;“城外的人想冲进去，城里的人想逃出来。”&lt;br&gt;
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>毕业感想</title>
    <link href="http://www.wshunli.com/2017/07/07/%E6%AF%95%E4%B8%9A%E6%84%9F%E6%83%B3/"/>
    <id>http://www.wshunli.com/2017/07/07/毕业感想/</id>
    <published>2017-07-07T02:52:52.000Z</published>
    <updated>2017-08-20T02:46:39.270Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p>&nbsp; &nbsp; &nbsp; &nbsp; 正如毕业论文致谢中所说： “回想四年来的学习生活，既有成功时的喜悦，也有失败时的痛楚。”</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 先看下我们那时吹过的牛逼，年少轻狂啊。</p><embed src="https://player.youku.com/player.php/sid/XNjM5MDkyMTY0/v.swf" allowfullscreen quality="high" width="800" height="450" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash"><p>&nbsp; &nbsp; &nbsp; &nbsp; 其实当时志愿报的通信工程，电气工程及其自动化，机械工程及其自动化等，最后调剂到地理信息科学专业。记得当时我跟学姐说我调剂了，学姐说，没准我可能喜欢这个专业，庆幸事实也是如此。我至今依然认为 GIS 专业是个很好的专业。和地理信息科学专业相比，我更喜欢 GIS 这个称谓，因为大多数听到地理信息科学老是认为我们是学地理的，事实我感觉 GIS 专业偏计算机更多一点。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 大一印象最深刻就是军训了，当时觉得也没啥，同样记得是学姐说，大学四年军训也是印象很深刻的一段回忆了。但是当时整个人都是懵逼的状态，谁也不知道谁，后来翻看照片。哦，原来这个是舍友啊。上学期还是比较浪的，去过河南省博物院、二七塔。我记得有一节课郭老师问，有谁去过河南省博物院，我们宿舍很骄傲啊。暑假的时候就去了陈老师的公司，也是很惬意，GIS 最基础的工作了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 大二就开始逃课了，也是当时对 GIS 有一点认识，算是启蒙吧。当时觉得 AR 很好，也了解一点。后来就跟着骆老师和赵老师参加ESRI的比赛，也是最开始接触 Android 开发。<a href="https://fir.im/zzumap" rel="external nofollow noopener noreferrer" target="_blank">https://fir.im/zzumap</a>. 至今非常感谢刘学长的指导。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我觉得大三是成长最快的一年，包括学习以及其他方面。知道自己该做什么，不该做什么，不至于一天到无所事。下学期也非常荣幸能跟着李老师做项目，也给了我很多机会。后来我发现，其实原来在大一暑假的时候参加比赛分组，李老师就联系过我，只不过我当时去陈老师的公司了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 大四也就是考研了，这也没有啥，有好基友在一块，只要能坚持下来就好了。毕业了，各奔东西。有人月薪2000，有人月薪8000+，年薪20万也有人在。开心就好。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 有些事我知道，有些事我不知道。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 现在大概走在通往全栈的不归路上，沉迷学术，不可自拔。一直觉得大学四年了得留一段文字记录下，防止以后忘了，今天终于如愿。</p><p></p><p style="text-align:right">2017年7月30日于武汉大学信息学部</p>​​​​<p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 正如毕业论文致谢中所说： “回想四年来的学习生活，既有成功时的喜悦，也有失败时的痛楚。”&lt;/p
      
    
    </summary>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>论文查重删除部分文章</title>
    <link href="http://www.wshunli.com/2017/05/22/%E8%AE%BA%E6%96%87%E6%9F%A5%E9%87%8D%E5%88%A0%E9%99%A4%E9%83%A8%E5%88%86%E6%96%87%E7%AB%A0/"/>
    <id>http://www.wshunli.com/2017/05/22/论文查重删除部分文章/</id>
    <published>2017-05-22T12:50:25.000Z</published>
    <updated>2017-06-30T04:19:44.015Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --><a id="more"></a><p>毕业论文查重会涉及到网络查重，先删除部分文章。。</p><p>涉及到内容也不是很多，后面分享要注意啊，发过论文再写。</p><embed height="500" width="100%" quality="high" allowfullscreen type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=8720031&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:44 GMT+0800 (中国标准时间) --&gt;
    
    </summary>
    
      <category term="论文" scheme="http://www.wshunli.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文" scheme="http://www.wshunli.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>《ArcGIS Runtime SDK for Android学习笔记》-11、自定义扩展图层加载Google地图/高德地图并缓存</title>
    <link href="http://www.wshunli.com/2017/03/03/%E3%80%8AArcGIS-Runtime-SDK-for-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B-11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E5%9B%BE%E5%B1%82%E5%8A%A0%E8%BD%BDGoogle%E5%9C%B0%E5%9B%BE-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E5%B9%B6%E7%BC%93%E5%AD%98/"/>
    <id>http://www.wshunli.com/2017/03/03/《ArcGIS-Runtime-SDK-for-Android学习笔记》-11、自定义扩展图层加载Google地图-高德地图并缓存/</id>
    <published>2017-03-03T03:16:06.000Z</published>
    <updated>2017-10-08T05:07:09.934Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p><strong>本文主要介绍自定义扩展图层加载Google地图/高德地图并缓存</strong><br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上篇文章介绍了自定义扩展图层加载天地图并缓存，由于众所周知的原因，天地图并不一定能满足所有项目需要，并不一定符合实际国情，所以这篇文章介绍自定义扩展图层加载Google地图/高德地图，因为 Google地图（<a href="http://ditu.google.cn" rel="external nofollow noopener noreferrer" target="_blank">http://ditu.google.cn</a> ）/ 高德地图（<a href="http://ditu.amap.com" rel="external nofollow noopener noreferrer" target="_blank">http://ditu.amap.com</a> ）的坐标系比较符合“中国特色坐标系“。<br>事实上加载Google地图/高德地图和加载天地图类似，甚至前者还要更简单。</p><h2 id="Google-Map"><a href="#Google-Map" class="headerlink" title="Google Map"></a>Google Map</h2><p>瓦片地址：</p><p><code>http://mt2.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;x=420&amp;y=193&amp;z=9</code></p><p>核心代码如下：</p><pre><code class="java">@Overrideprotected byte[] getTile(int level, int col, int row) throws Exception {    if (level &gt; layerInfo.getMaxZoomLevel() || level &lt; layerInfo.getMinZoomLevel()) {        return new byte[0];    }    byte[] bytes = null;    if (cachePath != null)        bytes = getOfflineCacheFile(cachePath, level, col, row);    if (bytes == null) {        String url = &quot;http://mt&quot; + (col % 4) + &quot;.google.cn/vt/lyrs=&quot;                + layerInfo.getLayerName() + &quot;&amp;hl=zh-CN&amp;gl=cn&amp;&quot;                + &quot;x=&quot; + col + &quot;&amp;&quot; + &quot;y=&quot; + row + &quot;&amp;&quot; + &quot;z=&quot; + level;        Log.d(&quot;GoogleMapLayer&quot;, &quot;getTile: &quot; + url);        Map&lt;String, String&gt; map = null;        bytes = com.esri.core.internal.io.handler.a.a(url, map);        if (cachePath != null)            AddOfflineCacheFile(cachePath, level, col, row, bytes);    }    return bytes;}</code></pre><p>其中</p><pre><code class="java">String url = &quot;http://mt&quot; + (col % 4) + &quot;.google.cn/vt/lyrs=&quot;                    + layerInfo.getLayerName() + &quot;&amp;hl=zh-CN&amp;gl=cn&amp;&quot;                    + &quot;x=&quot; + col + &quot;&amp;&quot; + &quot;y=&quot; + row + &quot;&amp;&quot; + &quot;z=&quot; + level;</code></pre><p>可以更改为</p><pre><code class="java">String url = &quot;https://mt&quot; + (col % 4) + &quot;.google.com/vt/lyrs=&quot;                    + layerInfo.getLayerName() + &quot;&amp;hl=zh-CN&amp;gl=cn&amp;&quot;                    + &quot;x=&quot; + col + &quot;&amp;&quot; + &quot;y=&quot; + row + &quot;&amp;&quot; + &quot;z=&quot; + level;</code></pre><p>但是这个URL不太符合目前的中国的国情。</p><p><strong>按照惯例下面是我封装好的Jar包。</strong><br>Jar包下载地址：<a href="http://img.wshunli.com/ArcGISforAndroid/11/ArcGMap.jar" rel="external nofollow noopener noreferrer" target="_blank">ArcGMap.jar</a></p><p>使用方法：</p><pre><code class="java">GoogleMapLayer（TYPE，PATH）；</code></pre><p>TYPE：有一下三种类型可选<br>PATH：缓存路径{选填}，为空则不缓存。</p><pre><code class="java">package com.wshunli.map.arcgmap;/** * 项目：ArcGMap * 作者：WangShunli * 时间：2017/3/2 14:34 * 邮箱：admin@wshunli.com * 说明： */public interface  GoogleMapLayerTypes {    /**     * 谷歌矢量地图服务     */    final int VECTOR_GOOGLE_MAP = 1;    /**     * 谷歌影像地图服务     */    final int IMAGE_GOOGLE_MAP = 2;    /**     * 谷歌地形地图服务     */    final int TERRAIN_GOOGLE_MAP = 3;}</code></pre><p>示例代码：</p><pre><code class="java">GoogleMapLayer GOOGLE_VECTOR_Layer = new GoogleMapLayer(GoogleMapLayerTypes.VECTOR_GOOGLE_MAP,ZZMANHOLE_PATH + &quot;/GMapCacheDemo&quot;);</code></pre><h2 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h2><p>瓦片地址：</p><p><code>http://webst01.is.autonavi.com/appmaptile?style=6&amp;x=13417&amp;y=6499&amp;z=14</code></p><p>核心代码如下：</p><pre><code class="java">@Overrideprotected byte[] getTile(int level, int col, int row) throws Exception {    if (level &gt; layerInfo.getMaxZoomLevel() || level &lt; layerInfo.getMinZoomLevel()) {        return new byte[0];    }    byte[] bytes = null;    if (cachePath != null)        bytes = getOfflineCacheFile(cachePath, level, col, row);    if (bytes == null) {        String url = &quot;http://webst0&quot; + ((col + row) % 4 + 1) + &quot;.is.autonavi.com/appmaptile?style=&quot;                + layerInfo.getLayerName()                + &quot;&amp;x=&quot; + col + &quot;&amp;y=&quot; + row + &quot;&amp;z=&quot; + level;        Map&lt;String, String&gt; map = null;        bytes = com.esri.core.internal.io.handler.a.a(url, map);        if (cachePath != null)            AddOfflineCacheFile(cachePath, level, col, row, bytes);    }    return bytes;}</code></pre><p>高德地图还可以获取路况信息：</p><pre><code class="java">http://history.traffic.amap.com/traffic?type=2&amp;day=7&amp;hh=11&amp;mm=0&amp;x=13417&amp;y=6499&amp;z=14</code></pre><p>道理是一样的。</p><p><strong>按照惯例下面是我封装好的Jar包。</strong><br>Jar包下载地址：<a href="http://img.wshunli.com/ArcGISforAndroid/11/ArcAMap.jar" rel="external nofollow noopener noreferrer" target="_blank">ArcAMap.jar</a></p><p>使用方法：</p><pre><code class="java">AMapLayer（TYPE，PATH）；</code></pre><p>TYPE：有一下三种类型可选<br>PATH：缓存路径{选填}，为空则不缓存。</p><pre><code class="java">package com.wshunli.map.arcamap;/** * 项目：ArcAMap * 作者：WangShunli * 时间：2017/3/3 10:19 * 邮箱：admin@wshunli.com * 说明： */public interface AMapLayerTypes {    /**     * 高德矢量地图服务     */    final int VECTOR_AMAP = 1;    /**     * 高德影像地图服务     */    final int IMAGE_AMAP = 2;    /**     * 高德地形路网服务     */    final int ROAD_AMAP = 3;}</code></pre><p>示例代码：</p><pre><code class="java">AMapLayer AMAP_VECTOR_Layer = new AMapLayer(AMapLayerTypes.VECTOR_AMAP, ZZMANHOLE_PATH + &quot;/AMapCacheDemo&quot;);</code></pre><blockquote><p>参考资料<br>1、ArcGIS For Android 使用谷歌地图服务 - 牧羊的专栏 - 博客频道 - CSDN.NET<br><a href="http://blog.csdn.net/u014014578/article/details/21476395" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/u014014578/article/details/21476395</a><br>2、客户端地图拼图算法解析 - 九毫 - 博客园<br><a href="http://www.cnblogs.com/ninemilli/archive/2011/12/26/2289285.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/ninemilli/archive/2011/12/26/2289285.html</a><br>3、OpenStreetMap/Google/百度/Bing瓦片地图服务(TMS) - 可可西 - 博客园<br><a href="http://www.cnblogs.com/kekec/p/3159970.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/kekec/p/3159970.html</a><br>4、国内主要地图瓦片坐标系定义及计算原理 | CntChen Blog<br><a href="http://cntchen.github.io/2016/05/09/国内主要地图瓦片坐标系定义及计算原理/" rel="external nofollow noopener noreferrer" target="_blank">http://cntchen.github.io/2016/05/09/国内主要地图瓦片坐标系定义及计算原理/</a><br>5、Arcgis for js加载百度地图 - LZUGIS - 博客频道 - CSDN.NET<br><a href="http://blog.csdn.net/gisshixisheng/article/details/44853709" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/gisshixisheng/article/details/44853709</a><br>6、jxsapp/ArcGis_moka: arcgis Android 加载 Google 地图 相关工具包<br><a href="https://github.com/jxsapp/ArcGis_moka" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jxsapp/ArcGis_moka</a><br>7、ArcGIS Javascript API 加载高德在线地图扩展 - ThinkGIS<br><a href="http://www.thinkgis.cn/topic/55bed4f76edd0d1a1d9f44cf" rel="external nofollow noopener noreferrer" target="_blank">http://www.thinkgis.cn/topic/55bed4f76edd0d1a1d9f44cf</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;本文主要介绍自定义扩展图层加载Google地图/高德地图并缓存&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/categories/ArcGIS-Runtime-SDK-for-Android/"/>
    
    
      <category term="ArcGIS" scheme="http://www.wshunli.com/tags/ArcGIS/"/>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/tags/ArcGIS-Runtime-SDK-for-Android/"/>
    
      <category term="ArcGIS for Android" scheme="http://www.wshunli.com/tags/ArcGIS-for-Android/"/>
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>《ArcGIS Runtime SDK for Android学习笔记》-10、自定义扩展图层加载天地图并缓存</title>
    <link href="http://www.wshunli.com/2017/03/02/%E3%80%8AArcGIS-Runtime-SDK-for-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B-10%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E5%9B%BE%E5%B1%82%E5%8A%A0%E8%BD%BD%E5%A4%A9%E5%9C%B0%E5%9B%BE%E5%B9%B6%E7%BC%93%E5%AD%98/"/>
    <id>http://www.wshunli.com/2017/03/02/《ArcGIS-Runtime-SDK-for-Android学习笔记》-10、自定义扩展图层加载天地图并缓存/</id>
    <published>2017-03-02T04:11:25.000Z</published>
    <updated>2017-10-08T05:04:48.516Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p><strong>本文主要介绍自定义扩展图层加载天地图并缓存</strong><br><a id="more"></a></p><p>国家地理信息公共服务平台“ <a href="http://www.tianditu.com" rel="external nofollow noopener noreferrer" target="_blank">天地图</a> ”（以下简称“天地图“）是国家测绘地理信息局主导建设的网络化地理信息共享与服务门户，集成了来自国家、省、市（县）各级测绘地理信息部门，以及相关政府部门、企事业单位 、社会团体、公众的地理信息公共服务资源，向各类用户提供权威、标准、统一的在线地理信息综合服务。<br>“天地图”属于基础性、公益性服务平台，针对不同用途设计了多种数据版本和服务模式，用户可根据自身需求进行使用。<br>基本情况如下：<br>1、基于 OGC 的 WMTS 1.0.0版本；<br>2、提供矢量地图、影像地图和地形图；<br>3、提供两种坐标系：国家2000大地坐标系和 Web Mercator 投影坐标系；<br>4、地图和标注数据分开，矢量地图和影像地图提供中英文标注，地形图仅提供中文标注。</p><p>核心代码如下：</p><pre><code class="java">protected byte[] getTile(int level, int col, int row) throws Exception {        if (level &gt; layerInfo.getMaxZoomLevel()                || level &lt; layerInfo.getMinZoomLevel())            return new byte[0];        byte[] bytes = null;        if (cachePath != null)            bytes = getOfflineCacheFile(cachePath, level, col, row);        if (bytes == null) {            String url = layerInfo.getUrl()                    + &quot;?service=wmts&amp;request=gettile&amp;version=1.0.0&amp;layer=&quot;                    + layerInfo.getLayerName() + &quot;&amp;format=tiles&amp;tilematrixset=&quot;                    + layerInfo.getTileMatrixSet() + &quot;&amp;tilecol=&quot; + col                    + &quot;&amp;tilerow=&quot; + row + &quot;&amp;tilematrix=&quot; + (level + 1);            Map&lt;String, String&gt; map = null;            bytes = com.esri.core.internal.io.handler.a.a(url, map);            if (cachePath != null)                AddOfflineCacheFile(cachePath, level, col, row, bytes);        }        return bytes;    }</code></pre><p>我把整个项目封装成Jar包以供调用。下载地址：</p><p><a href="https://img.wshunli.com/ArcGISforAndroid/10/tianditu.jar" rel="external nofollow noopener noreferrer" target="_blank">tianditu.jar</a></p><p>支持的天地图图层类型：</p><pre><code class="java">package com.wshunli.map.tianditu;/** * 项目：TiDiTu * 作者：WangShunli * 时间：2016/4/9 11:33 * 邮箱：admin@wshunli.com * 说明： */public interface TianDiTuLayerTypes {    /**     * 天地图矢量墨卡托投影地图服务     */    final int TIANDITU_VECTOR_MERCATOR = 0;    /**     * 天地图矢量墨卡托中文标注     */    final int TIANDITU_VECTOR_ANNOTATION_CHINESE_MERCATOR = 1;    /**     * 天地图矢量墨卡托英文标注     */    final int TIANDITU_VECTOR_ANNOTATION_ENGLISH_MERCATOR = 2;    /**     * 天地图影像墨卡托投影地图服务     */    final int TIANDITU_IMAGE_MERCATOR = 3;    /**     * 天地图影像墨卡托投影中文标注     */    final int TIANDITU_IMAGE_ANNOTATION_CHINESE_MERCATOR = 4;    /**     * 天地图影像墨卡托投影英文标注     */    final int TIANDITU_IMAGE_ANNOTATION_ENGLISH_MERCATOR = 5;    /**     * 天地图地形墨卡托投影地图服务     */    final int TIANDITU_TERRAIN_MERCATOR = 6;    /**     * 天地图地形墨卡托投影中文标注     */    final int TIANDITU_TERRAIN_ANNOTATION_CHINESE_MERCATOR = 7;    /**     * 天地图矢量国家2000坐标系地图服务     */    final int TIANDITU_VECTOR_2000 = 8;    /**     * 天地图矢量国家2000坐标系中文标注     */    final int TIANDITU_VECTOR_ANNOTATION_CHINESE_2000 = 9;    /**     * 天地图矢量国家2000坐标系英文标注     */    final int TIANDITU_VECTOR_ANNOTATION_ENGLISH_2000 = 10;    /**     * 天地图影像国家2000坐标系地图服务     */    final int TIANDITU_IMAGE_2000 = 11;    /**     * 天地图影像国家2000坐标系中文标注     */    final int TIANDITU_IMAGE_ANNOTATION_CHINESE_2000 = 12;    /**     * 天地图影像国家2000坐标系英文标注     */    final int TIANDITU_IMAGE_ANNOTATION_ENGLISH_2000 = 13;    /**     * 天地图地形国家2000坐标系地图服务     */    final int TIANDITU_TERRAIN_2000 = 14;    /**     * 天地图地形国家2000坐标系中文标注     */    final int TIANDITU_TERRAIN_ANNOTATION_CHINESE_2000 = 15;}</code></pre><p>调用方法示例：</p><pre><code class="java">package com.wshunli.map.tianditu.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import com.esri.android.map.MapView;import com.esri.android.map.event.OnZoomListener;import com.wshunli.map.tianditu.TianDiTuLayer;import com.wshunli.map.tianditu.TianDiTuLayerTypes;/** * 项目：TiDiTuDemo * 作者：WangShunli * 时间：2017/3/2 12:38 * 邮箱：admin@wshunli.com * 说明： */public class MainActivity extends AppCompatActivity {    public static String TDT_PATH = android.os.Environment.getExternalStorageDirectory() + &quot;/TDTCacheDemo&quot;;    MapView mMapView;    //矢量地图    public TianDiTuLayer vec_c;    //矢量标注    public TianDiTuLayer cva_c;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mMapView = (MapView) findViewById(R.id.map);        vec_c = new TianDiTuLayer(TianDiTuLayerTypes.TIANDITU_VECTOR_2000, TDT_PATH);        mMapView.addLayer(vec_c);        cva_c = new TianDiTuLayer(TianDiTuLayerTypes.TIANDITU_VECTOR_ANNOTATION_CHINESE_2000, TDT_PATH);        mMapView.addLayer(cva_c);        /**         * 解决天地图标注覆盖问题         */        mMapView.setOnZoomListener(new OnZoomListener() {            @Override            public void preAction(float v, float v1, double v2) {            }            @Override            public void postAction(float v, float v1, double v2) {                cva_c.clearTiles();            }        });    }}</code></pre><blockquote><p>参考资料<br>1、ArcGIS读取天地图2.0 - ArcGIS产品与技术专栏 - 博客频道 - CSDN.NET<br><a href="http://blog.csdn.net/arcgis_all/article/details/8848120" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/arcgis_all/article/details/8848120</a><br>2、arcgis api for android 叠加天地图 - 阿华博台 - 博客频道 - CSDN.NET<br><a href="http://blog.csdn.net/yu624774720hua/article/details/8755398" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/yu624774720hua/article/details/8755398</a><br>3、入门Android开发–ArcGis读取天地图，并实现一些简单功能。 - 从入门到忘记 - 博客频道 - CSDN.NET<br><a href="http://blog.csdn.net/u013867301/article/details/51036200" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/u013867301/article/details/51036200</a><br>4、arcgis for android 本地缓存 | 大光的博客<br><a href="http://daguang.me/2013/08/01/arcgis-for-android-本地缓存/" rel="external nofollow noopener noreferrer" target="_blank">http://daguang.me/2013/08/01/arcgis-for-android-本地缓存/</a><br>5、Android开发，arcgis自定义layer-历史影像和地图缓存的实现 - 博客频道 - CSDN.NET<br><a href="http://blog.csdn.net/Stanny_Bing/article/details/53736659" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/Stanny_Bing/article/details/53736659</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;本文主要介绍自定义扩展图层加载天地图并缓存&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/categories/ArcGIS-Runtime-SDK-for-Android/"/>
    
    
      <category term="ArcGIS" scheme="http://www.wshunli.com/tags/ArcGIS/"/>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/tags/ArcGIS-Runtime-SDK-for-Android/"/>
    
      <category term="ArcGIS for Android" scheme="http://www.wshunli.com/tags/ArcGIS-for-Android/"/>
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>《ArcGIS Runtime SDK for Android学习笔记》-9、ArcGIS for Android 常用数据加载方法</title>
    <link href="http://www.wshunli.com/2017/03/02/%E3%80%8AArcGIS-Runtime-SDK-for-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B-9%E3%80%81ArcGIS-for-Android-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%B3%95/"/>
    <id>http://www.wshunli.com/2017/03/02/《ArcGIS-Runtime-SDK-for-Android学习笔记》-9、ArcGIS-for-Android-常用数据加载方法/</id>
    <published>2017-03-02T03:55:42.000Z</published>
    <updated>2017-10-08T05:03:28.911Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><h1 id="ArcGIS-for-Android-支持的空间数据类型"><a href="#ArcGIS-for-Android-支持的空间数据类型" class="headerlink" title="ArcGIS for Android 支持的空间数据类型"></a>ArcGIS for Android 支持的空间数据类型</h1><p>ArcGIS Runtime SDK for Android支持的空间数据源有多种，主要分为3大类：ArcGIS在线数据源、ArcGIS离线数据源（自10.2版本起），以及第三方数据源，详细的类别支持请见下表：</p><table><thead><tr><th>数据源类型</th><th>数据源名称</th></tr></thead><tbody><tr><td>ArcGIS在线数据源</td><td>切片地图服务（ArcGISTiledMapServiceLayer）、动态地图服务（ArcGISDynamicMapServiceLayer）、影像服务（ArcGISImageServiceLayer）、要素服务（ArcGISFeatureLayer）</td></tr><tr><td>ArcGIS离线数据源</td><td>紧凑型切片（ArcGISLocalTiledLayer）、tpk切片包（ArcGISLocalTiledLayer）、.geodatabase数据文件（GeodatabaseFeature）、.shp文件（ShapefileFeatureTable）、地名地址库（Locator）、网络数据集（Network Dataset）</td></tr><tr><td>第三方数据源</td><td>Bing地图（BingMapsLayer）、Open Street map（OpenStreetMapLayer）、OGC图层（KMLLayer、WMSLayer）、第三方自定义扩展图层</td></tr></tbody></table><h1 id="ArcGIS-for-Android-常用数据加载方法"><a href="#ArcGIS-for-Android-常用数据加载方法" class="headerlink" title="ArcGIS for Android 常用数据加载方法"></a>ArcGIS for Android 常用数据加载方法</h1><h2 id="ArcGISTiledMapServiceLayer"><a href="#ArcGISTiledMapServiceLayer" class="headerlink" title="ArcGISTiledMapServiceLayer"></a>ArcGISTiledMapServiceLayer</h2><p>ArcGISTiledMapServiceLayer图层对应ArcGIS for Server服务中的切片服务，由于切片都是事先做好的，ArcGISTiledMapServiceLayer不能对图层中的数据进行更改，除非更新服务缓存，在ArcGIS Runtime SDK for Android中，也不允许对此类型的数据进行查询，通常用做底图使用。同时，因为加载的是缓存切片，这个类型的图层是ArcGIS Runtime SDK for Android中相应请求最快的图层之一，它采用多个线程，通常是使用单独线程来处理请求和绘制图片，并且异步处理。用法如下：</p><pre><code class="java">map = (MapView)findViewById(R.id.map);// Add tiled layer to MapViewArcGISTiledMapServiceLayer tileLayer = new ArcGISTiledMapServiceLayer(&quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer&quot;);map.addLayer(tileLayer);</code></pre><h2 id="ArcGISDynamicMapServiceLayer"><a href="#ArcGISDynamicMapServiceLayer" class="headerlink" title="ArcGISDynamicMapServiceLayer"></a>ArcGISDynamicMapServiceLayer</h2><p>ArcGISDynamicMapServiceLayer图层对应ArcGIS for Server服务中的动态服务，动态地图服务的地图数据是按照移动设备范围读取的。 ArcGISDynamicMapServiceLayer图层通常包含多个图层，这些图层由server根据请求来渲染并以raster image形式返回，并且返回的raster并不包含feature的额外信息。它的功能特点是更新非常方便，并能及时呈现给用户，同时，图层的可视性和空间参考可以改变，可以给图层添加单独的layer definition，ArcGIS for Server为每个image动态投影，而地图的空间参考是由第一个加载的图层决定。</p><p>它的性能特点是，它的渲染时间取决于请求数据的数量和复杂度，因此一般都比tiled map server要慢，因此，它适合数据经常发生改变、或者需要针对不同的用户呈现不同的数据，且要素信息（如attributes，geometry，symbol等）不需要的情况。</p><p>它的用法与ArcGISTiledMapServiceLayer图层相同，示例代码如下：</p><pre><code class="java">map = (MapView)findViewById(R.id.map);// Add DynamicMapServiceLayer to MapViewArcGISDynamicMapServiceLayer agsDynlyr = new ArcGISDynamicMapServiceLayer(&quot;http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Demographics/ESRI_Population_World/MapServer&quot;);map.addLayer(agsDynlyr);</code></pre><p><strong>在国内的话可以使用</strong><br><a href="http://www.geoq.cn/v1/basemap_free.html" rel="external nofollow noopener noreferrer" target="_blank">智图</a> 提供的全国基础地图服务<br>服务地址：<br><a href="http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer" rel="external nofollow noopener noreferrer" target="_blank">http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer</a></p><h2 id="ArcGISImageServiceLayer"><a href="#ArcGISImageServiceLayer" class="headerlink" title="ArcGISImageServiceLayer"></a>ArcGISImageServiceLayer</h2><p>ArcGISImageServiceLayer图层对应ArcGIS for Server服务中的影像服务，它为移动端使用影像数据提供了一种途径，通过这种方式调用的影像数据通常可以用来作为底图。调用影像服务也非常简单，同调用上述服务一样，示例代码如下：</p><pre><code class="java">map = (MapView)findViewById(R.id.map);map.addLayer(new ArcGISImageServiceLayer(&quot;http://myserver/arcgis/rest/services/MyImage/ImageServer&quot;,null));</code></pre><h2 id="ArcGISFeatureLayer"><a href="#ArcGISFeatureLayer" class="headerlink" title="ArcGISFeatureLayer"></a>ArcGISFeatureLayer</h2><p>ArcGISFeatureLayer图层对应ArcGIS for Server服务中的Feature Service，该图层可以是空间图层，也可以是非空间的表，该图层包含了要素最丰富的信息，其中的每个要素都能被空间查询和SQL查询。从Feature Service中请求要素时以JSON格式返回，每个要素都单独渲染，因此与其它图层类型相比，要素图层具有最丰富的功能。</p><p>只有Feature Service（要素服务）才可以具备在线数据编辑功能，因此，如果想要对某个数据进行在线编辑或同步，需要将其发布成Feature Service，并在移动端新建一个ArcGISFeatureLayer图层以加载该服务。该图层有一些设定，这些设定能影响图层的性能，包括请求时间，返回大小、处理和响应时间等（设置需要在图层initialized完成之后进行）。</p><p>ArcGISFeatureLayer图层继承自GraphicsLayer，因此也具有该图层的所有操作。调用该图层的示例代码如下：</p><pre><code class="java">String url =&quot;https://servicesbeta.esri.com/ArcGIS/rest/services/SanJuan/TrailConditions/FeatureServer/0&quot;;map = (MapView)findViewById(R.id.map);//按照快照方式加载该图层map.addLayer(new ArcGISFeatureLayer(url,MODE.ONDEMAND));setContentView (map);</code></pre><h2 id="加载tpk和紧凑型切片"><a href="#加载tpk和紧凑型切片" class="headerlink" title="加载tpk和紧凑型切片"></a>加载tpk和紧凑型切片</h2><p>ArcGISLocalTiledLayer是ArcGIS Runtime SDK for Android中专门用来添加离线数据包（底图）的图层，该图层目前支持两种格式的离线数据：一个是紧凑型切片，另一个就是tpk。使用起来也很简单，实例化该类的一个对象，并在构造函数中输入数据的路径即可，代码示例如下：</p><pre><code class="java">map = (MapView)findViewById(R.id.map);// Add Local tiled layer to MapViewArcGISLocalTiledLayer agsLocaltiledlyr = new ArcGISLocalTiledLayer(&quot;file:///mnt/sdcard/ArcGIS/sample/HelloWorld/Layers&quot;);map.addLayer(agsLocaltiledlyr);</code></pre><h2 id="加载影像数"><a href="#加载影像数" class="headerlink" title="加载影像数"></a>加载影像数</h2><p>ArcGIS Runtime SDK for Android 从10.2.4开始支持直接读取本地影像数据，数据类型包含：ASRP/USRP、CIB1,5,10、DTED0, 1, 2、GeoPackage、GeoTIFF、HFA、HRE、IMG、JPEG、JPEG2000、NITF、PNG、RPF、SRTM1, FileRasterSource是加载本地影像数据文件类，地图视图中以RasterLayer作为图层对象展示出来。代码如下：</p><pre><code class="java">String rasterPath = Environment.getExternalStorageDirectory().getPath() + &quot;/raster/test.tif&quot;;FileRasterSource rasterSource;try {   rasterSource = new FileRasterSource(rasterPath);  } catch (IllegalArgumentException ie) {  Log.d(TAG, &quot;null or empty path&quot;);} catch (FileNotFoundException fe) {  Log.d(TAG, &quot;raster file doesn&#39;t exist&quot;);} catch (RuntimeException re) {  Log.d(TAG, &quot;raster file can&#39;t be opened&quot;);}RasterLayer rasterLayer = new RasterLayer(rasterSource);mMapView.addLayer(rasterLayer);</code></pre><h2 id="加载离线的-geodatabase-本地文件"><a href="#加载离线的-geodatabase-本地文件" class="headerlink" title="加载离线的 .geodatabase 本地文件"></a>加载离线的 .geodatabase 本地文件</h2><p>.geodatabase 文件是ArcGIS 10.2中专为业务数据的离线而推出的一种数据格式，本质上，它仍然是SQLite数据库的封装，在SQLite数据模型的基础上，Esri计划逐步实现桌面端Geodatabase数据模型的存储，不仅包括Feature Class，还包括镶嵌数据集、网络数据集等。目前，主要实现了Feature Class的存储。</p><p>即，在ArcGIS 10.2.2中，要使用完全的离线功能，可以使用ArcGIS for Desktop提供的GP工具来将需要编辑和离线的业务数据导出到.geodatabase中，也可以直接从ArcGIS for Server上的要素服务中下载数据，并在移动端存储为.geodatabase，从而实现完全离线的移动应用。</p><p>ArcGIS Runtime SDK for Android中也提供了具体的Geodatabase类和FeatureLayer图层来加载.geodatabase文件，常用的类包括Geodatabase、GeodatabaseFeatureTable、GeodatabaseFeature、GeodatabaseFeatureServiceTable等，分别用来打开geodatabase数据文件、获取要素图层、获取图层中的具体要素，以及获取在线的要素服务。具体来讲，加载.geodatabase文件的步骤有如下几步：</p><ol><li>实例化一个Geodatabase对象，这个类有两个构造函数，都需要指定本地数据库的存储路径；</li><li>创建一个GeodatabaseFeatureTable对象实例，用来获取需要的图层；</li><li>创建一个FeatureLayer来存储获取的图层，并将获取的图层加载到地图中；</li><li>调用dispose()方式释放资源。</li></ol><p>示例代码如下：</p><pre><code class="java">//实例化geodatabase对象，并指定文件目录gdb = new Geodatabase(&quot;{/path/to/geodatabase}&quot;);//实例化gdbfeaturetable对象，并获取第一个图层gdbfeaturetable = gdb.getGeodatabaseFeatureTableByLayerId(0);//创建一个FeatureLayer来存储获取的图层，并将获取的图层加载到地图中featurelayer = new FeatureLayer(gdbfeaturetable);mMapView.removeAll();mMapView.addLayer(featurelayer);    //调用dispose()方式释放资源gdb.dispose();</code></pre><h2 id="加载ShapeFile文件"><a href="#加载ShapeFile文件" class="headerlink" title="加载ShapeFile文件"></a>加载ShapeFile文件</h2><p>ShapeFile文件：ArcGIS平台中最常见的数据格式，包含属性信息、投影信息等。新版本的SDK（10.2.4开始）可以直接加载.shp文件进行数据的展示、查询。代码加载如下：</p><pre><code class="java">ShapefileFeatureTable shpTable = new ShapefileFeatureTable(shpUrl);FeatureLayer fl = new FeatureLayer(shpTable);fl.setRenderer(new SimpleRenderer(new SimpleMarkerSymbol(        Color.BLACK, 2, STYLE.CIRCLE)));mapView.addLayer(fl);</code></pre><blockquote><p>参考资料<br>1、《ArcGIS Runtime SDK for Android开发笔记》——（10）、ArcGIS Runtime SDK支持的空间数据类型 - gis-luq - 博客园 <a href="http://www.cnblogs.com/gis-luq/p/4941737.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/gis-luq/p/4941737.html</a><br>2、《ArcGIS Runtime SDK for Android开发笔记》——（11）、ArcGIS Runtime SDK常见空间数据加载 - gis-luq - 博客园 <a href="http://www.cnblogs.com/gis-luq/p/5062715.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/gis-luq/p/5062715.html</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;ArcGIS-for-Android-支持的空间数据类型&quot;&gt;&lt;a href=&quot;#ArcGIS-for-Android-支持的空间数据类型&quot; 
      
    
    </summary>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/categories/ArcGIS-Runtime-SDK-for-Android/"/>
    
    
      <category term="ArcGIS" scheme="http://www.wshunli.com/tags/ArcGIS/"/>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/tags/ArcGIS-Runtime-SDK-for-Android/"/>
    
      <category term="ArcGIS for Android" scheme="http://www.wshunli.com/tags/ArcGIS-for-Android/"/>
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>《ArcGIS Runtime SDK for Android学习笔记》-8、ArcGIS for Android 离线数据部署</title>
    <link href="http://www.wshunli.com/2017/03/02/%E3%80%8AArcGIS-Runtime-SDK-for-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B-8%E3%80%81ArcGIS-for-Android-%E7%A6%BB%E7%BA%BF%E6%95%B0%E6%8D%AE%E9%83%A8%E7%BD%B2/"/>
    <id>http://www.wshunli.com/2017/03/02/《ArcGIS-Runtime-SDK-for-Android学习笔记》-8、ArcGIS-for-Android-离线数据部署/</id>
    <published>2017-03-02T03:13:23.000Z</published>
    <updated>2017-10-08T04:59:30.121Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p><strong>本文主要介绍在代码工程中添加数据并部署到移动终端的操作步骤</strong><br><a id="more"></a></p><p>数据是GIS应用的基础，与所有GIS应用一样，用 ArcGIS for Android 开发的应用也离不开数据。而Android应用是在移动终端上运行的，数据和应用安装包都需要通过数据线连接进行拷贝，当终端较多时，尤其显得数据拷贝工作既繁琐又枯燥。为了更方便地部署应用数据，可以将数据文件放在工程资源中，在程序启动的同时，将数据一起部署到目标设备的指定目录。<br>本文介绍在代码工程中添加数据并部署到移动终端的操作步骤：<br>首先，数据文件拷贝到工程的assets目录；<br>然后，程序启动时，获取assets的内容并将其存储至移动端的指定目录。通过assets的方式，可以将数据一起打包到apk安装包中，安装完成后，程序启动时即可将数据部署至移动端，不需要再单独拷贝。</p><p>代码如下：</p><pre><code class="java">/** * 将assets写入移动设备 * * @param dir   assets下的文件夹 */public void copyAssetsDirToSdcard(String dir) {    String desFolder = ZZMANHOLE_PATH + dir;    FileUtils.createOrExistsDir(desFolder);    String[] mAssetsFileList = null;    try {        mAssetsFileList = getAssets().list(dir);    } catch (IOException e) {        e.printStackTrace();    }    assert mAssetsFileList != null;    for (String file : mAssetsFileList) {        File desFile = new File(desFolder + &quot;/&quot; + file);        if (!desFile.exists())            try {                InputStream is = getAssets().open(dir + &quot;/&quot; + file);                writeFileFromIS(desFile, is, false);            } catch (IOException e) {                e.printStackTrace();            }    }}</code></pre><p>说明：<br>1、<code>assets</code> 目录位置 <code>\app\src\main\assets</code>；<br>2、其中 <code>ZZMANHOLE_PATH</code> 为项目目录可通过以下代码获得：</p><pre><code class="java">public static String PATH = android.os.Environment.getExternalStorageDirectory() + &quot;/pathname/&quot;;</code></pre><p>3、将 <code>assets</code> 目录下的 <code>path</code> 复制到 SDcard 项目目录：<br>copyAssetsDirToSdcard(“path”);<br>即将<code>\app\src\main\assets\path</code> 复制到 <code>PATH\path</code>；<br>4、<code>writeFileFromIS</code> 代码如下：</p><pre><code class="java">/** * 将输入流写入文件 * * @param file   文件 * @param is     输入流 * @param append 是否追加在文件末 * @return {@code true}: 写入成功&lt;br&gt;{@code false}: 写入失败 */public static boolean writeFileFromIS(File file, InputStream is, boolean append) {    if (file == null || is == null) return false;    if (!createOrExistsFile(file)) return false;    OutputStream os = null;    try {        os = new BufferedOutputStream(new FileOutputStream(file, append));        byte data[] = new byte[1024];        int len;        while ((len = is.read(data, 0, 1024)) != -1) {            os.write(data, 0, len);        }        return true;    } catch (IOException e) {        e.printStackTrace();        return false;    } finally {        closeIO(is, os);    }}</code></pre><p>5、<code>closeIO</code> 代码如下：</p><pre><code class="java">/** * 关闭IO * @param closeables closeable */public static void closeIO(Closeable... closeables) {    if (closeables == null) return;    for (Closeable closeable : closeables) {        if (closeable != null) {            try {                closeable.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><blockquote><p>参考资料<br>1、java - android 怎么复制assets文件夹到本地SD卡？ - SegmentFault <a href="https://segmentfault.com/q/1010000004478829" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/q/1010000004478829</a><br>2、Android学习之遍历拷贝assets下的目录 - linzhiyong的专栏 - 博客频道 - CSDN.NET <a href="http://blog.csdn.net/u012527802/article/details/52025849" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/u012527802/article/details/52025849</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;本文主要介绍在代码工程中添加数据并部署到移动终端的操作步骤&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/categories/ArcGIS-Runtime-SDK-for-Android/"/>
    
    
      <category term="ArcGIS" scheme="http://www.wshunli.com/tags/ArcGIS/"/>
    
      <category term="ArcGIS Runtime SDK for Android" scheme="http://www.wshunli.com/tags/ArcGIS-Runtime-SDK-for-Android/"/>
    
      <category term="ArcGIS for Android" scheme="http://www.wshunli.com/tags/ArcGIS-for-Android/"/>
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>《SuperMap iMobile for Android学习笔记》-2、SuperMap for Android开发环境搭建</title>
    <link href="http://www.wshunli.com/2017/02/28/%E3%80%8ASuperMap-iMobile-for-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B-2%E3%80%81SuperMap-for-Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.wshunli.com/2017/02/28/《SuperMap-iMobile-for-Android学习笔记》-2、SuperMap-for-Android开发环境搭建/</id>
    <published>2017-02-28T11:39:26.000Z</published>
    <updated>2017-08-13T06:41:54.399Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><p><strong>本文主要针对在Windwos环境下用Android Studio搭建SuperMap for Android开发环境.</strong><br><a id="more"></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;strong&gt;本文主要针对在Windwos环境下用Android Studio搭建SuperMap for Android开发环境.&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SuperMap iMobile for Android" scheme="http://www.wshunli.com/categories/SuperMap-iMobile-for-Android/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="SuperMap iMobile for Android" scheme="http://www.wshunli.com/tags/SuperMap-iMobile-for-Android/"/>
    
      <category term="SuperMap for Android" scheme="http://www.wshunli.com/tags/SuperMap-for-Android/"/>
    
      <category term="SuperMap" scheme="http://www.wshunli.com/tags/SuperMap/"/>
    
  </entry>
  
  <entry>
    <title>《SuperMap iMobile for Android学习笔记》-1、SuperMap for Android介绍</title>
    <link href="http://www.wshunli.com/2017/02/28/%E3%80%8ASuperMap-iMobile-for-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B-1%E3%80%81SuperMap-for-Android%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.wshunli.com/2017/02/28/《SuperMap-iMobile-for-Android学习笔记》-1、SuperMap-for-Android介绍/</id>
    <published>2017-02-28T06:05:07.000Z</published>
    <updated>2017-06-08T01:29:20.515Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --><a id="more"></a><h1 id="产品简介"><a href="#产品简介" class="headerlink" title="产品简介"></a>产品简介</h1><p>SuperMap iMobile 8C是一款全新的移动GIS开发平台，具备专业、全面的移动GIS功能。支持基于Android和iOS操作系统的智能移动终端，可以快速开发在线和离线的移动GIS应用。</p><h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><p><img src="https://img.wshunli.com/SuperMapforAndroid/1/SuperMapforAndroid%E4%BB%8B%E7%BB%8D.png" alt=""></p><h1 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h1><ul><li>专业的移动 GIS 开发平台，提供全面的移动GIS功能。在专业数据采集、行业GIS应用、大众化GIS应用等领域都有广泛的应用。</li><li>全新的地图显示引擎，SuperMap iMobile 8C利用OpenGL在面片渲染、文本渲染及反走样等方面的优势提升地图显示效果，使得地图绘制效果更精美；同时利用OpenGL的整体渲染模式，大幅提升地图的显示性能。</li><li>除支持广泛的在线地图服务外，还支持强大的离线数据。在多种特殊的应用场景都有广泛的应用，如：移动网络信号无覆盖、移动网络流量受限、数据保密、高性能移动GIS等。</li><li>提供移动端、桌面端和服务器端通用数据格式，跨终端交换数据无需转换格式，即拷即用。</li><li>消息总线功能，支持多端之间的协同操作，在一个终端执行的操作可以快速同步到其它相关终端，从而实现数据共享和即时通讯的功能。</li><li>支持态势标绘功能，提供多种点符号和箭头符号的标绘。可应用于调度，指挥等多种应急行业中。</li><li>高性能的二三维一体化，在移动端支持高精细的三维模型，支持水纹、火焰、喷泉、樱花等多种动画效果。</li><li>支持在线和离线方式浏览倾斜摄影建模数据，支持选中单个模型对象高亮、以及单体模型的属性信息、空间信息查询等GIS功能。</li><li>GIS和导航一体化，极大的提高了室外GIS作业的便利性和工作成效。</li><li>SuperMap iMobile 8C 通过对三种国际标准AMQP、MQTT和STOMP的支持，实现了GIS数据的广播方式消息传播和点对点消息传播，进而实现多端协同和数据分发。</li></ul><h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><p><strong>全面的GIS功能</strong><br>作为专业的移动GIS开发平台，SuperMap iMobile 8C提供了涵盖地图操作、数据采集、绘制编辑、空间分析、路径导航等专业移动GIS应用功能。基于该平台构建的移动GIS应用将能够便捷的提供多源地图组合与专题数据浏览，实现空间信息的查询与分析，进行终端的数据采集、编辑与管理，并能够高效的进行动态变化数据的展示与监控。</p><p><strong>全新的地图显示引擎</strong><br>相比PC端地图，移动端地图更注重用户体验:地图显示效果及地图操作性能。为了提升地图的体验，SuperMap iMoble 8C 采用全新的OpenGL显示技术绘制地图，大大的提升了地图的显示效果及显示性能。在地图显示效果方面， 利用OpenGL面片渲染、文本渲染及反走样的优势，确保地图绘制效果更精美。在地图显示性能方面，OpenGL的整体渲染模式，不仅可以大幅提高地图的整体渲染性能，而且可以利用GPU加速，让地图加载更快，显示更流畅。新版显示引擎还可实现地图透明、地图旋转、地图俯仰角等多种地图显示特效。</p><p><strong>离线在线一体化</strong><br>SuperMap iMobile既支持多种在线地图服务，也支持完全离线应用。这在移动网络信号无覆盖、网络流量受限、数据保密以及高性能移动GIS应用等领域发挥了重要作用。</p><p><strong>导航GIS一体化</strong><br>导航可以直接使用GIS应用的地图和数据，实现导航与业务功能无缝衔接。可以根据业务需要定制路径分析和导航的参数条件，实现个性化按需导航。</p><p><strong>互联互通一体化</strong><br>SuperMap iMobile 8C通过对三种国际标准AMQP、MQTT和STOMP的支持，实现了GIS数据的广播方式消息传播和点对点消息传播，进而实现多端协同和数据分发。同时，iMobile 8C 对 GeoJson 传输格式的支持，使得移动端能够更好的实现和服务器端进行几何对象的交互应用。</p><p>SuperMap iMobile 8C实现了可以让移动终端通过蓝牙与高精度数据定位采集终端的定位盒子通讯，获取亚米级的定位数据。这为移动终端在位置服务应用上带来数据采集的便捷性和准确性，位置数据的采集和服务应用面更加广泛。</p><p><strong>专业的空间分析</strong><br>SuperMap iMobile 8C提供全面的GIS分析功能，可以基于本地和服务数据进行缓冲区分析、叠加分析和路网、管线分析等，对数据进行即时的信息挖掘与处理。</p><p><strong>高效的网络分析</strong><br>SuperMap iMobile 8C 支持高效的网络拓扑分析，可以广泛应用于GIS数据路线规划、管网分析、管网巡查等业务。</p><p><strong>增强的数据采集功能</strong><br>GPS 数据采集：SuperMap iMobile 8C 提供5种 GPS 数据采集模式：普通模式、抓路模式、等距离间隔模式、等时间间隔模式、智能记录模式。<br>多媒体数据采集：除位置信息之外，SuperMap iMobile 8C 提供照片、音频和视频信息的采集。</p><p><strong>动态变化对象实时显示</strong><br>SuperMap iMobile 8C 提供了在终端根据实时数据动态渲染专题地图的能力，可以根据终端应用需求和数据的即时变化来动态展示专题信息，进一步发挥移动应用的即时效应。对于位置和状态属性快速变化的动态对象，SuperMap iMobile 8C 提供了高性能的交互显示。终端应用可以实现在地图上实时监控目标对象的位置变化、状态变化，并能够以动画方式展示对象变化的过程。动态对象支持手势交互操作，为应用提供丰富直观的交互体验。通过动态对象显示，可以简单快捷的实现车辆监控，电子围栏等对运动目标的监控应用，以及对设备报警、运行状态等实时状态监控应用。针对海量数据显示，SuperMap iMobile 8C版本还提供了聚合显示的功能，全面提升了海量数据的显示性能和效果。</p><p><strong>应用于调度指挥的态势标绘</strong><br>SuperMap iMobile 8C 支持应用于指挥调用的态势标绘功能，提供多种点符号及箭头符号的标绘。通过这些标绘符号，可以快速的进行调度或指挥信息的表达，同时，结合iMobile的手绘几何对象功能、涂鸦功能，可以更丰富的表达信息。</p><p><strong>高性能移动三维</strong><br>三维场景是SuperMap iMobile 8C的核心应用功能，用户可以快速构建二三维一体化的移动GIS应用系统，在移动终端实现三维地图和场景的浏览与交互操作。提供地形、影像、模型、矢量等数据和粒子、水面等特效的移动端三维显示和查询。</p><p><strong>三维倾斜摄影</strong><br>倾斜摄影测量是测绘领域近些年发展起来的一项新技术，通过使用同一飞行器的多台传感设备，可以同时从垂直和四向采集影像，从而达到快速还原真实世界的效果。相对于人工建模，倾斜摄影具备以下特性：能够真实反映地物的情况、获取的数据精度高、能够自动化建模。这些特性可以显著降低三维数据的建模成本，大大提高数据采集效率。在SuperMap iMobile 8C产品中提供便捷高效的模型加载机制，支持在线和离线直接浏览OSGB倾斜摄影数据，无需进行数据转换。同时支持模型选中高亮、单体模型的属性信息查询等高级GIS功能。</p><p><strong>数据安全</strong><br>SuperMap iMobile 8C更加的注重数据的安全，在数据加密方面提供了工作空间加密、数据源加密以及缓存数据加密功能。</p><p>工作空间加密：支持在工作空间中设置密码，打开工作空间时需要输入密码，此种加密方式只能粗略保证数据安全。<br>数据源加密：根据密钥，把整个文件进行加密，高安全的一种做法，即使是数据流失，在其它工具中也无法打开此文件。<br>缓存文件加密：根据密钥，把整个文件进行加密，高安全的一种做法，即使是数据流失，在其它工具中也无法打开此文件。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Oct 29 2017 17:52:43 GMT+0800 (中国标准时间) --&gt;
    
    </summary>
    
      <category term="SuperMap iMobile for Android" scheme="http://www.wshunli.com/categories/SuperMap-iMobile-for-Android/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="SuperMap iMobile for Android" scheme="http://www.wshunli.com/tags/SuperMap-iMobile-for-Android/"/>
    
      <category term="SuperMap for Android" scheme="http://www.wshunli.com/tags/SuperMap-for-Android/"/>
    
      <category term="SuperMap" scheme="http://www.wshunli.com/tags/SuperMap/"/>
    
  </entry>
  
</feed>
