<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2017-11-29T14:47:00.689Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Java编程思想》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/6e418c5b.html"/>
    <id>http://www.wshunli.com/posts/6e418c5b.html</id>
    <published>2017-11-28T13:15:08.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类与接口。</p><a id="more"></a><h1 id="第5章-初始化与清理"><a href="#第5章-初始化与清理" class="headerlink" title="第5章 初始化与清理"></a>第5章 初始化与清理</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类与接口。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/235f2f09.html"/>
    <id>http://www.wshunli.com/posts/235f2f09.html</id>
    <published>2017-11-28T12:47:30.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 基础知识部分。</p><a id="more"></a><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a>第3章 操作符</h1><p>Java 中的数据是通过使用操作符来操作的。</p><ul><li>赋值操作符</li><li>算术操作符</li><li>关系操作符</li><li>逻辑操作符</li><li>按位操作符</li><li>其他操作符</li></ul><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a>第4章 控制执行流程</h1><p>1.Java 中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p>2.Foreach 语法，用于数组或容器</p><pre><code class="Java">int [] numbers = {10, 20, 30, 40, 50};for(int x : numbers ){    System.out.print( x );    System.out.print(&quot;,&quot;);}// 10,20,30,40,50,</code></pre><p>3.return、break、continue</p><p>return：指定方法的返回值或者退出当前方法。</p><p>break：主要用于循环或者 switch 语句，退出整个语句块。<br>continue：跳转到下一次循环迭代。</p><p>4.Java 分支结构：swich 语句与 if 语句</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 基础知识部分。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/1349c3d1.html"/>
    <id>http://www.wshunli.com/posts/1349c3d1.html</id>
    <published>2017-11-28T02:58:36.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 一切皆对象。</p><a id="more"></a><h1 id="第1章-对象导论"><a href="#第1章-对象导论" class="headerlink" title="第1章 对象导论"></a>第1章 对象导论</h1><p>本章主要介绍 OOP 面向对象的思想以及抽象、封装、继承、多态的概念。</p><p>JAVA 是一种面向对象编程语言：</p><ul><li>万物皆对象，每一个对象都会存储数据，并且可以对自身执行操作。因此，每一个对象包含两部分：成员变量和成员方法。在成员方法中可以改变成员变量的值。</li><li>程序是对象的集合，他们通过发送消息来告知彼此所要做的事情，也就是调用相应的成员函数。</li><li>每一个对象都有自己的由其他对象所构成的存储，也就是说在创建新对象的时候可以在成员变量中使用已存在的对象。</li><li>每个对象都拥有其类型，每个对象都是某个类的一个实例，每一个类区别于其它类的特性就是可以向它发送什么类型的消息，也就是它定义了哪些成员函数。</li><li>某一个特定类型的所有对象都可以接受同样的消息。</li></ul><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a>第2章 一切都是对象</h1><p>1.Java 中一切都被视为对象，但是操作的标识符实际是对象的引用。</p><pre><code class="Java">String s;                         // s 为引用，并不是对象。String s = new String(&quot;wshunli&quot;); // s 与新的对象关联String s = &quot;wshunli&quot;;             // 等价</code></pre><p>2.数据存储位置可分为：寄存器、堆栈、堆、常量存储、非 RAM 存储。</p><ul><li>寄存器位于处理器内部，最快的存储区；</li><li>堆栈通常位于 RAM 中，存储对象引用；</li><li>堆通常也是位于 RAM 中，存储所有 Java 对象；</li><li>常量存储直接存放在代码内部；</li><li>非 RAM 存储的数据完全存活于程序之外，比如流对象和持久化对象。</li></ul><p>3.Java 基本数据类型：</p><ul><li>byte、short、int、long</li><li>float、double</li><li>boolean</li><li>char</li></ul><p>4.类：字段、方法组成。</p><p>5.HelloWorld：</p><pre><code class="Java">public class HelloWorld {    /* 第一个Java程序     * 它将打印字符串 Hello World     */    public static void main(String []args) {        System.out.println(&quot;Hello World&quot;); // 打印 Hello World    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 一切皆对象。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（四）</title>
    <link href="http://www.wshunli.com/posts/9695607b.html"/>
    <id>http://www.wshunli.com/posts/9695607b.html</id>
    <published>2017-11-19T06:34:43.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文具体内容. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文具体内容. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1+sWew/Yotwca05pqZ3k61xf6pDJFhIDiYdsswTGwyVRKH53OpNVMTNrQaPGVfA6meLk2yR/WybjJTBiapc1nxuoJ64ykmRQuQc/7BZoK+SWQHQc4cV4qi0SaReX763orB4rItcKAtUHFh6Frw00syeOMlK+WoZVDtqU5duYFzh2+HBy59ElHpmBzo3L2RRAaFvFzvShz4rDLeKoKVC01qJpSXY1zVeNJtfMTnZ6b0zBU3ILc4SVS5tKIRqh5Ftq6bDSu6kOXugPajU5ZQ2jqFVfO4TAOqdQ4Bptu67oQ3U5zaUXo2AkQAFXyw8cuzt90yjabKxUTuzeFAPGWhobWqUzml0RuSlG7C66VpSQSubeQg5QIuaV6VJnSU6CcT0wxfOPpUQDuPxnuE/GYKzFpq5iTKkIc5YHvzCDRF4KRxeDqVqitJ5xk3Gmxup+YxS78z1bZhuZ5rprGGAEqjrkzs1OgFrKI44mSNjQkZlfXO/i8+gwPTYESElB1i3g9jSKYcb+X+tEbir2rDTkV4kFVslZlkQj6KmJGQqXyoThf0kRYnZhPup0HWI7ZvXpFB2Jf7/cBf9MoOvQAScyZclITjNXv9YwgbI1IzkK3q52pEY8iY8SZLP/VCVfBt1qnKO5+tQ0z3bsWcxOMFT5Lr66emZJ6tIhBMp0TeoOHx0Zb+Pr7gtGsyskq8uSPFcfzg9BH453Vwk+RpSh/Yynzaq1fsYhBBI7Ap5VO0sWy8Zey1GAuWN7RnjrUgyiIjeVCEcrs4Ef9fp5vDYkzbEk2Wv0eFNoUunEMkr5R4qO1DYoIFZTj9WBOUlasqR55syTiHJc8QBgAmaVH5tlsYTnKsoV7SyiJnwHWJXFKoOD237utl0ftl7any+OFoIAmf1XICBOi79RIj4ppQm6E1NHfHvdlXMMtLIprCQ/Um6gN1PBKAZ3AY0YoGEu2HA7OijgFu4V32yzOgnIyvJKvYPGrQ6zOLUljJOhIq74soYEA+8yHjf2xF8JNMDre/dzvit1zrCAbbKG9t9vZOWSCmARPl+QofbcAACiO5jET5Ak89WGjBR/JqLc9m2nfqBTezfU3HyP/f+1+9+pVEwAIPtELLeURW7niSdLqMjRZjiXhH/t0U9IP3WaU2fJqF7C9GIjQifc2zra2r/d8o2LTHTxehe7gXQzUyEi4boJ3ifqMzhAC9kiqE1VPq1eqVGiBvWI3mUF7SAuk0nzSrv1q/XY6CdKlsZ3mYge1B/UeO1Ta7WGTtshZtcvvn7WbvQQkFc7ykHzsdNYX/zEhWnSV2CjBJHgACSumPS44I4Ec2aJTTvLjbnbg7+7buTZX4JUS0FoTTE6KjfYhEdWx6KtFK50BqIJdMTM/+pWzb3IbnfOENg1juf4g3AF8Xp/EC1gWcfr8Rw0XRdZsVvZc7T7baojtF10QdAVyQJVoUjKQB/2TEBz73cQHhmsG4YvzyuwNRp9XfPn1X8u/zpYhLpcI35fR7S4nVOrDPwqKGL6YFyKZYzgT/7ayY+qpEuQxTtgFFQ+4ncjH/RC2fg39HKQvHbloA7glQliLPxLYs/g/JYfst6cgWdybEexBDJ2UFDR+5Rs1QQadV5nb86/HRL9AIM9Q/6uEB52J40kI5PBt+9sDaeSDrn7/FFRA3UHWyk3MgVmVzsQEHbQ/nNk0CTCRgAsY8riNBwxPx4oU5oVkvSr1CxXOIlIjwW/9J5Q5C1Rn9wL1zPUsXconDbwcc4WegjACuMF8jUofmBQ0WOiWLHpn+l/2UotIhTZ+BpoAt/kDlZAqdu6TpYHwChlKpOamnHWzpBITvLEmyo4941l420VaGzUWp5Artl17FvbHNSBcmoqTCvJEQA+lDnvNBLq36VOPlT4u4LAJE4I8Y7ikaPH7/Q8WHkRSRdJ4sFz8Skwx5KHO2Mov8w2e4OP2rKud4nayMyYnxL25PrCjU4GqgXEdkHD1/CyxAJEPvS7SmyS3xyZmgf8LR/rHpWIEAOliqRzkZgrbHOf0yuoYHk26qw+Ro7Cx6sOMKFMK94RA7D7/zsrBaaQbj+DMGyvpeTcL1bM2zwgzUpkwayrsrZjSxehAS28IX76Xqk9Y+N6i99hi1NcM5teje+JJqcrIdqT+3NgndsTcBLP94v/55gq6cdar28CVLRGNXYcYbeicrsLIQUNNd+ctbeY27cb9QfCirif56fK3OrnLYaTgEUHGF8tP3qTb1JL8RyXkjIr2yQM06ntUTSEZqKHai7AFMR4iP1Hu3lkNtpGs7LNVqT2NWssUxMkysWRfPSjSi/R0qVxJVyf0ZQ1LAuowgUpxKN4fmMBvW5X1ZHz2U1s3+n5ZakLGA+4qUu1CR0T7RdSdAPIY9Ul5WSLgxVU24N/FlSnVh5ESr/M6LURvjEMfpJwQKM7etCqqV/Zhb2D8U516bNRap+bcXVodSsMt7oJRw/tWxrxIjYeUoovUD++VUhScCdCX/lznmBC/566sF2AJU5AzjYmZFZSjaqeEio/BNFJ85ROlrj3nXQvDh/1naYajD0Jeh3hhcGQW++S70LTX0FBYGCVPNtiJq2tChygc61c/RMt6iedVBpCD9WFyqarmUGOzDgOKw0ry9+O86eIRg0eQLL+qHCQIPBg5VpEPUdm/ohH5b3pvnHJL4oe5wJ5UX9TQEuZvs8fEGG/FXw5c8XKhzpSqmOP2VIZ8PRJjYR05FQdIH0F1Dz7xEbfl1osrJ1D/NsZ/72TTw7TIij9qdQjjDlc8Hxg1gOg/zu1iN2FEfYRSNqhIDveyMAid4kg13DQL4qqxp/66cDMyRrJG8A3g74uXDnqvcyTQE+GgceQEaAwAEXHGNRgXqezuHc5HhfXoeIdRJeiSX97ODjmaDkVlh5vuTeSAX/Sua6qRFW6qRI+Lr2onLaYIXUB16PSgfmB+6OEkL7CBAdxHUT8EPjQT/jVmKEyUomytUUNf9BKsBmtQlyIB5rJ3zUytyMbqVaAPkZ/7gl3DKt++kKcP8ST9HJsGIliaY7b1kDYqfT0g1cwJD55QFEyxMXTusE46LSpRsBhqes0IulhUjNtafRKac5ZTbZvnpOuhl/qDmldg/5vxPx5TavFHDDgeXtoO/LBc9DHBD1duDw1SJZMh5XAKlSlHCeAjU1quy1uIor5IvOaEYBu0SlPG8e4HatVRd1OgvYB8zdOTH3CBV+BuGz6OCi3X/FznbHVUAcImGRB5inJZXx6/eLYU++acq916jEBbGOyW21D8+uDaKyU4IhP68d8PTo0ixoKZ5ZAcqO2ajCQ2R1ZkIHI+vmLuexpn6pj+mywf8liNKp8pegAUQyGNdp1VsVXir/6M4kA6t78ESCjtxAMkkwtV17r8X4wgpqr18RrsO0DsBRpcMzSX3+mqLicR7iPB2sm95181geoIWeoGnIdYFrpIDuIaccQU8wR//ca9HpevnfCpPsRat+D8/OkrnXxu958GR16yyURuRfY+M0wdhECiTu70VBdMtTiGRUgqEbc/2K+9GWCovFhzHUO4gJ4NC5aXaP/FyZk5irDo9ZMOgcKtVhXUgl6N9ujgUk2v+yyoA3Hnh/tQwWh3WoZlyFtZ5g3FCCz3zzPASiWiWvU4TxaXWfN2UBSSm3mGET+Cj1gBRa4lvv8x3BBhnYX+cSQS45yjd8/w5pIWOTIgRg/d3QjQHP+dhLFmbDxHCeMRsJDAJmqAgA2GG+0u3iUpWaHzUqvKLekW0F2FaBrQUurHUFsStvR39YCzegqp55rUkVxP1Qba2RQOQQwMEJlBg4a26ENoB6HD5EABQ+GA1a18E1BcFsgi/pp5IMCUv7oWs6VI+fU6h8la0wMlFpCm5/sWNSikM4lJxLn1UK+dWlpfiQ7In3Tk6zi+cFkq77R3cpmQhJv3iXeyC4/GOi0DpLOZ1IemqQRLTbYTI3aEpWZq3SuSRj8ZvZoYdSuftLSyarhXHA54kaNdzSZMmrytmwIZQaUcKoay6J+0HdmhbY/hLCcSK9PRJpNKhCGcaAJdRywjukiz9/U9FNI9ljFHINyL1BnmdVQ7rwQQeWQsE8CQN6F5N1FWqabJ0qMYz+VV1NJmM0ZPngQ/94Np/mei5B9EiodXjFLE172b5WrAsbeu0TczJnQw6qBoYhMU79g0U2Opuu75oiRYs0SZtNDCF2qs0DDZUTcDir28J1czVHF/qrbaIIz6rGssvWJiMG7rBrJr8vhXMJyrHcKJ7daGMQ1VFU2LIlL0J6QdLN7SX6b84aeiMmE71CJ4lTW+qVCRVq5RMol34/PAm4yp7Pd27J2o2M6Jv/FWTLPr4DjEKltLZj5SYqBWfvMhkY9e+BmBhvZ8P08l3YTNO6ZPS0TYfFvLKWaQy+ZJyQDYf//yduSgVbpErOZcKYtqnepZonleGOBycd3QhIGCuCAOkLwx96PQtpEJ9vX6k6SdrSTvcj3Xa0Wy+BnkkrrbwIcv4BeUhcNoIgTtSYRPjRtwASg2HKim6wIrZeBFpIXGzpNpJ7IYKSkLI4lEBPfK/QxOzRSEbIKr3xjIWU8evaMpghKtnC1wCuAFbWLA/aI2//YYf322c3jCDMLfmF79GtXyDuDIsKYMEpqICZjQ/+JkXmzGalE/gl8P8kMBhPlCc3yNJlxkJIuaHOnsi8b9VCPqxubPQ98Y7ZWdOI0ZFFVlMqY8+iRJ4V/Ti6SYCLV3QlcAON1ueIzb/VJKBq1GcFexjPBnnod4UVc/lq0LUE1V3LMw+wkkLMyXPJuMj0JjVOZhkzikW4W44unJZo5xddT4rvmjr89FkHsoBFTs90XQ86SL3dXk/ige7lOtl7C1hE+wyF3nbD4op/iJuCwEDYqG+IalGROidtMlXACjahUExbu+ythWCAK/H3zEMlrq1e3aHzK8BqC2cZk2DjAtKem2lB+0W5gl38OVIhGUhcZWoBlH2HfgKqbin9Gim6snam6cXGwEjDEUJix/5sTO18DJKzbfi6otzNWPU2xRC/PdI1osiU7ezrgNBzBCIykvOqgqb0o2+IWtvurZ5MeUsQnQXwBAWQoCJ8DAJTtOKmf5LZwkzjRD0YntYc9TGYj8Q1mnlOZeOZut9PU8+UOHl/U5/miiHLjykwoXZN3Cp2a31MYW6euOQyGf2FC3W/y9aMNsi2BVe8K5sY5ir1RyHdDiaC0YmXn1sYySqFkNm84TrYFAbjRRnqWqg9OzcPnvDSTkwGPrM9MPvF++EqsJBA4JZgxE2nsWL1GcaUzeED8ei4MqjPUGLcBqCON7wKMAAQEsuJLOnbS8EOG68napPGg+7LInRu6mOchI+3dN0/BkLwJYDP7Tp1jvsvdTN48GBu+QvK8gXoIc/RTA7eKqMmYeCmzbLEmXopTuBnfwRsbrlFySjw0HcCdLQqO3dGN7r3YFm6Ik3rS784Cv/mrnEbYybn7+IkkvoXRegttut2T/9A1mNQVu4fLIM4aLfuofb6uydaR6dvXoaoOYGehTMiYm5WdjxAZqSY6Enbbl4ZRia5VifeUrHdLmPyvgn/Gsvmi8f3B266nrgUsy7/EQkqtZqFoiTzkcRZZ6WF5TYQR/uEE9jloeZxSgjrusro86HUxRJaOrX1DRZclaDcsvWISRCjhb3rx+fKaCttqWujNk/bOvHIDQenRBMkgds409NW3ZJCBssdcZAKNTeFcBKJ100m9xJlejTyqI6aGg4qyFcPLCu5Lmg4w2de9Svmu7ceYXSEZZdg6xgdjr6kT2zIB5mbDpMvqJ2WWA5oeEiF4UGXPRyPp1NdlkBtYJZodQm4Gy0bkEXMSH5b+Q1ZvBaF+j7h4Q2/rS6OZUomIuJYEyt1o8N+IBlVEFUgxQxRfFlIZb3S0K0idk0lqhiSsLpUluzPH0RTFG+nqM98fB+kuP3pYRTurdOiLxSst/zd6hENbO6r33PUWmOrScaNW4eqEA1+2kpF4N/HO+B3uE/7grHRxUpAXiKH/0JFhDjhnHDrRfweXFSMNKhsXUVAvtU1kCmSPkp2U2JRiu7MJ0AYDz0bmLUb/YsMJ7Q3QxDFCQ6BW5yO7LZIn6AmyqTPkuzVIvA6lU8afPV1NMkkeomI1TJ3Ogq+C+CozTzidkG3rQEOukLx/+/1qtYtJuJlsCNJn7nHyPCJxT+A4Br2NIba3svySejasCWUgHf/FOosZcQEyTc/rivpb38SAazNGYrrdFJN2XfuhTSo995aYRE2LIuyfOtWP4pDbTAvWHAHrUnCoFwekSFfld47FoMrKtjKSkKVIJv7CHZ4kWEOQoSJg94umeazVmuzFfJojgKHOIA5GNFP6Ii94hQuY1kPTQ+m35t2eb4e/FKyFKgOIKP7MXz3/FisXhXWUJGRk7Eewklp+knQB6+IPWToqgzLP/KlDkT0Tw4hvqVeG49GSSRLyW43t7QZL2xY2qlH/cMX4XLfFRle9xKwCmU3tlX6m36LbC3wMj8tzIOwk40eZk4rBKFK/ZiPeHP5B9leGM3bqminAK8JSxa0JtoT2woI7EKSdP1V+ICc7vld0pPsye7z/AWiulJRGzoY4Gz6Fz+R9GZYJYCl0uZWe74jxJUanrYQoV6d8zinysl4aB2MOXPRlzJP5nMyoRI6pjBXiMUs4EcQ2xJOIGZ8GYlai6OdbeBLixsMxHNss2/eUTwWW0sxj95Xn/YWvyQNYL21a5Fm2TMPABu9CwJj7fZFvNUgOOG2q9Ks7nrBbVSp352tLZLHI4iEh7DjVrngnWHx09lJAhnQJivi1+zOA71C8oH9txXPfrJSguz5TDUDMEu7JB0K/tALFMKw/UcZ4ZAQnqfp88kI5ptmQRJVL5t+ySsXK/wib99Q1CZE7eugef3E6mqWRbwBxGgCv+ytCwClL8kXQEE78zuthfTcMxpIinftqqppV4LVvWBSEvIcrMqYUWkMmaGtRGSgjWBjxPwkuXwfJNXoYND7Rarj0c4HvZ+wnsBh+yrMw5GmXqyWZcv5OzHG6I5gyc161ZsOZxzqSTmfZTQvKtKgzsgWwIjRIesQLF2jzvcN7Cf20NIKf+U2bwIf/v+t4D+Z5spmCo4uJ5gLddAD5ZgpZ3PJfF5JUw9Fg8WeLtoKEEWFiEIJfjkujAEFiGQF1nTbenwOwDRPN1B9X39oypLoXWvgYUKeKWfVC12QcxLeEflg2GLmuk12dc0MSLlS9yWFxMifCCPnFF8Of+bhMmu3jxqEyz/pq80uVaoHSmzfirMMXl8Sy4b50Ka1lDt5342mt9jFffvDlsbNuBQjLErijVS6pNw7EE5nS3evJWdu+BXU2CTGXjF/Ih8Kt2oPomwcnHzkMlxqfssUwKdRU34GTuO0r76S3L5hjxhRC6id7zdpmo2crsKqNcKRqoFT7ftwjFHv5hi50po4YiVaYxtoPwo0LzR5lP5kpcV3sXEqGI8Sa195a+imja+BbaroyL2s+bYL3GeU4phLGcFU3YAaFuhc7daEr4yfaBcxm5jdn7/UyhMa4TL/P200C0I+xaA6unnXnJMUoLYqx7e+oZvtc8OOcYRrxiaLSQKijspbpcDDtf3AY/vTFBAIHARiyktHQtSM5MF9+JNXKwwtZ2NGOv8cDHdipqxi7Rzatxes0JfW0cS+U7edmxps </div>]]></content>
    
    <summary type="html">
    
      看得更远，走得更远。
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《React Native开发指南》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/46b86b5e.html"/>
    <id>http://www.wshunli.com/posts/46b86b5e.html</id>
    <published>2017-11-18T04:23:39.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。<br><a id="more"></a></p><p>我选择的是先看 《React Native开发指南》 入门。</p><h1 id="第1章-初识-React-Native"><a href="#第1章-初识-React-Native" class="headerlink" title="第1章 初识 React Native"></a>第1章 初识 React Native</h1><p><a href="https://facebook.github.io/react-native/" rel="external nofollow noopener noreferrer" target="_blank">React Native</a> 是一款用来开发真正原生、可渲染 iOS 和 Android 移动应用的 JavaScript 框架。<br>React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。<br>在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。</p><h1 id="第2章-React-Native-工作原理"><a href="#第2章-React-Native-工作原理" class="headerlink" title="第2章 React Native 工作原理"></a>第2章 React Native 工作原理</h1><p>React Native 使用 Virtual DOM 作为中间层，介于开发者描述的视图与实际页面渲染的视图之间。<br>Virtual DOM 不仅能提升性能，而且提供了强大的抽象能力，在开发者代码和实际渲染之间加入一个抽象层。</p><p>React Native 调用 Objective-C 的 API 渲染 iOS 组件，调用 Java 接口渲染 Android 组件，而不是渲染到浏览器 DOM 上。</p><p>React Native 的渲染周期和 React 完全相同；组件也很类似，只是名称有差别，但是和原生的组件名字差不多；使用 JSX 以及 React 的内联样式。</p><p>React Native 同样可以调用宿主平台的接口，比如数据存储，操控硬件设备等等。</p><h1 id="第3章-构建你的第一个应用"><a href="#第3章-构建你的第一个应用" class="headerlink" title="第3章 构建你的第一个应用"></a>第3章 构建你的第一个应用</h1><p>类似 React ，使用 React Native 构建 Android 应用，可使用 <code>create-react-native-app</code> 脚手架工具。</p><pre><code class="JSX">npm install -g create-react-native-app</code></pre><p>安装完成后执行以下命令即可创建 React Native 项目：</p><pre><code class="JSX">create-react-native-app first-react-native-app// 打开项目目录cd first-react-native-appnpm start</code></pre><p>基本上就构建完成。</p><p>运行在 Andoroid 系统:</p><pre><code class="JSX">npm run android</code></pre><p>代码也比较容易理解：</p><pre><code class="JSX">import React from &#39;react&#39;;import { StyleSheet, Text, View } from &#39;react-native&#39;;export default class App extends React.Component {  render() {    return (      &lt;View style={styles.container}&gt;        &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt;        &lt;Text&gt;Changes you make will automatically reload.&lt;/Text&gt;        &lt;Text&gt;Shake your phone to open the developer menu.&lt;/Text&gt;      &lt;/View&gt;    );  }}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: &#39;#fff&#39;,    alignItems: &#39;center&#39;,    justifyContent: &#39;center&#39;,  },});</code></pre><p>感觉和 React.js 差不多，比较容易理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。&lt;br&gt;
    
    </summary>
    
      <category term="跨平台技术" scheme="http://www.wshunli.com/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React Native" scheme="http://www.wshunli.com/tags/React-Native/"/>
    
      <category term="《React Native开发指南》" scheme="http://www.wshunli.com/tags/%E3%80%8AReact-Native%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/86c8e45a.html"/>
    <id>http://www.wshunli.com/posts/86c8e45a.html</id>
    <published>2017-11-15T08:05:27.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习 《深入浅出React和Redux》<br><a id="more"></a></p><h1 id="第3章-从-Flux-到-Redux"><a href="#第3章-从-Flux-到-Redux" class="headerlink" title="第3章 从 Flux 到 Redux"></a>第3章 从 Flux 到 Redux</h1><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>Redux 是 Flux 单向数据流思想的另一种实现方式，先介绍 Flux 的优缺点。</p><h3 id="MVC-介绍"><a href="#MVC-介绍" class="headerlink" title="MVC 介绍"></a>MVC 介绍</h3><p>MVC 框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分为三个部分：<br><img src="https://img.wshunli.com/React/深入浅出React和Redux/MVC.png-hexo.png" alt="MVC"></p><ul><li>Model （模型）负责管理数据，大部分业务逻辑也应该放在Model 中；</li><li>View （视图）负责渲染用户界面，应该避免在View 中涉及业务逻辑；</li><li>Controller （控制器）负责接受用户输入根据用户输入调用对应的Model 部分逻辑，把产生的数据结果交给View 部分，让View 渲染出必要的输出。</li></ul><p>MVC 框架提出的数据流很理想，用户请求先到达 Controller ，由 Controller 调用 Model 获得数据，然后把数据交给 View，但是在实际框架实现中，总是允许 View 和 Model 可以直接通信，MVC 很快就变得非常复杂。</p><p>Flux 执行更严格的数据流控制。一个 Flux 应用包含四个部分：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/Flux.png-hexo.png" alt="Flux"></p><ul><li>Dispatcher ，处理动作分发，维持Store 之间的依赖关系；</li><li>Store ，负责存储数据和处理数据相关逻辑；</li><li>Action ，驱动 Dispatcher 的JavaScript 对象；</li><li>View ，视图部分，负责显示用户界面。</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Flux 的基本原则是“单向数据流”， Redux 在此基础上强调三个基本原则：</p><ul><li>唯一数据源（ Single Source of Truth);</li><li>保持状态只读（ State is read-only);</li><li>数据改变只能通过纯函数完成（ Changes are made with pure functions ）。</li></ul><blockquote><p>参考资料<br>1、Flux | Application Architecture for Building User Interfaces<br><a href="https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow" rel="external nofollow noopener noreferrer" target="_blank">https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow</a><br>2、Flux 架构入门教程 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2016/01/flux.html</a><br>3、</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习 《深入浅出React和Redux》&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>又拍云CDN全站加速</title>
    <link href="http://www.wshunli.com/posts/97fe98e3.html"/>
    <id>http://www.wshunli.com/posts/97fe98e3.html</id>
    <published>2017-11-11T11:44:24.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。</p><a id="more"></a><p>前几天使用 Travis CI 自动构建 Hexo 博客并且上传至 Github 和 Coding，就在想能不能同时上传至 <a href="https://console.upyun.com/register/?invite=H1_D-bC4W" rel="external nofollow noopener noreferrer" target="_blank">又拍云</a>。</p><p>今天晚上使用 ftp 上传至又拍云，网站实现全站 CDN 加速。</p><p>前面发现是有工具可以直接上传至又拍云：</p><p><a href="https://github.com/Menci/hexo-deployer-upyun" rel="external nofollow noopener noreferrer" target="_blank">hexo-deployer-upyun</a></p><p>但是这个工具在 Windows 系统下使用有问题，并且我已经使用 Travis CI 自动部署了，继续使用这个工具有<strong>令牌</strong>暴露的风险。</p><p>所以就想使用 ftp 上传至又拍云，然后就发现了这个工具：</p><p><a href="https://github.com/git-ftp/git-ftp" rel="external nofollow noopener noreferrer" target="_blank">Git-ftp</a> – uploads to FTP servers the Git way</p><p>在 linux 下的安装方法：</p><pre><code class="Shell">git clone https://github.com/git-ftp/git-ftp.gitcd git-ftp# choose the newest releasetag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;# checkout the latest taggit checkout &quot;$tag&quot;sudo make install</code></pre><p>配置 git-ftp ：</p><pre><code class="Shell">git config git-ftp.url &quot;ftp://ftp.example.net:21/public_html&quot;git config git-ftp.user &quot;ftp-user&quot;git config git-ftp.password &quot;secr3t&quot;</code></pre><p>第一次上传执行：</p><pre><code class="Shell">git ftp init</code></pre><p>后面上传执行，只会上传变化的部分：</p><pre><code class="Shell">git ftp push</code></pre><p>使用方法也很简单，下面就默认在原来 <a href="https://www.wshunli.com/posts/7dcaaf9e.html">Travis CI 自动部署</a> 的基础上:</p><p>在 <code>.travis.yml</code> 文件中修改：</p><pre><code class="Shell">install:  - npm install  - git clone https://github.com/git-ftp/git-ftp.git  - cd git-ftp  - tag=&quot;$(git tag | grep &#39;^[0-9]*\.[0-9]*\.[0-9]*$&#39; | tail -1)&quot;  - git checkout &quot;$tag&quot;  - sudo make install  - cd ..</code></pre><p>在 <code>publish-to-gh-pages.sh</code> 中修改</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;git ftp init# git ftp push</code></pre><p>第一次上传之后，修改 <code>publish-to-gh-pages.sh</code> 文件</p><pre><code class="Shell"># git-ftp 上传至 upyungit config git-ftp.url &quot;ftp://v0.ftp.upyun.com:21/&quot;git config git-ftp.user &quot;${UPYUN_USE}&quot;git config git-ftp.password &quot;${UPYUN_PSD}&quot;# git ftp initgit ftp push -v</code></pre><p>其中 UPYUN_USE 和 UPYUN_PSD 是在 Travis 中配置的 UPYUN ftp 用户名密码。<br>具体值可参考：<a href="https://docs.upyun.com/api/developer_tools/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.upyun.com/api/developer_tools/</a></p><p>其实有点弊端就是上传之后更新具有一定的延迟性，但是速度快很多。</p><blockquote><p>参考资料<br>1、travis-ci-deploy-ftp<br><a href="https://github.com/ansediao/travis-ci-deploy-ftp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ansediao/travis-ci-deploy-ftp</a><br>2、How to use git-ftp： 使用 git-ftp 管理你的 FTP<br><a href="https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9" rel="external nofollow noopener noreferrer" target="_blank">https://medium.com/@awonwon/how-to-use-git-ftp-使用-git-ftp-管理你的-ftp-1864700c6eb9</a><br>3、使用 git-ftp 将 git 两次提交发生变化的文件上传到服务器<br><a href="http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server" rel="external nofollow noopener noreferrer" target="_blank">http://www.sunzhongwei.com/use-the-git-ftp-to-upload-git-diff-files-to-the-server</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Travis CI 自动部署 Hexo 博客，同时上传至又拍云。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="Upyun" scheme="http://www.wshunli.com/tags/Upyun/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/d0f6201d.html"/>
    <id>http://www.wshunli.com/posts/d0f6201d.html</id>
    <published>2017-11-10T05:40:03.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。</p><a id="more"></a><p>之间就简单地使用 <a href="https://reactjs.org" rel="external nofollow noopener noreferrer" target="_blank">React</a> 搭建过一次 Demo ，借这次机会把 React 给搞定了，至少能写个简单的界面。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React技术栈.png-hexo.png" alt="React技术栈"></p><p>看着这 React技术栈 ，还是压力山大啊。</p><p>这次选了两本书 《深入浅出React和Redux》 和 《React全栈》。书都很新也很薄，这次先看一本入门。</p><h1 id="第1章-React-新的前端思维方式"><a href="#第1章-React-新的前端思维方式" class="headerlink" title="第1章 React 新的前端思维方式"></a>第1章 React 新的前端思维方式</h1><p>首先使用 <code>creat-react-app</code> 创建一个 React 应用。</p><p>在确认 Node.js 和 npm 安装好之后，在命令行执行以下命令安装 <code>creat-react-app</code> 工具。</p><pre><code class="Shell">npm install -g create-react-appcreate-react-app first-react-appnpm start</code></pre><p>浏览器会自动打开 <a href="http://localhost:3000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:3000/</a> 显示如下界面：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app.png-hexo.png" alt="first-react-app"></p><p>我们来看一下 first-react-app 的目录结构：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/first-react-app2.png-hexo.png" alt="first-react-app"></p><p>在开发过程中，我们主要关注 src 目录的内容。</p><p>其中 <code>src/index.js</code> 文件是应用的入口文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import App from &#39;./App&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>这里的代码渲染了一个 App 组件，效果就是首页界面。<br>我们看下 App 组件是怎么定义的，在 <code>src/App.js</code> 文件中：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import logo from &#39;./logo.svg&#39;;import &#39;./App.css&#39;;class App extends Component {  render() {    return (      &lt;div className=&quot;App&quot;&gt;        &lt;header className=&quot;App-header&quot;&gt;          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;        &lt;/header&gt;        &lt;p className=&quot;App-intro&quot;&gt;          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.        &lt;/p&gt;      &lt;/div&gt;    );  }}export default App;</code></pre><p>React 应用实际上依赖很复杂的技术栈，我们使用 <code>creat-react-app</code> 避免一开始就浪费太多精力配置技术栈。</p><p>我们启动 React 的命令是 <code>npm start</code> ，在 <code>package.json</code> 中：</p><pre><code class="JS">  &quot;scripts&quot;: {    &quot;start&quot;: &quot;react-scripts start&quot;,    &quot;build&quot;: &quot;react-scripts build&quot;,    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  }</code></pre><p>npm build 可以创建生产环境优化代码；<br>npm teat 用于单元测试；<br>npm eject 把 react-scripts 技术栈配置都弹射到应用顶层，不可逆。</p><h2 id="添加-React-组件"><a href="#添加-React-组件" class="headerlink" title="添加 React 组件"></a>添加 React 组件</h2><p>仿照着增加一个新的 React 组件。同样在 src 目录新建文件 <code>ClickCounter.js</code> 写入如下代码：</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;class ClickCounter extends Component {  constructor(props) {    super(props);    this.onClickButton = this.onClickButton.bind(this);    this.state = {      count: 0    }  }  onClickButton() {    this.setState({count: this.state.count + 1});  }  render() {    const counterStyle = {      margin: &#39;16px&#39;    }    return (      &lt;div style={counterStyle}&gt;        &lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;        &lt;div&gt;          Click Count: &lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    );  }}export default ClickCounter;</code></pre><p>修改 <code>src/index.js</code> 文件：</p><pre><code class="JSX">import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import &#39;./index.css&#39;;import ClickCounter from &#39;./ClickCounter&#39;;import registerServiceWorker from &#39;./registerServiceWorker&#39;;ReactDOM.render(&lt;ClickCounter /&gt;, document.getElementById(&#39;root&#39;));registerServiceWorker();</code></pre><p>其中在 index.js 中使用 import 导入 ClickCounter 组件，替代之前的 App 组件。</p><pre><code class="JSX">import ClickCounter from &#39;./ClickCounter&#39;;</code></pre><p>在 ClickCounter.js 的第一行我们以同样的方式引入 React 和 Component 。</p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;</code></pre><p>Component 为所有组件的基类，提供很多组件共有的功能。</p><pre><code class="JSX">class ClickCounter extends Component {}</code></pre><p>React 没有在代码中直接使用，但在 JSX 使用的范围内必须有 React，因为 JSX 最终会被转译成依赖 React 的表达式。</p><p><strong>JSX</strong>：JSX 是 JavaScript 的一种扩展语法，使我们能够在 JavaScript 中编写类似 HTML 的代码。<br>JSX 的基本语法规则：遇到 HTML 标签（以&lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。</p><p>首先，在 JSX 中使用的元素不限于 HTML 元素，可以是 React 组件。而区分二者的方法是首字母是否大写。<br>其次，在 JSX 中可以通过 onClick 这样的方式为元素添加事件处理函数。</p><pre><code class="JSX">&lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;</code></pre><h2 id="React-的工作方式"><a href="#React-的工作方式" class="headerlink" title="React 的工作方式"></a>React 的工作方式</h2><p>React的理念归结为一个公式：UI=render(data) 。</p><p>用户看到的界面（UI）是一个函数（render）的执行结果，只接受数据（data）作为参数。这是一个纯函数，即输出只依赖于输入的函数，两次函数的调用如果输入相同，那么输出也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于data ，哪些属于render ，想要更新用户界面，要做的就是更新data ，用户界面自然会做出响应，所以React 实践的也是“响应式编程”（ Reactive Programming ）的思想。</p><p><strong>Virtual DOM</strong>：是对DOM树的抽象，它并不触及浏览器部分，只是存在于 JavaScript 空间的树形结构，每次在渲染 React 组件，React 会对前后两次产生的 Virtual DOM 进行比较，最后只有发生了改变的地方会被重新渲染。</p><blockquote><p>总而言之，React利用函数式编程的思维来解决用户界面渲染的问题，强制所有组件都以数据驱动渲染的模式进行开发。</p></blockquote><h1 id="第2章-设计高质量的-React-组件"><a href="#第2章-设计高质量的-React-组件" class="headerlink" title="第2章 设计高质量的 React 组件"></a>第2章 设计高质量的 React 组件</h1><p>作为软件设计的通则，组件的划分要满足高内聚（High Cohesion ）和低搞合（ Low Coupling）的原则。</p><h2 id="React-组件的数据"><a href="#React-组件的数据" class="headerlink" title="React 组件的数据"></a>React 组件的数据</h2><p>React 组件的数据分为两种， prop 和 state。</p><p>prop 是组件的对外接口， state 是组件的内部状态，对外用 prop ，内部用 state 。</p><h3 id="React-的-prop"><a href="#React-的-prop" class="headerlink" title="React 的 prop"></a>React 的 prop</h3><p>prop ( property 的简写）是外部传递给组件的数据， React 组件通过定义自己能够接受的 prop 就定义了自己的对外公共接口。</p><pre><code class="JSX">&lt;SampleButtonid= &quot;sample&quot; borderWidth={2} onClick={onButtonClick}style={{color :"red"}}/&gt;</code></pre><p>当 prop 的值不是字符串类型时，在 JSX 中必须用花括号 {} 包住，<br>所以 style 的值有两层花括号，外层花括号代表是 JSX 的语法，内层的花括号代表这是一个对象常量。</p><pre><code class="JSX">class ControlPanel extends Component {  render() {    console.log(&#39;enter ControlPanel render&#39;);    return (      &lt;div&gt;        &lt;Counter caption=&quot;First&quot; initValue={0}/&gt;        &lt;Counter caption=&quot;Second&quot; initValue={10} /&gt;        &lt;Counter caption=&quot;Third&quot; initValue={20} /&gt;      &lt;/div&gt;    );  }}</code></pre><p>上面是给 prop 赋值，下面读取 prop 的值：</p><pre><code class="JSX">class Counter extends Component {  constructor(props) {    console.log(&#39;enter constructor: &#39; + props.caption);    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue || 0    }  }  ···</code></pre><p>在构造函数中可以通过参数 props 获得传人 prop 值，在其他函数中则可以通过 <code>this.props</code> 访问传人 prop 的值。</p><pre><code class="JSX">  ··· render() {    console.log(&#39;enter render &#39; + this.props.caption);    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }</code></pre><p><strong>propTypes 检查</strong>：组件声明接口规范，即组件支持的 prop 及其格式。</p><pre><code class="JSX">Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number};</code></pre><p>建议在开发阶段使用，产品环境下去除。</p><h3 id="React-的-state"><a href="#React-的-state" class="headerlink" title="React 的 state"></a>React 的 state</h3><p>state 代表组件的内部状态。</p><p>1、初始化 state</p><p>通常在组件的构造函数结尾处初始化 state 。</p><pre><code class="JSX">constructor(props) {    ···    this.state = {      count: props.initValue || 0    }  }</code></pre><p>React 的 defaultProps 给 prop 默认初始值：</p><pre><code class="JSX">Counter.defaultProps = {  initValue: 0}// this.state 可省去判断this.state = {  count: props.initValue}</code></pre><p>2、读取更新 state</p><p>this.state 读取 state<br>this.setState 更新 state</p><pre><code class="JSX">onClickIncrementButton() {  this.setState({count: this.state.count + 1});}</code></pre><h3 id="prop-和state-的区别"><a href="#prop-和state-的区别" class="headerlink" title="prop 和state 的区别"></a>prop 和state 的区别</h3><ul><li>prop 用于定义外部接口， state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时， state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><p>组件是绝不应该去修改传人的 props 值，否则会影响其他组件。</p><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：</p><ul><li>装载过程（ Mount ），也就是把组件第一次在DOM 树中渲染的过程；</li><li>更新过程（ Update ），当组件被重新渲染的过程；</li><li>卸载过程（ Unmount ），组件从DOM 中删除的过程。</li></ul><p>三种不同的过程， React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/React组件生命周期.png-hexo.png" alt="React组件生命周期"></p><p><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a></p><h3 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h3><p>当组件第一次渲染的时候，依次调用的函数如下：</p><ul><li>constructor()</li><li>getlnitialState()</li><li>getDefaultProps()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p>1、constructor()<br>ES6 中类的构造函数，主要是初始化 state 和绑定成员函数的 this 环境。</p><p>2、getlnitialState() 和 getDefaultProps()<br>getlnitialState() 返回值用来初始化组件的 this.state ，getDefaultProps() 返回值用来作为 prop 的初始值。<br>这两个方法只有用 React.createClass 方法创建组件类时才会生效。</p><pre><code class="JSX">const Sample = React.createClass({  getInitialState() {    console.log(&#39;enter getInitialState&#39;);  }  getDefaultProps() {    console.log(&#39;enter getDefaultProps&#39;);  }});</code></pre><p>而在 ES6 中使用 defaultProps 指定初试 prop 初始值。</p><pre><code class="JSX">const Sample extends React.Component({  constructor(props) {    super(props);    this.state = {foo: &quot;bar&quot;}  }}Sample.defaultProps = {  return {sampleProp: 0}};</code></pre><p>React.createClass 已经被 Facebook 官方逐渐废弃。</p><p>3、render()</p><p>render() 函数在 React 中必须实现，其他生命周期函数在 React.Component 中都有默认实现。</p><p>render() 并不做实际的渲染动作，只是返回 JSX 描述的结构，最终由 React 操作渲染过程。<br>不需要渲染界面可以返回 null 或者 false 。</p><p>4、componentWillMount() 和 componentDidMount()</p><p>在装载过程中，componentWillMount() 会在调用 render() 函数之前被调用， componentDidMount() 会在调用 render() 函数之后被调用。</p><p>componentWillMount() 是将要装载，虽然还没有渲染出来结果，但是修改组件状态已经晚了。<br>componentDidMount() 是 render() 函数返回的内容已经渲染好了，组件已经被装载在 DOM 树上了。</p><p>componentWilIMount() 和 componentDidMount() 这对兄弟函数还有一个区别：<br>componentWillMount() 可以在服务器端被调用，也可以在浏览器端被调用；<br>而componentDidMount() 只能在浏览器端被调用，在服务器端使用 React 的时候不会被调用。</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>当组件的 props 或者 state 被修改的时候，就会引发组件的更新过程。<br>更新过程会依次调用下面的生命周期函数：</p><ul><li>componentWillReceiveProps(nextProps)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><p>1、componentWillReceiveProps(nextProps)</p><p>只要是父组件的 render() 函数被调用，在 render() 函数里面被谊染的子组件就会经历更新过程，<br>不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps() 函数。</p><p>componentWillReceiveProps(nextProps) 适合根据新的 props 值（也就是参数 nextProps ）来计算出是不是要更新内部状态state 。</p><p>注意，更新组件内部状态的方法 this.setState() 方法触发的更新过程不会调用这个函数，否则会导致 componentWillReceiveProps 再次被调用，陷入死循环。</p><p>当组件的 props 发生改变：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当组件的 state 发生改变：</p><pre><code class="TXT">&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>当父组件导致子组件重新渲染：</p><pre><code class="TXT">&quot;componentWillReceiveProps&quot;&quot;shouldComponentUpdate&quot;&quot;componentWillUpdate&quot;&quot;render&quot;&quot;componentDidUpdate&quot;</code></pre><p>2、shouldComponentUpdate(nextProps, nextState)</p><p>shouldComponentUpdate() 函数决定组件是否需要渲染，返回布尔值。</p><pre><code class="JSX">shouldComponentUpdate(nextProps, nextState) {  return (nextProps.caption !== this.props.caption) ||         (nextState.count !== this.state.count);}</code></pre><p>3、componentWillUpdate() 和 componentDidUpdate()</p><p>当组件的 shouldComponentUpdate() 函数返回 true ,React 接下来依次调用对应组件的 componentWillUpdate()、render() 和 componentDidUpdate() 函数。</p><p>和装载过程不同的是，当在服务器端使用 React 渲染时，二者都可以在服务端调用。</p><h3 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h3><p>componentWillUnmount() 表示组件要从 DOM 树上删除掉之前，比较适合做一些清理工作。</p><h2 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h2><p><code>ControlPanel.js</code></p><pre><code class="JSX">import React, { Component } from &#39;react&#39;;import Counter from &#39;./Counter.js&#39;;const style = {  margin: &#39;20px&#39;};class ControlPanel extends Component {  constructor(props) {    super(props);    this.onCounterUpdate = this.onCounterUpdate.bind(this);    this.initValues = [ 0, 10, 20];    const initSum = this.initValues.reduce((a, b) =&gt; a+b, 0);    this.state = {      sum: initSum    };  }  onCounterUpdate(newValue, previousValue) {    const valueChange = newValue - previousValue;    this.setState({ sum: this.state.sum + valueChange});  }  render() {    return (      &lt;div style={style}&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;First&quot; /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Second&quot; initValue={this.initValues[1]} /&gt;        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Third&quot; initValue={this.initValues[2]} /&gt;        &lt;hr/&gt;        &lt;div&gt;Total Count: {this.state.sum}&lt;/div&gt;      &lt;/div&gt;    );  }}export default ControlPanel;</code></pre><p><code>Counter.js</code></p><pre><code class="JSX">import React, { Component, PropTypes } from &#39;react&#39;;const buttonStyle = {  margin: &#39;10px&#39;};class Counter extends Component {  constructor(props) {    super(props);    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);    this.state = {      count: props.initValue    }  }  onClickIncrementButton() {    this.updateCount(true);  }  onClickDecrementButton() {    this.updateCount(false);  }  updateCount(isIncrement) {    const previousValue = this.state.count;    const newValue = isIncrement ? previousValue + 1 : previousValue - 1;    this.setState({count: newValue})    this.props.onUpdate(newValue, previousValue)  }  render() {    const {caption} = this.props;    return (      &lt;div&gt;        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;      &lt;/div&gt;    );  }}Counter.propTypes = {  caption: PropTypes.string.isRequired,  initValue: PropTypes.number,  onUpdate: PropTypes.func};Counter.defaultProps = {  initValue: 0,  onUpdate: f =&gt; f //什么都不做的函数};export default Counter;</code></pre><blockquote><p>参考资料<br>1、React.Component - React<br><a href="https://reactjs.org/docs/react-component.htm" rel="external nofollow noopener noreferrer" target="_blank">https://reactjs.org/docs/react-component.htm</a><br>2、React组件生命周期<br><a href="https://nsne.github.io/2017/02/15/react-component-lifecycle/" rel="external nofollow noopener noreferrer" target="_blank">https://nsne.github.io/2017/02/15/react-component-lifecycle/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis CI自动部署Hexo博客</title>
    <link href="http://www.wshunli.com/posts/7dcaaf9e.html"/>
    <id>http://www.wshunli.com/posts/7dcaaf9e.html</id>
    <published>2017-11-09T11:14:08.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。</p><a id="more"></a><p>我一般都是将博客的源文件保存到私有仓库中，虽然几个简单地命令就能部署，但是过程还是很繁琐。最近申请了 Github Student Developer Pack ，就想利用软件开发中的持续集成工具 Travis CI 来帮助完成 Hexo 博客的部署过程。这样就只需要把源代码 push 到仓库就能自动部署好了。</p><p>CI 是 Continuous Integration 的缩写，持续集成之意。持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><h1 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h1><p>关于 Hexo 博客的搭建请参考文章：<a href="https://www.wshunli.com/posts/9642fffa.html">https://www.wshunli.com/posts/9642fffa.html</a></p><h1 id="Travis-CI-配置"><a href="#Travis-CI-配置" class="headerlink" title="Travis CI 配置"></a>Travis CI 配置</h1><p>1.使用 GitHub 账户登录 <a href="https://travis-ci.org" rel="external nofollow noopener noreferrer" target="_blank">Travis CI</a> 官网，然后用 Github 账号登陆，就可以看到可以持续集成的仓库。</p><p>还有个地址 <a href="https://travis-ci.com" rel="external nofollow noopener noreferrer" target="_blank">https://travis-ci.com</a> 可以部署 Github 私有仓库。</p><p>选择要启用的项目，打开<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo1.png" alt=""></p><p>然后选择一些通用的设置<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo2.png" alt=""></p><p>2.登陆 GitHub –Settings -Developer Settings 选项，找到 Personal access tokens 页面。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo3.png" alt=""></p><p>点击右上角的 Generate new token 按钮会生成新的token，点击后提示输入密码后继续，然后来到如下界面。<br>取个名字，勾选相应权限，这里只需要 repo 下全部和 user 下的 user:email 即可。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo4.png" alt=""></p><p>生成完成后，将该token拷贝下来。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo5.png" alt=""></p><p><strong>如果需要将代码同时部署到 Coding 类似</strong>：<br>3.登陆 Coding ，账户 -访问令牌，新建访问令牌：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding1.png" alt=""></p><p>勾选相应权限：<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo-Coding2.png" alt=""></p><p>4.将上面获取到的token添加到 Environment Variables 部分，值为该 token ，而名称为 GH_TOKEN、CD_TOKEN 。<br><img src="https://img.wshunli.com/使用TravisCI自动部署Hexo博客/TravisCI-Hexo6.png" alt=""></p><h1 id="创建-travis-yml"><a href="#创建-travis-yml" class="headerlink" title="创建 .travis.yml"></a>创建 .travis.yml</h1><p>要想自动部署还需在博客源码新增加 <code>.travis.yml</code> 配置文件。</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - npm install -g hexo-cliinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:    - cd ./public    - git init    - git config user.name &quot;yourname&quot; # 修改name    - git config user.email &quot;youremail&quot; # 修改email    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master     # GH_TOKEN 是在 Travis 中配置 token 的名称branches:    only:        - master #只监测 master 分支，master是我的分支的名称，可根据自己情况设置env:    global:        - GH_REF: github.com/yourname/yourname.github.io.git         # 设置 GH_REF，注意更改 yourname</code></pre><h1 id="实现自动部署"><a href="#实现自动部署" class="headerlink" title="实现自动部署"></a>实现自动部署</h1><p>将原代码 push 到 Github 即可，如果配置没问题就该自动构建了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>虽然实现了基本的自动部署，还是有问题的。</p><h2 id="master-commit-树被清空"><a href="#master-commit-树被清空" class="headerlink" title="master commit 树被清空"></a>master commit 树被清空</h2><p>自动部署会把原来的 commit 清空，显然不是我们想要的结果。</p><p>为了解决这个问题，将配置文件改为了如下的内容：</p><pre><code class="TXT">after_script:    - git clone https://${GH_REF} .deploy_git    - cd .deploy_git    - git checkout master    - cd ../    - mv .deploy_git/.git/ ./public/    - cd ./public    - git config user.name &quot;yourname&quot;    - git config user.email &quot;your email&quot;    - git add .    - git commit -m &quot;Travis CI Auto Builder&quot;    - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master</code></pre><h2 id="添加-commit-时间戳"><a href="#添加-commit-时间戳" class="headerlink" title="添加 commit 时间戳"></a>添加 commit 时间戳</h2><p>commit 的描述一直是 <code>Travis CI Auto Builder</code> 。</p><pre><code class="TXT">Travis CI Auto BuilderTravis CI Auto BuilderTravis CI Auto Builder// 之前Site updated: 2017-11-07 22:05:16Site updated: 2017-11-07 17:19:32Site updated: 2017-11-06 18:04:53</code></pre><p>最终 <code>.travis.yml</code> 配置文件：</p><pre><code class="TXT"># 设置语言language: node_js# 设置相应的版本node_js:  - &#39;6&#39;# 设置只监听哪个分支branches:  only:    - master# 缓存，可以节省集成的时间cache:  directories:    - node_modulesbefore_install:  - export TZ=&#39;Asia/Shanghai&#39;  - npm install -g hexo-cli  - chmod +x ./publish-to-gh-pages.shinstall:  - npm installscript:  - hexo clean  - hexo gafter_script:  - ./publish-to-gh-pages.shenv:    global:        - GH_REF: github.com/yourname/yourname.github.io.git        # 设置GH_REF，注意更改成自己的仓库地址        - CD_REF: git.coding.net/yourname/repository.git        # 同时部署到 Coding，repository 为仓库名称</code></pre><p>其中 <code>publish-to-gh-pages.sh</code> 文件：</p><pre><code class="TXT">#!/bin/bashset -evgit clone https://${GH_REF} .deploy_gitcd .deploy_gitgit checkout mastercd ../mv .deploy_git/.git/ ./public/cd ./publicgit config user.name  &quot;yourname&quot;git config user.email &quot;youremail&quot;git add .git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot;git push --force --quiet &quot;https://${TravisCIToken}@${GH_REF}&quot; master:mastergit push --force --quiet &quot;https://yourname:${CD_TOKEN}@${CD_REF}&quot; master:master# 同时部署到 Coding，注意修改 yourname</code></pre><blockquote><p>参考资料<br>1、使用Travis CI自动部署Hexo博客<br><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" rel="external nofollow noopener noreferrer" target="_blank">http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a><br>2、使用 Travis CI 自动部署 Hexo<br><a href="http://www.jianshu.com/p/5e74046e7a0f" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/5e74046e7a0f</a><br>3、使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器<br><a href="https://segmentfault.com/a/1190000009054888" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000009054888</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Hexo 文章的增多，加上压缩文件的时间，部署时间越来越长。&lt;/p&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="TravisCI" scheme="http://www.wshunli.com/tags/TravisCI/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/2a9bf8cf.html"/>
    <id>http://www.wshunli.com/posts/2a9bf8cf.html</id>
    <published>2017-11-09T06:52:46.000Z</published>
    <updated>2017-11-29T14:47:00.685Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>这部分学习 ES6 中新增的数据类型。</p><h1 id="第10章-Symbol"><a href="#第10章-Symbol" class="headerlink" title="第10章 Symbol"></a>第10章 Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。</p><pre><code class="JavaScript">let s = Symbol();typeof s // &quot;symbol&quot;// 字符串参数let s1 = Symbol(&#39;foo&#39;);s1.toString() // &quot;Symbol(foo)&quot;// 对象参数-调用 toString 方法const obj = {  toString() {    return &#39;abc&#39;;  }};const sym = Symbol(obj);sym // Symbol(abc)</code></pre><p>Symbol 值不能与其他类型的值进行运算；可显式转为字符串或布尔值，但不能转为数值。</p><pre><code class="JavaScript">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym // TypeError: can&#39;t convert symbol to string// 字符串String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;// 布尔值let sym = Symbol();Boolean(sym) // true!sym  // false</code></pre><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>Symbol 值唯一，能保证对象不会出现同名的属性。</p><pre><code class="JavaScript">let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = &#39;Hello!&#39;;// 第二种写法let a = {  [mySymbol]: &#39;Hello!&#39;};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });// 以上写法都得到同样结果console.log(a[mySymbol]); // &quot;Hello!&quot;</code></pre><pre><code class="JavaScript"></code></pre><h1 id="第11章-Set-和-Map-数据结构"><a href="#第11章-Set-和-Map-数据结构" class="headerlink" title="第11章 Set 和 Map 数据结构"></a>第11章 Set 和 Map 数据结构</h1><h1 id="第12章-Proxy"><a href="#第12章-Proxy" class="headerlink" title="第12章 Proxy"></a>第12章 Proxy</h1><h1 id="第13章-Reflect"><a href="#第13章-Reflect" class="headerlink" title="第13章 Reflect"></a>第13章 Reflect</h1><h1 id="第14章-Promise-对象"><a href="#第14章-Promise-对象" class="headerlink" title="第14章 Promise 对象"></a>第14章 Promise 对象</h1><h1 id="第15章-Iterator-和-for…of-循环"><a href="#第15章-Iterator-和-for…of-循环" class="headerlink" title="第15章 Iterator 和 for…of 循环"></a>第15章 Iterator 和 for…of 循环</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/281a70b1.html"/>
    <id>http://www.wshunli.com/posts/281a70b1.html</id>
    <published>2017-11-09T06:44:01.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(六) 学习JavaScript的一些高级技巧及实践方案。</strong>(22-25章)</p><h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><p>这部分后面再看吧，现在那么水，估计还用不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/4d143b68.html"/>
    <id>http://www.wshunli.com/posts/4d143b68.html</id>
    <published>2017-11-08T13:12:48.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(五) 学习 JavaScript 对各数据载体的操作方法（如JSON、XML），学会 Ajax 的使用方法。</strong>(18-21章)</p><h1 id="第十八章-JavaScript-与-XML"><a href="#第十八章-JavaScript-与-XML" class="headerlink" title="第十八章 JavaScript 与 XML"></a>第十八章 JavaScript 与 XML</h1><h2 id="浏览器对-XML-DOM-的支持"><a href="#浏览器对-XML-DOM-的支持" class="headerlink" title="浏览器对 XML DOM 的支持"></a>浏览器对 XML DOM 的支持</h2><p>如何检测浏览器是否支持DOM2级XML：</p><pre><code class="JavaScript">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;,&quot;2.0&quot;);</code></pre><p>在支持DOM2级的浏览器中创建一个空白XML:</p><pre><code class="JavaScript">var xmldom = document.implemention.createDocument(namespaceUri,root,docype);</code></pre><p>通过 JavaScript 处理XML时，通常只使用参数root，这个参数指定的是XML DOM文档元素的标签名。</p><pre><code class="JavaScript">var xmldom = document.implementation.createDocument(&quot;&quot;,&quot;root&quot;,null);console.log(xmldom.documentElement.tagName);  //&quot;root&quot;var child = xmldom.createElement(&quot;child&quot;);xmldom.documentElement.appendChild(child);</code></pre><p><strong>DOMParser 类型</strong>：将 XML 解析为 DOM 文档。</p><p><strong>XMLSerializer 类型</strong>：将 DOM 文档序列化为 XML 字符串。</p><pre><code class="JavaScript">var parser = new DOMParser();var xmldom = parser.parseFromString(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;, &quot;text/xml&quot;);//convert back into XMLvar serializer = new XMLSerializer();var xml = serializer.serializeToString(xmldom);console.log(xml);</code></pre><h2 id="浏览器对XPath的支持"><a href="#浏览器对XPath的支持" class="headerlink" title="浏览器对XPath的支持"></a>浏览器对XPath的支持</h2><p>XPath 是设计用来在 DOM 文档中查找节点的一种手段。</p><h2 id="浏览器对XSLT的支持"><a href="#浏览器对XSLT的支持" class="headerlink" title="浏览器对XSLT的支持"></a>浏览器对XSLT的支持</h2><p>XSLT 是与 XML 相关的一种技术，它利用 XPath 将文档从一种表现形式转换成另一种表现形式。</p><h1 id="第十九章-E4X"><a href="#第十九章-E4X" class="headerlink" title="第十九章 E4X"></a>第十九章 E4X</h1><p>E4X 本身不是一门语言，它只是 ECMAScript 语言的可选扩展。<br>就其本身而言，E4X 为处理 XML 定义了新的语法，也定义了特定于 XML 的对象。</p><h1 id="第二十章-JSON"><a href="#第二十章-JSON" class="headerlink" title="第二十章 JSON"></a>第二十章 JSON</h1><p>JSON（Javascript Object Notaion，Javascript对象表示法）是一种数据格式。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON有3种类型的值：简单值、对象 和 数组。</p><ul><li>简单值：字符串、数值、布尔值、null（JSON不支持JavaScript的特殊值undefined）。</li><li>对象：一组无序键值对。值可为简单值，或对象和数组。</li><li>数组：一组有序值的列表。值可为简单值，或对象和数组。</li></ul><p>JSON不支持变量、函数 和 对象实例。</p><p><strong>简单值</strong>：最简单的 JSON 数据形式就是简单值。</p><pre><code class="JSON">6&quot;Hello World!&quot; //必须为双引号</code></pre><p>布尔值和 null 也是有效的 JSON 数据形式，但简单值往往是复杂数据结构的一部分。</p><p><strong>对象</strong>：</p><pre><code class="JSON">// JavaScript对象字面量：var object = {  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29};// JSON 表示方式如下：{  &quot;name&quot;: &quot;Nicholas&quot;,  &quot;age&quot;: 29}</code></pre><p>JSON 对象 与 JavaScript 的对象字面量相比：首先，没有声明变量（JSON 中没有变量的概念）；其次，没有末尾的分号；JSON 对象的属性必须加双引号。</p><p><strong>数组</strong>：JSON 数组采用的就是 JavaScript 中的数组字面量形式。</p><pre><code class="JSON">// JavaScript 中的数组字面量：var values = [25, &quot;hi&quot;, true];// JSON 表示数组：[25, &quot;hi&quot;, true]</code></pre><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><p>ECMAScript5 对解析 JSON 进行了规范，定义了全局对象 JSON。</p><p>JSON 对象有两个方法：stringify() 和 parse()，分别用于把 JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。</p><pre><code class="JavaScript">var book = {        title: &quot;Professional JavaScript&quot;,        authors: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011    };var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);console.log(jsonText);// {&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011}var bookCopy =JSON.parse(jsonText);</code></pre><p><strong>序列化选项</strong>: JSON.stringify() 除了要序列化的 JavaScript 对象外，还可以接收另外两个参数指定以不同的方式序列化。<br>第一个参数是数据，第二个参数是个过滤器，可以是一个数组或函数；第三个参数是一个选项，表示是否在 JSON 字符串中保留缩进。</p><p>1.过滤结果：</p><p>如果过滤器参数是<strong>数组</strong>，那么 JSON.stringify()的结果中将只包含数组中列出的属性。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3}</code></pre><p>如果过滤器参数是<strong>函数</strong>，传入的函数接收两个参数，属性（键）名和属性值。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, function(key, value){   switch(key){       case &quot;authors&quot;:           return value.join(&quot;,&quot;)       case &quot;year&quot;:           return 5000;       case &quot;edition&quot;:           return undefined;       default:           return value;   }});//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000}</code></pre><p>2.字符串缩进</p><p>JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。<br>如果这个参数是一个<strong>数值</strong>，那它表示的是每个级别缩进的空格数。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, 4);</code></pre><p>结果：</p><pre><code class="JSON">{    &#39;title&#39;: &#39;Professional JavaScript&#39;,    &#39;authors&#39;: [        &#39;Nicholas C. Zakas&#39;    ],    &#39;edition&#39;: 3,    &#39;year&#39;: 2011}</code></pre><p>如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON 字符串中被用作缩进字符（不再使用空格）。</p><pre><code class="JavaScript">var jsonText = JSON.stringify(book, null, &quot; - -&quot;);</code></pre><p>结果：</p><pre><code class="JSON">{ - -&#39;title&#39;: &#39;Professional JavaScript&#39;, - -&#39;authors&#39;: [ - - - -&#39;Nicholas C. Zakas&#39; - -], - -&#39;edition&#39;: 3, - -&#39;year&#39;: 2011}</code></pre><p>缩进字符串最长不能超过 10 个字符长。如果字符串长度超过了 10 个，结果中将只出现前 10 个字符。</p><p>3.toJSON()方法</p><p>给对象自定义 toJSON() 方法，返回其自身的 JSON 数据格式。</p><pre><code class="JavaScript">var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        toJSON: function(){            return this.title;        }    };var jsonText = JSON.stringify(book);console.log(jsonText);</code></pre><p>假设把一个对象传入 JSON.stringify()，序列化该对象的顺序如下：<br>(1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。<br>(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。<br>(3) 对第(2)步返回的每个值进行相应的序列化。<br>(4) 如果提供了第三个参数，执行相应的格式化。</p><p><strong>解析选项</strong>：JSON.parse() 方法也可以接收另一个参数，该参数是一个函数（还原函数），将在每个键值对儿上调用。<br>如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</p><pre><code class="JavaScript"> var book = {        &quot;title&quot;: &quot;Professional JavaScript&quot;,        &quot;authors&quot;: [            &quot;Nicholas C. Zakas&quot;        ],        edition: 3,        year: 2011,        releaseDate: new Date(2011, 11, 1)    };var jsonText = JSON.stringify(book);console.log(jsonText);var bookCopy = JSON.parse(jsonText, function(key, value){    if (key == &quot;releaseDate&quot;){        return undefined;    } else {        return value;    }});console.log(&quot;releaseDate&quot; in bookCopy);</code></pre><h1 id="第二十一章-Ajax-与-Comet"><a href="#第二十一章-Ajax-与-Comet" class="headerlink" title="第二十一章 Ajax 与 Comet"></a>第二十一章 Ajax 与 Comet</h1><p>Ajax(Asynchronous Javascript + XML)技术的核心是 XMLHttpRequest 对象，即: XHR。<br>它所指的仅仅是<strong>无须刷新页面即可从服务器端获取数据</strong>的技术，其通信与数据格式无关，并不一定是 XML 数据。</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p><strong>XHR的用法</strong>：</p><p>使用 XMLHttpRequest 构造函数来创建 XHR 对象。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();</code></pre><p>使用 XHR对象的时候，要调用的第一个方法是open()，它接受3个参数:</p><ol><li>要发送请求的类型，如: get/post</li><li>请求的 url</li><li>是否异步发送请求，这个参数是一个布尔值</li></ol><p>再调用 send() 方法，才会真正发起 ajax 请求。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.php&#39;, false)xhr.send(null);</code></pre><p>本例中的请求是同步的，Javascript 代码会等到服务器响应之后再执行。<br>收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性有:</p><ul><li>responseText: 作为响应主体被返回的文本。</li><li>responseXML: 如果响应的内容类型是 “text/xml” 或者 “application/xml”，那么这个属性中将保存着包含响应数据的 XML DOM 文档。</li><li>status: 响应的 HTTP 状态。</li><li>statusText: HTTP 状态的说明。</li></ul><p>发送异步请求：JavaScript 继续执行而不必等待。<br>此时，我们可以检测readyState属性，该属性表示请求/响应过程的当前活动阶段。它的可取值有如下几种：</p><ul><li>0: 未初始化。 尚未调用 open() 方法。</li><li>1: 启动。 已经调用open()方法，但，尚未调用send()方法。</li><li>2: 发送。 已经调用send()方法，但，尚未接收到响应。</li><li>3: 接收。 已经接收到部分响应数据。</li><li>4: 完成。 已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p>readyState 属性的每一次变化，都会触发一次 readyStateChange 事件，我们可以利用这个事件来检测 readyState 值。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    if(xhr.readyState == 4){        if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){            console.log(xhr.responseText);        }        else{            console.log(&#39;fail, &#39; + xhr.status);        }    }}xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.send(null);</code></pre><p>在接收到响应之前，可以调用 abort() 方法来取消异步请求。</p><pre><code class="JavaScript">xhr.abort();</code></pre><p><strong>HTTP 头部信息</strong>：XHR 对象提供了操作头部信息的方法，包括对请求头部和响应头部的操作。</p><p>默认情况下，发送XHR请求的同时，还会发送以下头部信息:</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language: 浏览器当前设置的语言</li><li>Connection: 浏览器与服务器之间的连接类型</li><li>Cookie: 当前页面的任何Cookie</li><li>Host: 发出请求的页面，所在的域</li><li>Referer: 发出请求的页面的URI</li><li>User-Agent: 浏览器的用户代理字符串</li></ul><p>setRequestHeader()：自定义的头部信息。</p><pre><code class="JavaScript">xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);xhr.setRequestHeader(&quot;MySite&quot;, &quot;wshunli.com&quot;);xhr.send(null);</code></pre><p>getResponseHeader()：获取响应头部信息。</p><pre><code class="JavaScript">var mySite = xhr.getResponseHeader(&#39;MySite&#39;); // wshunli.com</code></pre><p>getAllResponseHeaders()：在服务器端，也可以利用头部信息向浏览器发送额外的结构化数据。</p><pre><code class="JavaScript">var allHeaders = xhr.getAllResponseHeaders();// 返回内容Date: Sun, 14 Nov 2004 18:04:22 GMTServer: Apache/1.3.29 (Unix)Vary: AcceptX-Powerd-By: PHP/4.3.8Connection: closeContent-Type: text/html; charset=iso-8859-1</code></pre><p><strong>GET 请求</strong>：向服务器查询某些信息。</p><pre><code class="JavaScript">xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true);</code></pre><p><strong>POST 请求</strong>：向服务器发送应该被保存的数据。</p><pre><code class="JavaScript">xhr.open(&quot;post&quot;, &quot;post.php&quot;, true);xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);var form = document.getElementById(&quot;my-form&quot;);xhr.send(serialize(form));</code></pre><h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><p><strong>FormData</strong>：</p><p>XMLHttpRequest 2 级定义了 FormData 类型，来处理表单数据的序列化，以及创建与表单格式相同的数据。</p><pre><code class="JavaScript">var data = new FormData();// 添加键值对data.append(&#39;site&#39;, &#39;wshunli.com&#39;);// 直接传入表单元素var data = new FormData(document.forms[0]);</code></pre><p>创建 FromData 的实例后，就可以传给 XHR 的 send() 方法。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest(); ···var form = document.getElementById(&#39;site-info&#39;);xhr.send(new FormData(form));</code></pre><p>XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。</p><p><strong>超时设定</strong>：</p><p>XHR 对象添加了一个 timeout 属性，表示请求在等待多少毫秒之后就终止。</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){    try{        if(xhr.readyState == 4){            if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){                console.log(xhr.responseText);            }            else{                console.log(&#39;fail, &#39; + xhr.status);            }        }    }    catch(ex){    }}xhr.open(&#39;get&#39;, &#39;example.php&#39;, true);xhr.timeout = 1000; // 1秒超时，仅适用IE8+xhr.ontimeout = function(){    console.log(&#39;fail, timeout&#39;);}xhr.send(null);</code></pre><p>在给 timeout 设置一个数值后，如果在规定时间内浏览器没有接收到响应信息，就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。<br>如果在超时终止请求之后再访问 status 属性，就会导致错误。因此，将相关的代码封装到 try-catch 语句中。</p><p><strong>overrideMimeType() 方法</strong>：重写 XHR 响应的 MIME 类型。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.open(&#39;get&#39;, &#39;text.php&#39;, true);xhr.overrideMimeType(&#39;text/xml&#39;);xhr.send(null);</code></pre><h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><p>进度事件包括以下6个：</p><ul><li>loadstart: 在接收到响应数据的第一个字节时触发</li><li>progress: 在接收响应期间持续不断地触发</li><li>error: 在请求发生错误时触发</li><li>abort: 在因为调用 abort() 方法而终止连接时触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 在通信完成或者触发 error、abort 或 load 事件之后触发</li></ul><p>每个请求都从触发 loadstart 事件开始，接下来是一个或多个 progress 事件，然后触发 error、abort 或者 load 事件中的一个，最后以触发 loadend 事件结束。</p><p><strong>load 事件</strong>：响应接收完毕后将触发 load 事件，因此就没有必要再去检查 readyState 属性了。</p><p><strong>progress 事件</strong>：progress 事件会在浏览器接收新数据的过程中周期性地被触发。</p><pre><code class="JavaScript">var xhr = createXHR();xhr.onload = function(){    if( (xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300) || xhr.status ==304 ){        console.log(xhr.responseText);    }    else{        console.log(&#39;fail, &#39; + xhr.status);    }}xhr.onprogress = function(event){    var statusDiv = document.getElementById(&#39;status&#39;);    if( event.lengthComputable ){        statusDiv.innerHTML = &#39;Received &#39; + event.position + &#39; of &#39; + event.totalSize + &#39; bytes&#39;;    }}xhr.open(&#39;get&#39;, &#39;progress.php&#39;, true);xhr.send(null);</code></pre><p>onprogress 事件处理程序，会接收到一个event对象，其 target 属性是 XHR 对象。<br>event 对象还包含了另外3个额外属性：lengthComputable、position、totalSize。</p><ul><li>lengthComputable 是一个布尔值，它表示进度信息是否可用；</li><li>position 表示已经接收的字节数；</li><li>totalSize 表示根据 Content-Length 响应头确定的预期字节数。</li></ul><h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）：使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。IE中要使用XDR对象实现，其他浏览器XHR对象原生支持。</p><pre><code class="JavaScript">// 发送请求附加 Origin 头部Origin: http://www.wshunli.com// 响应请求Access-Control-Allow-Origin: http://www.wshunli.com</code></pre><p><strong>图像 Ping</strong>：动态创建图像经常用于图像 Ping 。</p><pre><code class="JavaScript">var img = new Image();img.onload = img.onerror = function(){    console.log(&#39;Done&#39;);}img.src = &#39;http://www.wshunli.com/test?action=click&#39;;</code></pre><p>我们可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。</p><p><strong>JSOUP</strong>：(JSON with padding，填充式 JSON 或参数式 JSON) 它看起来与 JSON 非常相似，只不过是被包含在函数调用中的 JSON。</p><pre><code class="JavaScript">function handleResponse(response){    console.log(&quot;You&#39;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);}var script = document.createElement(&quot;script&quot;);script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);</code></pre><p><strong>Comet</strong>: 一种服务器向页面推送数据的技术。</p><p>实现Comet有 2 种方式: 长轮询和流。<br>1.长轮询是相对于传统轮询(短轮询)而言的，传统轮询即浏览器定时向服务器发送请求，查看是否有数据更新。<br>而长轮询则是，页面向服务器发起一个请求后，服务器一直保持连接打开，直到有数据可以发送。<br>发送完数据后，浏览器关闭连接，随即又向服务器发起一个新的请求。<br>这一过程在页面打开期间一直持续不断。<br>2.另外一种实现 Comet 的方式就是HTTP流。流的特点是，在页面的整个生命周期内只有使用一个HTTP连接。<br>也就是说，浏览器向服务器发送一个请求后，服务器保持连接打开，然后周期性地向浏览器发送数据</p><p><strong>服务器发送事件</strong>：SSE(Server-Sent Events)服务器发送事件，是围绕只读 Comet 交互推出的 API 或者模式。</p><p><strong>Web Sockets</strong>：Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。</p><p>创建 Web Sockets，可以先实例一个 WebSocket 对象并传入要连接 URL:</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);</code></pre><p>实例化 WebSocket 对象之后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket也有一个表示当前状态的 readyState 属性。</p><ul><li>WebSocket.OPENING (0) : 正在建立连接</li><li>WebSocket.OPEN (1): 已经建立连接</li><li>WebSocket.CLOSING (2): 正在关闭连接</li><li>WebSocket.CLOSE (3): 已经关闭连接</li></ul><p>WebSocket 没有 readystatechange 事件，readyState 的值永远从0开始。<br>要关闭 Web Socket 连接，可以在任何时候调用close()方法。<br>调用该方法后，readyState 的值立即变为2(正在关闭)，当成功关闭连接后变为3。</p><pre><code class="JavaScript">socket.close();</code></pre><p>发送和接收数据：Web Socket 打开之后就可以通过连接发送和接收数据。</p><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);socket.send(&quot;Hello World!&quot;);</code></pre><p>Web Socket 只能通过连接发送纯文本数据，对于复杂数据必须进行序列化。</p><pre><code class="JavaScript">socket.onmessage = function(event){    var data = event.data;}</code></pre><p>当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。</p><p>WebSocket 对象的其他事件：<br>WebSocket对象还有其他3个事件，在连接生命周期的不同阶段触发。</p><ul><li>open: 在成功建立连接时触发</li><li>error: 在发生错误时触发，连接不能持续</li><li>close: 在连接关闭时触发</li></ul><pre><code class="JavaScript">var socket = new WebSocket(&#39;ws://www.wshunli.com/server.php&#39;);socket.onopen = function(){    console.log(&#39;WebSocket Opened.&#39;)}socket.onerror = function(){    console.log(&#39;WebSocket Error.&#39;)}socket.onclose = function(){    console.log(&#39;WebSocket Closed.&#39;)}</code></pre><p>其中只有 close 事件的event的对象有额外的信息。这个事件的事件对象有3个额外属性: wasClean、code 和 reason。<br>其中，wasClean 是一个布尔值，表示连接是否已经明确关闭；code 是服务器返回的数值状态码；而 reason 是一个字符串，包含服务器发回的信息。</p><pre><code class="JavaScript">socket.onclose = function(event){    console.log(event.wasClean + &#39;,&#39; + event.code + &#39;,&#39; + event.reason);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/228afe2f.html"/>
    <id>http://www.wshunli.com/posts/228afe2f.html</id>
    <published>2017-11-08T09:06:23.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(四) 学习在浏览器中进行实际开发时的错误调试技巧。</strong>(17章)</p><h1 id="第十七章-错误处理与调试"><a href="#第十七章-错误处理与调试" class="headerlink" title="第十七章 错误处理与调试"></a>第十七章 错误处理与调试</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>try-catch 语句</strong>：</p><p>try-catch 语句 和 Java 很类似。</p><pre><code class="JavaScript">function testFinally(){    try {        return 2;    } catch (error){        return 1;    } finally {        return 0;    }}function testWithoutFinally(){    try {        return 2;    } catch (error){        return 1;    }}alert(testFinally());alert(testWithoutFinally());</code></pre><p>我们把可能会抛出错误的语句放到 try 语句中，处理错误的代码放到 catch 块中，finally 语句块无论如何都会执行。</p><p><strong>抛出错误</strong>：与 try-catch 语句相配的还有一个 throw 操作符，用于随时抛出自定义错误 。</p><p>在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时，代码才回继续执行。</p><pre><code class="JavaScript">if (!(values instanceof Array)){    throw new Error(&quot;process(): Argument must be an array.&quot;);}</code></pre><p>捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。</p><p><strong>常见的错误类型</strong>：类型转换错误、数据类型错误、通信错误。</p><h2 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h2><p><strong>将消息记录到控制台</strong>：通过 console 对象向 JavaScript 控制台中写入消息。</p><p>error(message): 将错误消息记录到控制台<br>info(message): 将信息性消息记录到控制台<br>log(message): 将一般消息记录到控制台<br>warn(message): 将警告消息记录到控制台</p><p><strong>将消息记录到当前页面</strong>：在页面中开辟一小块区域，用以显示消息。</p><p><strong>抛出错误</strong>：自定义 assert() 函数。<br>两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。</p><pre><code class="JavaScript">function assert(condition, message){    if (!condition){        throw new Error(message);    }}function divide(num1, num2){    assert(typeof num1 == &quot;number&quot; &amp;&amp; typeof num2 == &quot;number&quot;,            &quot;divide(): Both arguments must be numbers.&quot;);    return num1 / num2;}var result = divide(10, 23);result = divide(&quot;hi&quot;, 3);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/95a7e74a.html"/>
    <id>http://www.wshunli.com/posts/95a7e74a.html</id>
    <published>2017-11-07T14:07:10.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/demobox.css">《JavaScript高级程序设计》读书笔记<br><br><a id="more"></a><p><strong>学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。</strong>(15-16章)</p><h1 id="第十五章-使用-Canvas-绘图"><a href="#第十五章-使用-Canvas-绘图" class="headerlink" title="第十五章 使用 Canvas 绘图"></a>第十五章 使用 Canvas 绘图</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>使用 <code>&lt;canves&gt;</code> 元素；指定 width 和 height 属性。</p><pre><code class="JavaScript">&lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;Your browser doesn&#39;t support canvas&lt;/canvas&gt;</code></pre><p>要在画布上绘制，还需取得绘图上下文。</p><pre><code class="JavaScript">var drawing = document.getElementById(&quot;drawing&quot;),//make sure &lt;canvas&gt; is completely supportedif (drawing.getContext){    var context = drawing.getContext(&quot;2d&quot;);}</code></pre><h2 id="2D-上下文"><a href="#2D-上下文" class="headerlink" title="2D 上下文"></a>2D 上下文</h2><p><strong>填充和描边</strong>：2D 上下文的两种基本绘图操作。<br>fillStyle 属性（填充）：指定的样式（颜色、渐变或图像）填充图形；<br>strokeStyle 属性（描边）：只在图形边缘画线。</p><p><strong>绘制矩形</strong>：矩形是唯一一种可以直接在 2D上下文中绘制的形状。</p><p>与矩形有关的方法包括fillRect()、strokeRect和clearRect()。<br>这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形的宽度和矩形高度。</p><div class="demobox"><div class="demobox-result"><canvas id="drawing" width="200" height="100">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing");if(t.getContext){var e=t.getContext("2d");e.fillStyle="#ff0000",e.fillRect(10,10,50,50),e.strokeStyle="rgba(0,0,255,0.5)",e.strokeRect(30,30,50,50),e.clearRect(40,40,10,10)}}()</script></div><div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x77E9;&#x5F62;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.fillStyle = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">    context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.strokeStyle = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>;</span><br><span class="line">    context.strokeRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    context.clearRect(<span class="number">40</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>绘制路径</strong>：</p><p>首先调用 beginPath() 方法；<br>然后调用一下方法：<br>arc(x,y,radius,startAngle,endAngle,bool);<br>arcTo(x1,y1,x2,y2,radius);<br>lineTo(x,y);<br>moveTo(x,y);<br>rect(x,y,w,h);<br>最后调用 closePath() 方法。</p><p><strong>绘制文本</strong>：fillText(str, x, y, width);strokeText(str, x, y, width)。</p>    <div class="demobox">      <div class="demobox-result">  <canvas id="drawing2" width="200" height="200">Your browser doesn&apos;t support the canvas tag.</canvas><script>!function(){var t=document.getElementById("drawing2");if(t.getContext){var e=t.getContext("2d");e.beginPath(),e.arc(100,100,99,0,2*Math.PI,!1),e.moveTo(194,100),e.arc(100,100,94,0,2*Math.PI,!1),e.moveTo(100,100),e.lineTo(100,15),e.moveTo(100,100),e.lineTo(35,100),e.stroke(),e.strokeText?(e.font="bold 14px Arial",e.textAlign="center",e.textBaseline="middle",e.fillText("12",100,20),e.textAlign="start",e.fillText("12",100,40),e.textAlign="end",e.fillText("12",100,60)):console.log("Your browser doesn't support the canvas text API.")}}()</script></div>    <div class="demobox-meta"><span class="demobox-meta-collapse" onclick="jQuery(this).parents(&apos;.demobox&apos;).toggleClass(&apos;demobox-expand&apos;)"></span><div class="demobox-name">&#x7ED8;&#x5236;&#x8DEF;&#x5F84;&#x548C;&#x6587;&#x672C;</div></div><div class="demobox-code-wrap"><div class="demobox-code demobox-html"><figure class="highlight html"><figcaption><span>html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span>Your browser doesn&apos;t support the canvas tag.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="demobox-code demobox-script"><figure class="highlight javascript"><figcaption><span>javascript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">&quot;drawing2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (drawing.getContext){</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">194</span>, <span class="number">100</span>);</span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">100</span>, <span class="number">15</span>);</span><br><span class="line">    context.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    context.lineTo(<span class="number">35</span>, <span class="number">100</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line">    <span class="keyword">if</span> (context.strokeText){</span><br><span class="line">        context.font = <span class="string">&quot;bold 14px Arial&quot;</span>;</span><br><span class="line">        context.textAlign = <span class="string">&quot;center&quot;</span>;</span><br><span class="line">        context.textBaseline = <span class="string">&quot;middle&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">        context.textAlign = <span class="string">&quot;end&quot;</span>;</span><br><span class="line">        context.fillText(<span class="string">&quot;12&quot;</span>, <span class="number">100</span>, <span class="number">60</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Your browser doesn&apos;t support the canvas text API.&quot;</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></div></div>  <p><strong>变换</strong>：<br>rotate(angle): 围绕原点旋转图像angle角度。<br>scale(scaleX, scaleY): 缩放图像。<br>translate(x,y)：将坐标原点移到（x,y）。</p><p><strong>阴影</strong>：<br>shadowColor()<br>shadowOffsetX:x方向的阴影偏移量。<br>shadowOffsetY:y方向的阴影偏移量。<br>shadowBlur:模糊的像素数，默认为0不模糊。</p><p><strong>渐变</strong>：渐变由 CanvasGradient 实例表示。</p><p>线性渐变：createLinearGradient(x1,y1,x2,y2);</p><pre><code class="JavaScript">var gradient = context.createLinearGradient(30,30,70,70);    gradient.addColorStop(0,&quot;orange&quot;);    gradient.addColorStop(1, &quot;blue&quot;);    context.fillStyle = gradient;    context.fillRect(30, 30,70,70);</code></pre><p>径向渐变：createRadialGradient(x1,y1,r1,x2,y2,r2);</p><pre><code class="JavaScript">var gra = context.createRadialGradient(55,55,10,55,55,30);    gra.addColorStop(0, &quot;blue&quot;);    gra.addColorStop(1, &quot;orange&quot;);    context.fillStyle = gra;    context.fillRect(30,30,50,50);</code></pre><p><strong>模式</strong>：模式就是重复的图像，可以用来填充或描边图形。</p><p>createPattern(img, str);<br>img： 表示一个 HTML 的 img 元素；<br>str： 可取值 “repeat”、“repeat-x”、“repeat-y”和“no-repeat”。</p><pre><code class="JavaScript">var img = document.images[0];var pattern = context.createPattern(img, &quot;repeat&quot;);context.fillStyle = pattern;context.fillRect(10,10,150,150);</code></pre><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p>WebGL 是针对 Canvas 的 3D 上下文。</p><h1 id="第十六章-HTML5-脚本编程"><a href="#第十六章-HTML5-脚本编程" class="headerlink" title="第十六章 HTML5 脚本编程"></a>第十六章 HTML5 脚本编程</h1><h2 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h2><p>跨文档消息传递，简称XDM，指的是来自不同域的页面间传递消息。</p><p>postMessage() 发送消息：</p><pre><code class="JavaScript">var iframeWindow = document.getElementById(&quot;myFrame&quot;).contentWindow;iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wshunli.com&quot;);</code></pre><p>接收消息，触发 window 对象的 message 事件，异步方式。</p><pre><code class="JavaScript">window.addEventListener(&quot;message&quot;,function(){    if(event.origin == &quot;http://www.wshunli.com&quot;){//发送消息的文档所在的域      processMessage(event.data); //处理接收的数据      event.source.postMessage(&quot;Received!&quot;, &quot;http://github.com&quot;); //可选：向来源窗口发送回执  }},false)</code></pre><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p>HTML5新增了 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 两个标签。</p><pre><code class="JavaScript">&lt;video src=&quot;conference.mpg&quot; id=&quot;muvideo&quot;&gt;video palyer not available&lt;/video&gt;&lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;audio player not available&lt;/audio&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/demobox.css&quot;&gt;《JavaScript高级程序设计》读书笔记&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章链接问题</title>
    <link href="http://www.wshunli.com/posts/261b7c4.html"/>
    <id>http://www.wshunli.com/posts/261b7c4.html</id>
    <published>2017-11-06T08:58:12.000Z</published>
    <updated>2017-11-29T14:47:00.685Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 文章链接问题<br><a id="more"></a></p><p>今天 <a href="https://www.google.com/search?safe=active&amp;q=site:wshunli.com" rel="external nofollow noopener noreferrer" target="_blank">搜索</a> 一下网站，发现有个很大的问题。</p><p>有很多链接 404，比如这个链接：</p><p><a href="http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/">http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/</a></p><p>搜索引擎跳转之后是：</p><p><a href="http://www.wshunli.com/2017/10/29/《javascript高级程序设计》读书笔记（一）/">http://www.wshunli.com/2017/10/29/《javascript高级程序设计》读书笔记（一）/</a></p><p>单单因为 <code>JavaScript</code> 大小写的问题，就找不到页面。</p><p>所以在 Hexo 官网找了一下固定链接的插件。</p><p>最终选择是： hexo-abbrlink ; Github ：<a href="https://github.com/rozbo/hexo-abbrlink" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/rozbo/hexo-abbrlink</a></p><p>安装插件：</p><pre><code class="TXT">npm install hexo-abbrlink --save</code></pre><p>在站点配置文件中修改 <code>permalink</code> ：</p><pre><code class="TXT">permalink: posts/:abbrlink.html</code></pre><p>站点配置文件中配置插件：</p><pre><code class="TXT"># abbrlink configabbrlink:  alg: crc32  #support crc16(default) and crc32  rep: hex    #support dec(default) and hex</code></pre><p>链接效果：</p><pre><code class="TXT">crc16 &amp; hexhttps://www.wshunli.com/posts/66c8.htmlcrc16 &amp; dechttps://www.wshunli.com/posts/65535.htmlcrc32 &amp; hexhttps://www.wshunli.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://www.wshunli.com/posts/1690090958.html</code></pre><p>更多内容参考：<a href="https://post.zz173.com/detail/hexo-abbrlink.html" rel="external nofollow noopener noreferrer" target="_blank">https://post.zz173.com/detail/hexo-abbrlink.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 文章链接问题&lt;br&gt;
    
    </summary>
    
      <category term="博客维护" scheme="http://www.wshunli.com/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/67855b9d.html"/>
    <id>http://www.wshunli.com/posts/67855b9d.html</id>
    <published>2017-11-05T12:01:26.000Z</published>
    <updated>2017-11-29T14:47:00.685Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>ES6 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><h1 id="字符、数值、正则的扩展"><a href="#字符、数值、正则的扩展" class="headerlink" title="字符、数值、正则的扩展"></a>字符、数值、正则的扩展</h1><p>第4章 字符串的扩展：<a href="http://es6.ruanyifeng.com/#docs/string" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/string</a><br>第5章 数值的扩展：<a href="http://es6.ruanyifeng.com/#docs/array" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/array</a><br>第6章 正则的扩展：<a href="http://es6.ruanyifeng.com/#docs/regex" rel="external nofollow noopener noreferrer" target="_blank">http://es6.ruanyifeng.com/#docs/regex</a></p><h1 id="第7章-数组的扩展"><a href="#第7章-数组的扩展" class="headerlink" title="第7章 数组的扩展"></a>第7章 数组的扩展</h1><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展运算符是三个点（<code>...</code>），将一个数组转为用逗号分隔的参数序列。</p><pre><code class="JavaScript">console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5function push(array, ...items) {  array.push(...items);}function add(x, y) {  return x + y;}const numbers = [4, 38];add(...numbers); // 42</code></pre><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><pre><code class="JavaScript">let arrayLike = {    &#39;0&#39;: &#39;a&#39;,    &#39;1&#39;: &#39;b&#39;,    &#39;2&#39;: &#39;c&#39;,    length: 3};// ES5的写法var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]// ES6的写法let arr2 = Array.from(arrayLike);    // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of 方法用于将一组值，转换为数组。</p><pre><code class="JavaScript">Array.of(3, 11, 8) // [3,11,8]</code></pre><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h2><p>数组实例的 copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</p><pre><code class="JavaScript">Array.prototype.copyWithin(target, start = 0, end = this.length)</code></pre><p>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p><pre><code class="JavaScript">[1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5]</code></pre><h2 id="find-amp-findIndex"><a href="#find-amp-findIndex" class="headerlink" title="find() &amp; findIndex()"></a>find() &amp; findIndex()</h2><p>数组实例的 find() 方法，用于找出第一个符合条件的数组成员。<br>它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。</p><pre><code class="JavaScript">[1, 5, 10, 15].find(function(value, index, arr) {  return value &gt; 9;}) // 10</code></pre><p>find() 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><pre><code class="JavaScript">[1, 5, 10, 15].findIndex(function(value, index, arr) {  return value &gt; 9;}) // 2</code></pre><p>findIndex() 方法的用法与 find() 方法非常类似，返回第一个符合条件的数组成员的位置</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p>数组实例的 fill() 方法使用给定值，填充一个数组。</p><pre><code class="JavaScript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7); // [7, 7, 7]new Array(3).fill(7); // [7, 7, 7]// 第二个和第三个参数，用于指定填充的起始位置和结束位置。[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2); // [&#39;a&#39;, 7, &#39;c&#39;]</code></pre><h2 id="entries-，keys-和-values"><a href="#entries-，keys-和-values" class="headerlink" title="entries()，keys() 和 values()"></a>entries()，keys() 和 values()</h2><p>ES6 提供三个新的方法 – entries()，keys() 和 values() – 用于遍历数组。<br>可以用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p><pre><code class="JavaScript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {  console.log(index);}// 0// 1for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {  console.log(elem);}// &#39;a&#39;// &#39;b&#39;for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {  console.log(index, elem);}// 0 &quot;a&quot;// 1 &quot;b&quot;</code></pre><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p><pre><code class="JavaScript">[1, 2, 3].includes(2)     // true[1, 2, 3].includes(4)     // false[1, 2, NaN].includes(NaN) // true// 第二个参数表示搜索的起始位置，默认为0[1, 2, 3].includes(3, 3);  // false</code></pre><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。</p><pre><code class="JavaScript">Array(3) // [, , ,]</code></pre><p>ES6 明确将空位转为 undefined。</p><pre><code class="JavaScript">Array.from([&#39;a&#39;,,&#39;b&#39;]); // [ &quot;a&quot;, undefined, &quot;b&quot; ]</code></pre><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p><h1 id="第8章-函数的扩展"><a href="#第8章-函数的扩展" class="headerlink" title="第8章 函数的扩展"></a>第8章 函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><pre><code class="JavaScript">function log(x, y = &#39;World&#39;) {  console.log(x, y);}log(&#39;Hello&#39;)          // Hello Worldlog(&#39;Hello&#39;, &#39;China&#39;) // Hello Chinalog(&#39;Hello&#39;, &#39;&#39;)      // Hello</code></pre><p>参数默认值是惰性求值的。</p><p><strong>与解构赋值默认值结合使用</strong>：</p><p>函数默认值生效：当前参数没有传值或传值为 undefined ；<br>解构赋值默认值生效：当前参数传值或没有传值而默认值与 undefined 严格相等。</p><pre><code class="JavaScript">// 写法一function m1({x = 0, y = 0} = {}) {  return [x, y];}// 写法二function m2({x, y} = { x: 0, y: 0 }) {  return [x, y];}m1()               // [0, 0]m2()               // [0, 0]m1( {x: 3, y: 8} ) // [3, 8]m2( {x: 3, y: 8} ) // [3, 8]m1( {x: 3} )       // [3, 0]m2( {x: 3} )       // [3, undefined]m1( {} )           // [0, 0];m2( {} )           // [undefined, undefined]m1( {z: 3} )       // [0, 0]m2( {z: 3} )       // [undefined, undefined]</code></pre><p>区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><p><strong>参数默认值的位置</strong>：</p><p>定义了默认值的参数应该是函数的尾参数，否则这个参数不能省略。</p><pre><code class="JavaScript">// 例一：默认值的参数在前function f(x = 1, y) {  console.log([x, y]);}f();             // [1, undefined]f(2);            // [2, undefined]f(, 1);          // 报错f(undefined, 1); // [1, 1]// 例二：默认值的参数在后function f(x , y= 1) {  console.log([x, y]);}f();             // [undefined, 1]f(2);            // [2, 1]f(2, );          // [2, 1]f(2, undefined); // [2, 1]</code></pre><p>undefined 能触发默认值，null 不能。</p><pre><code class="JavaScript">function foo(x = 5, y = 6) {  console.log(x, y);}foo(undefined, null); // 5 null</code></pre><p><strong>函数的 length 属性</strong>：没有指定默认值的参数个数。</p><p><strong>作用域</strong>：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。</p><pre><code class="JavaScript">var x = 1;function f(x, y = x) {  console.log(y);}f();  // undefinedf(2); // 2// x 没有定义，所以指向外部全局变量 xlet x = 1;function f(y = x) {  let x = 2;  console.log(y);}f();  // 1f(3); // 3</code></pre><p>更复杂的例子：</p><pre><code class="JavaScript">var x = 1; // 全局变量function foo(x, y = function() { x = 2; }) { //函数参数作用域  var x = 3; // 函数内部变量  y();  console.log(x);}foo();          // 3 - 第5行console.log(x); // 1</code></pre><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数。</p><pre><code class="JavaScript">function add(...values) {  let sum = 0;  for (var val of values) {    sum += val;  }  return sum;}add(2, 5, 3); // 10</code></pre><p>rest 参数搭配的变量为数组，arguments 为类似数组的对象。<br>rest 参数之后不能再有其他参数；函数的 length 属性，也不包括 rest 参数。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>函数的 name 属性，返回该函数的函数名。</p><pre><code class="JavaScript">function foo() {}foo.name // &quot;foo&quot;var f = function () {};f.name // &quot;&quot; - ES5f.name // &quot;f&quot; - ES6</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><pre><code class="JavaScript">var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) {  return num1 + num2;};</code></pre><p>箭头函数有几个使用注意点：<br>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。<br>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p><pre><code class="JavaScript">function foo() {  setTimeout(() =&gt; {    console.log(&#39;id:&#39;, this.id);  }, 100);}var id = 21;foo.call({ id: 42 }); // id: 42</code></pre><p>箭头函数 this 指向定义时所在的对象。</p><pre><code class="JavaScript">function Timer() {  this.s1 = 0;  this.s2 = 0;  setInterval(() =&gt; this.s1++, 1000); // 箭头函数  setInterval(function () {           // 普通函数    this.s2++;  }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100); // s1: 3setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100); // s2: 0</code></pre><p>前者的 this 绑定定义时所在的作用域（即Timer函数），后者的 this 指向运行时所在的作用域（即全局对象）。</p><p>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。</p><pre><code class="JavaScript">// ES6function foo() {  setTimeout(() =&gt; {    console.log(&#39;id:&#39;, this.id);  }, 100);}// ES5function foo() {  var _this = this;  setTimeout(function () {    console.log(&#39;id:&#39;, _this.id);  }, 100);}</code></pre><p>由于没有 this，因而也不存在通过 bind()、call()、apply() 来改变 this 的指向。</p><p><strong>嵌套的箭头函数</strong>：箭头函数内部，还可以再使用箭头函数。</p><pre><code class="JavaScript">let insert = (value) =&gt; ({into: (array) =&gt; ({after: (afterValue) =&gt; {  array.splice(array.indexOf(afterValue) + 1, 0, value);  return array;}})});// 等价于function insert(value) {  return {into: function (array) {    return {after: function (afterValue) {      array.splice(array.indexOf(afterValue) + 1, 0, value);      return array;    }};  }};}// 结果相同insert(2).into([1, 3]).after(1); //[1, 2, 3]</code></pre><h2 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h2><p>函数绑定运算符是并排的两个冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><pre><code class="JavaScript">foo::bar;// 等同于bar.bind(foo);</code></pre><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><pre><code class="JavaScript">var method = obj::obj.foo;// 等同于var method = ::obj.foo;</code></pre><p>双冒号运算符的运算结果，还是一个对象，因此可以采用链式写法。</p><pre><code class="JavaScript">let { find, html } = jake;document.querySelectorAll(&quot;div.myClass&quot;)::find(&quot;p&quot;)::html(&quot;hahaha&quot;);</code></pre><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用（Tail Call）是指某个函数的最后一步是调用另一个函数。</p><pre><code class="JavaScript">function f(x) {  if (x &gt; 0) {    return m(x)  }  return n(x);}</code></pre><p><strong>尾调用优化</strong>：即只保留内层函数的调用帧。</p><p>函数调用会在内存形成一个调用记录即“调用帧”，如果函数 A 调用函数 B ，还会形成一个 B 的调用帧，依次类推形成一个调用栈。</p><p>如果函数存在尾调用，只保留最后的函数的调用帧即可，这将大大节省内存。</p><pre><code class="JavaScript">function f() {  let m = 1;  let n = 2;  return g(m + n);}f();// 等同于function f() {  return g(3);}f();// 等同于g(3);</code></pre><p>执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p><p>注意，只有不再用到外层函数的内部变量才能进行“尾调用优化”。<br>下面函数就不会进行“尾调用优化”。</p><pre><code class="JavaScript">function addOne(a){  var one = 1;  function inner(b){    return b + one;  }  return inner(a);}</code></pre><p><strong>尾递归</strong>：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><pre><code class="JavaScript">function factorial(n) {  if (n === 1) return 1;  return n * factorial(n - 1);}factorial(5) // 120// 改写成尾递归function factorial(n, total) {  if (n === 1) return total;  return factorial(n - 1, n * total);}facorial(5, 1) // 120</code></pre><h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><p>ES2017 允许函数的最后一个参数有尾逗号。</p><pre><code class="JavaScript">function clownsEverywhere(  param1,  param2,) { /* ... */ }clownsEverywhere(  &#39;foo&#39;,  &#39;bar&#39;,);</code></pre><h1 id="第9章-对象的扩展"><a href="#第9章-对象的扩展" class="headerlink" title="第9章 对象的扩展"></a>第9章 对象的扩展</h1><h2 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h2><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p><pre><code class="JavaScript">const foo = &#39;bar&#39;;const baz = {foo};// 等同于const baz = {foo: foo};</code></pre><p>除了属性简写，方法也可以简写。</p><pre><code class="JavaScript">const o = {  method() {    return &quot;Hello!&quot;;  }};// 等同于const o = {  method: function() {    return &quot;Hello!&quot;;  }};</code></pre><h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p><pre><code class="JavaScript">// 方法一obj.foo = true;// 方法二obj[&#39;a&#39; + &#39;bc&#39;] = 123;</code></pre><p>如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。<br>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名。</p><pre><code class="JavaScript">let lastWord = &#39;last word&#39;;const a = {  &#39;first word&#39;: &#39;hello&#39;,  [lastWord]: &#39;world&#39;};a[&#39;first word&#39;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#39;last word&#39;] // &quot;world&quot;</code></pre><p>表达式还可以用于定义方法名。</p><pre><code class="JavaScript">let obj = {  [&#39;h&#39; + &#39;ello&#39;]() {    return &#39;hi&#39;;  }};obj.hello(); // hi</code></pre><p>注意：属性名表达式与简洁表示法不能同时使用；属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 <code>[object Object]</code>。</p><h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p><pre><code class="JavaScript">const person = {  sayName() {    console.log(&#39;hello!&#39;);  },};person.sayName.name   // &quot;sayName&quot;</code></pre><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES6 提出“Same-value equality”（同值相等）算法，用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。。</p><pre><code class="JavaScript">Object.is(&#39;foo&#39;, &#39;foo&#39;); // trueObject.is({}, {});       // false</code></pre><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><pre><code class="JavaScript">+0 === -0           // trueNaN === NaN         // falseObject.is(+0, -0)   // falseObject.is(NaN, NaN) // true</code></pre><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign() 方法用于对象的合并，将源对象（source）的所有<strong>可枚举属性</strong>，复制到目标对象（target）。</p><pre><code class="JavaScript">const target = { a: 1 };const source1 = { b: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3}</code></pre><p>Object.assign() 方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>如果 undefined 或 null 作为第一个参数会报错，在之后则会跳过；<br>数值、布尔值可以被转换成包装对象，但依然会被忽略；<br>字符串转对象会被拆分成数组，除了原始值会被拷贝到<code>[[PrimitiveValue]]</code>属性中，每个字符都是可枚举的实义属性，因此是有效的。</p><pre><code class="JavaScript">const v1 = &#39;abc&#39;;const v2 = true;const v3 = 10;const obj = Object.assign({}, v1, v2, v3);console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</code></pre><p>Object.assign() 只拷贝对象的自有属性，属性名为 Symbol 的属性也会被拷贝，继承属性和不可枚举的属性不会被拷贝。<br>Object.assign() 执行的是浅拷贝，对于同名属性会直接覆盖而非合并。<br>Object.assign() 可以用于处理数组，但会把数组转换成属性名为 0、1、2…… 的对象，并依次替换。</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES2017 引入了 <code>Object.getOwnPropertyDescriptors()</code> ，返回指定对象所有自身属性（非继承属性）的描述对象。</p><h2 id="Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="Object.setPrototypeOf()，Object.getPrototypeOf()"></a>Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p><code>__proto__属性</code>:（前后各两个下划线），用来读取或设置当前对象的prototype对象。</p><p><strong>Object.setPrototypeOf()</strong>: 作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数对象本身。<br><strong>Object.getPrototypeOf()</strong>: 读取一个对象的原型对象。</p><h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><p>ES5 引入了 Object.keys() 来返回一个数组，其成员是参数对象的可枚举的自有属性的键名。<br>ES2017 跟着引入了 Object.values() 和 Object.entries() 用于返回属性对应的值，以及以键值对数组的形式返回。<br>可以配合 for…of 循环使用。</p><h2 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。</p><p><strong>可枚举性</strong>：描述对象的 enumerable 属性，如果该属性为false，就表示某些操作会忽略当前属性。</p><p>for…in 循环、Object.keys()、JSON.stringify()、Object.assign() 忽略 enumerable 为 false 的属性。</p><p>ES6 一共有5种方法可以遍历对象的属性。</p><ol><li><code>for...in</code>：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li><li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</li><li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</li><li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li><li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li></ol><p>以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。</p><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p>ES2017 将这个运算符引入了对象。</p><p><strong>解构赋值</strong>:对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。</p><pre><code class="JavaScript">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };x // 1y // 2z // { a: 3, b: 4 }</code></pre><p>解构赋值必须是最后一个参数，否则会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><p><strong>扩展运算符</strong>:</p><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre><code class="JavaScript">let z = { a: 3, b: 4 };let n = { ...z }; // { a: 3, b: 4 }</code></pre><p>扩展运算符可以用于合并两个对象。</p><pre><code class="JavaScript">let ab = { ...a, ...b };// 等同于let ab = Object.assign({}, a, b);</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre><code class="JavaScript">let newVersion = {  ...previousVersion,  name: &#39;New Name&#39; // Override the name property};</code></pre><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><pre><code class="JavaScript">let aWithDefaults = { x: 1, y: 2, ...a };// 等同于let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);</code></pre><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p><pre><code class="JavaScript">// 空对象没有任何效果{...{}, a: 1} // { a: 1 }// 忽略 null 和 undefinedlet emptyObject = { ...null, ...undefined }; // 不报错</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《ECMAScript6入门》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/ebc6af5b.html"/>
    <id>http://www.wshunli.com/posts/ebc6af5b.html</id>
    <published>2017-11-05T03:36:26.000Z</published>
    <updated>2017-11-29T14:47:00.685Z</updated>
    
    <content type="html"><![CDATA[<p>《ECMAScript6入门》读书笔记</p><a id="more"></a><p>《JavaScript高级程序设计》中学习了前八章，后面是一些 DOM 相关的知识，现在开始学习 ES6 语法。</p><p><a href="http://es6.ruanyifeng.com/" rel="external nofollow noopener noreferrer" target="_blank">《ECMAScript6入门》</a> 作者：阮一峰。</p><h1 id="第1章-ECMAScript6-简介"><a href="#第1章-ECMAScript6-简介" class="headerlink" title="第1章 ECMAScript6 简介"></a>第1章 ECMAScript6 简介</h1><p>ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等。</p><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码。<br>ESLint 用于静态检查代码的语法和风格；Mocha 则是一个测试框架。</p><h1 id="第2章-let-和-const-命令"><a href="#第2章-let-和-const-命令" class="headerlink" title="第2章 let 和 const 命令"></a>第2章 let 和 const 命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>let 命令只在其所在的代码块内有效。</p><pre><code class="JavaScript">{  let a = 10;  var b = 1;}console.log(a); // ReferenceError: a is not defined.console.log(b); // 1</code></pre><p>前面闭包中有说：闭包只能取得函数中任何变量的最后一个值。</p><pre><code class="JavaScript">var a = [];for (var i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 10</code></pre><p>使用 let 声明的变量仅在块级作用域内有效。</p><pre><code class="JavaScript">var a = [];for (let i = 0; i &lt; 10; i++) {  a[i] = function () {    console.log(i);  };}a[6](); // 6</code></pre><p>其实 i 仅在当前循环有效。每循环一次就是一个新的变量。</p><p><strong>1.不存在变量提升</strong>：var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined；let 变量声明前使用会报错。</p><pre><code class="JavaScript">console.log(c); // ReferenceError: a is not defined.console.log(d); // undefinedlet c;var d;</code></pre><p><strong>2.暂时性死区</strong>：在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。</p><pre><code class="JavaScript">var tmp = 123;if (true) {  tmp = &#39;abc&#39;; // ReferenceError  let tmp;}</code></pre><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><p><strong>3.不允许重复声明</strong>：let 不允许在相同作用域内，重复声明同一个变量。也不能在函数内部重新声明参数。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>第一种场景，内层变量可能会覆盖外层变量；第二种场景，用来计数的循环变量泄露为全局变量。</p><p>let 实际上为 JavaScript 新增了块级作用域。</p><pre><code class="JavaScript">function f1() {  let n = 5;  if (true) {    let n = 10;  }  console.log(n); // 5}</code></pre><p>内部代码块可以定义外层作用域的同名变量；外层作用域无法读取内层作用域的变量，也不受内层代码块的影响。</p><p><strong>块级作用域与函数声明</strong>：ES6 允许在块级作用域之中声明函数，但函数在块级作用域之外不可引用。<br>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p>const声明一个只读的常量。一旦声明，就必须立即初始化，常量的值不能改变。</p><pre><code class="JavaScript">const PI = 3.1415;console.log(PI); // 3.1415PI = 3; // TypeError: Assignment to constant variable.const foo; // SyntaxError: Missing initializer in const declaration</code></pre><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。<br>const 命令声明的常量也是不提升；同样存在暂时性死区，只能在声明的位置后面使用；并且不可重复声明。</p><p><strong>本质</strong>：const 其实是变量指向的内存地址不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），等同于常量。但对于复合类型的数据（主要是对象和数组），变量保存的只是一个指针，const 只能保证这个指针是固定的。</p><pre><code class="JavaScript">const foo = {};// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = {}; // TypeError: &quot;foo&quot; is read-only</code></pre><p>如果真的想将对象冻结，应该使用 <code>Object.freeze</code> 方法。</p><pre><code class="JavaScript">const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;</code></pre><h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 中，顶层对象的属性与全局变量是等价的。</p><pre><code class="JavaScript">window.a = 1;console.log(a); // 1b = 2;console.log(window.b); // 2</code></pre><p>ES6 规定 let、const、class 命令声明的全局变量，不属于顶层对象的属性。</p><pre><code class="JavaScript">var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.aconsole.log(window.a) // 1let b = 1;console.log(window.b) // undefined</code></pre><h1 id="第3章-变量的解构赋值"><a href="#第3章-变量的解构赋值" class="headerlink" title="第3章 变量的解构赋值"></a>第3章 变量的解构赋值</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对 <strong>变量</strong> 进行赋值，这被称为解构。</p><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><pre><code class="JavaScript">let [a, b, c] = [1, 2, 3];</code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><pre><code class="JavaScript">// 右边比左边少，解构不成功，值为 undefinedlet [bar, foo] = [1]; // undefined,undefined// 右边比左边多，不完全解构let [x, y] = [1, 2, 3]; //1,2</code></pre><p><strong>默认值</strong>：解构赋值允许指定默认值。</p><pre><code class="JavaScript">let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // &#39;a&#39;,&#39;b&#39;let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // &#39;a&#39;,&#39;b&#39;// 只有数组成员 严格等于 undefined 时，默认值才会生效let [x = 1] = [null]; // null</code></pre><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class="JavaScript">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; //&quot;aaa&quot;,&quot;bbb&quot;let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // undefined</code></pre><p>对象的属性没有次序；变量必须与属性同名，才能取到正确的值。</p><p>变量名与属性名不一致:真正被赋值的是后者，而不是前者。</p><pre><code class="JavaScript">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };console.log(baz); // &quot;aaa&quot;</code></pre><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。</p><p>实际上，对象的解构时下面形式的简写：</p><pre><code class="JavaScript">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 完整形式let { foo     , bar      } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 简写形式</code></pre><p>嵌套赋值：</p><pre><code class="JavaScript">let obj = {};let arr = [];({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });console.log(obj); // {prop:123}console.log(arr); // [true]</code></pre><p>对象的解构也可以指定默认值。同样严格等于 undefined 才生效。</p><pre><code class="JavaScript">let {x = 3} = {};console.log(x); // 3let {x: y = 3} = {};console.log(y); // 3</code></pre><p>如果要将一个已经声明的变量用于解构赋值，必须用括号包裹，不能让花括号处于行首。</p><pre><code class="JavaScript">let x;{x} = {x: 1}; // 错误的写法({x} = {x: 1}); // 正确的写法</code></pre><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><pre><code class="JavaScript">// 字符串可以看做数组进行结构const [a, b, c, d, e] = &#39;hello&#39;;    // a:&quot;h&quot;, b:&quot;e&quot;, c:&quot;l&quot;, d:&quot;l&quot;, e:&quot;o&quot;,// 字符串作为类数组对象，拥有length属性。let {length : len} = &#39;hello&#39;;       // len:5</code></pre><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>数值和布尔值也能进行解构，两者会先转为对象，剩下的就是匹配对象中的方法</p><pre><code class="JavaScript">let {toString: s} = 123;s === Number.prototype.toString  // truelet {toString: s} = true;s === Boolean.prototype.toString // true// undefined和null不能转为对象，没有属性let { prop: x } = undefined;     // TypeErrorlet { prop: y } = null;          // TypeError</code></pre><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p><pre><code class="JavaScript">function add([x, y]){  return x + y;}add([1, 2]); // 3</code></pre><p>函数 add() 的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引。</p><p>函数参数的解构也可以使用默认值。</p><pre><code class="JavaScript">function move({x = 0, y = 0} = {}) {  return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3});       // [3, 0]move({});           // [0, 0]move();             // [0, 0]</code></pre><p>下面代码是为函数 move() 的参数指定默认值。</p><pre><code class="JavaScript">function move({x, y} = { x: 0, y: 0 }) {  return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3});       // [3, undefined]move({});           // [undefined, undefined]move();             // [0, 0] - 无参数，默认值生效</code></pre><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>ES6 规定，但凡有可能产生歧义，就不能使用圆括号。以下3种情况下不能用圆括号：</p><p>1.变量声明语句</p><pre><code class="JavaScript">let [(a)] = [1];let {x: (c)} = {};let { o: ({ p: p }) } = { o: { p: 2 } };</code></pre><p>2.函数参数</p><pre><code class="JavaScript">function f([(z)]) { return z; }function f([z,(x)]) { return x; }</code></pre><p>3.赋值语句的模式</p><pre><code class="JavaScript">[(b)] = [3]; // 正确，数组的解构赋值根据索引来，与括号无关({ p: (d) } = {}); // 正确，p 是模式，但 d 不是模式。</code></pre><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>1.<strong>交换变量的值</strong></p><pre><code class="javascript">let x = 1;let y = 2;[x, y] = [y, x];</code></pre><p>2.<strong>从函数返回多个值</strong></p><pre><code class="javascript">// 返回一个数组function example() {  return [1, 2, 3];}let [a, b, c] = example();// 返回一个对象function example() {  return {    foo: 1,    bar: 2  };}let { foo, bar } = example();</code></pre><p>3.<strong>函数参数的定义</strong></p><pre><code class="javascript">// 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1});</code></pre><p>4.<strong>提取JSON数据</strong></p><pre><code class="javascript">let jsonData = {  id: 42,  status: &quot;OK&quot;,  data: [867, 5309]};let { id, status, data: number } = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309]</code></pre><p>5.<strong>函数参数的默认值</strong></p><pre><code class="javascript">jQuery.ajax = function (url, {  async = true,  beforeSend = function () {},  cache = true,  complete = function () {},  crossDomain = false,  global = true,  // ... more config}) {  // ... do stuff};</code></pre><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p>6.<strong>遍历 Map 结构</strong></p><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><pre><code class="javascript">const map = new Map();map.set(&#39;first&#39;, &#39;hello&#39;);map.set(&#39;second&#39;, &#39;world&#39;);for (let [key, value] of map) {  console.log(key + &quot; is &quot; + value);}// first is hello// second is world// 如果只想获取键名或键值，可以写成下面这样。for (let [key] of map) { ... }// 获取键名for (let [,value] of map) { ...}// 获取键值</code></pre><p>7.<strong>输入模块的指定方法</strong></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><pre><code class="javascript">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《ECMAScript6入门》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《ECMAScript6入门》" scheme="http://www.wshunli.com/tags/%E3%80%8AECMAScript6%E5%85%A5%E9%97%A8%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/d8b94418.html"/>
    <id>http://www.wshunli.com/posts/d8b94418.html</id>
    <published>2017-11-05T03:18:50.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p><strong>(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。</strong>(8-14章)</p><h1 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p>BOM 的核心对象是 window，表示浏览器的实例。既是范文浏览器窗口的接口，又是 ECMAScript 规定的 Global 对象。</p><p><strong>全局作用域</strong>：全局作用域中声明的变量函数会变成 window 对象的属性和方法。</p><p><strong>窗口关系及框架</strong>：若页面中包含框架，则每个框架都有自己的 window 对象，并且保存在 frames 集合中。</p><p>top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。<br>parent 对象始终指向当前框架的直接上层框架。<br>self 对象始终指向 window。</p><p>所有这些对象都是 window 对象的属性。</p><p><strong>窗口位置</strong>：IE、Safari、Opera、Chrome 提供 screenLeft 和 screenTop 属性，FireFox 提供 screenX 和 screenY 属性，分别用于表示窗口相对于屏幕左边和上边的位置。</p><p><strong>窗口大小</strong>：innerWidth、innerHeight、outerWidth、outerHeight</p><p><strong>导航和打开窗口</strong>: window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。</p><p>接受 4 个参数：要加载的URL、窗口目标、一个特性字符串、一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。</p><p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p><p><strong>间歇调用和超时调用</strong>：JavaScript 是单线程语言，但允许通过设置超时时间和间歇时间调度代码在特定的时刻执行。</p><p>超时调用 setTimeout()：指定的时间过后执行代码。</p><pre><code class="JavaScript">var timeoutId=setTimeout(function(){    console.log(&quot;Hello world!&quot;);},1000);//取消超时调用clearTimeout(timeoutId);</code></pre><p>间歇调用 setInterval()：指定的时间间隔重复执行代码。</p><p><strong>系统对话框</strong>：alert()、confirm()、prompt()</p><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>location 对象不仅提供与当前窗口中加载的文档有关信息，还提供了一些导航功能。<br>即是 window 对象的属性，也是 document 对象的属性。</p><p>除直接修改 location 对象属性外 assign()、replace()、reload() 方法也可以改变当前加载页面。</p><pre><code class="JavaScript">location.assign(&quot;http://www.wshunli.com&quot;);// 等价于window.location=&quot;htttp://www.wshunli.com&quot;;location.href=&quot;htttp://www.wshunli.com&quot;;location.replace=&quot;htttp://www.wshunli.com&quot;;// 无法返回前一个页面location.reload();// 重新加载页面</code></pre><h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p>navigator 对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。</p><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><p>screen 对象用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息 ，如像素高度和宽度等。每个浏览器中的screen对象都包含着不同过的属性，支持也不同。</p><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此每个浏览器窗口、每个标签乃至每个框架，都有自己的history 对象与特定的 window 对象关联。</p><h1 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a>第九章 客户端检测</h1><p>客户端检测主要包括：<br>能力检测：浏览器的特定能力；<br>怪癖检测：浏览器实际中存在的 bug ；<br>用户代理检测：通过检测用户代理字符串识别浏览器。</p><p>尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案。</p><h1 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h1><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM 将任何HTML或XML文档描绘成一个由多层节点构成的树形结构。总共有 12 种节点，其中常用的有 4 种。</p><p>Node.ELEMENT_NODE(1) - 元素节点<br>Node.ATTRIBUTE_NODE(2) - 特性（属性）节点<br>Node.TEXT_NODE(3) - 文本节点<br>Node.COMMENT_NODE(8) - 注释节点</p><p>DOM 节点关系：</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/DOM节点关系.png" alt="DOM节点关系"></p><p><strong>Document 类型</strong>：JavaScript通过Document类型表示文档；浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面，且也是window对象的一个属性，因此可以将其作为全局对象来访问。</p><p>文档属性：<br>document.title：取得当前页面的标题，也可以修改标题。<br>document.URL：页面完整的URL；<br>document.domain：只包含页面的域名；<br>document.referrer：保存着链接到当前页面的那个页面的 URL。<br>文档方法：<br>document.getElementById()<br>document.getElementsByTagName()<br>document.getElementsByName()<br>特殊集合：<br>document.anchors：包含文档中所有带name特性的<code>&lt;a&gt;</code>元素；<br>document.forms：包含文档中所有<code>&lt;form&gt;</code>元素；<br>document.img：包含文档中所有<code>&lt;img&gt;</code>元素；<br>document.links：包含文档中所有带href特性的<code>&lt;a&gt;</code>元素。</p><p><strong>Element 类型</strong>：Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。</p><p>特性（属性）操作：getAttribute()、setAttribute()、removeAttribute()<br>创建元素：document.createElement()</p><p><strong>Text 类型</strong>：文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。</p><p>创建文本节点：document.createTextNode()</p><p>规范文本节点：父元素上调用 normalize()，其实就是将元素的相邻文本节点合并成一个节点。</p><pre><code class="JavaScript">var element = document.createElement(&quot;div&quot;);element.className = &quot;message&quot;;var textNode = document.createTextNode(&quot;Hello world!&quot;);element.appendChild(textNode);var anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);element.appendChild(anotherTextNode);document.body.appendChild(element);console.log(element.childNodes.length);  //2element.normalize();console.log(element.childNodes.length);  //1console.log(element.firstChild.nodeValue);  //&quot;Hello World!Yippee!&quot;</code></pre><p>分割文本节点：spiltText()</p><pre><code class="JavaScript">var element=document.createElement(&quot;div&quot;);element.className=&quot;message&quot;;var textNode=docuemnt.createTextNode(&quot;Hello World!&quot;);element.appendChild(textNode);document.body.appendChild(element);var newNode=element.firstChild.spiltText(5);console.log(element.firstChild.nodeValue); //&quot;Hello&quot;console.log(newNode.nodeValue);            //&quot; World&quot;console.log(element.childNodes.length);    //2</code></pre><p><strong>Attr 类型</strong>：元素的特性（属性）在 DOM 中以 Attr 类型来表示。<br>Attr对象有3个属性：name、value和specified。<br>其中，name是特性名称，value是特性的值，specified是一个布尔值，用以区别特性是在代码中指定的还是默认的。</p><p><strong>Comment 类型</strong>：注释在 DOM 中是通过 Comment 类型来表示的。</p><p><strong>其他节点类型</strong>：</p><p>Node.CDATA_SECTION_NODE(4)<br>Node.ENTITY_REFERENCE_NODE(5)<br>Node.ENTITY_NODE(6)<br>Node.PROCESSING_INSTRUCTION_NODE(7)<br>Node.DOCUMENT_NODE(9)<br>Node.DOCUMENT_TYPE_NODE(10)<br>Node.DOCUMENT_FRAGMENT_NODE(11)<br>Node.NOTATION_NODE(12)</p><h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><p>利用 JavaScript 代码、CSS 样式、表格修改 DOM 元素的结构、属性、内容的技术。</p><p>动态脚本：<code>&lt;script&gt;</code><br>动态样式：<code>&lt;link&gt;</code>,<code>&lt;style&gt;</code><br>操作表格：<code>&lt;table&gt;</code></p><h1 id="第十一章-DOM-扩展"><a href="#第十一章-DOM-扩展" class="headerlink" title="第十一章 DOM 扩展"></a>第十一章 DOM 扩展</h1><p>DOM扩展主要包含两方面：Selector API，HTML5</p><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><p>querySelector() ：接收一个 CSS 选择符，返回匹配的第一个元素；<br>querySelectorAll() ：返回 NodeList 对象。</p><pre><code class="JavaScript">// 取得ID为&quot;myDIV&quot;的元素var myDIV = document.querySelector(&quot;#myDiv&quot;);// 取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName(&quot;em&quot;))var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);</code></pre><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p>Element Traversal 规范为 DOM <strong>元素</strong>新定义了5个属性：<br>childElementCount：返回子元素的个数（不包括文本节点和注释）<br>firstElementChild：指向第一个子元素，firstChild元素版<br>lastElementChild：指向最后一个子元素，lastChild元素版<br>previousElementSibling：指向前一个同辈元素，previousSibling元素版<br>nextElementSibling：指向后一个同辈元素，nextSibling元素版</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p><strong>与类相关的扩展</strong>：</p><p>getElementsByClassName()：返回带有特定类的所有元素的 NodeList。<br>classList属性：HTML5为所有元素添加 classList属性。</p><p><strong>焦点管理</strong>：HTML5也添加了辅助管理DOM焦点的功能。<br>document.activeElement 属性，始终会引用 DOM 中当前获得焦点的元素。<br>document.hasFocus()方法，确定文档是否获得了焦点。</p><pre><code class="JavaScript">var button = document.getElementById(&quot;myButton&quot;);button.focus();console.log(document.activeElement === button); // trueconsole.log(document.hasFocus()); // true</code></pre><p><strong>HTMLDocument 的变化</strong>：</p><p>readyState 属性：document.readyState 指示文档是否加载完成。<br>loading：正在加载文档；complete：已经加载完文档。</p><p>head 属性：document.head 属性可以获得<code>&lt;head&gt;</code>元素。</p><p><strong>字符集属性</strong>：</p><p>document.charset：表示文档中实际使用的字符集。<br>document.defaultCharset：当前文档的默认字符集。</p><p><strong>自定义数据属性</strong>：</p><p>HTML5规定可以为元素添加非标准的属性，以此为元素提供与渲染无关的信息。<br>每个自定义数据属性，都要为其添加前缀data-。可通过 dataset 属性访问自定义属性的值。</p><pre><code class="JavaScript">&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myName=&quot;nicholas&quot;&gt;&lt;/div&gt;// 访问上述div元素的自定义属性var div = document.getElementById(&quot;myDiv&quot;);// 访问自定义属性值时，属性名前不必加data-前缀var appId = div.dataset.appId;</code></pre><p><strong>插入标记</strong>：</p><p>innerHTML 属性：<br>在读模式下，innerHTML属性返回调用元素的所有子节点HTML标记。<br>在写模式下，innerHTML属性会根据指定的值创建新的DOM树，然后用新DOM树替换调用元素原先的所有子节点。</p><p>outerHTML 属性：<br>在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。<br>在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。</p><p>insertAdjacentHTML() 方法：<br>语法：insertAdjacentHTML(插入位置，要插入的HTML文本)<br>插入位置必须是下列四个值之一：</p><ul><li>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素</li><li>“afterend”，在当前元素之后插入一个紧邻的同辈元素</li><li>“afterbegin”，给当前元素插入第一个子元素（不管当前元素是否有无子元素）</li><li>“beforeend”，给当前元素插入最后一个子元素（不管当前元素是否有无子元素）</li></ul><p><strong>scrollIntoView() 方法</strong>：所有元素均可调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</p><h1 id="第十二章-DOM2-和-DOM3"><a href="#第十二章-DOM2-和-DOM3" class="headerlink" title="第十二章 DOM2 和 DOM3"></a>第十二章 DOM2 和 DOM3</h1><p>DOM1级主要定义的是HTML和XML文档的底层结构。DOM2 和DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。</p><h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p><p>事件冒泡（event bubbling）：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。<br>事件捕获（event capturing）:不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流.jpg" alt="事件-事件流"></p><p>事件流包括三个阶段：<br>事件捕获阶段：首先发生，为截获事件提供了机会。<br>处于目标阶段：实际的目标接收到事件。<br>事件冒泡阶段：在此阶段可以对事件做出响应。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流三个阶段.jpg" alt="事件-事件流三个阶段"></p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作（比如click、load、mouseover等）<br>事件处理程序（事件侦听器）是响应某个事件的函数。<br>事件处理程序的名字以“on”开头，如click事件的事件处理程序是onclick。</p><p><strong>HTML事件处理程序</strong>：</p><p>为元素添加一个与事件处理程序同名的属性，该属性的值是能够执行的JS代码或JS函数。</p><pre><code class="JavaScript">&lt;script type=&quot;text/javascript&quot;&gt;    function showMessage() {        console.log(&quot;Hello world&quot;);    }&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;Clicke Me&quot; onclick=&quot;showMessage()&quot; /&gt;</code></pre><p><strong>DOM0级事件处理程序</strong>：</p><p>将一个函数赋值给一个事件处理程序属性。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);// 为按钮指定onclick事件处理程序btn.onclick = function(){    console.log(&quot;Clicked&quot;);}// 删除事件处理程序btn.onclick = null;</code></pre><p><strong>DOM2级事件处理程序</strong>：</p><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()、removeEventListener() 。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);//定义事件处理程序函数var handler = function(){    console.log(this.id);}btn.addEventListener(&quot;click&quot;, handler, false);btn.removeEventListener(&quot;click&quot;, handler, false);</code></pre><p>true：在捕获阶段调用事件处理程序；false：在冒泡阶段调用事件处理程序。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>触发DOM上的某个事件时，会产生一个event事件对象，该对象包含着所有与事件有关的信息。</p><p>兼容DOM（DOM0级和DOM2级）的浏览器将event对象传入到事件处理程序中。</p><pre><code class="JavaScript">var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event){    console.log(event.type);  //&quot;click&quot;};btn.addEventListener(&quot;click&quot;, function(event){    console.log(event.type);  //&quot;click&quot;}, false);</code></pre><p><strong>属性/方法</strong>：</p><p>currentTarget：正在处理事件的那个元素<br>target：事件的目标<br>type：事件类型<br>cancelable：可以阻止特定事件的默认行为<br>preventDefault()：阻止特定事件的默认行为<br>stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡<br>eventPhase：事件出于事件流的阶段 捕获阶段为1 处于目标对象为2 冒泡阶段为3</p><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件、合成事件、变动事件。</p><h1 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h1><p>在HTML中，表单是由 <code>&lt;form&gt;</code> 元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/e8afa8c0.html"/>
    <id>http://www.wshunli.com/posts/e8afa8c0.html</id>
    <published>2017-10-29T09:51:02.000Z</published>
    <updated>2017-11-29T14:47:00.689Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript高级程序设计》读书笔记</p><a id="more"></a><p>从今天开始阅读 《JavaScript高级程序设计》（第三版）。</p><p>按照图灵社区推荐的阅读规划：</p><pre><code class="HTML">(一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。(1-7章)(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。(8-14章)(三) 学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。(15-16章)(四) 学习在浏览器中进行实际开发时的错误调试技巧。(17章)(五) 学习JavaScript对各数据载体的操作方法（如JSON、XML），学会Ajax的使用方法。(18-21章)(六) 学习JavaScript的一些高级技巧及实践方案。(22-25章)</code></pre><p><strong>(一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。</strong>(1-7章)</p><h1 id="第一章-JavaScript-简介"><a href="#第一章-JavaScript-简介" class="headerlink" title="第一章 JavaScript 简介"></a>第一章 JavaScript 简介</h1><p>一个完整的 JavaScript 实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。</p><p>ECMAScript：提供核心语言功能；<br>DOM：提供访问和操作网页内容的方法和接口；<br>BOM：提供与浏览器交互的方法和接口。</p><h1 id="第二章-在-HTML-中使用-JavaScript"><a href="#第二章-在-HTML-中使用-JavaScript" class="headerlink" title="第二章 在 HTML 中使用 JavaScript"></a>第二章 在 HTML 中使用 JavaScript</h1><p>HTML 4.01 为 <code>&lt;script&gt;</code> 元素定义了6个属性：async、charset、defer、language（废弃）、src、type 。</p><p>在不存在 defer 和 async 属性时，浏览器都会按照不同<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它们依次进行解析。</p><p>标签的位置：为了避免浏览器在呈现页面时出现明显的延迟，现代Web应用程序一般都把全部 JavaScript 引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p><p>延迟脚本：defer 属性表明脚本在执行时不会影响页面的构造，告诉浏览器立即下载文件，但脚本会被延迟到整个页面都解析完毕后再运行；只适用于外部脚本文件。</p><pre><code class="JavaScript">&lt;script defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></pre><p>异步脚本：async 属性表示当前脚本不必等待其他脚本，也不必阻塞文档呈现，告诉浏览器立即下载文件，且并不保证标记为 async 的脚本按照他们的先后顺序执行；只适用于外部脚本文件。</p><pre><code class="JavaScript">&lt;script async src=&quot;example1.js&quot;&gt;&lt;/script&gt;&lt;script async src=&quot;example2.js&quot;&gt;&lt;/script&gt;</code></pre><p>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p><blockquote><p>页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载；而 load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded)。</p></blockquote><h1 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h1><p>本章内容：语法、数据类型、操作符、控制流语句、函数。<br>其中内容和 Java 类似的部分，不再记笔记。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>区分大小写：ECMAScript 中的一切都区分大小写。</p><p>ECMAScript 5 引入严格模式。在整个脚本中启用严格模式，在顶部添加 <code>&quot;use strict&quot;;</code></p><p>给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 中有5种基本数据类型：Undefined、Null、Boolean、Number、String。<br>还有1种复杂数据类型：Object，Object 本质是一组无序的键值对组成。</p><p><code>typeof 操作符</code>：用来检测变量的数据类型。<br>“undefined”：未定义、”boolean”：布尔值、”string”：字符串、”number”：数值、”object”：对象或 null、 “function”：函数</p><blockquote><p>检测 null 值返回 “Object”、检测函数返回 “function” 。</p></blockquote><p><strong>Undefined 类型</strong>：使用 var 声明变量但未对其初始化时，这个变量的值就是 undefined。</p><blockquote><p>对未声明的变量只能只能执行一项操作，即使用 tyoeof 检测其数据类型，返回 undefined 值。</p></blockquote><p><strong>Null 类型</strong>：null 值表示一个空对象指针；只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。</p><blockquote><p>undefined 表示未初始化的变量；null 表示空对象指针；<code>null == undefined</code> 。</p></blockquote><p><strong>Boolean 类型</strong>：其他类型转换为 Boolean 类型，使用函数 Boolean()。</p><p><strong>Number 类型</strong>：表示整数和浮点数值。</p><p>NaN 即非数值（Not a Number）是一个特殊的数值，表示一个原本要返回数值的操作未返回数值的情况。</p><blockquote><p>任何涉及 NaN 的操作都会返回 NaN；NaN与任何值都不等，包括 NaN 本身。<br>NaN 类型可以使用 isNaN() 函数检测。</p></blockquote><p>数值转换：有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()。<br>Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p><p><code>Number()</code> 函数转换：null和空字符串返回 0；undefined和无法转换的字符串返回 NaN ；对象依次尝试调用 valueOf()、toString()方法，根据函数返回值进行转换。<br><code>parseInt()</code> 函数转换：忽略字符前的空格，找到第一个非空格字符；如果第一个字符不是数字字符或者负号，返回 NaN ；继续解析遇到非数字字符为止。可选第二个参数指定进制。<br><code>parseFloat()</code> 函数转换：和 parseInt() 函数类似，但是字符串中的第一个小数点是有效的。</p><p><strong>String 类型</strong>：符串是不可变的，要改变要先删除。<br>其他类型转换为 String 类型，使用函数 toString() 或 String() 或加一个空字符串（<code>&quot;&quot;</code>）。</p><blockquote><p>数值、布尔值、对象、字符串值 都有 toString() 方法。null、undefined 值没有。<br>String() ：null 返回 <code>&quot;null&quot;</code> ， undefined 返回 <code>&quot;undefined&quot;</code>。其他调用 toString() 方法。</p></blockquote><p><strong>Object 类型</strong>：一组数据（属性）和功能（方法）的组合。</p><p>创建对象的方法：</p><pre><code class="JavaScript">var o = new Object();</code></pre><p>在 ECMAScript 中，Object 类型是其他所有实例的基础，Object 类型具有的属性和方法也同样存在于更具体的对象中。<br>Object 的每个实例（对象）都具有下列属性和方法：</p><ul><li>constructor：保留着用于创建当前对象的函数即构造函数；</li><li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在；</li><li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型；</li><li>propertyIsEnumerable()；toLocaleString()；</li><li>toString()：返回对象的字符串表示；</li><li>valueOf()：返回对象的字符串、数值或布尔值表示。</li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符包括：算数操作符、位操作符、关系操作符、相等操作符。</p><p>用法和概念基本和 Java 一致，相同部分不再记笔记。</p><p>在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。</p><pre><code class="JavaScript">&quot;23&quot;&lt;&quot;3&quot; //true</code></pre><p>相等操作符基本规则：<br>null == undefined，且不转换；<br>对象除非指向同一个否则互相不等；<br>操作值是数值，则另一个值转换为数值进行比较；<br>操作值是布尔值，则将布尔值转换为数值再进行比较，false转换为0,true转换为1。</p><pre><code class="JavaScript">true == 1 ; //truetrue == 2 ; //falseNaN == NaN ; //falseNaN != NaN ; //true</code></pre><p>全等和不全等：两个操作数未经转换就相等为<strong>全等</strong>；转换之后相等为<strong>非全等</strong>。</p><pre><code class="JavaScript">&quot;23&quot; == 23 ; //true&quot;23&quot; === 23 ; //false</code></pre><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>for-in 语句可以用来枚举对象的属性。</p><pre><code class="JavaScript">for (property in expression) {  ...}</code></pre><p>break 和 continue 语句与 label 语句联合使用：多发生在循环嵌套的情况下。</p><pre><code class="JavaScript">var num = 0;outermost:for (var i = 0; i &lt; 10; i++) {  for (var j = 0; j &lt; 10; j++) {    if (i == 5 &amp;&amp; j ==5) {      break outermost;    }    num++;  }}console.log(num);  // 55</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数参数：参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。<br>在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p><p>没有重载：ECMAScript 函数不能像传统意义上那样实现重载。如果在ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p><h1 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h1><p>JavaScript 变量的特征：本质是松散类型，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。</p><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>基本类型指的是简单的数据段，而引用数据类型指那些可能由多个值构成的对象。<br>Undefined、Null、Boolean、Number 和 String 这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p><p><strong>动态的属性</strong>：对引用类型可添加属性和方法，也可改变和删除其属性和方法；对基本类型也能添加属性，但基本类型并不会保存，操作是无效的。</p><p><strong>复制变量值</strong>：从一个变量向另一个变量复制值，基本类型会创建新值并复制到新变量；而引用类型只会复制指向对象的指针，新旧变量会相互影响。</p><p><strong>传递参数</strong>：函数的参数是按值传递时的，即把函数外部的值复制给函数内部的参数（参数实际上是函数的局部变量），就和把值从一个变量复制到另一个变量一样。<br>基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样，复制的是一个指向对象的指针。</p><pre><code class="JavaScript">function setName(obj){  obj.name = &#39;Nicholas&#39;;  obj = new Object();  obj.name = &#39;Greg&#39;;}var person = new Object();setName(person);console.log(person.name);  // =&gt; Nicholas</code></pre><p>对于引用类型，当把参数名指向新的内存空间，再对其做添加属性等操作，不会影响到原来传递的那个对象，所以不是按引用传递参数。</p><p><strong>检测类型</strong>：instanceof 根据原型链，检测变量是什么引用类型的实例。</p><p>检测基本数据类型 typeof 非常有用，但如果变量是对象或 null ，typeof 只能返回 “Object” 。</p><h2 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h2><p><strong>执行环境</strong>：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。有全局执行环境和局部（函数）执行环境之分。</p><p><strong>作用域链</strong>：搜索变量和函数的作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。</p><p><strong>延长作用域链</strong>：try-catch 语句的 catch 块和 with 语句。</p><p><strong>没有块级作用域</strong>：由花括号封闭的代码没有自己的作用域。如 if 、for 语句中只是在语句的执行环境中（全局或函数）。</p><p>查询标识符：从作用域链的前端开始，向上逐级查询，找到后搜索结果停止，没有找到则一直追溯到全局环境的变量对象。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>JavaScript 具有自动垃圾回收机制，即执行环境会负责管理代码执行过程中使用的内存。</p><p>最常用的方法有标记清除和引用计数。</p><p><strong>管理内存</strong>：最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。解除一个值的引用并不意味着自动回收该值所占用的内存——解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><h1 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h1><p>引用类型的值（对象）是引用类型（类、对象定义）的一个实例。</p><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建对象：</p><pre><code class="JavaScript">// 1、使用 Object 构造函数var person = new Object();person.name = &quot;Nicholas&quot;;person.age = 29;// 2、对象字面量表示法var person = {    name : &quot;Nicholas&quot;,    age : 29};// 属性名可以使用字符串var person = {    &quot;name&quot; : &quot;Nicholas&quot;,    &quot;age&quot; : 29,    5 : true //自动转换为字符串};// 与 new Object() 等价var person = {};person.name = &quot;Nicholas&quot;;person.age = 29;</code></pre><p>访问对象属性：</p><pre><code class="JavaScript">// 1、点表示法person.name// 2、方括号表示法person[&quot;name&quot;]// 通过变量访问var n = &#39;name&#39;;console.log(person[n]);// 包含语法错误的字符onsole.log(person[&#39;first name&#39;];</code></pre><h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>ECMAScript 数组的每项可保存任何类型的数据，没项类型可不同；大小可自动调整。</p><p>创建数组：</p><pre><code class="JavaScript">var a1 = new Array();var a2 = new Array(20);var a3 = new Array(&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;);var a4 = [];var a5 = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];</code></pre><p><strong>检测数组</strong>：Array.isArray() 方法可检测对象是不是数组。</p><p><strong>转换方法</strong>：toLocaleString()、toString()和 valueOf()方法。</p><p>toLocaleString()、toString() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。<br>toLocaleString() 方法为了取得每一项的值，调用的是每一项的 toLocaleString() 方法。<br><code>valueOf()</code> 方法返回的还是数组。</p><pre><code class="JavaScript">var person1 = {  toLocaleString : function () {      return &quot;Nikolaos&quot;;  },  toString : function() {      return &quot;Nicholas&quot;;  }};var person2 = {  toLocaleString : function () {      return &quot;Grigorios&quot;;  },  toString : function() {      return &quot;Greg&quot;;  }};var people = [person1, person2];console.log(people);                      //Nicholas,Gregconsole.log(people.toString());           //Nicholas,Gregconsole.log(people.toLocaleString());     //Nikolaos,Grigorios</code></pre><p><code>join()</code> 方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];console.log(colors.join(&quot;,&quot;));      //red,green,blueconsole.log(colors.join(&quot;||&quot;));     //red||green||blue</code></pre><p><strong>栈方法</strong>：push() 和 pop() 方法。</p><p><code>push()</code> 方法接收任意数量的参数，把他们逐个加到数组末尾，并返回修改后的数组长度。<br><code>pop()</code> 方法从数组末尾移除最后一项，减少数组长度，然后返回移除项。</p><p><strong>队列方法</strong>：shift() 和 unshift() 方法。</p><p><code>shift()</code> 从数据前端取项方法。类比 pop() 。<br><code>unshift()</code> 从数组前端添加项。类比 push() 。</p><p><strong>重排序方法</strong>：reverse() 和 sort() 方法。</p><p><code>reverse()</code> 反转数组项的顺序。<br><code>sort()</code> 默认升序排列数组项，调用每项的 toString() 转型方法，然后比较字符串。</p><p>sort() 方法可以接受一个比较函数作为参数。比较函数接受两个参数，第一个参数在第二个之前返回负数。</p><pre><code class="JavaScript">// 从小到大：function compare(value1, value2) {    if (value1 &lt; value2) {        return -1;    } else if (value1 &gt; value2) {        return 1;    } else {        return 0;    }}var values = [0, 1, 5, 10, 15];values.sort(compare);console.log(values);    //0,1,5,10,15// 或者function compare(value1, value2) {    return value1 &lt; value2;}var values = [0, 1, 5, 10, 15];values.sort(compare);console.log(values);    //0,1,5,10,15</code></pre><p><strong>操作方法</strong> ：concat() slice() splice() 。</p><p><code>concat()</code> 添加项。创建新数组。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);console.log(colors);     //red,green,blueconsole.log(colors2);    //red,green,blue,yellow,black,brown</code></pre><p><code>slice()</code> 截取。创建新数组。</p><p>在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);console.log(colors2);   //green,blue,yellow,purpleconsole.log(colors3);   //green,blue,yellow</code></pre><p><code>splice()</code> 删除插入替换。改变原数组。</p><p>三个参数：起始位置、要删除的项数、要插入的项。<br>第三个不传是删除功能，第二个为 0 是插入功能，都有则替换。<br>返回：删除的项。</p><pre><code class="JavaScript">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1);              //remove the first itemconsole.log(colors);     //green,blueconsole.log(removed);    //red - one item arrayremoved = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);  //insert two items at position 1console.log(colors);     //green,yellow,orange,blueconsole.log(removed);    //empty arrayremoved = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);    //insert two values, remove oneconsole.log(colors);     //green,red,purple,orange,blueconsole.log(removed);    //yellow - one item array</code></pre><p><strong>位置方法</strong>：indexOf() lastIndexOf() 接收两个参数：要查找的项和（可选）查找起点位置的索引；indexOf()从前往后查找，lastIndexOf()从后往前查找；返回要查找的项的位置，没找到则返回 -1。</p><p><strong>迭代方法</strong>：两个参数：在每项运行的函数和（可选的）作用域对象；其中函数接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。</p><p>every()：对数组中的每一项运行给定函数，如果该函数对<strong>每一项</strong>都返回true，则返回true。有返回false的项时就不会再对后面的项检测了，直接返回false。<br>some()：对数组中的每一项运行给定函数，如果该函数对<strong>任一项</strong>返回true，则返回true。有返回true的项时就不再对后面的项检测了，直接返回ture。</p><p>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</p><p>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。本质上与使用 for 循环迭代数组一样。</p><pre><code class="JavaScript">var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = a.every(function (item, index, array) {  return (item &gt; 2);});console.log(everyResult);  // falsevar someResult = a.some(function (item, index, array) {  return (item &gt; 2);});console.log(someResult);  // truevar filterResult = a.filter(function (item, index, array) {  return (item &gt; 2);});console.log(filterResult);  // [3, 4, 5, 4, 3]var mapResult = a.map(function (item, index, array) {  return (item * 2);});console.log(mapResult);  // [2, 4, 6, 8, 10, 8, 6, 4, 2]var forEachResult = a.forEach(function (item, index, array) {  console.log(item);});console.log(forEachResult);  // undefined</code></pre><p><strong>缩小方法</strong>（递归方法）：reduce() 和 reduceRight() 迭代数组的所有项，然后构建一个最终返回的值；reduce()方法从前往后，reduceRight()从后往前。<br>reduce() 和 reduceRight() 接收两个参数：一个在每项上调用的函数和（可选的）作为缩小基础的初始值。其中函数接收4个参数：前一个值、当前值、项的索引和数组对象。函数的返回值又会作为第一个参数自动传给下一项。</p><pre><code class="JavaScript">var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array){  return prev + cur;},1);console.log(sum); //16</code></pre><h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><p>创建日期对象：</p><pre><code class="JavaScript">var now = new Date();var date = new Date(2005, 4, 5, 17, 55, 55);  // 2005年5月5日下午5点55分55秒</code></pre><p>获取调用时的日期和时间和毫秒数：</p><pre><code class="JavaScript">var start = Date.now();doSomething();var stop = Date.now();var result = stop - start;</code></pre><p>日期的格式化方法：</p><pre><code class="JavaScript">var date = new Date(2015, 2, 5, 17, 55, 55);date.toString();  // &quot;Thu Mar 05 2015 17:55:55 GMT+0800 (CST)&quot;date.toDateString();  // &quot;Thu Mar 05 2015&quot;date.toTimeString();  // &quot;17:55:55 GMT+0800 (CST)&quot;date.toLocaleString();  // &quot;2015/3/5 下午5:55:55&quot;date.toLocaleDateString();  // &quot;2015/3/5&quot;date.toLocaleTimeString();  // &quot;下午5:55:55&quot;</code></pre><h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><p>创建正则表达式：</p><pre><code class="JavaScript">var exp1 = / pattern / flags ;var exp2 = new RegExp(&#39;pattern&#39;, &#39;flags&#39;);</code></pre><p>模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。<br>标志（flags）用以标明正则表达式的行为。正则表达式的匹配模式支持下列3 个标志：</p><ul><li>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li><li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li><li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li></ul><p>RegExp 实例方法：</p><p><code>exec()</code>：返回第一个匹配项信息的数组，数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串；还包含两个额外的属性，index 和 input。<br><code>test()</code>：在模式与该参数匹配的情况下返回true，否则返回false。</p><p>正则表达式：<a href="http://www.runoob.com/regexp/regexp-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/regexp/regexp-tutorial.html</a></p><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>函数实际上是对象。函数名实际上是指向函数对象的指针。<br>每个函数都是 Function 类型的实例，而且与其他引用类型一样具有属性和方法。</p><pre><code class="JavaScript">// 函数声明function sum (num1, num2){  return num1 + num2;}// 函数表达式var sum = function(num1, num2){  return num1 + num2;};// 使用构造函数，不推荐var sum = new Function(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;);</code></pre><p><strong>函数声明与函数表达式</strong>：解释器会率先读取函数声明，并使其在执行任何代码之前可用（函数声明提升）；函数表达式必须等到解释器执行到它所在行才会真正被解释执行。</p><pre><code class="JavaScript">// 函数声明console.log(sum(10,10));function sum (num1, num2){  return num1 + num2;}// 函数表达式console.log(sum(10,10));// Uncaught TypeError: sum is not a functionvar sum = function(num1, num2){  return num1 + num2;};</code></pre><p><strong>作为值的函数</strong>：因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。</p><p><strong>函数的内部属性</strong>：arguments 、this 。</p><p><code>arguments</code>: 是一个类数组对象，包含着传入函数中的所有参数。</p><pre><code class="JavaScript">function factorial(num){    if (num &lt;= 1) {        return 1;    } else {        return num * factorial(num-1)    }}function factorial(num){    if (num &lt;= 1) {        return 1;    } else {        return num * arguments.callee(num-1)    }}</code></pre><p>arguments 的属性 callee 指向拥有此 arguments 的函数。</p><pre><code class="JavaScript">// 无论引用函数时使用的什么名字，都可以保证正常完成递归。var trueFactorial = factorial;factorial = function(){    return 0;};console.log(trueFactorial(5));   //120console.log(factorial(5));       //0</code></pre><p><code>this</code> 引用的是函数据以执行的环境对象。</p><p>在全局作用域中调用函数，this 引用的是全局对象 window；<br>把函数赋给对象 o 并调用时，this 引用的就是对象 o 。</p><p>caller : 调用当前函数的函数的引用，返回后者的源代码。</p><p><strong>函数的属性和方法</strong>：</p><p>函数的两个属性：length 和 prototype 。</p><p><code>length</code>：表示函数希望接收的命名参数的个数。</p><p><code>prototype</code>: 对于ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。不可枚举。</p><p>函数的两个非继承而来的方法：apply() 和 call() 。在特定的作用域中调用函数。</p><p><code>apply()</code>：接受两个参数，运行函数的作用于和参数数组。</p><pre><code class="JavaScript">function sum(num1, num2){    return num1 + num2;}// 参数数组可以是 Array 的实例，也可以是 arguments 对象。function callSum1(num1, num2){    return sum.apply(this, arguments);}function callSum2(num1, num2){    return sum.apply(this, [num1, num2]);}console.log(callSum1(10,10));   //20console.log(callSum2(10,10));   //20</code></pre><p><code>call()</code>：必须明确地传入每个参数。</p><pre><code class="JavaScript">function sum(num1, num2){    return num1 + num2;}function callSum(num1, num2){    return sum.call(this, num1, num2);}console.log(callSum(10,10));   //20</code></pre><p>apply() 和 call() 真正强大的地方是能够扩充函数赖以运行的作用域。而使用它们来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。</p><pre><code class="JavaScript">window.color = &quot;red&quot;;var o = { color: &quot;blue&quot; };function sayColor(){    console.log(this.color);}sayColor();            //redsayColor.call(this);   //redsayColor.call(window); //redsayColor.call(o);      //blue</code></pre><p><code>bind()</code> 方法会创建一个函数的实例，其 this 值会绑定到传给 bind() 函数的值。</p><pre><code class="JavaScript">var objectSayColor = sayColor.bind(o);objectSayColor();   //blue</code></pre><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>Boolean 类型、Number 类型、String 类型。</p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>Global 对象、Math 对象。</p><h1 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h1><p>对象：无序属性的集合，其属性可以包含基本值、对象或者函数。</p><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>属性在创建时都带了一些特征值（characteristic），JavaScript 通过这些特征值来定义他们的行为。</p><p>ECMAScript 中有两种属性：数据属性和访问器属性。<br>描述属性的各种特征，是为了实现JavaScript引擎用的，不能直接访问。</p><p><strong>数据属性</strong>：</p><ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li><li>[[Writeable]]：表示能否修改属性的值。</li><li>[[Value]]：包含这个属性的数据值。</li></ul><p><strong>访问器属性</strong>：</p><ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为数据属性。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li><li>[[Get]]：在读取属性时调用的函数。</li><li>[[Set]]：在写入属性时调用的函数。</li></ul><p><strong>定义及读取特性</strong>：Object.defineProperty() Object.defineProperties()；Object.getOwnPropertyDescriptor() 。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然使用 Object 构造函数或者对象字面量可以创建单个对象，但使用同一接口创建很多对象，会产生大量的重复代码。</p><p><strong>工厂模式</strong>：使用函数来封装以特定接口来创建对象。</p><pre><code class="JavaScript">function createPerson(name,age,job){  var o=new Object();  o.name=name;  o.age=age;  o.job=job;  o.sayName=function(){    console.log(this.name);  };  return o;}var person1=createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;);</code></pre><p><strong>构造函数模式</strong>：</p><pre><code class="JavaScript">function Person(name,age,job){  this.name=name;  this.age=age;  this.job=job;  this.sayName=function(){    console.log(this.name);  };}var person1=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);</code></pre><p>要创建Person的实例，必须使用new操作符。用这种方式调用构造函数需要4个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象。</li></ol><p>构造函数和其他函数唯一的区别，就是在于调用他们的方式不同。<br>任何函数，只要通过 new 操作符来调用，那么它就可以作为构造函数。</p><p><strong>原型模式</strong>：</p><p>创建的每一个函数都有一个 prototype（原型）属性，指向一个对象；这个对象（原型对象 ）的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>prototype 就是通过调用构造函数而创建的实例的原型对象。好处是可以让所有的实例共享原型对象包含的属性和方法，不用在构造函数里面定义实例的信息，而是直接添加到原型对象中。</p><pre><code class="JavaScript">function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){    console.log(this.name);};var person1 = new Person();person1.sayName();   //&quot;Nicholas&quot;var person2 = new Person();person2.sayName();   //&quot;Nicholas&quot;console.log(person1.sayName == person2.sayName);  //true</code></pre><p>1.理解原型对象：</p><p>只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，指向原型对象；<br>默认所有原型对象都会获得一个 <code>constructor</code> 属性，指向 <code>prototype</code> 属性所在函数（构造函数）；<br>调用构造函数创建实例后，实例内部将包含一个指针 <code>[[Prototype]]</code> 或者 <code>__proto__</code> 指向构造函数的原型对象。</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象.png" alt="向对象的程序设计-理解原型对象"></p><pre><code class="JavaScript">···// 使用 isPrototype() 来检测构造函数的原型对象和实例对象之间是否有关系console.log(Person.prototype.isPrototypeOf(person1));  //trueconsole.log(Person.prototype.isPrototypeOf(person2));  //true// Object.getPrototypeOf() 返回实例对象的原型if (Object.getPrototypeOf){    console.log(Object.getPrototypeOf(person1) == Person.prototype);  //true    console.log(Object.getPrototypeOf(person1).name);  //&quot;Nicholas&quot;}</code></pre><p>当代码读取某个对象的属性时，先从对象实例本身开始，若没有找到才会在原型对象中查找。</p><p>当为对象实例添加属性时，这个属性会屏蔽掉原型对象中的同名属性，即使将这个属性设置为 null ，也只会在实例中设置这个属性。不过使用 delete 操作符可以完全删除实例属性，使得可以重新访问原型中的属性。</p><pre><code class="JavaScript">···person1.name = &quot;Greg&quot;;console.log(person1.name);   //&quot;Greg&quot; - 来自实例console.log(person2.name);   //&quot;Nicholas&quot; - 来自原型delete person1.name;console.log(person1.name);   //&quot;Nicholas&quot; - 来自原型// 使用 hasOwnProperty() 来检测属性存在于实例中还是原型中console.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型person1.name = &quot;Greg&quot;;console.log(person1.hasOwnProperty(&quot;name&quot;)); // true - 来自实例delete person1.name;console.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型</code></pre><p>实例与原型的关系：<br><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象2.png" alt="向对象的程序设计-理解原型对象2"></p><p>2.原型与 in 操作符：单独使用和在 for-in 循环中使用。</p><pre><code class="JavaScript">···// 单独使用时无论属性在原型还是在实例中都返回 trueconsole.log(&quot;name&quot; in person1); // trueperson1.name = &quot;Greg&quot;;console.log(&quot;name&quot; in person1);   //true// for-in 循环时，返回的是所有能通过对象访问的、可枚举的属性；同样也包括原型和实例中的。for (var prop in person1) {  console.log(prop);  // name age job sayName}</code></pre><p>Object.keys() 方法可以取得对象上所有可枚举的实例属性。</p><pre><code class="JavaScript">···var keys = Object.keys(Person.prototype);console.log(keys);   //&quot;name,age,job,sayName&quot;</code></pre><p>Object.getOwnPropertyNames() 方法可以得到所有实例属性，无论其是否可枚举。</p><pre><code class="JavaScript">···var keys = Object.getOwnPropertyNames(Person.prototype);console.log(keys);   //&quot;constructor,name,age,job,sayName&quot;</code></pre><p>3.更简单的原型语法：</p><pre><code class="JavaScript">function Person(){}// 本质是重写了默认的 prototype 对象// constructor 属性指向 ObjectPerson.prototype = {    name : &quot;Nicholas&quot;,    age : 29,    job: &quot;Software Engineer&quot;,    sayName : function () {        console.log(this.name);    }};console.log(friend instanceof Object);  //trueconsole.log(friend instanceof Person);  //trueconsole.log(friend.constructor == Person);  //falseconsole.log(friend.constructor == Object);  //true</code></pre><p>为解决 constructor 无法确定对象类型的问题：</p><pre><code class="JavaScript">function Person(){}// 方法1：Person.prototype = {    // 使 constructor 属性指向构造函数    constructor : Person,    name : &quot;Nicholas&quot;,    age : 29,    job: &quot;Software Engineer&quot;,    sayName : function () {        console.log(this.name);    }};// 方法2：Person.prototype = {    name : &quot;Nicholas&quot;,    age : 29,    job: &quot;Software Engineer&quot;,    sayName : function () {        console.log(this.name);    }};// 设置 constructor 属性不可枚举Object.defineProperty(Person.prototype.&quot;constructor&quot;){  enumerable : false,  value: Person}// 结果相同var friend = new Person();console.log(friend instanceof Object);  //trueconsole.log(friend instanceof Person);  //trueconsole.log(friend.constructor == Person);  //trueconsole.log(friend.constructor == Object);  //false</code></pre><p>4.原型的动态性：</p><p>我们对原型的修改都能立刻反映到实例上。<br>但是重写原型，实例对象还是指向原来的原型，不会指向新重写的原型对象。<br>重写原型切断了新的原型和之前已经存在的对象实例间的联系。</p><p>5.原型对象的问题：原型对象中讯在引用类型的属性，会使所有实例共享该引用。</p><p><strong>组合使用构造函数和原型模式</strong>：</p><p>构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。</p><pre><code class="JavaScript">function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];}Person.prototype = {    constructor: Person,    sayName : function () {        console.log(this.name);    }};var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);console.log(person1.friends);    //&quot;Shelby,Court,Van&quot;console.log(person2.friends);    //&quot;Shelby,Court&quot;console.log(person1.friends === person2.friends);  //falseconsole.log(person1.sayName === person2.sayName);  //true</code></pre><p>实例属性都是在构造函数中定义的，每个实例都会有自己的一份实例属性的副本。</p><p><strong>动态原型模式</strong>：将原型信息封装在构造函数中。</p><pre><code class="JavaScript">function Person(name, age, job){    //properties    this.name = name;    this.age = age;    this.job = job;    //methods    if (typeof this.sayName != &quot;function&quot;){        Person.prototype.sayName = function(){            console.log(this.name);        };    }}var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName();</code></pre><p><code>寄生构造函数模式</code>、<code>稳妥构造函数模式</code>。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript 只支持<strong>实现继承</strong>，主要依靠原型链来实现。</p><p><strong>原型链</strong>：利用原型将一个引用类型继承另一个引用类型的属性和方法。</p><pre><code class="JavaScript">function SuperType(){    this.property = true;}SuperType.prototype.getSuperValue = function(){    return this.property;};function SubType(){    this.subproperty = false;}//继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function (){    return this.subproperty;};var instance = new SubType();console.log(instance.getSuperValue());   //true</code></pre><p>实例以及构造函数和原型之间的关系：</p><p><img src="https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-原型链.png" alt="向对象的程序设计-原型链"></p><p>getSuperValue() 方法仍然在 SuperType.prototype 中，但 property 位于 SubType.prototype 中。<br>因为我们重写了 SubType 的原型，新原型即 SuperType 的实例；property 是实例的属性，getSuperValue() 则是 SuperType 原型的方法。</p><p>1.注意默认原型：函数的默认原型是 Object 实例，因此默认原型会包含指针指向 Object.prototype 。</p><p>2.确定实例与原型的关系：</p><pre><code class="JavaScript">console.log(instance instanceof Object);      //trueconsole.log(instance instanceof SuperType);   //trueconsole.log(instance instanceof SubType);     //trueconsole.log(Object.prototype.isPrototypeOf(instance));    //trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); //trueconsole.log(SubType.prototype.isPrototypeOf(instance));   //true</code></pre><p>3.谨慎地定义方法：给原型添加方法一定要在替换原型之后；也不能使用字面量创建原型方法。</p><p>4.原型链问题：引用类型的原型属性会被所有实例共享；不能向超类传递参数。</p><p><strong>借用构造函数</strong>：通过 apply() 或 call() 方法在新创建的对象上执行超类的构造函数。</p><pre><code class="JavaScript">function SuperType(){    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}function SubType(){    //继承自 SuperType    SuperType.call(this);}var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);    //&quot;red,blue,green,black&quot;var instance2 = new SubType();console.log(instance2.colors);    //&quot;red,blue,green&quot;</code></pre><p>通过 apply() 或 call() 方法在 SubType 实例的环境下调用了 SuperType 构造函数。</p><p>1.传递参数：</p><pre><code class="JavaScript">function SuperType(name){    this.name = name;}function SubType(){    //继承自 SuperType，传递参数    SuperType.call(this, &quot;Nicholas&quot;);    //实例属性    this.age = 29;}var instance = new SubType();console.log(instance.name);    //&quot;Nicholas&quot;;console.log(instance.age);     //29</code></pre><p>2.问题： 和构造函数模式类似，方法都在构造函数中定义，无法复用。</p><p><strong>组合继承</strong>：JavaScript中最常用的继承。融合了原型链和构造函数的优点。</p><pre><code class="JavaScript">function SuperType(name){    this.name = name;    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){    console.log(this.name);};function SubType(name, age){    SuperType.call(this, name);    this.age = age;}SubType.prototype = new SuperType();SubType.prototype.sayAge = function(){    console.log(this.age);};var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);  //&quot;red,blue,green,black&quot;instance1.sayName();      //&quot;Nicholas&quot;;instance1.sayAge();       //29var instance2 = new SubType(&quot;Greg&quot;, 27);console.log(instance2.colors);  //&quot;red,blue,green&quot;instance2.sayName();      //&quot;Greg&quot;;instance2.sayAge();       //27</code></pre><p><code>原型式继承</code>、<code>寄生式继承</code>、<code>寄生组合式继承</code>。</p><h1 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h1><p>定义函数的方法有两种：<a href="#Function-类型">函数声明与函数表达式</a>。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身函数构成。</p><pre><code class="JavaScript">function factorial(num){    if (num &lt;= 1){        return 1;    } else {        return num * factorial(num-1);    }}var anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(4));  //error! - factorial 已经不是函数</code></pre><p>解决办法是使用命名函数表达式：</p><pre><code class="JavaScript">function factorial = (function f(num){    if (num &lt;= 1){        return 1;    } else {        return num * f(num-1);    }});</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包</strong> 是有权访问另一个函数作用域中的变量的函数。</p><p>1.闭包和变量:闭包只能取得函数中任何变量的最后一个值。</p><pre><code class="JavaScript">function createFunctions(){    var result = new Array();    for (var i=0; i &lt; 10; i++){        result[i] = function(){            return i;        };    }    return result;}</code></pre><p>其中每个函数都引用着保存变量 i 的同一个变量对象,所以函数内部返回的值都是 10 。</p><pre><code class="JavaScript">function createFunctions(){    var result = new Array();    for (var i=0; i &lt; 10; i++){        result[i] = function(num){            return function(){                return num;            };        }(i);    }    return result;}</code></pre><p>2.关于 this 对象:匿名函数通常具有全局性,因此其 this 对象通常指向 windows 。</p><pre><code class="JavaScript">var name = &quot;The Window&quot;;var object = {    name : &quot;My Object&quot;,    getNameFunc : function(){        return function(){            return this.name;        };    }};console.log(object.getNameFunc()());  //&quot;The Window&quot; 在非严格模式下</code></pre><p>this 的值有时候会意外发生改变。</p><pre><code class="JavaScript">var name = &quot;The Window&quot;;var object = {    name : &quot;My Object&quot;,    getName: function(){        return this.name;    }};console.log(object.getName());     //&quot;My Object&quot;console.log((object.getName)());   //&quot;My Object&quot;console.log((object.getName = object.getName)());   //&quot;The Window&quot; 在严格模式下}</code></pre><p>第三个其实是重写了 getName 方法,this 值就指向全局了。</p><h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>JavaScript 没有块级作用域(私有作用域)的概念,可使用匿名函数方法模仿。</p><pre><code class="JavaScript">(function () {    ...})();</code></pre><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>JavaScript 没有私有成员的概念,所有对象属性都是公有的,但是有个私有变量的概念,也就是函数中定义的变量。</p><pre><code class="JavaScript">function Person(name){    this.getName = function(){        return name;    };    this.setName = function (value) {        name = value;    };}var person = new Person(&quot;Nicholas&quot;);console.log(person.getName());   //&quot;Nicholas&quot;person.setName(&quot;Greg&quot;);console.log(person.getName());   //&quot;Greg&quot;</code></pre><p>创建 Person 实例只能 通过 getName() 和 setName() 方法访问内部变量,但是针对每个实例都会创建一组新方法。</p><p>1.静态私有变量</p><pre><code class="JavaScript">(function(){    var name = &quot;&quot;;    Person = function(value){        name = value;    };    Person.prototype.getName = function(){        return name;    };    Person.prototype.setName = function (value){        name = value;    };})();var person1 = new Person(&quot;Nicholas&quot;);console.log(person1.getName());   //&quot;Nicholas&quot;person1.setName(&quot;Greg&quot;);console.log(person1.getName());   //&quot;Greg&quot;var person2 = new Person(&quot;Michael&quot;);console.log(person1.getName());   //&quot;Michael&quot;console.log(person2.getName());   //&quot;Michael&quot;</code></pre><p>初始化未声明的变量,总会创建一个全局变量。严格模式下报错。</p><p>示例代码中 name 变成了一个静态的,所有实例共享的属性。</p><p>2.模块模式</p><p>模块模式是为单例创建私有变量和特权方法。单例即只有一个实例的对象。</p><pre><code class="JavaScript">function BaseComponent(){}function OtherComponent(){}var application = function(){    //私有变量和方法    var components = new Array();    //初始化    components.push(new BaseComponent());    //公共接口    return {        getComponentCount : function(){            return components.length;        },        registerComponent : function(component){            if (typeof component == &quot;object&quot;){                components.push(component);            }        }    };}();application.registerComponent(new OtherComponent());console.log(application.getComponentCount());  //2</code></pre><p>3.增强的模块模式</p><p>针对单例必须是某种类型的实例,同时还对其添加属性或方法的情况。</p><pre><code class="JavaScript">function BaseComponent(){}function OtherComponent(){}var application = function(){    //私有变量和方法    var components = new Array();    //初始化    components.push(new BaseComponent());    //创建 application 的一个局部副本    var app = new BaseComponent();    //公共接口    app.getComponentCount = function(){        return components.length;    };    app.registerComponent = function(component){        if (typeof component == &quot;object&quot;){            components.push(component);        }    };    //返回副本    return app;}();console.log(application instanceof BaseComponent);application.registerComponent(new OtherComponent());console.log(application.getComponentCount());  //2</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript高级程序设计》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript高级程序设计》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript DOM 编程艺术》读书笔记</title>
    <link href="http://www.wshunli.com/posts/25be2399.html"/>
    <id>http://www.wshunli.com/posts/25be2399.html</id>
    <published>2017-10-22T01:58:31.000Z</published>
    <updated>2017-11-29T14:47:00.685Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript DOM 编程艺术》读书笔记<br><a id="more"></a></p><p>本科的时候也有看前端的内容但是没有系统地学习，现在有 WebGIS 相关的项目，并且发现 Android 开发也发生了一些变化: 很多应用不再单单是一个简单的原生 Android 应用，用到了跨平台技术，比如说 React Native 、 Ionic 等等，这都需要 Javascript 基础。所以打算系统地学习下 Javascript 。</p><p>其实有这个想法很久了，包括暑假来到也有意学习前端技术，最开始是在慕课网看 <a href="http://www.imooc.com/course/list?c=fe&amp;sort=pop" rel="external nofollow noopener noreferrer" target="_blank">前端基础</a> 相关视频，然后也简单地在 <a href="http://www.runoob.com/html/html-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">菜鸟教程</a> 看了相关文字内容，最后在廖雪峰的网站看 <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" rel="external nofollow noopener noreferrer" target="_blank">JavaScript全栈教程</a>，这部分对后来 Node.js 后端开发很有帮助。</p><p>但是现在发现 Javascript 水品还不行，没有接近实战的水平，所以打算再系统学习下。<br>按照知乎 <a href="https://www.zhihu.com/question/19713563" rel="external nofollow noopener noreferrer" target="_blank">如何循序渐进、有效地学习JavaScript？</a> 问题的回答，决定先学习 《JavaScript DOM 编程艺术》（第二版），后面再学习 《JavaScript高级程序设计》，最后再刷 <a href="http://es6.ruanyifeng.com/" rel="external nofollow noopener noreferrer" target="_blank">《ECMAScript 6 入门》</a> 学习 ES6 。</p><h1 id="第1章-JavaScript-简史"><a href="#第1章-JavaScript-简史" class="headerlink" title="第1章 JavaScript 简史"></a>第1章 JavaScript 简史</h1><p>本章主要介绍了 JavaScript 的起源、浏览器之间的战争、DOM 的演变史。</p><p>DOM (Document Object Model,文档对象模型) 是一套对文档的内容进行抽象和概念化的方法。<br>感觉和类的说法很类似。</p><h1 id="第2章-JavaScript-语法"><a href="#第2章-JavaScript-语法" class="headerlink" title="第2章 JavaScript 语法"></a>第2章 JavaScript 语法</h1><p>程序设计语言分为解释型和编译型两大类。Java或者C++等语言需要一个编译器，把用Java等高级语言编写出来的源代码翻译为计算机能直接执行的文件。<br>解释型语言不需要编译器–它们仅需要解释器，对于JavaScript而言，Web浏览器负责完成有关解释和执行工作。<br>浏览器的JavaScript解释器将直接读取源代码并执行，相关错误也只能在此时才能发现。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JavaScript 语法基本上和 Java 或者 C++ 类似，下面主要介绍不同点。</p><p>JavaScript 是一种弱类型语言，变量使用前不需要进行类型声明，但不建议这样做。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript 中的数据类型主要包括 字符串、数值、布尔值 三种。</p><ul><li>字符串：单引号双引号都可以，最好根据字符内容选择。</li><li>数值：不单单是整数，允许任意位小数。</li><li>布尔值：true 或 false 。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JavaScript 数组声明不必指出数组长度：</p><pre><code class="JavaScript">var car = Array(5);var car = Array();var car = [];</code></pre><p>声明数组的同时也可以进行填充（向数组添加元素）：</p><pre><code class="JavaScript">var cars = new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);var cars = [&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];</code></pre><p>数组元素类型不必相同，甚至可以是数组或者对象：</p><pre><code class="JavaScript">var cars = new Array(&quot;Saab&quot;,2017,true);var beatles = [];beatles[0] = cars;// beatles[0][1] 的值为 2017 。</code></pre><h3 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h3><p>对象的声明使用 Object 关键字：</p><pre><code class="JavaScript">var car = new Object();var car = {};var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};</code></pre><p>对象属性取值赋值方法：</p><pre><code class="JavaScript">var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};person.lastname = &quot;Wang&quot;;var name = person.lastname;var name = person[&quot;lastname&quot;];</code></pre><h2 id="算数操作符、条件语句、循环语句"><a href="#算数操作符、条件语句、循环语句" class="headerlink" title="算数操作符、条件语句、循环语句"></a>算数操作符、条件语句、循环语句</h2><p>和 Java、C++ 基本一致，不再赘述。</p><p>比较操作符不太一样:<br><strong>==</strong> : 表示类型转换后值是否相等；<br><strong>===</strong> ：严格相等，类型必须相同。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数声明及调用方法：</p><pre><code class="JavaScript">function myFunction(a, b) {    return a * b;}// 调用函数myFunction(2,5);</code></pre><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>全局变量：可以在脚本的任意位置引用，包括函数内部。<br>局部变量：在函数内部声明，只在函数内部有效。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是自包含的数据集合，包含在对象里的数据可通过 属性（property） 和 方法（method） 访问。</p><ul><li>属性是隶属于某个特定对象的变量</li><li>方法是只有某个特定对象才能调用的函数</li></ul><p>对象分类：</p><ul><li>自定义对象：利用 JavaScript 创建的自己的对象；</li><li>内建对象：JavaScript提供的一系列预先定义好的对象。数组也可以看做是 JavaScript 的内建对象的一种。常见的还有Data对象；</li><li>宿主对象：由浏览器提供的预定义对象。常见的有 windows，document 等。</li></ul><h1 id="第3章-DOM"><a href="#第3章-DOM" class="headerlink" title="第3章 DOM"></a>第3章 DOM</h1><p>DOM 三个字母的具体含义:<br>D 是基础，没有文档（Document）DOM 也就无从谈起；<br>O 是对象（Object），JavaScript 本身就可以看做是由对象构成的语言，其重要性不言而喻；<br>M 是模型（Model），其含义是某种事物的表现形式。<br>具体的说 DOM 把文档表示成了一颗家谱树（DOM 使用 parent、child，sibling 等记号来表明家庭成员之间的关系。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>DOM 由许多不同的节点（node）组成，节点可分为三类：<br>元素节点：DOM 的原子是元素节点，可以包含其他元素。<br>文本节点：元素节点的内容。<br>属性节点：元素节点的描述。</p><pre><code class="JavaScript">&lt;p title=&quot;Paragraph&quot;&gt;This is a paragraph.&lt;/p&gt;/*** 元素节点：p* 文本节点：This is a paragraph.* 属性节点：title=&quot;Paragraph&quot;*/</code></pre><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>有三种方法可以获取元素节点，分别通过 id、标签名、class 。</p><pre><code class="JavaScript">// document 特有函数，返回一个元素var x = document.getElementById(&quot;intro&quot;);// getElementsByTagName、getElementsByClassName 返回元素数组var y = document.getElementsByTagName(&quot;p&quot;);var y = x.getElementsByTagName(&quot;p&quot;);// 允许使用通配符var y = x.getElementsByTagName(&quot;*&quot;);var z = document.getElementsByClassName(&quot;intro&quot;);var z = x.getElementsByClassName(&quot;intro&quot;);// 允许查找带有多个类名的元素，并且类名顺序不重要var z = x.getElementsByClassName(&quot;import intro&quot;);</code></pre><h2 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h2><p>获取和设置属性的方法如下：<br>getAttribute()：该方法只能通过元素节点对象调用；<br>setAttribute():该方法允许我们对属性节点的值做出修改。</p><pre><code class="JavaScript">var img = document.getElementById(&quot;image&quot;)；img.getAttribute(&quot;src&quot;);img.src;img.setAttribute(&quot;src&quot;,&quot;landscape.jpg&quot;);img.src = &quot;landscape.jpg&quot;;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;</code></pre><p>通过浏览器查看源代码，其属性并不会改变，也就是说 setAttribute 做出的修改不会反映到文档本身的源码里。这种“表里不一”的的现象源自 DOM 的工作模式：<br>先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。</p><h1 id="第4章-案例研究：JavaScript图片库"><a href="#第4章-案例研究：JavaScript图片库" class="headerlink" title="第4章 案例研究：JavaScript图片库"></a>第4章 案例研究：JavaScript图片库</h1><h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>事件处理函数的作用是，在特定事件发生时调用特定的代码。</p><pre><code class="HTML"> &lt;a href=&quot;images/fireworks.jpg&quot; title=&quot;A fireworks display&quot; onclick=&quot;showPic(this); return false;&quot;&gt;Fireworks&lt;/a&gt;</code></pre><p>事件处理函数的工作机制：在给某元素添加事件处理函数后，一旦事件发生相应的 JavaScript 代码就会执行。<br>被调用的 JavaScript 代码可以返回一个值，这个值将被传递至事件处理函数。</p><p>例如：我们给某链接添加一个 onclick 事件处理函数，并把这个事件处理函数所触发的 JavaScript 代码返回 true 或 false 。<br>这样一来，当这个链接被点击时，JavaScript 代码返回值是 true ，onclick 事件处理函数就认为 这个链接被点击了；反之，认为没有被点击。</p><p>所以在 onclick 事件处理函数所触发的 JavaScript 代码里增加一条 <code>return false;</code> 语句，屏蔽掉链接的默认行为。</p><h2 id="对函数进行拓展"><a href="#对函数进行拓展" class="headerlink" title="对函数进行拓展"></a>对函数进行拓展</h2><h3 id="childNodes-属性"><a href="#childNodes-属性" class="headerlink" title="childNodes 属性"></a>childNodes 属性</h3><p>childNodes 属性可以获取任一元素的所有子元素。</p><pre><code class="JavaScript">var body_element = document.getElementById(&quot;body&quot;)[0];// 得到 body 的所有子元素、数组body_element.childNodes;</code></pre><h3 id="nodeType-属性"><a href="#nodeType-属性" class="headerlink" title="nodeType 属性"></a>nodeType 属性</h3><p>childNodes 属性返回的数组包括所有类型的节点，而不仅仅是元素节点。<br>事实上，文档里的每样东西都是一个节点，设置连空格和换行符都被解释为节点。</p><p>可通过节点的 nodeType 属性区分不同的节点。</p><p><code>node.nodeType</code></p><p>返回值是一个数字。</p><p>nodeType 共有 12 种取值，其中仅 3 种具有实用价值。</p><p>元素节点：1.<br>属性节点：2.<br>文本节点：2.</p><h3 id="nodeValue-属性"><a href="#nodeValue-属性" class="headerlink" title="nodeValue 属性"></a>nodeValue 属性</h3><p>若改变 文本节点 的值，可通过 DOM 提供的 nodeValue 属性。</p><p><code>node.nodeValue</code></p><p>注意：对于元素节点而言，<code>element.nodValue</code> 得到的值并不是元素的文本值。</p><p>正确的做法的先得到元素节点的文本节点，再取 nodeValue 属性：</p><p><code>element.childNodes[0].nodeValue</code></p><h3 id="firstChild-和-lastChild-属性"><a href="#firstChild-和-lastChild-属性" class="headerlink" title="firstChild 和 lastChild 属性"></a>firstChild 和 lastChild 属性</h3><p>firstChild：元素的第一个子元素。<br>lastChild：元素的最后一个元素。</p><pre><code class="JavaScript">function showPic(whichPic) {    var source = whichPic.getAttribute(&quot;href&quot;);//获取资源路径    var placeholder = document.getElementById(&quot;placeholder&quot;);    placeholder.setAttribute(&quot;src&quot;,source);    var text = whichPic.getAttribute(&quot;title&quot;);//获取内容    var description = document.getElementById(&quot;description&quot;);    description.firstChild.nodeValue = text;}</code></pre><h1 id="第5章-最佳实践"><a href="#第5章-最佳实践" class="headerlink" title="第5章 最佳实践"></a>第5章 最佳实践</h1><p>1、在使用任何一句JavaScript代码时，都应该想想，对这个网页是否有用；<br>2、平稳退化（graceful degradation)：如果正确使用了 JavaScript 脚本，可以让访问者在他们的浏览器不支持 JavaScript 的情况下仍能顺利地浏览你网站。<br>虽然某些功能无法使用，但是最基本的操作仍能顺利完成；<br>3、渐进加强：用额外的信息层去包裹原始数据；使 CSS 代码负责提供关于“表示”的信息，JavaScript 代码负责提供关于“行为”的信息。<br>4、分离 JavaScript：在 HTML 文档中使用诸如 onclick 之类的属性也是一种没有效率又容易引发问题的做法。<br>如果利用像 CSS 中的 class 和 id 属性那样，把JavaScript 代码调用行为与 HTML 文档内容和结构分离，网页就会健壮不少。<br>5、向后兼容：对象检测：检测浏览器对 JavaScript 的支持程度。<br>用一个 if 语句的条件表达式看求值结果是 true 还是 false 来采取不同的行动。<br>如在代码前加上 <code>if(!getElementById) return false</code>;<br>6、性能考虑：<br>尽量少访问DOM和尽量减少标记，不管什么时候只要是查询DOM中的某些元素，浏览器就会搜索整个DOM树，从中查找可能匹配的元素。<br>在多个函数都会取得一组类似元素的情况下，可以考虑重新构建代码，把搜索结果保存在一个全局变量里，或者把一组元素以参数形式传递给函数。<br>减少标记数量的目的在于，过多的不必要的元素只会增加DOM树的规模。<br>7、合并和放置脚本：减少请求数量是在性能优化时首先要考虑的；<br>把所以的<code>&lt;script&gt;</code>标签都放在文档的末尾，<code>&lt;/body&gt;</code>标记之前，就可以让页面变得更快。<br>8、压缩脚本：指的是把脚本文件中的不必要的字节，比如空格和注释，统统删除，从而达到“压缩”文件的目的；<br>多数情况下应该有两个版本，一个是工作副本，可以修改代码并添加注释，另一个是精简副本，用于放在站点上，通常在精简副本的文件名上加上 min 字样。</p><h1 id="第6章-案例研究：图片库改进版"><a href="#第6章-案例研究：图片库改进版" class="headerlink" title="第6章 案例研究：图片库改进版"></a>第6章 案例研究：图片库改进版</h1><p>本章主要是第5章内容在 图片库 上的实践。</p><p>共享onload事件：</p><p>假如有两个函数 firstFunction 和 secondFunction 需要在页面加载时执行：</p><pre><code class="JavaScript">window.onload = firstFunction;window.onload = secondFunction;</code></pre><p>这样做的话实际上只有后一个可以执行。</p><pre><code class="JavaScript">window.onload = function(){　　firstFunction();　　secondFunction();}</code></pre><p>这样做创建了一个匿名函数，在需要绑定的函数不是很多的场合的确很实用.</p><p>最佳解决方案,使用 addLoadEvent 函数。<br>这个方案需要额外添加一些代码，但一旦有了这些代码，绑定函数到 onload 就很方便。</p><pre><code class="JavaScript">function addLoadEvent(func){   //将现有的 window.onload 处理函数保存到 oldonload　　var oldonload = window.onload;    //如果现有的 window.onload 上没有处理函数，将 func 添加给它　　if(typeof oldonload != &#39;function&#39;)　　{　　　　window.onload = func;　　}　　else{　　　　window.onload function()　　　　{　　　　　　oldload();　　　　　　func();　　　　}　　}}</code></pre><h1 id="第7章-动态创建标记"><a href="#第7章-动态创建标记" class="headerlink" title="第7章 动态创建标记"></a>第7章 动态创建标记</h1><p>JavaScript 可以通过创建新元素和修改现有元素改变网页的结构。</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><h3 id="document-write"><a href="#document-write" class="headerlink" title="document.write"></a>document.write</h3><p>document 的 write() 方法可以方便快速地将字符串插入到文档内。</p><pre><code class="JavaScript">&lt;body&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    document.write(&quot;&lt;p&gt;This is inserted.&lt;/p&gt;&quot;);  &lt;/script&gt;&lt;/body&gt;</code></pre><blockquote><p>缺点就是违背了”行为与表现分离的原则”,<br>即使把这句语句挪到外部，还是需要在<code>&lt;body&gt;</code>里边添加<code>&lt;script&gt;</code>标签才可以调用。</p></blockquote><h3 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h3><p>innerHTML 属性可以用来读写某给定元素里地 HTML 元素。</p><pre><code class="JavaScript">&lt;body&gt;  &lt;div id=&quot;testdiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;window.onload = function(){  var testdiv = document.getElementById(&quot;testdiv&quot;);  testdiv.innerHTML=&quot;&lt;p&gt;I inserted &lt;em&gt;this&lt;/em&gt; content.&lt;/p&gt;&quot;;}</code></pre><p>利用此技术无法区分“插入一段内容”还是“替换一段内容”。</p><h2 id="DOM-方法"><a href="#DOM-方法" class="headerlink" title="DOM 方法"></a>DOM 方法</h2><h3 id="createElement-方法"><a href="#createElement-方法" class="headerlink" title="createElement 方法"></a>createElement 方法</h3><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);</code></pre><p>创建元素节点，只创建会出现一个文档碎片（document fragment）。<br>本身并不影响页面表现，它是游荡在JavaScript世界里的一个孤儿。<br>但是它已经有 nodeType 和 nodeName 属性。</p><h3 id="appendChild-方法"><a href="#appendChild-方法" class="headerlink" title="appendChild 方法"></a>appendChild 方法</h3><p>把新创建的节点插入文档的节点树最简单方法是：让其成为某个现有节点的一个子节点。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);</code></pre><h3 id="createTextNode-方法"><a href="#createTextNode-方法" class="headerlink" title="createTextNode 方法"></a>createTextNode 方法</h3><p>创建文本节点填充元素节点的内容。<br>把文本节点插入为元素节点的子节点。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);var txt = document.createTextNode(&quot;Hello World&quot;);para.appendChild(txt);</code></pre><p>改变顺序，二者结果相同。</p><pre><code class="JavaScript">var para = document.createElement(&quot;p&quot;);var txt = document.createTextNode(&quot;Hello World&quot;);para.appendChild(txt);var testdiv = document.getElementById(&quot;testdiv&quot;);testdiv.appendChild(para);</code></pre><h2 id="重回图片库"><a href="#重回图片库" class="headerlink" title="重回图片库"></a>重回图片库</h2><h3 id="在已有元素前插入元素"><a href="#在已有元素前插入元素" class="headerlink" title="在已有元素前插入元素"></a>在已有元素前插入元素</h3><p>DOM 提供了 insertBefore() 方法，把一个元素插入到现有元素之前。</p><p><code>parentElement.insertBefore(newElement,targetElement);</code></p><p>其中：<br>parentElement：目标元素的父元素，<br>newElement：想插入的元素，<br>targetElement：想插入哪个元素之前。</p><pre><code class="JavaScript">var gallery = document.getElementById(&quot;imagegallery&quot;);gallery.parentNode.insertBefore(placeholder,gallery);</code></pre><h3 id="在已有元素后插入元素"><a href="#在已有元素后插入元素" class="headerlink" title="在已有元素后插入元素"></a>在已有元素后插入元素</h3><p>DOM 并没有提供了 insertAfter() 方法，下面编写：</p><pre><code class="JavaScript">function insertAfter (newElement,targetElement){  var parent = targetElement.parentNode;  if(parent.lastChild == targetElement){    parent.appendChild(newElement);  }else{    parent.insertBefore(newElement,targetElement.nextSibling);  }}var gallery = document.getElementById(&quot;imagegallery&quot;);insertAfter(placeholder,gallery);</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax 可以做到只更新页面中的一小部分，其它内容不用重新加载。<br>Ajax 的主要优势是对页面的请求以异步方式发送到服务器。</p><h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>Ajax 的核心是 XMLHttpRequest 对象，XMLHttpRequest 充当浏览器脚本与服务器之间的中间人的角色。<br>JavaScript 可以通过这个对象自己发送请求，同时自己处理响应。</p><pre><code class="JavaScript">function getnewContent (){  var request = new XMLHttpRequest();  if(request){    request.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);    request.onreadystatechange = function(){      if(request.readyState == 4){        var para = document.createElement(&quot;p&quot;);        var txt = document.createTextNode(request.responseText);        para.appendChild(txt);        var testdiv = document.getElementById(&quot;testdiv&quot;);        testdiv.appendChild(para);      }    };    request.send(null);  }}</code></pre><p>其中 readyState 属性的值，有5个可能值：<br>0 表示未初始化<br>1 表示正在加载<br>2 表示加载完毕<br>3 表示正在交互<br>4 表示完成</p><p>访问服务器返回的数据要通过两个属性完成。<br>responseText：保存文本字符串形式的数据。<br>responseXML：保存 Content-Type 头部指定为 “text/xml” 的数据。</p><p>注意 异步请求，脚本在发送 XMLHttpRequest 请求之后仍然会继续执行，不会等待响应返回。</p><h3 id="HIjax"><a href="#HIjax" class="headerlink" title="HIjax"></a>HIjax</h3><p>HIjax 意思是渐进增强地使用 Ajax 。</p><h1 id="第8章-充实文档内容"><a href="#第8章-充实文档内容" class="headerlink" title="第8章 充实文档内容"></a>第8章 充实文档内容</h1><p>JavaScript 脚本只应该用来充实文档内容，要避免使用 DOM 技术来创建核心内容。</p><pre><code class="JavaScript">function displayAbbreviations() {  if (!document.getElementsByTagName || !document.createElement || !document.createTextNode) return false;// 得到所有链接  var abbreviations = document.getElementsByTagName(&quot;abbr&quot;);  if (abbreviations.length &lt; 1) return false;  var defs = new Array();// 遍历链接  for (var i=0; i&lt;abbreviations.length; i++) {    var current_abbr = abbreviations[i];    if (current_abbr.childNodes.length &lt; 1) continue;    var definition = current_abbr.getAttribute(&quot;title&quot;);    var key = current_abbr.lastChild.nodeValue;    defs[key] = definition;  }// 创建列表  var dlist = document.createElement(&quot;dl&quot;);// 遍历访问键  for (key in defs) {    var definition = defs[key];    var dtitle = document.createElement(&quot;dt&quot;);    var dtitle_text = document.createTextNode(key);    dtitle.appendChild(dtitle_text);    var ddesc = document.createElement(&quot;dd&quot;);    var ddesc_text = document.createTextNode(definition);    ddesc.appendChild(ddesc_text);// 添加列表项到列表中    dlist.appendChild(dtitle);    dlist.appendChild(ddesc);  }  if (dlist.childNodes.length &lt; 1) return false;// 创建标题  var header = document.createElement(&quot;h2&quot;);  var header_text = document.createTextNode(&quot;Abbreviations&quot;);  header.appendChild(header_text);// 把标题添加到页面主体  document.body.appendChild(header);// 把列表添加到页面主体  document.body.appendChild(dlist);}addLoadEvent(displayAbbreviations);</code></pre><blockquote><p>我的理解就是把原本 HTML 的内容通过 JavaScript 操作提取出来摘要，再加到 HTML 中充实文档内容。</p></blockquote><h1 id="第9章-CSS-DOM"><a href="#第9章-CSS-DOM" class="headerlink" title="第9章 CSS-DOM"></a>第9章 CSS-DOM</h1><p>我们在浏览器看到的网页其实有三部分构成：</p><ul><li>结构层(structural layer) 由 XHTML 或者 HTML 等标记语言创建。</li><li>表示层(presentation layer) 由 CSS 负责创建。</li><li>行为层(behavior layer) 负责内容应该如何响应事件这一动作，这主要是由 javaScript 和 DOM 负责。</li></ul><h2 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h2><p>在文档中每个人元素都是一个对象，每个元素都有一个 style 属性，他们也是一个对象。</p><h3 id="获取样式"><a href="#获取样式" class="headerlink" title="获取样式"></a>获取样式</h3><pre><code class="javaScript">element.style.color;// 中间带连字符的 CSS 属性要使用驼峰写法element.style.fontFamily;</code></pre><p>获取样式属性的返回值与设置值采用同样的单位。<br>如我们在 CSS font-size 属性时以 em 为单位，相应的 DOM fontSize 属性也以 em 为单位。</p><blockquote><p>注意 通过 style 获取属性的局限性，即只能返回 <strong>内联样式</strong>。</p></blockquote><p><code>&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;</code></p><p>通过 link 元素引入的 CSS 文件样式不能用 DOM style 属性检索出来。</p><p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></p><p>通过 <code>&lt;head&gt;</code> 部分引入的 <code>&lt;style&gt;</code> 标签里也不能用 DOM style 属性检索出来。</p><pre><code class="HTML">&lt;head&gt;  &lt;style&gt;  hr {color:sienna;}  p {margin-left:20px;}  &lt;/style&gt;&lt;/head&gt;</code></pre><h3 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h3><p>style 对象的各个属性都是可读写的，可以通过元素的 style 属性获取样式，也可以通过它更新样式。</p><pre><code class="JavaScript">element.style.property = value;// 例如：para.style.color = &quot;black&quot;;</code></pre><h2 id="何时该用-DOM-脚本设置样式"><a href="#何时该用-DOM-脚本设置样式" class="headerlink" title="何时该用 DOM 脚本设置样式"></a>何时该用 DOM 脚本设置样式</h2><p>在绝大多数场合还是应该使用 CSS 声明样式。<br>在使用 CSS 不方便的场合，可以利用 DOM 对文档的样式做一些小的增强。</p><p>通过 CSS 设置样式方式：</p><pre><code class="CSS">// 1.通过标签元素p {  font-size: 1em;}// 2.通过class属性.fineorint {  font-size: 1em;}// 3.通过id属性#fineorint {  font-size: 1em;}</code></pre><p>通过 DOM 脚本设置样式的情况：</p><ul><li>根据元素在节点数的位置来设置样式</li><li>根据某种条件反复设置某种样式</li><li>响应事件，即事件发生时设置有关元素的样式</li></ul><h2 id="className-属性"><a href="#className-属性" class="headerlink" title="className 属性"></a>className 属性</h2><p>前面一直在使用 DOM 直接设置或者修改元素的样式，这种让行为层干表示层的活，并不是理想的工作方式。</p><p>与其使用 DOM 直接改变某个元素的样式，倒不如通过 JavaScript 代码修改元素的 class 属性。</p><p>通过修改 DOM 直接改变元素样式：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.style.fontWeight = &quot;bold&quot;;    elem.style.fontSize = &quot;1.2em&quot;;  }}</code></pre><p>通过修改 class 属性：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.setAttribute(&quot;class&quot;,&quot;intro&quot;);  }}</code></pre><p>当然需要提前引入 CSS 样式：</p><pre><code class="CSS">.intro {  font-weight: bold;  font-size: 1.2em;}</code></pre><p>更简单的是通过 className 属性。<br>className 属性是一个可读/可写的属性，凡是元素节点都有这个属性。</p><p>获得元素的 class 属性：<br><code>element.className</code><br>修改元素的 class 属性：<br><code>element.className = value</code></p><p>通过 className 属性修改样式：</p><pre><code class="JavaScript">function styleHeaderSiblings() {  if (!document.getElementsByTagName) return false;  var headers = document.getElementsByTagName(&quot;h1&quot;);  for (var i=0; i&lt;headers.length; i++) {    var elem = getNextElement(headers[i].nextSibling);    elem.className = &quot;intro&quot;;  }}</code></pre><blockquote><p>缺点：通过 className 属性设置元素的 class 属性将替换原有 class 设置。</p></blockquote><p>可以通过 字符串拼接 解决(注意 intro 前的空格)：</p><p><code>elem.className += &quot; intro&quot;;</code></p><h1 id="第10章-用JavaScript实现动画效果"><a href="#第10章-用JavaScript实现动画效果" class="headerlink" title="第10章 用JavaScript实现动画效果"></a>第10章 用JavaScript实现动画效果</h1><p>JavaScript 能够按照预定的时间间隔重复调用一个函数，而这意味着我们可以随着时间的推移而不断地改变某个元素地样式。</p><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>位置通常是由 CSS 负责设置的：</p><pre><code class="CSS">element {  position: absolute;  top: 50px;  left: 100px;}</code></pre><ul><li><strong>static</strong>: 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li><strong>relative</strong>: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li><li><strong>absolute</strong>: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li><strong>fixed</strong>: 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li><strong>inherit</strong>: 规定应该从父元素继承 position 属性的值。</li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>JavaScript 函数 setTimeout 能让某个函数在经过一段预定的时间后才开始执行。</p><p><code>variable = setTimeout(&quot;function&quot;,interval);</code></p><p>第一个参数为函数名字，第二个参数为间隔时间。若想取消执行：</p><p><code>clearTimeout(variable)</code></p><p>本章主要是定义的一个位置随时间运动的函数：</p><pre><code class="JavaScript">function moveElement(elementID,final_x,final_y,interval) {  if (!document.getElementById) return false;  if (!document.getElementById(elementID)) return false;  var elem = document.getElementById(elementID);  var xpos = parseInt(elem.style.left);  var ypos = parseInt(elem.style.top);  if (xpos == final_x &amp;&amp; ypos == final_y) {    return true;  }  if (xpos &lt; final_x) {    xpos++;  }  if (xpos &gt; final_x) {    xpos--;  }  if (ypos &lt; final_y) {    ypos++;  }  if (ypos &gt; final_y) {    ypos--;  }  elem.style.left = xpos + &quot;px&quot;;  elem.style.top = ypos + &quot;px&quot;;  var repeat = &quot;moveElement(&#39;&quot;+elementID+&quot;&#39;,&quot;+final_x+&quot;,&quot;+final_y+&quot;,&quot;+interval+&quot;)&quot;;  movement = setTimeout(repeat,interval);}</code></pre><h1 id="第11章-HTML5"><a href="#第11章-HTML5" class="headerlink" title="第11章 HTML5"></a>第11章 HTML5</h1><p>本章介绍了 HTML5 的新特性，包括 <code>&lt;canvas&gt;</code>、 <code>&lt;audio&gt;</code>、 <code>&lt;video&gt;</code> 元素及新的表单控件。</p><h1 id="第12章-综合示例"><a href="#第12章-综合示例" class="headerlink" title="第12章 综合示例"></a>第12章 综合示例</h1><p>结合前面的知识实现了一个综合示例，对前面的知识进行了很好的回顾。</p><blockquote><p>这本书看下来，感受最大的是 HTML 和 CSS 基础太差，JavaScript 部分还好。<br>原来计划上个周末看完呢，中间又催文档啥的，这个周末（2017.10.29）才看完。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript DOM 编程艺术》读书笔记&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.wshunli.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《JavaScript编程艺术》" scheme="http://www.wshunli.com/tags/%E3%80%8AJavaScript%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B/"/>
    
  </entry>
  
</feed>
