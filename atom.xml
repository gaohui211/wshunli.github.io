<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wshunli.com/"/>
  <updated>2017-12-30T15:03:29.575Z</updated>
  <id>http://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017年终总结，我这一年的点点滴滴</title>
    <link href="http://www.wshunli.com/posts/33b6fcdd.html"/>
    <id>http://www.wshunli.com/posts/33b6fcdd.html</id>
    <published>2017-12-30T13:37:12.000Z</published>
    <updated>2017-12-30T15:03:29.575Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19QNSKWYWBs7X7CqLxh7P7DknSQERz5VTAGuTAVmnUkaawyfTjnXyKa8ABUkIgJpxhIQGtsnWVHG/ZQu7PTUxpD5TqmaZoyF8rXKAaV19L0vXtFPKSbegOUdUKBwAOCnXZuWcocUSqwXbXbksCgnGaAsr/yQTuJCIxaiR6dQX0U5VHcWNaFyvoBCDjsf4ZIP9dLCX2bVsPmV3a48UxaHBudB6Uv3AzqttsVdPCwuWVNQNjNeNQRaIUwDo5a28EtCvfAsGuFLdaTqX8Lxwyh9vv+1WmX7Y32TuUyz3px7GVNFB2+Etw0OJTk9hpHmxYfIk5IFqsN0d+jFXoY/oAaQPBKM9CXD3N3FL4GPFvhrJ8TCU+eQui28+Q5Z3N2Pps2/mm2XRFs/g9GeN+JjZIBpQs92uXd/bs52Q0c+10X7l3J/gP41W2dES7nGvlZYhxri2o1LS+i/hjI/exnPizklq5Cm0P0qMP/5aEI43p+EK1pXw+RprcvdzB5jxWfHVs4oZxucd7tfifyyicZGEoFHeCEvwpvQrohrs9bWVSJRVTRuniWJgGT3wd+IHvTr6x/bd2j3dXuieOPoyM0V2t+pUeTjlNfO/ZsZtPWVkd28O4Uqmantq8T6eyxGpDw/HuAvckZkV9DftlzDcn+FazAGOiJpDlDX93/T/NmXjVNMmtWqiOFKByLT1Z374wttwBmrBP7uv1EB5iQN3euewNz5a5UfDL6pq5pbXZBNsGTf0H3wxDrW9Uu4gDqb+k/LbWh4jCSourwX/eP3Mf1hS2zC2jo6qcTORMxtQNODEJ1zng4oVhZpYC6ds3wlCGeE72TsvFa22hWWeGedgsDBMgow0Ro75Rc5kVscP9zzVB6pSkSts1NIg+sX84t7dGiwfmRIPnWfzR+uIj9sgfKeVbsGDSqFpSQSjRXQIge9z79W0QSs023zdTR3TGWOYo8/mfnM3oDEvf5QZxK3/Xz1XSLD5Xlvx2p1USNoOBkVaOqxXf8Cq8BzGeO6iAhQBjNqVe1ffHB1iepN4Yz5CWRWUqGoRTde7/PFIzBqrsYp7Cp8FdI+MBUwHAw+Pyj+915DsAgx4gGp0JVoiwrI8le3IiEO7/W+WH3+UlwcIpsDwz/ZAdbqd3dP5xmzznhWTlZQppe268zp1y4Lx9HvbFUtXp80lsjaqZqMKsGmWoMsUz4bekYUb0HsVyR24Rf8B6g6gG1WP/0KmgNWUg9nMPwqntwPhVkZGqNO5ICvHbrb49ZA9YGJHMtG2Rqpie+A9on0Kq6OHIA1yNMO9ulz0yH2ksHW1C25Lm/VqkIkx8= </div>]]></content>
    
    <summary type="html">
    
      【加密文章】 深自缄默吗，如云漂泊
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="年终总结" scheme="http://www.wshunli.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/fba26489.html"/>
    <id>http://www.wshunli.com/posts/fba26489.html</id>
    <published>2017-12-27T07:05:30.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver</p><a id="more"></a><h1 id="第5章-全局大喇叭"><a href="#第5章-全局大喇叭" class="headerlink" title="第5章 全局大喇叭"></a>第5章 全局大喇叭</h1><p>BroadcastReceiver，广播接收者，它是一个系统全局的监听器，用于监听系统全局的Broadcast消息，所以它可以很方便的进行系统组件之间的通信。</p><p>BroadcastReceiver属于系统级的监听器，它拥有自己的进程，只要存在与之匹配的Broadcast被以Intent的形式发送出来，BroadcastReceiver就会被激活。</p><p>第7章 跨程序共享数据</p><p>第10章 后台默默的劳动者</p><blockquote><p>参考资料<br>1、Broadcasts | Android Developers<br><a href="https://developer.android.com/guide/components/broadcasts.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/broadcasts.html</a><br>2、Android之BroadcastReceiver | 吴小龙同學<br><a href="http://wuxiaolong.me/2015/11/03/BroadcastReceiver/" rel="external nofollow noopener noreferrer" target="_blank">http://wuxiaolong.me/2015/11/03/BroadcastReceiver/</a><br>3、Android BroadcastReceiver使用详解 - 简书<br><a href="https://www.jianshu.com/p/f348f6d7fe59" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f348f6d7fe59</a><br>4、Android深入四大组件（四）广播的注册、发送和接收过程 | 刘望舒的博客<br><a href="http://liuwangshu.cn/framework/component/4-broadcastreceiver.html" rel="external nofollow noopener noreferrer" target="_blank">http://liuwangshu.cn/framework/component/4-broadcastreceiver.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统下搭建Android开发环境</title>
    <link href="http://www.wshunli.com/posts/80d94eb7.html"/>
    <id>http://www.wshunli.com/posts/80d94eb7.html</id>
    <published>2017-12-26T05:25:55.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu 16.04 LTS 系统下搭建 Android 开发环境</p><a id="more"></a><p>昨天圣诞节在机房装了台 Ubuntu ，主要是想试下管理系统的部署，<br>原来在虚拟机下部署的没问题，在真机上部署基本上也没有什么问题。</p><p>有台 Ubuntu 还是很有必要的，后面编译软件会方便很多。<br>现在先学习搭建下 Android 开发环境。</p><h1 id="Java-环境"><a href="#Java-环境" class="headerlink" title="Java 环境"></a>Java 环境</h1><p>在比较新的版本 Android Studio 里面已经有 OpenJDK 了，但是 Oracle Java 更好点，我们直接使用命令安装。</p><pre><code class="bash">sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install java-common oracle-java8-installer</code></pre><p>在安装的过程会询问是否同意许可，选择同意即可。</p><p>配置 Java 环境变量，依次执行以下命令：</p><pre><code class="bash">sudo apt-get install oracle-java8-set-defaultsource /etc/profile</code></pre><p>默认安装路径在 <code>/usr/lib/jvm/java-8-oracle</code> .</p><h1 id="Android-环境"><a href="#Android-环境" class="headerlink" title="Android 环境"></a>Android 环境</h1><p>安装 Android Studio 和 安装 JDK 类似，执行一下命令：</p><pre><code class="bash">sudo add-apt-repository ppa:maarten-fonville/android-studiosudo apt updatesudo apt install android-studio`</code></pre><p>JDK 默认安装路径在 <code>/opt/android-studio</code> .</p><h2 id="配置-Android-环境变量："><a href="#配置-Android-环境变量：" class="headerlink" title="配置 Android 环境变量："></a>配置 Android 环境变量：</h2><pre><code class="bash">gedit ~/.bashrc</code></pre><p>在文件的末尾添加如下代码并保存</p><pre><code class="bash">export ANDROID_HOME=/home/wshunli/Android/Sdkexport PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH</code></pre><p>其中 <code>/home/wshunli/Android/Sdk</code> 替换为自己 SDK 的安装位置，一般在 <code>android-studio</code> 同级目录下。</p><p>应用环境变量：</p><pre><code class="bash">source ~/.bashrc</code></pre><p>测试下查看原来设置的目录：</p><pre><code class="bash">echo $ANDROID_HOME</code></pre><p>返回 SDK 所在目录，配置正确。</p><p>接下来就可以启动 Android Studio 了。</p><h2 id="NDK-安装及环境配置（可选）："><a href="#NDK-安装及环境配置（可选）：" class="headerlink" title="NDK 安装及环境配置（可选）："></a>NDK 安装及环境配置（可选）：</h2><p>可以在 Android Studio 中下载，也执行以下命令下载并解压</p><pre><code class="bash">wget -c https://dl.google.com/android/repository/android-ndk-r10e-linux-x86_64.zipunzip android-ndk-r10e-linux-x86_64.zip</code></pre><p>配置 NDK 环境变量，和 SDK 类似：</p><pre><code class="bash">gedit ~/.bashrc</code></pre><p>在文件的末尾添加如下代码并保存</p><pre><code class="bash">export ANDROID_NDK=/home/wshunli/Android/android-ndk-r10eexport PATH=$ANDROID_NDK:$PATH</code></pre><p>其中 <code>/home/wshunli/Android/android-ndk-r10e</code> 替换为自己 NDK 的安装位置</p><p>应用环境变量：</p><pre><code class="bash">source ~/.bashrc</code></pre><p>测试下查看原来设置的目录：</p><pre><code class="bash">echo $ANDROID_NDK</code></pre><p>Android Studio 中文社区(官网)下载所需开发工具。<br><a href="http://www.android-studio.org/" rel="external nofollow noopener noreferrer" target="_blank">http://www.android-studio.org/</a></p><blockquote><p>参考资料<br>1、2 Ways to Install Android Studio in Ubuntu 16.04 and Ubuntu 17.04 - LinuxBabe.Com<br><a href="https://www.linuxbabe.com/ubuntu/install-android-studio-ubuntu-16-04" rel="external nofollow noopener noreferrer" target="_blank">https://www.linuxbabe.com/ubuntu/install-android-studio-ubuntu-16-04</a><br>2、Ubuntu系统下配置Android开发环境 - 简书<br><a href="https://www.jianshu.com/p/949a5a2ddceb" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/949a5a2ddceb</a><br>3、Ubuntu 16.04 搭建Android开发环境 - Droi - 博客园<br><a href="http://www.cnblogs.com/droi/p/5399975.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/droi/p/5399975.html</a><br>4、Ubuntu下安装Android NDK - 简书<br><a href="https://www.jianshu.com/p/b12d714435bc" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b12d714435bc</a><br>5、NDK:Linux下NDK安装和配置 - 简书<br><a href="https://www.jianshu.com/p/abdad7fd1367" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/abdad7fd1367</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu 16.04 LTS 系统下搭建 Android 开发环境&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="Ubuntu" scheme="http://www.wshunli.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（五）</title>
    <link href="http://www.wshunli.com/posts/f90ba53c.html"/>
    <id>http://www.wshunli.com/posts/f90ba53c.html</id>
    <published>2017-12-20T12:59:34.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】今天又没找到对象
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/b6bcc7db.html"/>
    <id>http://www.wshunli.com/posts/b6bcc7db.html</id>
    <published>2017-12-06T07:35:48.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 应用组件之 Activity</p><a id="more"></a><p>Android 应用的四大组件 Activity，Service，Broadcast Receiver， Content Provider 最为核心。</p><h1 id="第2章-先从看得到的入手"><a href="#第2章-先从看得到的入手" class="headerlink" title="第2章 先从看得到的入手"></a>第2章 先从看得到的入手</h1><p>Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片或查看地图等操作。</p><h2 id="Activity-创建、启动及销毁"><a href="#Activity-创建、启动及销毁" class="headerlink" title="Activity 创建、启动及销毁"></a>Activity 创建、启动及销毁</h2><p>要创建 Activity，必须创建 <a href="https://developer.android.com/reference/android/app/Activity.html" rel="external nofollow noopener noreferrer" target="_blank">Activity</a> 的子类（或使用其现有子类）。</p><h3 id="实现用户界面"><a href="#实现用户界面" class="headerlink" title="实现用户界面"></a>实现用户界面</h3><p>Activity 的用户界面是由层级式视图 — 衍生自 View 类的对象 — 提供的，也可以利用 Android 提供的现成视图设计和组织布局。</p><p>利用视图定义布局的最常见方法是借助保存在您的应用资源内的 XML 布局文件。</p><pre><code class="Java">setContentView(R.layout.activity_main);</code></pre><p>不过，也可以在 Activity 代码中创建新 View，并通过将新 View 插入 ViewGroup 来创建视图层次，然后通过将根 ViewGroup 传递到 setContentView() 来使用该布局。</p><h3 id="声明-Activity"><a href="#声明-Activity" class="headerlink" title="声明 Activity"></a>声明 Activity</h3><p>Activity 需要在 清单文件 中声明。</p><pre><code class="XML">&lt;manifest ... &gt;  &lt;application ... &gt;    &lt;activity android:name=&quot;.MainActivity&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;    ...  &lt;/application ... &gt;  ...&lt;/manifest &gt;</code></pre><p><code>&lt;action&gt;</code> 元素指定这是应用的“主”入口点。<br><code>&lt;category&gt;</code> 元素指定此 Activity 应列入系统的应用启动器内（以便用户启动该 Activity）。</p><h3 id="启动-Activity"><a href="#启动-Activity" class="headerlink" title="启动 Activity"></a>启动 Activity</h3><p>可以通过调用 startActivity()，并将其传递给描述想启动的 Activity 的 Intent 来启动另一个 Activity。</p><pre><code class="Java">Intent intent = new Intent(Intent.ACTION_SEND);intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);startActivity(intent);</code></pre><p>启动 Activity 推荐写法：</p><pre><code class="Java">public class SecondActivity extends FirstActivity {    public static void actionStart(Context context, String data1, String data2) {        Intent intent = new Intent(context, SecondActivity.class);        intent.putExtra(&quot;param1&quot;, data1);        intent.putExtra(&quot;param2&quot;, data2);        context.startActivity(intent);    }    ···}</code></pre><p>可以通过调用 startActivityForResult() 方法启动 Activity 并实现 onActivityResult() 回调方法得到启动 Activity 的结果。</p><pre><code class="Java">private void pickContact() {    Intent intent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);    startActivityForResult(intent, PICK_CONTACT_REQUEST);}@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    // If the request went well (OK) and the request was PICK_CONTACT_REQUEST    if (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == PICK_CONTACT_REQUEST) {        // Perform a query to the contact&#39;s content provider for the contact&#39;s name        Cursor cursor = getContentResolver().query(data.getData(),        new String[] {Contacts.DISPLAY_NAME}, null, null, null);        if (cursor.moveToFirst()) { // True if the cursor is not empty            int columnIndex = cursor.getColumnIndex(Contacts.DISPLAY_NAME);            String name = cursor.getString(columnIndex);            // Do something with the selected contact&#39;s name...        }    }}</code></pre><p>处理 Activity 结果时应该在 onActivityResult() 方法中使用的基本逻辑。</p><p>检查请求是否成功以及requestCode 与随 startActivityForResult() 发送的第二个参数是否匹配。<br>代码通过查询 Intent 中返回的数据（data 参数）从该处开始处理 Activity 结果。</p><h3 id="结束-Activity"><a href="#结束-Activity" class="headerlink" title="结束 Activity"></a>结束 Activity</h3><p>通过调用 Activity 的 finish() 方法来结束该 Activity。也可以通过调用 finishActivity() 结束之前启动的另一个 Activity。</p><h2 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h2><h3 id="Activity-状态"><a href="#Activity-状态" class="headerlink" title="Activity 状态"></a>Activity 状态</h3><p>Activity 在其生命周期中最多有4种状态：</p><ul><li>运行状态：Activity 位于屏幕前台并具有用户焦点。</li><li>暂停状态：另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。</li><li>停止状态：该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。</li><li>销毁状态：系统结束 Activity （调用其 finish() 方法）或直接终止其进程，将其从内存中删除。</li></ul><h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>当一个 Activity 转入和转出上述不同状态时，系统会通过各种回调方法向其发出通知。</p><pre><code class="Java">public class ExampleActivity extends Activity {    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // The activity is being created.    }    @Override    protected void onStart() {        super.onStart();        // The activity is about to become visible.    }    @Override    protected void onResume() {        super.onResume();        // The activity has become visible (it is now &quot;resumed&quot;).    }    @Override    protected void onPause() {        super.onPause();        // Another activity is taking focus (this activity is about to be &quot;paused&quot;).    }    @Override    protected void onStop() {        super.onStop();        // The activity is no longer visible (it is now &quot;stopped&quot;)    }    @Override    protected void onDestroy() {        super.onDestroy();        // The activity is about to be destroyed.    }}</code></pre><p>这些方法共同定义 Activity 的整个生命周期。可以通过实现这些方法监控 Activity 生命周期中的三个嵌套循环：</p><ul><li><strong>完整生命周期</strong> 发生在 onCreate() 与 onDestroy() 之间，就是完整的生存期。</li><li><strong>可见生命周期</strong> 发生在 onStart() 与 onStop() 之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。</li><li><strong>前台生命周期</strong> 发生在 onResume() 与 onPause() 之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。</li></ul><center><img src="https://img.wshunli.com/Android/第一行代码/2.activity_lifecycle.png" alt="activity_lifecycle"></center><p>Activity 生命周期回调方法汇总表。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.activity_lifecycle_method.png" alt="activity_lifecycle"></p><p>名为“是否能事后终止？”的列表示系统是否能在不执行另一行 Activity 代码的情况下，在方法返回后随时终止承载 Activity 的进程。</p><h3 id="保存-Activity-状态"><a href="#保存-Activity-状态" class="headerlink" title="保存 Activity 状态"></a>保存 Activity 状态</h3><p>在 Activity 暂停或者停止时，Activity 的状态会得到保留。<br>但是当系统为了回复内存而销毁 Activity 时，Activity 对象也会被销毁，<br>我们可以使用 onSaveInstanceState() 方法保存 Acitivity 状态信息，使用 onRestoreInstanceState() 方法 恢复保存的状态信息。</p><center><img src="https://img.wshunli.com/Android/第一行代码/2.restore_instance.png" alt="restore_instance"></center><p>当 Activity A 启动 Activity B 时一系列操作的发生顺序：</p><ol><li>Activity A 的 onPause() 方法执行。</li><li>Activity B 的 onCreate()、onStart() 和 onResume() 方法依次执行。（Activity B 现在具有用户焦点。）</li><li>然后，如果 Activity A 在屏幕上不再可见，则其 onStop() 方法执行。</li></ol><h2 id="Intent-和-Intent-过滤器"><a href="#Intent-和-Intent-过滤器" class="headerlink" title="Intent 和 Intent 过滤器"></a>Intent 和 Intent 过滤器</h2><p>Intent 是一个消息传递对象，可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p><p><strong>启动 Activity</strong>：Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。</p><p>如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，您的 Activity 将结果作为单独的 Intent 对象接收。</p><p><strong>启动服务</strong>：Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。</p><p>如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。</p><p><strong>传递广播</strong>：广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。</p><h3 id="显示Intent和隐式Intent"><a href="#显示Intent和隐式Intent" class="headerlink" title="显示Intent和隐式Intent"></a>显示Intent和隐式Intent</h3><p>显式 Intent 按名称（完全限定类名）指定要启动的组件。</p><pre><code class="Java">startActivity(new Intent(this, SecondActivity.class));</code></pre><p>隐式 Intent 不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。</p><p>创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.intent-filters.png-hexo.png" alt="intent-filters"></p><p>隐式 Intent 如何通过系统传递以启动其他 Activity 的图解：<br>[1] Activity A 创建包含操作描述的 Intent，并将其传递给 startActivity()。<br>[2] Android 系统搜索所有应用中与 Intent 匹配的 Intent 过滤器。 找到匹配项之后，<br>[3] 该系统通过调用匹配 Activity（Activity B）的 onCreate() 方法并将其传递给 Intent，以此启动匹配 Activity。</p><h3 id="构建-Intent"><a href="#构建-Intent" class="headerlink" title="构建 Intent"></a>构建 Intent</h3><p>Intent 对象携带了 Android 系统用来确定要启动哪个组件的信息，以及收件人组件为了正确执行操作而使用的信息。</p><p>Intent 中包含的主要信息如下：</p><ul><li>组件名称(Component name)：要启动的组件名称。</li><li>操作(Action)：指定要执行的通用操作的字符串。如 ACTION_VIEW 、ACTION_SEND。</li><li>数据(Data)：引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。</li><li>类别(Category)：一个包含应处理 Intent 组件类型的附加信息的字符串。如 CATEGORY_BROWSABLE、CATEGORY_LAUNCHER。</li><li>Extra：携带完成请求操作所需的附加信息的键值对。</li><li>标志(Flags)：在 Intent 类中定义的、充当 Intent 元数据的标志。</li></ul><p>隐式创建 Intent 示例：</p><pre><code class="Java">// Create the text message with a stringIntent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);sendIntent.setType(&quot;text/plain&quot;);// Verify that the intent will resolve to an activityif (sendIntent.resolveActivity(getPackageManager()) != null) {    startActivity(sendIntent);}</code></pre><p>使用<strong>应用选择器</strong></p><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。</p><p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()。</p><pre><code class="Java">Intent sendIntent = new Intent(Intent.ACTION_SEND);...String title = getResources().getString(R.string.chooser_title);// Create intent to show the chooser dialogIntent chooser = Intent.createChooser(sendIntent, title);if (sendIntent.resolveActivity(getPackageManager()) != null) {    startActivity(chooser);}</code></pre><h3 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，需要在清单文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent 过滤器。</p><p>在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p><p><code>&lt;action&gt;</code> 在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。<br><code>&lt;data&gt;</code> 使用一个或多个指定数据 URI 各个方面（scheme、host、port、path 等）和 MIME 类型的属性，声明接受的数据类型。<br><code>&lt;category&gt;</code> 在 name 属性中，声明接受的 Intent 类别。该值必须是操作的文本字符串值，而不是类常量。</p><pre><code class="XML">&lt;activity android:name=&quot;ShareActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><h3 id="使用待定-Intent"><a href="#使用待定-Intent" class="headerlink" title="使用待定 Intent"></a>使用待定 Intent</h3><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p><p>待定 Intent 的主要用例包括：</p><ul><li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li><li>声明用户使用您的 应用小部件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li><li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li></ul><h3 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h3><p>当系统收到隐式 Intent 以启动 Activity 时，它根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p><ul><li>Intent 操作</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;action android:name=&quot;android.intent.action.EDIT&quot; /&gt;    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;    ...&lt;/intent-filter&gt;</code></pre><ul><li>Intent 数据（URI 和数据类型）</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;    ...&lt;/intent-filter&gt;</code></pre><ul><li>Intent 类别</li></ul><pre><code class="Java">&lt;intent-filter&gt;    &lt;data android:mimeType=&quot;video/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt;    &lt;data android:mimeType=&quot;audio/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt;    ...&lt;/intent-filter&gt;</code></pre><h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent 过滤器匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。<br>例如，主页应用通过使用指定 ACTION_MAIN 操作和 CATEGORY_LAUNCHER 类别的 Intent 过滤器查找所有 Activity，以此填充应用启动器。</p><p>PackageManager 提供了一整套 query…() 方法来返回所有能够接受特定 Intent 的组件，resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities()、queryIntentServices()、queryBroadcastReceivers()将返回能够执行那些作为参数传递的 Intent 的所有 组件 列表，但方法均不会激活组件，而只是列出能够响应的组件。</p><h3 id="通用-Intent"><a href="#通用-Intent" class="headerlink" title="通用 Intent"></a>通用 Intent</h3><p>主要是调用系统提供的一些服务，如闹钟、相机等等。</p><p><a href="https://developer.android.com/guide/components/intents-common.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/intents-common.html</a></p><h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><h3 id="任务和返回栈"><a href="#任务和返回栈" class="headerlink" title="任务和返回栈"></a>任务和返回栈</h3><p>任务是指在执行特定作业时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈（即返回栈）中。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.diagram_backstack.png" alt="diagram_backstack"></p><p>当前 Activity 启动另一个 Activity 时，新 Activity 会被推到栈顶，并获得焦点。当用户按返回按钮时，当前 Activity 会从栈顶弹出并销毁。</p><p>当用户直接按 Home 键回到主屏幕时，尽管该任务中的所有 Activity 全部停止，但是任务的返回栈仍然不变。</p><p>即使来自其他任务，Activity 也可以多次实例化。</p><h3 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h3><p>通过使用 <code>&lt;activity&gt;</code> 清单文件元素中的属性</p><ul><li>taskAffinity</li><li>launchMode</li><li>allowTaskReparenting</li><li>clearTaskOnLaunch</li><li>alwaysRetainTaskState</li><li>finishOnTaskLaunch</li></ul><p>以及传递给 <code>startActivity()</code> 的 Intent 中的标志</p><ul><li>FLAG_ACTIVITY_NEW_TASK</li><li>FLAG_ACTIVITY_CLEAR_TOP</li><li>FLAG_ACTIVITY_SINGLE_TOP</li></ul><p>管理 Activity 如何与任务关联或者如何存在于返回栈中。</p><h3 id="定义启动模式"><a href="#定义启动模式" class="headerlink" title="定义启动模式"></a>定义启动模式</h3><p><strong>使用清单文件</strong>：</p><p>在清单文件中声明 Activity 时，您可以使用 <code>&lt;activity&gt;</code> 元素的 launchMode 属性指定 Activity 应该如何与任务关联。</p><p>launchMode 属性的启动模式共有四种：</p><p><strong>“standard”</strong>（默认模式）每次启动 Activity 系统都会在任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</p><p><strong>“singleTop”</strong> 如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建 Activity 的新实例。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的 Activity 并不是 Activity 的现有实例）。</p><p><strong>“singleTask”</strong> 系统创建新任务并实例化位于新任务底部的 Activity。但是如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。一次只能存在 Activity 的一个实例。</p><p><strong>“singleInstance”</strong> 与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。</p><p><strong>使用 Intent 标志</strong>：</p><p>启动 Activity 时，您可以通过在传递给 startActivity() 的 Intent 中加入相应的标志，修改 Activity 与其任务的默认关联方式。可用于修改默认行为的标志包括：</p><p><strong>FLAG_ACTIVITY_NEW_TASK</strong> 在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 onNewIntent() 中收到新 Intent。这会产生与 “singleTask” launchMode 值相同的行为。</p><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong> 如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 onNewIntent() 的调用，而不是创建 Activity 的新实例。这会产生与 “singleTop” launchMode 值相同的行为。</p><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong> 如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 onNewIntent() 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。产生这种行为的 launchMode 属性没有值。</p><h3 id="处理关联"><a href="#处理关联" class="headerlink" title="处理关联"></a>处理关联</h3><p>“关联”指示 Activity 优先属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此关联。</p><p>可以使用 <code>&lt;activity&gt;</code> 元素的 taskAffinity 属性修改任何给定 Activity 的关联。</p><p>taskAffinity 属性取字符串值，该值必须不同于在 <code>&lt;manifest&gt;</code> 元素中声明的默认软件包名称，因为系统使用该名称标识应用的默认任务关联。</p><p>在两种情况下，关联会起作用：</p><ul><li>启动 Activity 的 Intent 包含 FLAG_ACTIVITY_NEW_TASK 标志。</li><li>Activity 将其 allowTaskReparenting 属性设置为 “true”。</li></ul><h3 id="清理返回栈"><a href="#清理返回栈" class="headerlink" title="清理返回栈"></a>清理返回栈</h3><p>如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。<br>当用户再次返回到任务时，仅恢复根 Activity。</p><p><strong>alwaysRetainTaskState</strong> 如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。</p><p><strong>clearTaskOnLaunch</strong> 如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。</p><p><strong>finishOnTaskLaunch</strong> 此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。</p><h1 id="第4章-手机平板要兼容"><a href="#第4章-手机平板要兼容" class="headerlink" title="第4章 手机平板要兼容"></a>第4章 手机平板要兼容</h1><p>Fragment 表示 Activity 中的行为或部分用户界面。Fragment 必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。</p><p><img src="https://img.wshunli.com/Android/第一行代码/2.fragments.png" alt="fragments"></p><h2 id="创建-Fragment"><a href="#创建-Fragment" class="headerlink" title="创建 Fragment"></a>创建 Fragment</h2><p>要想创建 Fragment，必须创建 Fragment 的子类（或已有其子类）。</p><center><img src="https://img.wshunli.com/Android/第一行代码/2.fragment_lifecycle.png" alt="fragment_lifecycle"></center><p>其他 Fragment 子类，DialogFragment、ListFragment、PreferenceFragment 。</p><h3 id="构造-Fragment-界面"><a href="#构造-Fragment-界面" class="headerlink" title="构造 Fragment 界面"></a>构造 Fragment 界面</h3><p>实现 onCreateView() 回调方法，Android 系统会在 Fragment 需要绘制其布局时调用该方法。</p><pre><code class="Java">public static class ExampleFragment extends Fragment {    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        return inflater.inflate(R.layout.example_fragment, container, false);    }}</code></pre><p>inflater 利用 XML 中定义的布局资源来拓展 Fragment 布局。</p><h3 id="向-Activity-添加-Fragment"><a href="#向-Activity-添加-Fragment" class="headerlink" title="向 Activity 添加 Fragment"></a>向 Activity 添加 Fragment</h3><p>可以通过两种方式向 Activity 布局添加 Fragment ：</p><p><strong>在 Activity 的布局文件内声明 Fragment</strong>：</p><pre><code class="XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleListFragment&quot;            android:id=&quot;@+id/list&quot;            android:layout_weight=&quot;1&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;    &lt;fragment android:name=&quot;com.example.news.ArticleReaderFragment&quot;            android:id=&quot;@+id/viewer&quot;            android:layout_weight=&quot;2&quot;            android:layout_width=&quot;0dp&quot;            android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>当系统创建此 Activity 布局时，会实例化在布局中指定的每个Fragment，并为每个Fragment调用 onCreateView() 方法，以检索每个Fragment的布局。系统会直接插入Fragment返回的 View 来替代 <code>&lt;fragment&gt;</code> 元素。</p><p><strong>或者通过编程方式将 Fragment 添加到某个现有 ViewGroup</strong>:</p><p>用 FragmentTransaction 添加、移除或替换 Fragment 。</p><pre><code class="Java">FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();// 使用 add() 方法添加一个 FragmentExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);fragmentTransaction.commit();</code></pre><p>添加没有 UI 的 Fragment ：</p><p>使用 add(Fragment, String) 方法在 Activity 添加 Fragment，可以使用 Fragment 为 Activity 提供后台行为，而不显示额外 UI。</p><h2 id="管理-Fragment"><a href="#管理-Fragment" class="headerlink" title="管理 Fragment"></a>管理 Fragment</h2><p>在 Activity 调用 getFragmentManager() 方法得到 FragmentManager 对象可以管理 Activity 中的 Fragment。</p><p>FragmentManager 执行的操作包括：</p><ul><li>findFragmentById()（对于在 Activity 布局中提供 UI 的 Fragment ）或 findFragmentByTag()（对于提供或不提供 UI 的 Fragment）获取 Activity 中存在的 Fragment。</li><li>popBackStack()（模拟用户发出的返回命令）将 Fragment 从返回栈中弹出。</li><li>addOnBackStackChangedListener() 注册一个侦听返回栈变化的侦听器。</li></ul><h2 id="执行-Fragment-事务"><a href="#执行-Fragment-事务" class="headerlink" title="执行 Fragment 事务"></a>执行 Fragment 事务</h2><p>从 FragmentManager 获取 FragmentTransaction 实例，使用 add()、remove() 和 replace() 等方法动态管理 Fragment。</p><pre><code class="Java">// Create new fragment and transactionFragment newFragment = new ExampleFragment();FragmentTransaction transaction = getFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,// and add the transaction to the back stacktransaction.replace(R.id.fragment_container, newFragment);transaction.addToBackStack(null);// Commit the transactiontransaction.commit();</code></pre><p>通过调用 addToBackStack() 可将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一 Fragment 。</p><h2 id="Fragment-与-Activity-通信"><a href="#Fragment-与-Activity-通信" class="headerlink" title="Fragment 与 Activity 通信"></a>Fragment 与 Activity 通信</h2><p>尽管 Fragment 是作为独立于 Activity 的对象实现，并且可在多个 Activity 内使用，但 Fragment 的特定实例会直接绑定到包含它的 Activity。</p><p>Fragment 可以通过 getActivity() 访问 Activity 实例，并轻松地执行在 Activity 布局中查找视图等任务。</p><pre><code class="Java">View listView = getActivity().findViewById(R.id.list);</code></pre><p>同样地，Activity 也可以使用 findFragmentById() 或 findFragmentByTag()，通过从 FragmentManager 获取对 Fragment 的引用来调用Fragment中的方法。例如：</p><pre><code class="Java">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</code></pre><h2 id="处理-Fragment-生命周期"><a href="#处理-Fragment-生命周期" class="headerlink" title="处理 Fragment 生命周期"></a>处理 Fragment 生命周期</h2><p>管理Fragment生命周期与管理 Activity 生命周期很相似。和 Activity 一样，Fragment也以三种状态存在：</p><p><strong>Resumed</strong> Fragment在运行中的 Activity 中可见。<br><strong>Paused</strong> 另一个 Activity 位于前台并具有焦点，但此Fragment所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。<br><strong>Stopped</strong> Fragment不可见。宿主 Activity 已停止，或Fragment已从 Activity 中移除，但已添加到返回栈。 停止Fragment仍然处于活动状态（系统会保留所有状态和成员信息）。不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。</p><p>Activity 生命周期与 Fragment 生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。</p><p>默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈；<br>不过，仅当您在移除 Fragment 的事务执行期间通过调用 addToBackStack() 显式请求保存实例时，系统才会将 Fragment 放入由宿主 Activity 管理的返回栈。</p><h3 id="与-Activity-生命周期协调一致"><a href="#与-Activity-生命周期协调一致" class="headerlink" title="与 Activity 生命周期协调一致"></a>与 Activity 生命周期协调一致</h3><p>Fragment所在的 Activity 的生命周期会直接影响Fragment的生命周期，其表现为，Activity 的每次生命周期回调都会引发每个Fragment的类似回调。<br>例如，当 Activity 收到 onPause() 时，Activity 中的每个Fragment也会收到 onPause()。</p><p>不过，Fragment 还有几个额外的生命周期回调:</p><ul><li>onAttach() 在片段已与 Activity 关联时调用（Activity 传递到此方法内）。</li><li>onCreateView() 调用它可创建与片段关联的视图层次结构。</li><li>onActivityCreated() 在 Activity 的 onCreate() 方法已返回时调用。</li><li>onDestroyView() 在移除与片段关联的视图层次结构时调用。</li><li>onDetach() 在取消片段与 Activity 的关联时调用。</li></ul><center><img src="https://img.wshunli.com/Android/第一行代码/2.activity_fragment_lifecycle.png" alt="activity_fragment_lifecycle"></center><p>图示说明了受其宿主 Activity 影响的片段生命周期流。</p><blockquote><p>参考资料<br>1、Activity | Android Developers<br><a href="https://developer.android.com/guide/components/activities.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/activities.html</a><br>2、Activity/Service 生命周期 · 笔试面试知识整理<br><a href="https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html" rel="external nofollow noopener noreferrer" target="_blank">https://hit-alibaba.github.io/interview/Android/basic/Activity-Service-Lifecircle.html</a><br>3、Intent 和 Intent 过滤器<br><a href="https://developer.android.com/guide/components/intents-filters.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/components/intents-filters.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 应用组件之 Activity&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《第一行代码》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/df51fd76.html"/>
    <id>http://www.wshunli.com/posts/df51fd76.html</id>
    <published>2017-12-06T03:33:44.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<p>《第一行代码》读书笔记 – 平台架构</p><a id="more"></a><p>我最开始学习 Android 是在 2014 年下半年，看的是《疯狂Android讲义》。</p><p>在 2015 年参加 ESRI 中国组织的 GIS 开发大赛，也是主要在暑假学习了不少 Android 入门知识。</p><p>后面在较长一段时间，感觉停滞在 Android 入门的水平不前。也有尝试在项目中使用一些优秀的框架或者类库，但是感觉自身的水平并没有多大的提高。</p><p>所以有意在前面学习计算机基础、Java 语言基础，后面打算深入之后学习下数据结构及算法。也为明年找工作做准备。</p><p>其实这本书 《第一行代码》 在考研结束以后已经看过一遍了，这次再复习一遍，毕竟有一段时间没有具体做 Android 开发了，再者希望能记忆一些常用的知识点。</p><h1 id="第1章-开启启程"><a href="#第1章-开启启程" class="headerlink" title="第1章 开启启程"></a>第1章 开启启程</h1><h2 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h2><p>总的来说，Android的系统体系结构分为四层，自顶向下分别是：</p><ul><li>应用程序(Applications)</li><li>应用程序框架(Application Frameworks)</li><li>系统运行库与 Android 运行环境(Libraris &amp; Android Runtime)</li><li>Linux 核心层</li></ul><p><img src="https://img.wshunli.com/Android/第一行代码/1.Android系统架构.png" alt="1.Android系统架构"></p><h3 id="Linux核心层"><a href="#Linux核心层" class="headerlink" title="Linux核心层"></a>Linux核心层</h3><p><strong>Linux 内核</strong>(Linux Kernel)<br>Android 平台的基础是 Linux 内核，Linux 内核直接和硬件打交道。硬件驱动、进程管理、内存管理、网络管理的功能在这里实现。</p><p><strong>硬件抽象层</strong>(Hardware Abstraction Layer)<br>硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。<br>HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。</p><h3 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h3><p><strong>Android 运行环境</strong>(Android Runtime)<br>每个应用都在其自己的进程中运行，有其自己的 Android Runtime (ART) 实例（Android 5.0 之前是 Dalvik）。<br>并且 Android 还包含一套核心运行时库，可提供 Java API 框架使用的 Java 编程语言大部分功能。</p><p><strong>原生C/C++ 库</strong>(Native C/C++ Libraries)<br>许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。<br>Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。</p><h3 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h3><p><strong>Java API 框架</strong>(Java API Framework)</p><p>提供构建应用的各种 API 。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器。</li><li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件。</li><li>通知管理器，可让所有应用在状态栏中显示自定义提醒。</li><li>Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈。</li><li>内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据。</li></ul><p>开发者可以完全访问 Android 系统应用使用的框架 API。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><strong>系统应用</strong>(System Apps)</p><p>所有安装在手机上的应用程序都属于应用层，包括系统自带的软件和自己开发的软件。</p><h2 id="搭建-Android-开发环境"><a href="#搭建-Android-开发环境" class="headerlink" title="搭建 Android 开发环境"></a>搭建 Android 开发环境</h2><p>前面已经写过了，不再重复。<br>《ArcGIS Runtime SDK for Android学习笔记》-1、Android开发环境搭建 | CirGIS<br><a href="https://www.wshunli.com/posts/f6977dbb.html">https://www.wshunli.com/posts/f6977dbb.html</a></p><blockquote><p>参考资料<br>1、平台架构 | Android Developers<br><a href="https://developer.android.com/guide/platform/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://developer.android.com/guide/platform/index.html</a><br>2、Android系统架构简介 - 简书<br><a href="http://www.jianshu.com/p/69f0d25c727a" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/69f0d25c727a</a><br>3、Android系统架构介绍 - LCore的专栏 - CSDN博客<br><a href="http://blog.csdn.net/lcore/article/details/20993367" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/lcore/article/details/20993367</a><br>4、android系统体系结构 - CSDN博客<br><a href="http://blog.csdn.net/spy19881201/article/details/5775484" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/spy19881201/article/details/5775484</a><br>5、Android系统开篇 - Gityuan博客 | 袁辉辉博客<br><a href="http://gityuan.com/android/" rel="external nofollow noopener noreferrer" target="_blank">http://gityuan.com/android/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《第一行代码》读书笔记 – 平台架构&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://www.wshunli.com/tags/Android/"/>
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《第一行代码》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（九）</title>
    <link href="http://www.wshunli.com/posts/8c5a6523.html"/>
    <id>http://www.wshunli.com/posts/8c5a6523.html</id>
    <published>2017-12-05T09:51:24.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— Java I/O 系统。</p><a id="more"></a><p>第18章 <strong>Java I/O 系统</strong></p><h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h1><p>File 类不仅仅可以代表一个特定文件的名称，还可以代表一个目录下的一组文件的名称。</p><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><blockquote><p>参考资料<br>1、Java 编程思想（六）Java I/O - Invoker’s Tower - CSDN博客<br><a href="http://blog.csdn.net/kingcat666/article/details/78027078" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/kingcat666/article/details/78027078</a><br>2、java基础学习总结——流 - 孤傲苍狼 - 博客园<br><a href="http://www.cnblogs.com/xdp-gacl/p/3634409.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/xdp-gacl/p/3634409.html</a><br>3、《Java编程思想》学习笔记11——Java I/O - CSDN博客<br><a href="http://blog.csdn.net/chjttony/article/details/6966246" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/chjttony/article/details/6966246</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— Java I/O 系统。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（八）</title>
    <link href="http://www.wshunli.com/posts/f697447c.html"/>
    <id>http://www.wshunli.com/posts/f697447c.html</id>
    <published>2017-12-05T09:46:52.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 容器深入研究。</p><a id="more"></a><p>第17章 <strong>容器深入研究</strong></p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java容器1.png" alt="Java容器"></p><p>先占坑。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 容器深入研究。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（七）</title>
    <link href="http://www.wshunli.com/posts/1fc6c3f.html"/>
    <id>http://www.wshunli.com/posts/1fc6c3f.html</id>
    <published>2017-12-04T13:54:10.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类型信息及泛型。</p><a id="more"></a><h1 id="第14章-类型信息"><a href="#第14章-类型信息" class="headerlink" title="第14章 类型信息"></a>第14章 类型信息</h1><p>RTTI (Run-Time Type Identification, 运行时类型识别) 是 Java 中非常有用的机制。</p><pre><code class="Java">abstract class Shape {  void draw() { System.out.println(this + &quot;.draw()&quot;); }  abstract public String toString();}class Circle extends Shape {  public String toString() { return &quot;Circle&quot;; }}class Square extends Shape {  public String toString() { return &quot;Square&quot;; }}public class Shapes {  public static void main(String[] args) {    List&lt;Shape&gt; shapeList = Arrays.asList(      new Circle(), new Square()    );    for(Shape shape : shapeList) shape.draw();  }}/* Output:Circle.draw()Square.draw()*/</code></pre><p>在Java运行时，RTTI 维护类的相关信息，识别一个对象的类型。</p><p>1.Class 对象</p><p>类是程序的一部分，每个类都有一个Class对象。</p><pre><code class="Java">interface HasBatteries {}interface Waterproof {}interface Shoots {}class Toy {  // Comment out the following default constructor  // to see NoSuchMethodError from (*1*)  Toy() {}  Toy(int i) {}}class FancyToy extends Toyimplements HasBatteries, Waterproof, Shoots {  FancyToy() { super(1); }}public class ToyTest {  static void printInfo(Class cc) {    print(&quot;Class name: &quot; + cc.getName() + // 全限定的类型      &quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;); // Class 对象是否表示某接口    print(&quot;Simple name: &quot; + cc.getSimpleName()); // 不含包名的类名    print(&quot;Canonical name : &quot; + cc.getCanonicalName()); // 含包名的类名  }  public static void main(String[] args) {    Class c = null;    try {      c = Class.forName(&quot;typeinfo.toys.FancyToy&quot;); // 获取 Class 对象的引用    } catch(ClassNotFoundException e) {      print(&quot;Can&#39;t find FancyToy&quot;);      System.exit(1);    }    printInfo(c);    for(Class face : c.getInterfaces()) // 获取 Class 对象中包含的接口      printInfo(face);    Class up = c.getSuperclass(); // 获取 Class 对象的直接基类    Object obj = null;    try {      // Requires default constructor:      obj = up.newInstance(); // 实现虚拟构造器    } catch(InstantiationException e) {      print(&quot;Cannot instantiate&quot;);      System.exit(1);    } catch(IllegalAccessException e) {      print(&quot;Cannot access&quot;);      System.exit(1);    }    printInfo(obj.getClass());  }} /* Output:Class name: typeinfo.toys.FancyToy is interface? [false]Simple name: FancyToyCanonical name : typeinfo.toys.FancyToyClass name: typeinfo.toys.HasBatteries is interface? [true]Simple name: HasBatteriesCanonical name : typeinfo.toys.HasBatteriesClass name: typeinfo.toys.Waterproof is interface? [true]Simple name: WaterproofCanonical name : typeinfo.toys.WaterproofClass name: typeinfo.toys.Shoots is interface? [true]Simple name: ShootsCanonical name : typeinfo.toys.ShootsClass name: typeinfo.toys.Toy is interface? [false]Simple name: ToyCanonical name : typeinfo.toys.Toy*/</code></pre><p>2.类加载器是通过判断这个类包含的Class对象是否已经加载来判断它是否已经加载过这个类。为使用类而做的准备工作实际上包括三个步骤：</p><p>1 加载。这个由类加载器去完成。查找相关的字节码，并从这些字节码中创建一个Class对象。<br>2 链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且必须的话将解析这个类创建的对其他类的引用。<br>3 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了静态方法或者静态域进行首次引用时才执行。</p><pre><code class="Java">class Initable {  static final int staticFinal = 47;  static final int staticFinal2 =    ClassInitialization.rand.nextInt(1000);  static {    System.out.println(&quot;Initializing Initable&quot;);  }}class Initable2 {  static int staticNonFinal = 147;  static {    System.out.println(&quot;Initializing Initable2&quot;);  }}class Initable3 {  static int staticNonFinal = 74;  static {    System.out.println(&quot;Initializing Initable3&quot;);  }}public class ClassInitialization {  public static Random rand = new Random(47);  public static void main(String[] args) throws Exception {    Class initable = Initable.class;    System.out.println(&quot;After creating Initable ref&quot;);    // Does not trigger initialization:    System.out.println(Initable.staticFinal);    // Does trigger initialization:    System.out.println(Initable.staticFinal2);    // Does trigger initialization:    System.out.println(Initable2.staticNonFinal);    Class initable3 = Class.forName(&quot;Initable3&quot;);    System.out.println(&quot;After creating Initable3 ref&quot;);    System.out.println(Initable3.staticNonFinal);  }} /* Output:After creating Initable ref47Initializing Initable258Initializing Initable2147Initializing Initable3After creating Initable3 ref74*/</code></pre><p>3.instanceof</p><p>返回一个布尔值，判断对象是不是某个特定类型的实例。</p><pre><code class="Java">x instanceof Boy</code></pre><p>4.反射：运行时的类信息</p><p>反射机制是在运行状态中，<br>对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取的信息以及动态调用对象的方法的功能称为反射。</p><p>5.动态代理</p><p>代理是一本基本的设计模式；代理通常充当着中间人的角色。</p><h1 id="第15章-泛型"><a href="#第15章-泛型" class="headerlink" title="第15章 泛型"></a>第15章 泛型</h1><p>Java SE5 泛型实现了参数化类型的概念，使代码可以应用于多种类型。</p><p>泛型的出现，最引人注目的原因是为了创造容器类</p><p>一个只能持有单个对象的类：</p><pre><code class="Java">public class Holder {  private Automobile a;  public Holder(Automobile a) { this.a = a; }  Automobile get() { return a; }}</code></pre><p>显然，Holder 类的重用性很差，只能持有 Automobile 类对象。</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><pre><code class="Java">public class Holder3&lt;T&gt; {  private T a;  public Holder3(T a) { this.a = a; }  public void set(T a) { this.a = a; }  public T get() { return a; }  public static void main(String[] args) {    Holder3&lt;Automobile&gt; h3 =      new Holder3&lt;Automobile&gt;(new Automobile());    Automobile a = h3.get(); // No cast needed    // h3.set(&quot;Not an Automobile&quot;); // Error    // h3.set(1); // Error  }}</code></pre><p>告诉编译器使用什么类型，然后编译器帮你处理一切细节。</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型也可以应用于接口；例如生成器，这是一种专门负责创建对象的类。</p><p>生成器接口定义如下：</p><pre><code class="Java">public interface Generator&lt;T&gt; { T next(); }</code></pre><p>实现生成器接口</p><pre><code class="Java">public class CoffeeGeneratorimplements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt; {  private Class[] types = { Latte.class, Mocha.class,    Cappuccino.class, Americano.class, Breve.class, };  private static Random rand = new Random(47);  public CoffeeGenerator() {}  // For iteration:  private int size = 0;  public CoffeeGenerator(int sz) { size = sz; }  public Coffee next() {    try {      return (Coffee)        types[rand.nextInt(types.length)].newInstance();      // Report programmer errors at run time:    } catch(Exception e) {      throw new RuntimeException(e);    }  }  class CoffeeIterator implements Iterator&lt;Coffee&gt; {    int count = size;    public boolean hasNext() { return count &gt; 0; }    public Coffee next() {      count--;      return CoffeeGenerator.this.next();    }    public void remove() { // Not implemented      throw new UnsupportedOperationException();    }  };  public Iterator&lt;Coffee&gt; iterator() {    return new CoffeeIterator();  }  public static void main(String[] args) {    CoffeeGenerator gen = new CoffeeGenerator();    for(int i = 0; i &lt; 5; i++)      System.out.println(gen.next());    for(Coffee c : new CoffeeGenerator(5))      System.out.println(c);  }} /* Output:Americano 0Latte 1Americano 2Mocha 3Mocha 4Breve 5Americano 6Latte 7Cappuccino 8Cappuccino 9*/</code></pre><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一个基本指导原则：无论何时，只要你能做到，你就应该使用泛型方法。</p><pre><code class="Java">public class GenericMethods {  public &lt;T&gt; void f(T x) {    System.out.println(x.getClass().getName());  }  public static void main(String[] args) {    GenericMethods gm = new GenericMethods();    gm.f(&quot;&quot;);    gm.f(1);    gm.f(1.0);    gm.f(1.0F);    gm.f(&#39;c&#39;);    gm.f(gm);  }} /* Output:java.lang.Stringjava.lang.Integerjava.lang.Doublejava.lang.Floatjava.lang.CharacterGenericMethods*/</code></pre><p>泛型方法与可变参数列表能够很好地共存:</p><pre><code class="Java">public class GenericVarargs {  public static &lt;T&gt; List&lt;T&gt; makeList(T... args) {    List&lt;T&gt; result = new ArrayList&lt;T&gt;();    for(T item : args)      result.add(item);    return result;  }  public static void main(String[] args) {    List&lt;String&gt; ls = makeList(&quot;A&quot;);    System.out.println(ls);    ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);    System.out.println(ls);    ls = makeList(&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;));    System.out.println(ls);  }} /* Output:[A][A, B, C][, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]*/</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十四章 01 类型信息<br><a href="https://zhuanlan.zhihu.com/p/26081790" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/26081790</a><br>2、《java编程思想》14章类型信息 读书笔记 - CSDN博客<br><a href="http://blog.csdn.net/L2HL2H/article/details/51120480" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/L2HL2H/article/details/51120480</a><br>3、《Java编程思想》读书笔记 第十四章 02 反射<br><a href="https://zhuanlan.zhihu.com/p/26190300" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/26190300</a><br>4、Java泛型详解 | ZiWenXie<br><a href="https://www.ziwenxie.site/2017/03/01/java-generic/" rel="external nofollow noopener noreferrer" target="_blank">https://www.ziwenxie.site/2017/03/01/java-generic/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类型信息及泛型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（六）</title>
    <link href="http://www.wshunli.com/posts/d3fc1ba0.html"/>
    <id>http://www.wshunli.com/posts/d3fc1ba0.html</id>
    <published>2017-12-04T12:22:17.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。</p><a id="more"></a><h1 id="第13章-字符串"><a href="#第13章-字符串" class="headerlink" title="第13章 字符串"></a>第13章 字符串</h1><p>1.不可变的 String<br>String 对象是不可变的，每当修改 String 对象的时候，实际上都是创建了一个新的 String 对象，最初的 String 对象丝毫未动。</p><p>2.重载“+”与 StringBuilder<br>String 对象的不可变性带来一定的效率问题，例如为 String 对象重载的“+”操作符。（用于String的“+”、“+=”是 Java 中仅有的两个重载过的操作符，而 Java 并不允许程序员重载任何操作符）。</p><pre><code class="Java">public class WhitherStringBuilder {  public String implicit(String[] fields) {    String result = &quot;&quot;;    for(int i = 0; i &lt; fields.length; i++)      result += fields[i];    return result;  }  public String explicit(String[] fields) {    StringBuilder result = new StringBuilder();    for(int i = 0; i &lt; fields.length; i++)      result.append(fields[i]);    return result.toString();  }}</code></pre><p>StringBuilder 提供了丰富而全面的方法，包括 append(),toString(),delete(),insert(),replace(),substring() 甚至 reverse()。</p><p>3.String 上的操作</p><p><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">Java 字符串常用操作（String类）</a></p><p>String 是固定不变的，而 StringBuffer 和 StringBuilder 可以改变它们的值。<br>二者唯一的区别是 StringBuilder 是非同步的而 StringBuffer 是同步的。</p><p>4.格式化输出</p><p>Java SE5 推出了类似 C语言中 printf() 风格的格式化输出这一功能。</p><pre><code class="Java">public class SimpleFormat {  public static void main(String[] args) {    int x = 5;    double y = 5.332542;    // The old way:    System.out.println(&quot;Row 1: [&quot; + x + &quot; &quot; + y + &quot;]&quot;);    // The new way:    System.out.format(&quot;Row 1: [%d %f]\n&quot;, x, y);    // or    System.out.printf(&quot;Row 1: [%d %f]\n&quot;, x, y);  }}/* Output:Row 1: [5 5.332542]Row 1: [5 5.332542]Row 1: [5 5.332542]*/</code></pre><p>format() 和 printf() 是等价的。</p><p><strong>Formatter</strong> 看一看成一个翻译器，劲格式化字符串与数据翻译成需要的结果。</p><pre><code class="Java">private Formatter f = new Formatter(System.out);f.format(&quot;%s The Turtle is at (%d,%d)\n&quot;, name, x, y);</code></pre><p>5.正则表达式</p><p>6.扫描输入</p><p>Java SE5 新增了 Scanner 类接受任意类型的输入对象。</p><h1 id="第16章-数组"><a href="#第16章-数组" class="headerlink" title="第16章 数组"></a>第16章 数组</h1><h1 id="第19章-枚举类型"><a href="#第19章-枚举类型" class="headerlink" title="第19章 枚举类型"></a>第19章 枚举类型</h1><blockquote><p>参考资料<br>1、读书笔记 JAVA编程思想 第13章 字符串 - CSDN博客<br><a href="http://blog.csdn.net/imaginedranges/article/details/73335553" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/imaginedranges/article/details/73335553</a><br>2、Java 字符串常用操作（String类） - 薛遗山 - 博客园<br><a href="http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/freeabyss/archive/2013/05/15/3187057.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 字符串、数组及枚举类型。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（五）</title>
    <link href="http://www.wshunli.com/posts/b6f25079.html"/>
    <id>http://www.wshunli.com/posts/b6f25079.html</id>
    <published>2017-12-04T09:04:23.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 异常处理。</p><a id="more"></a><p>第12章 <strong>通过异常处理错误</strong></p><p>Java的基本理念是“结构不佳的代码不能运行”。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java异常.png" alt="Java异常"></p><p>Java 中的异常处理都是围绕着 try-catch-finally, throw, throws 这几个展开的，也就是：</p><p>try-catch-finally：捕获异常并处理。<br>throw：遇到错误的时候抛出一个异常。<br>throws：声明一个方法可能抛出的异常（所有可能抛出的异常都需要声明）。</p><pre><code class="Java">class ThreeException extends Exception {}public class FinallyWorks {  static int count = 0;  public static void main(String[] args) {    while(true) {      try {        // Post-increment is zero first time:        if(count++ == 0) throw new ThreeException();        System.out.println(&quot;No exception&quot;);      } catch(ThreeException e) {        System.out.println(&quot;ThreeException&quot;);      } finally {        System.out.println(&quot;In finally clause&quot;);        if(count == 2) break; // out of &quot;while&quot;      }    }  }}/* Output:ThreeExceptionIn finally clauseNo exceptionIn finally clause*/</code></pre><p>throw 与 throws 的差别</p><p>throw 是语句抛出一个 Throwable 类型的异常，总是出现在函数体中；程序会在 throw 语句之后立即终止。</p><p>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用 throws 子句来声明抛出异常；<br>throws 语句用在方法定义时声明该方法要抛出的异常类型，多个异常可使用逗号分割。</p><pre><code class="Java">f() throws Exception1, Exception2, Exception3, ... {    ...}</code></pre><p>例如：</p><pre><code class="Java">import java.lang.Exception;public class TestException {    public int div(int x, int y) throws MyException {        if (y == 0) {            throw new MyException(&quot;除数不能为0&quot;);        }        return (int)(x/y);    }    public static void main(String[] args) {        int x = 1;        int y = 0;        try {            int result = div(x, y);        } catch (MyException e) {            System.out.println(e.getMessage());        }    }}//自定义异常类class MyException extends Exception {    String message;    public MyException(String ErrorMessage) {        message = ErrorMessage;    }    public String getMessage() {        return message;    }}</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十二章 通过异常处理<br><a href="https://zhuanlan.zhihu.com/p/25935822" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25935822</a><br>2、Java编程思想第四版读书笔记——第十二章 通过异常处理错误 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/51780879" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/51780879</a><br>3、Java 异常处理<br><a href="https://zhuanlan.zhihu.com/p/24043941" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/24043941</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 异常处理。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（四）</title>
    <link href="http://www.wshunli.com/posts/d96c953e.html"/>
    <id>http://www.wshunli.com/posts/d96c953e.html</id>
    <published>2017-12-03T11:07:09.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 集合。</p><a id="more"></a><p>这部分只是还是挺重要的，面试题里面有好多。</p><p>第11章 <strong>持有对象</strong></p><p>Java 容器类提供了完善的方法保存对象，并经其划分为 <strong>Collection</strong> 和 <strong>Map</strong> 两个不同的概念。</p><p><img src="https://img.wshunli.com/Java/Java编程思想/Java容器.png" alt="Java容器"></p><p><strong>Collection</strong> 一个独立的元素序列；<strong>Map</strong> 一组成对的“键值对”对象。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>1.<strong>Collection</strong> 一个独立的元素序列，这些元素服从一条或者多条规则。</p><p>List 必须按照插入的顺序保存元素，而 Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序。</p><pre><code class="java">public class SimpleCollection {  public static void main(String[] args) {    Collection&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;();    for(int i = 0; i &lt; 10; i++)      c.add(i); // Autoboxing    for(Integer i : c)      System.out.print(i + &quot;, &quot;);  }}/* Output:0, 1, 2, 3, 4, 5, 6, 7, 8, 9,*/</code></pre><p>2.Arrays 和 Collections 类有很多实用的方法，可以在 Collection 中添加一组元素。</p><pre><code class="Java">public class AddingGroups {  public static void main(String[] args) {    Collection&lt;Integer&gt; collection =      new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5));    Integer[] moreInts = { 6, 7, 8, 9, 10 };    collection.addAll(Arrays.asList(moreInts));    // Runs significantly faster, but you can&#39;t    // construct a Collection this way:    Collections.addAll(collection, 11, 12, 13, 14, 15);    Collections.addAll(collection, moreInts);    // Produces a list &quot;backed by&quot; an array:    List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20);    list.set(1, 99); // OK -- modify an element    // list.add(21); // Runtime error because the                     // underlying array cannot be resized.  }}</code></pre><p>Arrays.asList() 接受一个数组或者可变参数列表，并将之转换为 List 对象。<br>需要注意的是，此种方式获得的 List 对象，由于底层实现仍然是数组，在添加或者删除元素时会出现 UnsupportedOperationException 异常。</p><p>Collections.addAll() 接收一个 Collection 对象、一个数组或者是可变参数列表作为参数，得到新的 Collection 对象。</p><p>3.容器的打印</p><pre><code class="Java">public class PrintingContainers {  static Collection fill(Collection&lt;String&gt; collection) {    collection.add(&quot;rat&quot;);    collection.add(&quot;cat&quot;);    collection.add(&quot;dog&quot;);    collection.add(&quot;dog&quot;);    return collection;  }  static Map fill(Map&lt;String,String&gt; map) {    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);    map.put(&quot;cat&quot;, &quot;Rags&quot;);    map.put(&quot;dog&quot;, &quot;Bosco&quot;);    map.put(&quot;dog&quot;, &quot;Spot&quot;);    return map;  }      public static void main(String[] args) {    print(fill(new ArrayList&lt;String&gt;()));    print(fill(new LinkedList&lt;String&gt;()));    print(fill(new HashSet&lt;String&gt;()));    print(fill(new TreeSet&lt;String&gt;()));    print(fill(new LinkedHashSet&lt;String&gt;()));    print(fill(new HashMap&lt;String,String&gt;()));    print(fill(new TreeMap&lt;String,String&gt;()));    print(fill(new LinkedHashMap&lt;String,String&gt;()));  }}/* Output:[rat, cat, dog, dog][rat, cat, dog, dog][dog, cat, rat][cat, dog, rat][rat, cat, dog]{dog=Spot, cat=Rags, rat=Fuzzy}{cat=Rags, dog=Spot, rat=Fuzzy}{rat=Fuzzy, cat=Rags, dog=Spot}*/</code></pre><p>Collection 打印出来的内容用 [ ] 括住，Map 打印出来的内容用 { } 括住。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List 接口在 Collection 基础上添加了大量的方法。可分为 ArrayList 和 LinkedList 两种。</p><p><strong>ArrayList</strong> 数据结构采用的是线性表，优势是访问和查询十分方便，但添加和删除的时候效率很低。<br><strong>LinkedList</strong> 数据结构采用的是链表，优势是删除和添加的效率很高，但随机访问元素时效率较 ArrayList 类低。</p><p>List 重要价值在于提供了一种可修改的序列。</p><p>contains(Object o) 确定某个对象是否在列表中。<br>remove(int index) 移除指定位置上的元素。<br>indexOf() 返回列表中首次出现指定元素的索引，如果不包含该元素，返回-1。</p><p>LikedList 增加了可以使其用作栈、队列或双端队列的方法。</p><pre><code class="Java">public class Stack&lt;T&gt; {    private LinkedList&lt;T&gt; storage = new LinkedList&lt;&gt;();    public void push(T v){        storage.addFirst(v);    }    public T peek(){        return storage.getFirst();    }    public T pop(){        return storage.removeFirst();    }    public boolean empty(){        return storage.isEmpty();    }    public String toString(){        return storage.toString();    }}</code></pre><p>LikedList 具有直接实现栈（LIFO）的所有功能的方法。</p><p>addFirst(E e)/addLast(E e)：将元素添加到列表的开头/结尾<br>getFirst()/element()：返回列表的第一个元素<br>peek()/peekFirst()：获取但不移除列表的第一个元素<br>offer(E e)/offerLast(E e)：将元素插入到列表末尾</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列是典型的先进先出（FIFO）的容器。</p><pre><code class="Java">public class QueueDemo {    public static void printQ(Queue queue) {  while(queue.peek() != null)      System.out.print(queue.remove() + &quot; &quot;);  System.out.println();    }    public static void main(String[] args) {  Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();  Random random = new Random(47);  for(int i = 0; i &lt; 10; i++)      queue.offer(random.nextInt(i+10));  printQ(queue);  Queue&lt;Character&gt; qCharacters = new LinkedList&lt;Character&gt;();  for(char c : &quot;Brontosaurus&quot;.toCharArray())      qCharacters.offer(c);  printQ(qCharacters);    }}/* Output: 8 1 1 1 5 14 3 1 0 1 B r o n t o s a u r u s*/</code></pre><p>LinkedList 提供了方法以支持队列的行为，并且它实现了 Queue 接口，<br>因此 LinkedList 可以用作 Queue 的一种实现，也可以将 LinkedList 向上转型为 Queue 。</p><p><strong>PriorityQueue</strong> 优先级队列声明下一个弹出的元素是最需要的元素(具有最高的优先级)，可以确保当调用 peek()、poll() 和 remove() 方法时，获取的元素将是队列中优先级最高的元素。</p><pre><code class="java">PriorityQueue priorityQueue = new PriorityQueue&lt;Integer&gt;(  inis.size(),Collections.reverseOrder());</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 具有与 Collection 完全一样的接口，实际上就是 Collection ，只是行为不同。</p><p><strong>HashSet</strong> 数据结构采用的是散列表，主要是设计用来做高性能集运算的，例如对两个集合求交集、并集、差集等。<br>集合中包含一组不重复出现且无特性顺序的元素，其值是不可重复与无序的。</p><p>LinkedHashSet 的核心概念相对于 HashSet 来说就是一个可以保持顺序的Set集合。</p><p><strong>TreeSet</strong> 数据结构使用的是红黑树，性能上低于HashSet，用于排序。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map：一组成对的“键值对”对象，允许使用键来查找值；<br>映射表允许我们使用另一个对象来查找某个对象，它被称为“关联数组”，因为它将某些对象与另外一些对象关联在了一起，或者被称为“字典”</p><pre><code class="Java">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</code></pre><p>get(Object o)：返回指定键所映射的值，如果不包含该键的映射关系，返回 null 。<br>put(K key, V value)：将指定的值与此映射中的指定键关联，如果已经存在映射关系，更新值。<br>hashCode()：返回此映射的哈希码值。</p><h2 id="Map-的三种实现"><a href="#Map-的三种实现" class="headerlink" title="Map 的三种实现"></a>Map 的三种实现</h2><p>HashMap：基于“拉链法”实现的散列表，一般用于单线程中，不是线程安全的。<br>HashTable：基于“拉链法”实现的散列表，一般用于多线程中，是线程安全的。<br>TreeMap：有序的散列表，通过红黑树实现的，一般用于单线程中存储有序的映射。</p><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>迭代器，用于遍历容器，JDK源码如下：</p><pre><code class="Java">package java.util;import java.util.function.Consumer;public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}</code></pre><p>Java 的 Iterator 只能单向移动：</p><pre><code class="Java">public class SimpleIteration {  public static void main(String[] args) {    List&lt;Pet&gt; pets = Pets.arrayList(12);    Iterator&lt;Pet&gt; it = pets.iterator();    while(it.hasNext()) {      Pet p = it.next();      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    }    System.out.println();    // A simpler approach, when possible:    for(Pet p : pets)      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    System.out.println();        // An Iterator can also remove elements:    it = pets.iterator();    for(int i = 0; i &lt; 6; i++) {      it.next();      it.remove();    }    System.out.println(pets);  }}/* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]*/</code></pre><p>Iterator() 要求容器返回一个Iterator。Iterator 准备好返回序列的第一个元素。<br>next() 获得序列中的下一个元素。<br>hasNext() 检查序列中是否还有元素。<br>remove() 将迭代器新近返回的元素删除。</p><h2 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h2><p>ListIterator 是 Iterator 的一个子类，只能用于各种List的访问。<br>ListIterator 可以双向移动，可以产生当前位置的前一个和后一个元素的索引，并且可以使用 set() 方法，将最近访问过的元素进行替换。<br>此外，还可以通过 listIterator(int index) 的方法，获得一个一开始就指向 index 位置的 ListIterator。</p><h1 id="Foreach-与迭代器"><a href="#Foreach-与迭代器" class="headerlink" title="Foreach 与迭代器"></a>Foreach 与迭代器</h1><p>foreach 语法主要用于数组，同样可以用于 Collection 对象。</p><pre><code class="Java">public class ForEachCollections {  public static void main(String[] args) {    Collection&lt;String&gt; cs = new LinkedList&lt;String&gt;();    Collections.addAll(cs,      &quot;Take the long way home&quot;.split(&quot; &quot;));    for(String s : cs)      System.out.print(&quot;&#39;&quot; + s + &quot;&#39; &quot;);  }}/* Output:&#39;Take&#39; &#39;the&#39; &#39;long&#39; &#39;way&#39; &#39;home&#39;*/</code></pre><p>因为 java SE5 引入了 Iterable 接口，该接口包含产生 Iterator 的 iterator 方法，<br>并且 Iterable 接口被 foreach 用来造序列中移动。</p><blockquote><p>参考资料<br>1、Java 容器知识整理 - FullStackDeveloper - SegmentFault<br><a href="https://segmentfault.com/a/1190000002903035" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000002903035</a><br>2、Java编程思想读书笔记——持有对象 - CSDN博客<br><a href="http://blog.csdn.net/baidu_21088863/article/details/78175347" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/baidu_21088863/article/details/78175347</a><br>3、Java编程思想第四版读书笔记——第十一章 持有对象 - CSDN博客<br><a href="http://blog.csdn.net/severusyue/article/details/49491441" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/severusyue/article/details/49491441</a><br>4、深入Java源码解析容器类List、Set、Map - 简书<br><a href="http://www.jianshu.com/p/047e33fdefd2" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/047e33fdefd2</a><br>5、《Java编程思想》读书笔记 第十一章 持有对象 02 Map<br><a href="https://zhuanlan.zhihu.com/p/25816448" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25816448</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 集合。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入全景图片</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-panoview.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-panoview.html</id>
    <published>2017-11-30T09:14:59.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<p>一款基于 Three.js 全景显示的 Hexo 插件。</p><a id="more"></a><h1 id="Threejs-介绍"><a href="#Threejs-介绍" class="headerlink" title="Threejs 介绍"></a>Threejs 介绍</h1><p><a href="https://threejs.org/" rel="external nofollow noopener noreferrer" target="_blank">three.js</a> The aim of the project is to create an easy to use, lightweight, 3D library. The library provides <code>&lt;canvas&gt;</code>, <code>&lt;svg&gt;</code>, CSS3D and WebGL renderers.</p><div id="panoview343" style="margin:0 auto"></div><script src="https://unpkg.com/three@0.88.0/build/three.min.js"></script><script>function init(){var e,n;(e=document.getElementById("panoview343")).style.width;(camera=new THREE.PerspectiveCamera(75,2,1,1e3)).target=new THREE.Vector3(0,0,0),scene=new THREE.Scene;var t=new THREE.SphereBufferGeometry(500,60,40);t.scale(-1,1,1);var o=new THREE.MeshBasicMaterial({map:(new THREE.TextureLoader).load("https://img.wshunli.com/pano/pano2.jpg")});n=new THREE.Mesh(t,o),scene.add(n),(renderer=new THREE.WebGLRenderer).setPixelRatio(window.devicePixelRatio),renderer.setSize(window.innerWidth,window.innerHeight),renderer.domElement.style.width="800px",renderer.domElement.style.height="400px",e.appendChild(renderer.domElement),e.addEventListener("mousedown",onDocumentMouseDown,!1),e.addEventListener("mousemove",onDocumentMouseMove,!1),e.addEventListener("mouseup",onDocumentMouseUp,!1),e.addEventListener("dragover",function(e){e.preventDefault(),e.dataTransfer.dropEffect="copy"},!1),e.addEventListener("dragenter",function(e){document.body.style.opacity=.5},!1),e.addEventListener("dragleave",function(e){document.body.style.opacity=1},!1)}function onDocumentMouseDown(e){e.preventDefault(),isUserInteracting=!0,onMouseDownMouseX=e.clientX,onMouseDownMouseY=e.clientY,onMouseDownLon=lon,onMouseDownLat=lat}function onDocumentMouseMove(e){!0===isUserInteracting&&(lon=.1*(onMouseDownMouseX-e.clientX)+onMouseDownLon,lat=.1*(e.clientY-onMouseDownMouseY)+onMouseDownLat)}function onDocumentMouseUp(e){isUserInteracting=!1}function onDocumentMouseWheel(e){var n=camera.fov+.05*e.deltaY;return camera.fov=THREE.Math.clamp(n,10,75),camera.updateProjectionMatrix(),!1}function animate(){requestAnimationFrame(animate),update()}function update(){!1===isUserInteracting&&(lon+=.1),lat=Math.max(-85,Math.min(85,lat)),phi=THREE.Math.degToRad(90-lat),theta=THREE.Math.degToRad(lon),camera.target.x=500*Math.sin(phi)*Math.cos(theta),camera.target.y=500*Math.cos(phi),camera.target.z=500*Math.sin(phi)*Math.sin(theta),camera.lookAt(camera.target),renderer.render(scene,camera)}var camera,scene,renderer,isUserInteracting=!1,onMouseDownMouseX=0,onMouseDownMouseY=0,lon=0,onMouseDownLon=0,lat=0,onMouseDownLat=0,phi=0,theta=0;init(),animate()</script><h1 id="Hexo-中插入全景图片"><a href="#Hexo-中插入全景图片" class="headerlink" title="Hexo 中插入全景图片"></a>Hexo 中插入全景图片</h1><p><a href="https://github.com/wshunli/hexo-tag-panoview" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-panoview</a> 是一款在 Hexo 中使用 <strong>全景图片</strong> 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-panoview --save</code></pre><p>之后在文章内使用 <code>panoview</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% panoview "https://img.wshunli.com/pano/pano2.jpg" 400 800 %}{% endpanoview %}</code></pre><p>其中：<br><code>panoview</code> 和 <code>endpanoview</code> 是 Hexo 的标签，不需要修改；<br><code>https://img.wshunli.com/pano/pano2.jpg</code> 部分是全景照片，建议 1024*512 ；<br><code>400</code> 是指全景的高度；<br><code>800</code> 是指全景的宽度。</p><p>灵感来自 <a href="https://threejs.org/examples/?q=pano#webgl_panorama_equirectangular" rel="external nofollow noopener noreferrer" target="_blank">webgl_panorama_equirectangular</a><br>也是我发布的第二个 npm 组件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一款基于 Three.js 全景显示的 Hexo 插件。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="panoview" scheme="http://www.wshunli.com/tags/panoview/"/>
    
      <category term="hexo-tag-panoview" scheme="http://www.wshunli.com/tags/hexo-tag-panoview/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入 AntV 动态图表</title>
    <link href="http://www.wshunli.com/posts/hexo-tag-antv.html"/>
    <id>http://www.wshunli.com/posts/hexo-tag-antv.html</id>
    <published>2017-11-30T02:53:24.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<p><strong>让数据栩栩如生</strong><br><a id="more"></a></p><div id="antv6418"></div><script src="https://gw.alipayobjects.com/as/g/datavis/assets/1.0.5/g2/3.0.0/g2.min.js"></script><script type="text/javascript">var chart=new G2.Chart({container:"antv6418",height:300,forceFit:!0,data:[{genre:"Sports",sold:275},{genre:"Strategy",sold:115},{genre:"Action",sold:120},{genre:"Shooter",sold:350},{genre:"Other",sold:150}],options:{scales:{genre:{alias:"游戏种类"},sold:{alias:"销售量"}},geoms:[{type:"interval",position:"genre*sold",color:"genre"}]}});chart.render()</script><h1 id="AntV-介绍"><a href="#AntV-介绍" class="headerlink" title="AntV 介绍"></a>AntV 介绍</h1><p><a href="https://antv.alipay.com" rel="external nofollow noopener noreferrer" target="_blank">AntV</a> 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。</p><h1 id="Hexo-中使用-AntV"><a href="#Hexo-中使用-AntV" class="headerlink" title="Hexo 中使用 AntV"></a>Hexo 中使用 AntV</h1><p><a href="https://github.com/wshunli/hexo-tag-antv" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-antv</a> 是一款在 Hexo 中使用 AntV 的插件。</p><p>插件的安装和使用非常的简单，只需要进入博客目录，然后安装：</p><pre><code class="bash">$ npm install hexo-tag-antv --save</code></pre><p>之后在文章内使用 <code>antv</code> 的 tag 就可以了：</p><pre><code class="JavaScript">{% antv 300 %}data:[    // TODO antv data goes here],options: {    // TODO antv options goes here}{% endantv %}</code></pre><p>其中：<br><code>antv</code> 和 <code>endantv</code> 是 Hexo 的标签，不需要修改；<br><code>300</code> 是指图表的高度，图表宽度是自适应的；<br><code>data</code> 部分是图表的数据；<br><code>options</code> 部分是图表的配置。</p><pre><code class="JavaSript">const options = {  scales: {object}, // 列定义声明  coord: {object}, // 坐标系配置  axes: {object}, // 坐标轴配置  legends: {object}, // 图例配置  guides: {array}, // 图表辅助元素配置  filters: {object}, // 数据过滤配置  tooltip: {object}, // 提示信息配置  facet: {object}, // 分面配置  geoms: {array} // 图形语法相关配置}</code></pre><p>更详细配置可参考官方文档：<a href="https://antv.alipay.com/zh-cn/g2/3.x/api/options.html" rel="external nofollow noopener noreferrer" target="_blank">配置项声明方式</a></p><p>下面我们来看一个饼图的使用样例：</p><pre><code class="javaSript">{% antv %}data:[  { genre: 'Sports', sold: 275 },  { genre: 'Strategy', sold: 115 },  { genre: 'Action', sold: 120 },  { genre: 'Shooter', sold: 350 },  { genre: 'Other', sold: 150 }],options: {    scales: {      'genre': {        alias: '游戏种类'      },      'sold': {        alias: '销售量'      }    },    geoms: [      {        type: 'percent',        position: 'genre*sold',        color: 'genre'      }    ]  }{% endantv %}</code></pre><p>即开头的图表效果。</p><p>灵感来自 <a href="https://github.com/quentin-chen/hexo-tag-echarts3" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-echarts3</a>，AntV 也刚刚发布了 3.0 版本所以就想尝试下。<br>最主要目的还是尝试发布自己的 npm 组件，可能现在还不够实用，后面我会不断完善。</p><blockquote><p>参考资料<br>1、发布自己的module - 我的第一个npm组件！<br><a href="https://segmentfault.com/a/1190000006250554" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000006250554</a><br>2、在 Hexo 中插入 ECharts 动态图表<br><a href="http://kchen.cc/2016/11/05/echarts-in-hexo/" rel="external nofollow noopener noreferrer" target="_blank">http://kchen.cc/2016/11/05/echarts-in-hexo/</a><br>3、标签插件（Tag） | Hexo<br><a href="https://hexo.io/zh-cn/api/tag.html" rel="external nofollow noopener noreferrer" target="_blank">https://hexo.io/zh-cn/api/tag.html</a><br>4、Hexo高级教程之插件开发<br><a href="http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ieclipse.cn/en/2016/07/18/Web/Hexo-dev-plugin/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;让数据栩栩如生&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://www.wshunli.com/tags/Hexo/"/>
    
      <category term="AntV" scheme="http://www.wshunli.com/tags/AntV/"/>
    
      <category term="hexo-tag-antv" scheme="http://www.wshunli.com/tags/hexo-tag-antv/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（三）</title>
    <link href="http://www.wshunli.com/posts/6e418c5b.html"/>
    <id>http://www.wshunli.com/posts/6e418c5b.html</id>
    <published>2017-11-28T13:15:08.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 类与接口。</p><a id="more"></a><h1 id="第5章-初始化与清理"><a href="#第5章-初始化与清理" class="headerlink" title="第5章 初始化与清理"></a>第5章 初始化与清理</h1><p>1.构造器初始化 initialize()<br>Java 采用构造器（constructor）<code>初始化</code>和<code>创建</code>对象，两个过程捆绑在一起。<br>类中没有构造器即构造函数时，编译器会自动创建一个默认构造器；反之，则不会自动创建。</p><p>2.方法重载：每个重载方法都有一个独一无二的参数类型列表。</p><p>3.this 关键字只能在方法内部使用，表示“调用方法的那个对象”。<br>static 方法就是没有 this 的方法，可以在没有创建对象的情况下仅仅通过类名本身调用 static 方法。</p><p>4.垃圾回收 finalize()</p><ul><li>对象可能不被垃圾回收。</li><li>垃圾回收并不等于“析构”。</li><li>垃圾回收只与内存有关。</li></ul><p>5.成员初始化及构造器初始化<br>Java 尽力保证：所有变量在使用前都能的到恰当的初始化。</p><p>6.初始化顺序：在类的内部，成员变量会在任何方法（包括构造器）调用之前初始化。<br>含静态数据的初始化：先静态对象后非静态对象。</p><p>7.声明数组变量</p><pre><code class="Java">int[] a;   // 首选的方法int a[];  // 效果相同，但不是首选方法</code></pre><p>初始化：</p><pre><code class="Java">int[] a = new int[5];int[] a = {1, 2, 3, 4, 5};</code></pre><p>可变参数列表：</p><pre><code class="Java">void fun (Object... args){  for(Object obj : args){    system.out.printf(obj + &quot;&quot;);  }}</code></pre><p>8.枚举类型 enum</p><pre><code class="Java">public enum Spiiness{  NOT, MILD, MEDIUM, HOT, FLAMING}</code></pre><h1 id="第6章-访问权限控制"><a href="#第6章-访问权限控制" class="headerlink" title="第6章 访问权限控制"></a>第6章 访问权限控制</h1><p>访问权限（由大到小）：public、protected、包访问权限和 private 。</p><ul><li>default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li></ul><p><img src="https://img.wshunli.com/Java/Java编程思想/访问控制.png-hexo.png" alt="访问控制"></p><h1 id="第7章-复用类"><a href="#第7章-复用类" class="headerlink" title="第7章 复用类"></a>第7章 复用类</h1><p>复用代码有两种方法：在新类中产生现有类的对象（组合）；按照现有类的类型创建新类（继承）。</p><p>1.组合，将对象的引用置于新类中即可。</p><p>2.继承，使用 extends 实现，导出类自动获得基类的所有域和方法。</p><p>没有参数的初始化构建过程，从基类“向外”扩散；带参数的构造器使用 super 显式地调用基类构造器语句。</p><p>3.代理是一种介于组合和继承的中庸之道，将成员对象置于构造地类中（类似组合），与此同时在新类中暴露该成员对象的所有方法（类似继承）。</p><pre><code class="Java">public class SpaceShipDelegation {  private String name;  private SpaceShipControls controls =    new SpaceShipControls();  public SpaceShipDelegation(String name) {    this.name = name;  }  // Delegated methods:  public void back(int velocity) {    controls.back(velocity);  }  public void forward(int velocity) {    controls.forward(velocity);  }  public static void main(String[] args) {    SpaceShipDelegation protector =      new SpaceShipDelegation(&quot;NSEA Protector&quot;);    protector.forward(100);  }}</code></pre><p>4.向上转型<br>新类和基类之间的关系，新类是现有类的一种类型。<br>基类所有的方法和属性在导出类中也同样存在，导出类可以转化为基类，即向上转型。</p><p>5.final 关键字，指“这是无法改变的”，可用在 <strong>数据、方法和类</strong> 上。</p><p>final 数据：一个永不改变的编译常量；一个运行时被初始化的值，而不希望被改变。<br>final 方法：方法锁定，在继承中保持行为不变，并且不会被覆盖；效率。<br>final 类：不允许继承。</p><p>final 强调不允许改变，static 强调只有一份。</p><p>6.初始化及类的加载</p><pre><code class="Java">//: reusing/Beetle.java// The full process of initialization.import static net.mindview.util.Print.*;class Insect {  private int i = 9;  protected int j;  Insect() {    print(&quot;i = &quot; + i + &quot;, j = &quot; + j);    j = 39;  }  private static int x1 =    printInit(&quot;static Insect.x1 initialized&quot;);  static int printInit(String s) {    print(s);    return 47;  }}public class Beetle extends Insect {  private int k = printInit(&quot;Beetle.k initialized&quot;);  public Beetle() {    print(&quot;k = &quot; + k);    print(&quot;j = &quot; + j);  }  private static int x2 =    printInit(&quot;static Beetle.x2 initialized&quot;);  public static void main(String[] args) {    print(&quot;Beetle constructor&quot;);    Beetle b = new Beetle();  }}/* Output:static Insect.x1 initializedstatic Beetle.x2 initializedBeetle constructori = 9, j = 0Beetle.k initializedk = 47j = 39*/</code></pre><h1 id="第8章-多态"><a href="#第8章-多态" class="headerlink" title="第8章 多态"></a>第8章 多态</h1><p>多态作用是消除类型之间的耦合关系，允许将多种类型视为同一类型处理。</p><p>1.方法调用绑定</p><p>将一个方法调用同一个方法主题关联起来被称作绑定：<br>前期绑定：在程序执行前进行绑定；<br>后期绑定：运行时根据对象的类型进行绑定。</p><p>Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定</p><pre><code class="Java">public class Shape {    public void draw() {}    public void erase() {}}class Circle extends Shape {    public void draw() { System.out.println(&quot;Circle.draw()&quot;); }    public void erase() { System.out.println(&quot;Circle.erase()&quot;); } }class Square extends Shape {    public void draw() { System.out.println(&quot;Square.draw()&quot;); }    public void erase() { System.out.println(&quot;Square.erase()&quot;); } }public static void main(String[] args) {    Shape shape = new Circle();    shape.draw();}/* Output:Circle.draw()*/</code></pre><p>因为继承，将 Shape 引用指向一个新创建的 Circle 对象不会有任何问题；<br>又因为时后期绑定，会使得程序能够正确调用 Circle.draw() 。</p><h1 id="第9章-接口"><a href="#第9章-接口" class="headerlink" title="第9章 接口"></a>第9章 接口</h1><p>接口和内部类为我们提供了一种将接口和实现分离的更加结构化的方法。</p><p>1.抽象类和抽象方法</p><p>抽象方法是不完整的，仅有声明而没有方法体。</p><pre><code class="Java">abstract void f();</code></pre><p>包含抽象方法的类叫做抽象类；如果一个类包含一个或多个抽象方法，该类必须被定义为抽象的。</p><p>继承自抽象类的新类需要提供所有抽象方法的定义，否则也是抽象类。</p><p>2.接口</p><p>interface 关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。<br>要让一个类遵循特定接口或者一组接口，需要使用 implements 关键字。</p><pre><code class="Java">interface Instrument {    int VALUE = 5;//final &amp;&amp; static    void play(String s);    void adjust();}class Wind implements Instrument {    public void play(String s) {        System.out.print(&quot;Wind.play()&quot;);    }    public void adjust() {        System.out.println(&quot;&quot;Wind.adjust()&quot;&quot;);    }}</code></pre><ul><li>接口中的方法默认是 public 的，不需要显式声明为 public 的；</li><li>接口中的任何域都自动是 static 和 final 的；</li><li>当要实现一个接口时，在接口中被定义的方法必须被显式声明为 public 的，否则只能得到默认的包访问权限。</li></ul><h1 id="第10章-内部类"><a href="#第10章-内部类" class="headerlink" title="第10章 内部类"></a>第10章 内部类</h1><p>将一个类的定义放在另一个类的定义的内部，这就是内部类。</p><pre><code class="Java">public class Parcel1 {  class Destination {    private String label;    Destination(String whereTo) {      label = whereTo;    }    String readLabel() { return label; }  }  // Using inner classes looks just like  // using any other class, within Parcel1:  public void ship(String dest) {    Destination d = new Destination(dest);    System.out.println(d.readLabel());  }  public static void main(String[] args) {    Parcel1 p = new Parcel1();    p.ship(&quot;Tasmania&quot;);  }}/* Output:Tasmania*/</code></pre><p>1.内部类不仅是一种名字隐藏和组织代码的模式，还拥有与其他外围类的所有元素的访问权限。</p><p>2.使用 .this 与 .new</p><p>.this 用来生成对外围对象的引用。</p><pre><code class="Java">public class DotThis {  void f() { System.out.println(&quot;DotThis.f()&quot;); }  public class Inner {    public DotThis outer() {      return DotThis.this;      // A plain &quot;this&quot; would be Inner&#39;s &quot;this&quot;    }  }  public Inner inner() { return new Inner(); }  public static void main(String[] args) {    DotThis dt = new DotThis();    DotThis.Inner dti = dt.inner();    dti.outer().f();  }}/* Output:DotThis.f()*/</code></pre><p>.new 用来创建外部类对象的内部类对象。</p><pre><code class="Java">public class DotNew {  public class Inner {}  public static void main(String[] args) {    DotNew dn = new DotNew();    DotNew.Inner dni = dn.new Inner();  }}</code></pre><p>3.匿名内部类</p><pre><code class="Java">public class Parcel7 {  public Contents contents() {    return new Contents() { // Insert a class definition      private int i = 11;      public int value() { return i; }    }; // Semicolon required in this case  }  public static void main(String[] args) {    Parcel7 p = new Parcel7();    Contents c = p.contents();  }}</code></pre><p>4.嵌套类</p><p>如果不需要内部类对象与外部类对象之间的联系，内部类声明可为 static ，通常称为嵌套类。</p><ul><li>创建嵌套类对象并不需要其外围对象。</li><li>不能从嵌套类对象中访问非静态的外围类对象。</li></ul><p>5.闭包和回调</p><p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。</p><p>回调（Callback）程序在特定时间自己回头调用预先实现的方法。</p><blockquote><p>参考资料<br>1、Java 修饰符<br><a href="http://www.runoob.com/java/java-modifier-types.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/java/java-modifier-types.html</a><br>2、《Java编程思想》读书笔记 第九章 接口<br><a href="https://zhuanlan.zhihu.com/p/25597956" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/25597956</a><br>3、Java—内部类（二）—实现闭包与回调<br><a href="http://blog.csdn.net/yuwenhao07/article/details/53607117" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/yuwenhao07/article/details/53607117</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 类与接口。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/235f2f09.html"/>
    <id>http://www.wshunli.com/posts/235f2f09.html</id>
    <published>2017-11-28T12:47:30.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 基础知识部分。</p><a id="more"></a><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a>第3章 操作符</h1><p>Java 中的数据是通过使用操作符来操作的。</p><ul><li>赋值操作符</li><li>算术操作符</li><li>关系操作符</li><li>逻辑操作符</li><li>按位操作符</li><li>其他操作符</li></ul><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a>第4章 控制执行流程</h1><p>1.Java 中有三种主要的循环结构：</p><ul><li>while 循环</li><li>do…while 循环</li><li>for 循环</li></ul><p>2.Foreach 语法，用于数组或容器</p><pre><code class="Java">int [] numbers = {10, 20, 30, 40, 50};for(int x : numbers ){    System.out.print( x );    System.out.print(&quot;,&quot;);}// 10,20,30,40,50,</code></pre><p>3.return、break、continue</p><p>return：指定方法的返回值或者退出当前方法。</p><p>break：主要用于循环或者 switch 语句，退出整个语句块。<br>continue：跳转到下一次循环迭代。</p><p>4.Java 分支结构：swich 语句与 if 语句</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 基础知识部分。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Java编程思想》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/1349c3d1.html"/>
    <id>http://www.wshunli.com/posts/1349c3d1.html</id>
    <published>2017-11-28T02:58:36.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>《Java编程思想》读书笔记 —— 一切皆对象。</p><a id="more"></a><h1 id="第1章-对象导论"><a href="#第1章-对象导论" class="headerlink" title="第1章 对象导论"></a>第1章 对象导论</h1><p>本章主要介绍 OOP 面向对象的思想以及抽象、封装、继承、多态的概念。</p><p>JAVA 是一种面向对象编程语言：</p><ul><li>万物皆对象，每一个对象都会存储数据，并且可以对自身执行操作。因此，每一个对象包含两部分：成员变量和成员方法。在成员方法中可以改变成员变量的值。</li><li>程序是对象的集合，他们通过发送消息来告知彼此所要做的事情，也就是调用相应的成员函数。</li><li>每一个对象都有自己的由其他对象所构成的存储，也就是说在创建新对象的时候可以在成员变量中使用已存在的对象。</li><li>每个对象都拥有其类型，每个对象都是某个类的一个实例，每一个类区别于其它类的特性就是可以向它发送什么类型的消息，也就是它定义了哪些成员函数。</li><li>某一个特定类型的所有对象都可以接受同样的消息。</li></ul><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a>第2章 一切都是对象</h1><p>1.Java 中一切都被视为对象，但是操作的标识符实际是对象的引用。</p><pre><code class="Java">String s;                         // s 为引用，并不是对象。String s = new String(&quot;wshunli&quot;); // s 与新的对象关联String s = &quot;wshunli&quot;;             // 等价</code></pre><p>2.数据存储位置可分为：寄存器、堆栈、堆、常量存储、非 RAM 存储。</p><ul><li>寄存器位于处理器内部，最快的存储区；</li><li>堆栈通常位于 RAM 中，存储对象引用；</li><li>堆通常也是位于 RAM 中，存储所有 Java 对象；</li><li>常量存储直接存放在代码内部；</li><li>非 RAM 存储的数据完全存活于程序之外，比如流对象和持久化对象。</li></ul><p>3.Java 基本数据类型：</p><ul><li>byte、short、int、long</li><li>float、double</li><li>boolean</li><li>char</li></ul><p>4.类：字段、方法组成。</p><p>5.HelloWorld：</p><pre><code class="Java">public class HelloWorld {    /* 第一个Java程序     * 它将打印字符串 Hello World     */    public static void main(String []args) {        System.out.println(&quot;Hello World&quot;); // 打印 Hello World    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Java编程思想》读书笔记 —— 一切皆对象。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端技术" scheme="http://www.wshunli.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://www.wshunli.com/tags/Java/"/>
    
      <category term="《Java编程思想》" scheme="http://www.wshunli.com/tags/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>沉迷学术，不可自拔（四）</title>
    <link href="http://www.wshunli.com/posts/9695607b.html"/>
    <id>http://www.wshunli.com/posts/9695607b.html</id>
    <published>2017-11-19T06:34:43.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. "/> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      【加密文章】看得更远，走得更远。
    
    </summary>
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="沉迷学术" scheme="http://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
      <category term="胡思乱想" scheme="http://www.wshunli.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《React Native开发指南》读书笔记（一）</title>
    <link href="http://www.wshunli.com/posts/46b86b5e.html"/>
    <id>http://www.wshunli.com/posts/46b86b5e.html</id>
    <published>2017-11-18T04:23:39.000Z</published>
    <updated>2017-12-30T15:03:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。<br><a id="more"></a></p><p>我选择的是先看 《React Native开发指南》 入门。</p><h1 id="第1章-初识-React-Native"><a href="#第1章-初识-React-Native" class="headerlink" title="第1章 初识 React Native"></a>第1章 初识 React Native</h1><p><a href="https://facebook.github.io/react-native/" rel="external nofollow noopener noreferrer" target="_blank">React Native</a> 是一款用来开发真正原生、可渲染 iOS 和 Android 移动应用的 JavaScript 框架。<br>React Native 结合了 Web 应用和 Native 应用的优势，可以使用 JavaScript 来开发 iOS 和 Android 原生应用。<br>在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染等。</p><h1 id="第2章-React-Native-工作原理"><a href="#第2章-React-Native-工作原理" class="headerlink" title="第2章 React Native 工作原理"></a>第2章 React Native 工作原理</h1><p>React Native 使用 Virtual DOM 作为中间层，介于开发者描述的视图与实际页面渲染的视图之间。<br>Virtual DOM 不仅能提升性能，而且提供了强大的抽象能力，在开发者代码和实际渲染之间加入一个抽象层。</p><p>React Native 调用 Objective-C 的 API 渲染 iOS 组件，调用 Java 接口渲染 Android 组件，而不是渲染到浏览器 DOM 上。</p><p>React Native 的渲染周期和 React 完全相同；组件也很类似，只是名称有差别，但是和原生的组件名字差不多；使用 JSX 以及 React 的内联样式。</p><p>React Native 同样可以调用宿主平台的接口，比如数据存储，操控硬件设备等等。</p><h1 id="第3章-构建你的第一个应用"><a href="#第3章-构建你的第一个应用" class="headerlink" title="第3章 构建你的第一个应用"></a>第3章 构建你的第一个应用</h1><p>类似 React ，使用 React Native 构建 Android 应用，可使用 <code>create-react-native-app</code> 脚手架工具。</p><pre><code class="JSX">npm install -g create-react-native-app</code></pre><p>安装完成后执行以下命令即可创建 React Native 项目：</p><pre><code class="JSX">create-react-native-app first-react-native-app// 打开项目目录cd first-react-native-appnpm start</code></pre><p>基本上就构建完成。</p><p>运行在 Andoroid 系统:</p><pre><code class="JSX">npm run android</code></pre><p>代码也比较容易理解：</p><pre><code class="JSX">import React from &#39;react&#39;;import { StyleSheet, Text, View } from &#39;react-native&#39;;export default class App extends React.Component {  render() {    return (      &lt;View style={styles.container}&gt;        &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt;        &lt;Text&gt;Changes you make will automatically reload.&lt;/Text&gt;        &lt;Text&gt;Shake your phone to open the developer menu.&lt;/Text&gt;      &lt;/View&gt;    );  }}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: &#39;#fff&#39;,    alignItems: &#39;center&#39;,    justifyContent: &#39;center&#39;,  },});</code></pre><p>感觉和 React.js 差不多，比较容易理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面学习前端技术一方面是为项目做准备，另一方面也是为现在跨平台开发打基础。&lt;br&gt;
    
    </summary>
    
      <category term="跨平台技术" scheme="http://www.wshunli.com/categories/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React Native" scheme="http://www.wshunli.com/tags/React-Native/"/>
    
      <category term="《React Native开发指南》" scheme="http://www.wshunli.com/tags/%E3%80%8AReact-Native%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出React和Redux》读书笔记（二）</title>
    <link href="http://www.wshunli.com/posts/86c8e45a.html"/>
    <id>http://www.wshunli.com/posts/86c8e45a.html</id>
    <published>2017-11-15T08:05:27.000Z</published>
    <updated>2017-12-30T15:03:29.583Z</updated>
    
    <content type="html"><![CDATA[<p>继续学习 《深入浅出React和Redux》<br><a id="more"></a></p><h1 id="第3章-从-Flux-到-Redux"><a href="#第3章-从-Flux-到-Redux" class="headerlink" title="第3章 从 Flux 到 Redux"></a>第3章 从 Flux 到 Redux</h1><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p>Redux 是 Flux 单向数据流思想的另一种实现方式，先介绍 Flux 的优缺点。</p><h3 id="MVC-介绍"><a href="#MVC-介绍" class="headerlink" title="MVC 介绍"></a>MVC 介绍</h3><p>MVC 框架是业界广泛接受的一种前端应用框架类型，这种框架把应用分为三个部分：<br><img src="https://img.wshunli.com/React/深入浅出React和Redux/MVC.png-hexo.png" alt="MVC"></p><ul><li>Model （模型）负责管理数据，大部分业务逻辑也应该放在Model 中；</li><li>View （视图）负责渲染用户界面，应该避免在View 中涉及业务逻辑；</li><li>Controller （控制器）负责接受用户输入根据用户输入调用对应的Model 部分逻辑，把产生的数据结果交给View 部分，让View 渲染出必要的输出。</li></ul><p>MVC 框架提出的数据流很理想，用户请求先到达 Controller ，由 Controller 调用 Model 获得数据，然后把数据交给 View，但是在实际框架实现中，总是允许 View 和 Model 可以直接通信，MVC 很快就变得非常复杂。</p><p>Flux 执行更严格的数据流控制。一个 Flux 应用包含四个部分：</p><p><img src="https://img.wshunli.com/React/深入浅出React和Redux/Flux.png-hexo.png" alt="Flux"></p><ul><li>Dispatcher ，处理动作分发，维持Store 之间的依赖关系；</li><li>Store ，负责存储数据和处理数据相关逻辑；</li><li>Action ，驱动 Dispatcher 的JavaScript 对象；</li><li>View ，视图部分，负责显示用户界面。</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Flux 的基本原则是“单向数据流”， Redux 在此基础上强调三个基本原则：</p><ul><li>唯一数据源（ Single Source of Truth);</li><li>保持状态只读（ State is read-only);</li><li>数据改变只能通过纯函数完成（ Changes are made with pure functions ）。</li></ul><blockquote><p>参考资料<br>1、Flux | Application Architecture for Building User Interfaces<br><a href="https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow" rel="external nofollow noopener noreferrer" target="_blank">https://facebook.github.io/flux/docs/in-depth-overview.html#structure-and-data-flow</a><br>2、Flux 架构入门教程 - 阮一峰的网络日志<br><a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2016/01/flux.html</a><br>3、</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续学习 《深入浅出React和Redux》&lt;br&gt;
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://www.wshunli.com/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://www.wshunli.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
</feed>
