<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CirGIS 博客</title>
  
  <subtitle>wshunli`s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wshunli.com/"/>
  <updated>2019-01-04T09:27:07.553Z</updated>
  <id>https://www.wshunli.com/</id>
  
  <author>
    <name>wshunli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Hexo 中插入 cPlayer 播放器</title>
    <link href="https://www.wshunli.com/posts/hexo-tag-mplayer.html"/>
    <id>https://www.wshunli.com/posts/hexo-tag-mplayer.html</id>
    <published>2019-01-04T03:08:24.000Z</published>
    <updated>2019-01-04T09:27:07.553Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍在 Hexo 中插入 cPlayer 播放器</p><center><div id="mplayer8931"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer8931"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"},{src:"https://img.wshunli.com/about/童话镇.mp3",poster:"https://img.wshunli.com/about/童话镇.jpg",name:"童话镇",artist:"陈一发儿",lyric:"[00:00.00]童话镇\n[00:05.00]演唱：陈一发\n[00:10.00]作曲:暗杠\n[00:15.00]作词:竹君\n[00:22.93]听说白雪公主在逃跑\n[00:26.43]小红帽在担心大灰狼\n[00:29.83]听说疯帽喜欢爱丽丝\n[00:33.17]丑小鸭会变成白天鹅\n[00:36.34]听说彼得潘总长不大\n[00:40.23]杰克他有竖琴和魔法\n[00:43.56]听说森林里有糖果屋\n[00:46.82]灰姑娘丢了心爱的玻璃鞋\n[00:50.39]只有睿智的河水知道\n[00:53.68]白雪是因为贪玩跑出了城堡\n[00:57.31]小红帽有件抑制自己\n[01:00.73]变成狼的大红袍\n[01:03.80]总有一条蜿蜒在童话镇里七彩的河\n[01:11.00]沾染魔法的乖张气息\n[01:14.42]却又在爱里曲折\n[01:17.76]川流不息扬起水\n[01:20.87]又卷入一帘时光入水\n[01:24.68]让全部很久很久以前\n[01:28.12]都走到幸福结局的时刻\n[01:33.18]music....\n[01:47.00]听说睡美人被埋藏\n[01:50.44]小人鱼在眺望金殿堂\n[01:53.79]听说阿波罗变成金乌\n[01:57.12]草原有奔跑的剑齿虎\n[02:00.73]听说匹诺曹总说着谎\n[02:04.16]侏儒怪拥有宝石满箱\n[02:07.57]听说悬崖有颗长生树\n[02:10.80]红鞋子不知疲倦地在跳舞\n[02:14.43]只有睿智的河水知道\n[02:17.84]睡美人逃避了生活的煎熬\n[02:21.14]小人鱼把阳光抹成眼影\n[02:24.58]投进泡沫的怀抱\n[02:27.77]总有一条蜿蜒在童话镇里七彩的河\n[02:35.06]沾染魔法的乖张气息\n[02:38.43]却又在爱里曲折\n[02:41.82]川流不息扬起水花\n[02:44.87]又卷入一帘时光入水\n[02:48.69]让全部很久很久以前\n[02:52.00]都走到幸福结局的时刻\n[02:55.46]总有一条蜿蜒在童话镇里梦幻的河\n[03:02.47]分隔了理想分隔现实\n[03:05.82]又在前方的山口汇合\n[03:09.22]川流不息扬起水花\n[03:12.36]又卷入一帘时光入水\n[03:16.23]让全部很久很久以前\n[03:19.38]都走到幸福结局的时刻\n[03:22.72]又陌生\n[03:24.52]啊~~啊~~啊~~啊~~"}],autoplay:!0,volume:.75,big:!0,dark:!1,zoomOutKana:!1,playmode:"listloop",point:0,showPlaylist:!1,dropDownMenuMode:"bottom"})</script></center><h1 id="cPlayer-介绍"><a href="#cPlayer-介绍" class="headerlink" title="cPlayer 介绍"></a>cPlayer 介绍</h1><p>A beautiful and clean WEB Music Player by HTML5. <a href="http://cplayer.js.org/" rel="external nofollow noopener noreferrer" target="_blank">http://cplayer.js.org/</a></p><h1 id="Hexo-中使用-cPlayer"><a href="#Hexo-中使用-cPlayer" class="headerlink" title="Hexo 中使用 cPlayer"></a>Hexo 中使用 cPlayer</h1><p><a href="https://github.com/wshunli/hexo-tag-mplayer" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-mplayer</a> 是一款在 Hexo 中使用 cPlayer 的插件。</p><p>插件的安装和使用非常的简单，只需要进入 Hexo 博客根目录，然后安装：</p><pre><code class="lang-bash">$ npm install hexo-tag-mplayer --save</code></pre><p>之后在文章内使用 <code>mplayer</code> 的 tag 就可以了：</p><pre><code class="lang-JavaScript">{% mplayer %}{    // TODO mplayer options goes here}{% endmplayer %}</code></pre><p>其中：<br><code>mplayer</code> 和 <code>endmplayer</code> 是 Hexo 的标签，不需要修改；<br><code>options</code> 部分是图表的配置。</p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>可参考如下配置，使用 <code>hexo-tag-mplayer</code> 插件。</p><pre><code class="lang-JavaScript">{% mplayer %}    playlist: [        {            src: '歌曲资源链接...',            poster: '封面链接...',            name: '歌曲名称...',            artist: '歌手名称...',            lyric: '歌词...',            sublyric: '副歌词，一般为翻译...',            album: '专辑，唱片...'        },        {            ...        },        ...    ],    autoplay: true,    volume: 0.75,    playmode: "listloop",    big: true,    dark: false{% endmplayer %}</code></pre><p>更详细配置可参考官方文档：<a href="https://github.com/MoePlayer/cPlayer#option" rel="external nofollow noopener noreferrer" target="_blank">cPlayer Option</a></p><h1 id="实例参考"><a href="#实例参考" class="headerlink" title="实例参考"></a>实例参考</h1><p>下面我们来看插件的一些使用样例：</p><p>1、默认样式</p><div id="mplayer181"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer181"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!1,dark:!1})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落'        }    ],    autoplay: false,    volume: 0.75,    big: false,    dark: false{% endmplayer %}</code></pre><p>2、暗黑样式</p><div id="mplayer4053"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer4053"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!1,dark:!0})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '省略歌词...'        }    ],    autoplay: false,    volume: 0.75,    big: false,    dark: true{% endmplayer %}</code></pre><p>3、大图样式</p><div id="mplayer2689"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer2689"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!0,dark:!1})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '省略歌词...'        }    ],    autoplay: false,    volume: 0.75,    big: true,    dark: false{% endmplayer %}</code></pre><p>4、大图暗黑样式</p><div id="mplayer3034"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer3034"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!1,volume:.75,big:!0,dark:!0})</script><p>源码参考如下：</p><pre><code class="lang-javaSript">{% mplayer %}    playlist: [        {            src: 'https://img.wshunli.com/about/阿婆说.mp3',            poster: 'https://img.wshunli.com/about/阿婆说.jpg',            name: '阿婆说',            artist: '陈一发儿',            lyric: '省略歌词...'        }    ],    autoplay: false,    volume: 0.75,    big: true,    dark: true{% endmplayer %}</code></pre><p>非常感谢 <a href="https://github.com/MoePlayer/cPlayer" rel="external nofollow noopener noreferrer" target="_blank">cPlayer</a> 及 <a href="https://github.com/EYHN/hexo-tag-cplayer" rel="external nofollow noopener noreferrer" target="_blank">hexo-tag-cplayer</a> 作者。</p><font color="red">最后欢迎 star 或者提交 PR 到本仓库。</font><p><a href="https://github.com/wshunli/hexo-tag-mplayer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/hexo-tag-mplayer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍在 Hexo 中插入 cPlayer 播放器&lt;/p&gt;&lt;center&gt;&lt;div id=&quot;mplayer8931&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer
      
    
    </summary>
    
      <category term="前端技术" scheme="https://www.wshunli.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="https://www.wshunli.com/tags/Hexo/"/>
    
      <category term="mplayer" scheme="https://www.wshunli.com/tags/mplayer/"/>
    
      <category term="cPlayer" scheme="https://www.wshunli.com/tags/cPlayer/"/>
    
      <category term="hexo-tag-mplayer" scheme="https://www.wshunli.com/tags/hexo-tag-mplayer/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结，我这一年的点点滴滴</title>
    <link href="https://www.wshunli.com/posts/f5281e38.html"/>
    <id>https://www.wshunli.com/posts/f5281e38.html</id>
    <published>2019-01-03T08:46:00.000Z</published>
    <updated>2019-01-04T09:27:07.545Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security"> <div class="hbe-input-container"> <input type="password" class="form-control" id="pass" placeholder=" 欢迎您访问我的博客，请输入密码查看本文. " /> <label for="pass"> 欢迎您访问我的博客，请输入密码查看本文. </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      【加密文章】 花开花谢，月圆月缺。
    
    </summary>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/categories/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
    
      <category term="年终总结" scheme="https://www.wshunli.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="沉迷学术" scheme="https://www.wshunli.com/tags/%E6%B2%89%E8%BF%B7%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Drone持续集成服务私有部署</title>
    <link href="https://www.wshunli.com/posts/b9adca20.html"/>
    <id>https://www.wshunli.com/posts/b9adca20.html</id>
    <published>2018-12-31T09:44:59.000Z</published>
    <updated>2019-01-04T09:27:07.545Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍基于 Github 的 Drone 持续集成服务单机部署。</p><h1 id="Docker-环境"><a href="#Docker-环境" class="headerlink" title="Docker 环境"></a>Docker 环境</h1><p>首先应该安装 Docker 及 docker-compose 环境。</p><p><a href="https://www.wshunli.com/posts/89bfe8.html">https://www.wshunli.com/posts/89bfe8.html</a></p><h1 id="Github-应用注册"><a href="#Github-应用注册" class="headerlink" title="Github 应用注册"></a>Github 应用注册</h1><p>打开 <a href="https://github.com/settings/applications/new" rel="external nofollow noopener noreferrer" target="_blank">Github New OAuth Application</a> 注册应用程序。</p><p><img src="https://img.wshunli.com/qnap/drone/github_application_create.png" alt="github_application_create"></p><p>创建完成，查看相应的 <code>Client ID</code> 及 <code>Client Secret</code> 值。</p><p><img src="https://img.wshunli.com/qnap/drone/github_application.png" alt="github_application"></p><h1 id="创建-Drone-服务"><a href="#创建-Drone-服务" class="headerlink" title="创建 Drone 服务"></a>创建 Drone 服务</h1><p>直接执行以下明命令即可</p><pre><code class="lang-Shell">docker run \  --volume=/var/run/docker.sock:/var/run/docker.sock \  --volume=/var/lib/drone:/data \  --env=DRONE_GITHUB_SERVER=https://github.com \  --env=DRONE_GITHUB_CLIENT_ID=xxx \  --env=DRONE_GITHUB_CLIENT_SECRET=xxxxxx \  --env=DRONE_RUNNER_CAPACITY=2 \  --env=DRONE_SERVER_HOST=drone.wshunli.com \  --env=DRONE_SERVER_PROTO=http \  --env=DRONE_GIT_ALWAYS_AUTH=true \  --env=DRONE_TLS_AUTOCERT=true \  --publish=30080:80 \  --publish=30443:443 \  --restart=always \  --detach=true \  --name=drone \  drone/drone:1.0.0-rc.3</code></pre><p>其中<br>DRONE_GITHUB_CLIENT_ID 替换为自己应用的 <code>Client ID</code> 值；<br>DRONE_GITHUB_CLIENT_SECRET 替换为 <code>Client Secret</code> 值；<br>DRONE_SERVER_HOST 替换为欲解析的域名。</p><h1 id="Drone-服务的使用"><a href="#Drone-服务的使用" class="headerlink" title="Drone 服务的使用"></a>Drone 服务的使用</h1><p>1、打开域名地址，授予权限</p><p><img src="https://img.wshunli.com/qnap/drone/github_authorize_application.png" alt="github_authorize_application"></p><p>2、点击中间的 ACTICVE 按钮，即可开启持续集成服务。</p><p><img src="https://img.wshunli.com/qnap/drone/drone_active_repositories.png" alt="drone_active_repositories"></p><p>3、然后在 Github 源码仓库中，添加 <code>.drone.yml</code> 文件</p><pre><code class="lang-YML">kind: pipelinename: defaultsteps:- name: test  image: node  commands:  - npm install  - npm test</code></pre><p>具体可参考官方文档。</p><p>4、以下是持续集成结果示例</p><p><img src="https://img.wshunli.com/qnap/drone/drone_continuous_integration.png" alt="drone_continuous_integration"></p><blockquote><p>参考资料<br>1、Drone Single Machine<br><a href="https://docs.drone.io/installation/github/single-machine/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.drone.io/installation/github/single-machine/</a><br>2、如何在Ubuntu上安装Drone持续集成环境 - 云+社区 - 腾讯云<br><a href="https://cloud.tencent.com/developer/article/1180481" rel="external nofollow noopener noreferrer" target="_blank">https://cloud.tencent.com/developer/article/1180481</a><br>3、Drone安装指南 - 怡红院落<br><a href="https://imnerd.org/drone-installation.html" rel="external nofollow noopener noreferrer" target="_blank">https://imnerd.org/drone-installation.html</a><br>4、基于Gogs+Drone搭建的私有CI/CD平台 | DongSheng’s Blog<br><a href="http://www.mdslq.cn/archives/1a623683.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.mdslq.cn/archives/1a623683.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍基于 Github 的 Drone 持续集成服务单机部署。&lt;/p&gt;&lt;h1 id=&quot;Docker-环境&quot;&gt;&lt;a href=&quot;#Docker-环境&quot; class=&quot;headerlink&quot; title=&quot;Docker 环境&quot;&gt;&lt;/a&gt;Docker 环境&lt;/h1&gt;&lt;p&gt;首先
      
    
    </summary>
    
      <category term="后端技术" scheme="https://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="qnap" scheme="https://www.wshunli.com/tags/qnap/"/>
    
      <category term="drone" scheme="https://www.wshunli.com/tags/drone/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境搭建从入门到放弃</title>
    <link href="https://www.wshunli.com/posts/89bfe8.html"/>
    <id>https://www.wshunli.com/posts/89bfe8.html</id>
    <published>2018-12-31T08:47:28.000Z</published>
    <updated>2019-01-04T09:27:07.545Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于 CentOS 搭建 Docker CE 环境，并完成 docker-compose 的安装。</p><h1 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h1><p>1、安装一些必要的依赖</p><pre><code class="lang-Shell">sudo yum install -y yum-utils \  device-mapper-persistent-data \  lvm2</code></pre><p>2、添加 Docker 存储库</p><pre><code class="lang-Shell">sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>因为众所周知的原因，这里推荐使用阿里云的镜像。</p><pre><code class="lang-Shell">sudo yum-config-manager \    --add-repo \    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>3、安装 Docker CE 环境</p><pre><code class="lang-Shell">sudo yum install docker-ce</code></pre><p>4、启动 Docker 服务</p><pre><code class="lang-Shell">sudo systemctl start docker</code></pre><p>设置 Docker 服务为开机自启</p><pre><code class="lang-Shell">sudo systemctl enable docker.service</code></pre><p>5、测试 Docker 安装</p><p>查看 Docker 信息,执行如下命令</p><pre><code class="lang-Shell">docker version</code></pre><p><img src="https://img.wshunli.com/qnap/docker/docker-version.png" alt="version"></p><p>Hello World Docker ! ,执行如下命令</p><pre><code class="lang-Shell">sudo docker run hello-world</code></pre><p><img src="https://img.wshunli.com/qnap/docker/docker-hello.png" alt="hello"></p><h1 id="使用安装脚本一键安装-Docker"><a href="#使用安装脚本一键安装-Docker" class="headerlink" title="使用安装脚本一键安装 Docker"></a>使用安装脚本一键安装 Docker</h1><p>官方提供了一键安装脚本</p><pre><code class="lang-Shell">curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh</code></pre><p>同样众所周知的原因，这里推荐使用阿里云的镜像。</p><pre><code class="lang-Shell">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></pre><p>这样安装的 Docker 没有灵魂，哈哈。</p><h1 id="配置阿里云镜像加速器"><a href="#配置阿里云镜像加速器" class="headerlink" title="配置阿里云镜像加速器"></a>配置阿里云镜像加速器</h1><p>直接从仓库拉取可能会比较慢，这里配置阿里云镜像加速。</p><p>登陆 <a href="https://cr.console.aliyun.com/" rel="external nofollow noopener noreferrer" target="_blank">容器镜像服务控制台</a> ，左侧 镜像加速器 。</p><pre><code class="lang-Shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;{  &quot;registry-mirrors&quot;: [&quot;https://xxxxxx.mirror.aliyuncs.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h1 id="安装-docker-compose-服务启动器"><a href="#安装-docker-compose-服务启动器" class="headerlink" title="安装 docker-compose 服务启动器"></a>安装 docker-compose 服务启动器</h1><pre><code class="lang-Shell">pip install docker-compose</code></pre><blockquote><p>参考资料<br>1、Get Docker CE for CentOS | Docker Documentation<br><a href="https://docs.docker.com/install/linux/docker-ce/centos/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/install/linux/docker-ce/centos/</a><br>2、安装Docker - 快速入门| 阿里云<br><a href="https://www.alibabacloud.com/help/zh/doc-detail/60742.htm" rel="external nofollow noopener noreferrer" target="_blank">https://www.alibabacloud.com/help/zh/doc-detail/60742.htm</a><br>3、如何在Ubuntu上安装使用Docker - 云+社区 - 腾讯云<br><a href="https://cloud.tencent.com/developer/article/1167995" rel="external nofollow noopener noreferrer" target="_blank">https://cloud.tencent.com/developer/article/1167995</a><br>4、Docker CE 镜像源站-云栖社区-阿里云<br><a href="https://yq.aliyun.com/articles/110806/" rel="external nofollow noopener noreferrer" target="_blank">https://yq.aliyun.com/articles/110806/</a><br>5、镜像加速器 · Docker —— 从入门到实践镜像加速器 · Docker —— 从入门到实践<br><a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" rel="external nofollow noopener noreferrer" target="_blank">https://yeasy.gitbooks.io/docker_practice/install/mirror.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文基于 CentOS 搭建 Docker CE 环境，并完成 docker-compose 的安装。&lt;/p&gt;&lt;h1 id=&quot;安装-Docker-环境&quot;&gt;&lt;a href=&quot;#安装-Docker-环境&quot; class=&quot;headerlink&quot; title=&quot;安装 Docker 
      
    
    </summary>
    
      <category term="后端技术" scheme="https://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="qnap" scheme="https://www.wshunli.com/tags/qnap/"/>
    
      <category term="docker" scheme="https://www.wshunli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>阿婆说</title>
    <link href="https://www.wshunli.com/posts/eb2a7b89.html"/>
    <id>https://www.wshunli.com/posts/eb2a7b89.html</id>
    <published>2018-12-09T10:00:00.000Z</published>
    <updated>2019-01-04T09:27:07.557Z</updated>
    
    <content type="html"><![CDATA[<p>阿婆说</p><a id="more"></a><center><div id="mplayer5840"></div><script src="https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js"></script><script>new cplayer({element:document.getElementById("mplayer5840"),playlist:[{src:"https://img.wshunli.com/about/阿婆说.mp3",poster:"https://img.wshunli.com/about/阿婆说.jpg",name:"阿婆说",artist:"陈一发儿",lyric:"[00:03.85]阿婆说-陈一发儿\n[00:04.86]作曲:暗杠\n[00:05.29]作词:暗杠/古道背棺人\n[00:05.81]编曲：暗杠\n[00:06.25]器乐演奏：暗杠\n[00:06.73]和声编配：暗杠\n[00:07.30]混音后期：A.Q.Studio\n[00:16.33]囡囡呀不要调皮\n[00:19.15]坐下听听阿婆说\n[00:23.12]这个季节天气转凉地上雨水多\n[00:30.17]囡囡呀不要惊慌\n[00:33.13]过来听听阿婆说\n[00:36.91]睡个觉雷声过后就能看云朵\n[00:44.58]囡囡别怕\n[00:46.26]囡囡别哭\n[00:47.84]快快睡咯\n[00:51.23]你静静听首歌\n[00:58.51]蛐蛐轻些\n[00:59.94]静静安歇\n[01:01.73]月儿圆哟\n[01:05.02]你乖乖呀抱阿婆\n[01:11.93]风铃呀轻响鸟儿轻唱远处谁在和\n[01:18.75]亲了彩虹惊了云朵\n[01:21.81]我已成归客\n[01:25.88]囡囡呀你会长大会走很远会觉得累了\n[01:33.02]只要记得河婆话“阿婆”怎么说\n[02:07.56]囡囡呀你会困惑\n[02:10.65]慢些脚步别忘了\n[02:14.39]慢慢的你会明白丢了是什么\n[02:21.46]人生路本就是场获得与失的选择\n[02:28.14]迷路时想想当年阿婆怎么说\n[02:35.85]回头看看\n[02:37.46]雨水过后\n[02:39.26]云彩很多\n[02:42.49]来吧阿婆帮你偷偷摘一朵\n[02:49.67]等你老了\n[02:51.29]阿婆走了\n[02:53.09]你要记得\n[02:56.64]把这乡音教会娃儿怎么说\n[03:03.66]把这乡音教给你的囡囡哟\n[03:38.37]回头看看\n[03:40.11]雨水过后\n[03:41.75]少了冷漠\n[03:45.09]来吧阿婆等你还在那村落"}],autoplay:!0,volume:.75,big:!0,dark:!1})</script></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿婆说&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于 frp 的内网穿透实践</title>
    <link href="https://www.wshunli.com/posts/be4c3c8c.html"/>
    <id>https://www.wshunli.com/posts/be4c3c8c.html</id>
    <published>2018-11-09T12:41:15.000Z</published>
    <updated>2019-01-04T09:27:07.553Z</updated>
    
    <content type="html"><![CDATA[<p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>1、利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。<br>2、对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。<br>3、利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务。</p><p>frp 搭建需要一台具有公网 IP 的服务器，并且访问效果和服务器的带宽和内网的上行带宽有关系。</p><h1 id="内网穿透实现方法"><a href="#内网穿透实现方法" class="headerlink" title="内网穿透实现方法"></a>内网穿透实现方法</h1><p>内网穿透有很多商业的软件比如花生壳、NATAPP 等，这里不多介绍。</p><p>还有一些半开源的工具比如 ZeroTier ，配置简单，但是需要额外安装软件。</p><p>再者就是 frp 、ngrok 等开源工具，利用具有公网 IP 的服务器搭建。</p><h1 id="frp-内网穿透实践"><a href="#frp-内网穿透实践" class="headerlink" title="frp 内网穿透实践"></a>frp 内网穿透实践</h1><p>frp：<a href="https://github.com/fatedier/frp" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp</a></p><p>中文文档：<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>做内网穿透前需要提前准备一些东西的</p><p>1、一台公网服务器，建议国外的 VPS ，带宽大一些；<br>2、一台内网服务器，我这里是 QNAP 的 NAS ，Linux 系统；<br>3、域名，用于解析，访问内网；<br>4、内网服务，访问的主要内容。</p><h2 id="frp-的安装配置"><a href="#frp-的安装配置" class="headerlink" title="frp 的安装配置"></a>frp 的安装配置</h2><p>这里 具有公网 IP 的机器称为服务端，处于内网环境的机器称为客户端。</p><p>1、下载 frp 文件</p><p>在 <a href="https://github.com/fatedier/frp/releases" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fatedier/frp/releases</a> 下载最新版即可。</p><p>下载并解压文件</p><pre><code class="lang-bash"> cd usr/local/wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gztar -zxvf  frp_0.21.0_linux_amd64.tar.gzcd frp_0.21.0_linux_amd64</code></pre><p>这里主要有 4 个文件，分别是 frpc、frpc.ini 和frps、frps.ini 。</p><p>将 frps 及 <strong>frps.ini</strong> 放到具有公网 IP 的机器上。<br>将 frpc 及 <strong>frpc.ini</strong> 放到处于内网环境的机器上。</p><p>2、配置具有公网 IP 的机器，也就是 frps.ini 文件</p><p>使用 <code>vim frps.ini</code> 命令修改配置文件</p><pre><code class="lang-TXT">[common]bind_port = 7000            # 内网穿透服务端口bind_udp_port = 7001        # 点对点内网穿透vhost_http_port = 10080     # 外部访问的 http 端口vhost_https_port = 10443    # 外部访问的 https 端口dashboard_port = 7500       # 管理面板端口dashboard_user = admin      # 管理面板用户名dashboard_pwd = admin       # 管理面板密码token = asdfgh              # 身份验证</code></pre><p>更多内容参考：<a href="https://github.com/fatedier/frp/blob/master/conf/frps_full.ini" rel="external nofollow noopener noreferrer" target="_blank">frps 完整配置文件</a></p><p>启动 frps 服务</p><pre><code class="lang-bash">./frps -c ./frps.ini</code></pre><p>后台启动方法</p><pre><code class="lang-bash">nohup ./frps -c ./frps.ini &amp;</code></pre><p>3、配置处于内网环境的机器，也就是 frpc.ini 文件</p><p>使用 <code>vim frpc.ini</code> 命令修改配置文件</p><pre><code class="lang-TXT">[common]server_addr = X.X.X.X           # 内网穿透服务地址server_port = 7000              # 内网穿透服务端口token = asdfgh                  # 身份验证，与服务端一致[qnap-web]type = httplocal_ip = 127.0.0.1            # 内网服务地址local_port = 8080               # 内网服务端口use_encryption = true           # 加密传输use_compression = true          # 压缩传输custom_domains = x.wshunli.com  # 访问域名</code></pre><p>这里 <code>custom_domains</code> 是外网服务器解析的域名，否则无法访问；可根据 <code>vhost_http_port</code> 端口反向代理解析。</p><p>更多内容参考：<a href="https://github.com/fatedier/frp/blob/master/conf/frpc_full.ini" rel="external nofollow noopener noreferrer" target="_blank">frpc 完整配置文件</a></p><p>启动 frpc 服务方法与 frps 类似。</p><p>前台启动：<code>./frpc -c ./frpc.ini</code></p><p>后台启动：<code>nohup ./frpc -c ./frpc.ini &amp;</code></p><p>4、frp 控制面板的使用</p><p>这里需要根据公网 IP 服务器访问，即 <code>http://{server_addr}:{dashboard_port}</code></p><p>更多内容参考 <a href="https://github.com/fatedier/frp/blob/master/README_zh.md" rel="external nofollow noopener noreferrer" target="_blank">frp 中文文档</a></p><h1 id="Linux-服务进程停止命令"><a href="#Linux-服务进程停止命令" class="headerlink" title="Linux 服务进程停止命令"></a>Linux 服务进程停止命令</h1><p>1、查找被占用的端口</p><pre><code class="lang-Shell">[root@localhost ~]# netstat -tln | grep 30080tcp6       0      0 :::30080                :::*                    LISTEN</code></pre><p>2、查看被占用端口的PID</p><pre><code class="lang-Shell">[root@localhost ~]# lsof -i:30080COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEdocker-pr 4390 root    4u  IPv6  36195      0t0  TCP *:30080 (LISTEN)docker-pr 4390 root    7u  IPv6 170434      0t0  TCP localhost:30080-&gt;localhost:42162 (ESTABLISHED)frpc      4509 root    6u  IPv4 170433      0t0  TCP localhost:42162-&gt;localhost:30080 (ESTABLISHED)</code></pre><p>3、杀掉相关进程</p><pre><code class="lang-Shell">[root@localhost ~]# kill -9 4509</code></pre><p><img src="https://img.wshunli.com/qnap/frp/linux.png" alt="服务停止启动"></p><blockquote><p>参考资料<br>1、一分钟实现内网穿透（ngrok服务器搭建） - 学习笔记 - CSDN博客<br><a href="https://blog.csdn.net/zhangguo5/article/details/77848658" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zhangguo5/article/details/77848658</a><br>2、十分钟教你配置frp实现内网穿透 - 诗雨远方的博客 - CSDN博客<br><a href="https://blog.csdn.net/u013144287/article/details/78589643" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u013144287/article/details/78589643</a><br>3、突破电信局域网：frp内网穿透教程（客户端：lede/win） - 电脑讨论 - Chiphell - 分享与交流用户体验<br><a href="https://www.chiphell.com/thread-1853360-1-1.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.chiphell.com/thread-1853360-1-1.html</a><br>4、使用frp进行内网穿透入门 - ＱＱ小冰 - CSDN博客<br><a href="https://blog.csdn.net/weixin_36241363/article/details/78457359" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/weixin_36241363/article/details/78457359</a><br>5、威联通折腾篇二：使用 frp 内网穿透 | Verne in GitHub<br><a href="https://blog.einverne.info/post/2018/06/qnap-frp-usage.html" rel="external nofollow noopener noreferrer" target="_blank">https://blog.einverne.info/post/2018/06/qnap-frp-usage.html</a><br>6、nohup和&amp;后台运行，进程查看及终止 - 弥尘 - 博客园<br><a href="https://www.cnblogs.com/baby123/p/6477429.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/baby123/p/6477429.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。&lt;/p&gt;&lt;p&gt;1、利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。&lt;br&gt;2、对于 http, https 服务支持基于域名的虚拟主机，
      
    
    </summary>
    
      <category term="后端技术" scheme="https://www.wshunli.com/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="qnap" scheme="https://www.wshunli.com/tags/qnap/"/>
    
      <category term="frp" scheme="https://www.wshunli.com/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>基于 WinSW 将 Java 程序部署为 Windows 自启动服务</title>
    <link href="https://www.wshunli.com/posts/762f39b0.html"/>
    <id>https://www.wshunli.com/posts/762f39b0.html</id>
    <published>2018-10-20T03:22:36.000Z</published>
    <updated>2019-01-04T09:27:07.553Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍基于 WinSW 将 Java 程序部署 为 Windows 自启动服务。</p><p>我们使用 Java -jar file.jar 将 Java 程序运行，起来，但是窗口关闭，服务就停止了。</p><p>WinSW 可以将 Windows 上的任何一个程序注册为服务，如果不需要，也可以方便的卸载服务。</p><p><a href="https://github.com/kohsuke/winsw" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kohsuke/winsw</a></p><p>1、下载 winsw 文件</p><p>下载 winsw-2.1.2-bin.exe 文件</p><p><a href="http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/" rel="external nofollow noopener noreferrer" target="_blank">http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/</a></p><p>最好修改下文件名称，本文修改为 <code>winsw-ai-server</code></p><p>2、添加配置文件</p><p>根据 winsw 文件名，新建相同名称的 xml 文件</p><pre><code class="lang-XML">&lt;service&gt;    &lt;id&gt;phcj-ai-server&lt;/id&gt;    &lt;name&gt;phcj-ai-server&lt;/name&gt;    &lt;description&gt;系统 AI 后台服务&lt;/description&gt;    &lt;executable&gt;java&lt;/executable&gt;        &lt;onfailure action=&quot;restart&quot; delay=&quot;10 sec&quot;/&gt;    &lt;arguments&gt; -jar &quot;D:\PHCJ\phcj-ai-server\target\phcj-ai-server-0.0.1-SNAPSHOT.jar&quot;&lt;/arguments&gt;    &lt;log mode=&quot;roll-by-size&quot;&gt;        &lt;sizeThreshold&gt;20480&lt;/sizeThreshold&gt;        &lt;keepFiles&gt;8&lt;/keepFiles&gt;    &lt;/log&gt;&lt;/service&gt;</code></pre><p>3、安装并启动服务</p><p>注意以管理员身份运行</p><p>安装服务 <code>./winsw-ai-server.exe install</code></p><p>启动服务 <code>net start phcj-ai-server</code></p><p>停止服务 <code>net stop phcj-ai-server</code></p><p>卸载服务 <code>./winsw-ai-server.exe uninstall</code></p><blockquote><p>参考资料：<br>1、winsw将可运行的jar文件做成后台服务 - qq_31451471的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_31451471/article/details/79298665" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_31451471/article/details/79298665</a><br>2、用winsw让任何Windows程序都能运行为服务 - 简书<br><a href="https://www.jianshu.com/p/fc9e4ea61e13" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/fc9e4ea61e13</a><br>3、使用WinSW将SpringBoot程序安装成Windows自启动服务 - blvyoucan的专栏 - CSDN博客<br><a href="https://blog.csdn.net/blvyoucan/article/details/81131234" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/blvyoucan/article/details/81131234</a><br>4、Spring Boot项目生成jar包，并在windows服务器中注册成服务，开机启动 - LiveYourLife - 博客园<br><a href="https://www.cnblogs.com/LiveYourLife/p/8681137.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/LiveYourLife/p/8681137.html</a><br>5、springboot解决第三方依赖jar包的问题 - 浅夏丶未央 - 博客园<br><a href="https://www.cnblogs.com/xiaosiyuan/p/6894766.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/xiaosiyuan/p/6894766.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍基于 WinSW 将 Java 程序部署 为 Windows 自启动服务。&lt;/p&gt;&lt;p&gt;我们使用 Java -jar file.jar 将 Java 程序运行，起来，但是窗口关闭，服务就停止了。&lt;/p&gt;&lt;p&gt;WinSW 可以将 Windows 上的任何一个程序注册为
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="WinSW" scheme="https://www.wshunli.com/tags/WinSW/"/>
    
  </entry>
  
  <entry>
    <title>Java 调用 Matlab 程序（Java 和 Matlab 混合编程）</title>
    <link href="https://www.wshunli.com/posts/45399dc2.html"/>
    <id>https://www.wshunli.com/posts/45399dc2.html</id>
    <published>2018-10-20T01:24:10.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Java 调用 Matlab 程序（Java 和 Matlab 混合编程）流程方法。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>1、 Java 环境，建议使用如下版本 。</p><p>Java™ SE Development Kit 8, Update 151 (JDK 8u151)</p><p>2、Matlab 工具（开发环境）</p><p>编写 Mattlab 代码，本文以最新版 Matlab 2018b 为例。</p><p>3、MATLAB Runtime（部署环境）</p><p>已经安装过 Matlab 就不需要再安装了，用来执行编译后的 Matlab 程序。</p><p>从以下网址下载即可，本文以 R2018b (9.5) 为例。</p><p><a href="https://ww2.mathworks.cn/products/compiler/matlab-runtime.html" rel="external nofollow noopener noreferrer" target="_blank">https://ww2.mathworks.cn/products/compiler/matlab-runtime.html</a></p><p>MATLAB Runtime 相比 Matlab 更加轻量级，免费。</p><p><strong>环境确认：</strong></p><p>本文建议 Java 版本和 Matlab 自带 JVM 保持一致。</p><p>在 Matlab 命令中输入 <code>version -java</code> 查看机器 Matlab 版本。</p><p><img src="https://img.wshunli.com/Java/Matlab/matlab-version.png" alt="java-version"></p><p>在 CMD 中执行 <code>java -version</code> 查看机器 Java 版本，</p><p><img src="https://img.wshunli.com/Java/Matlab/java-version.png" alt="java-version"></p><h1 id="Matlab-程序打包"><a href="#Matlab-程序打包" class="headerlink" title="Matlab 程序打包"></a>Matlab 程序打包</h1><p>Matlab 支持 C++ 、Java 、.Net 等语言的打包。</p><p>我们将 .m 文件打包为 Java 支持的库，如下图：</p><p><img src="https://img.wshunli.com/Java/Matlab/matlab-package.png" alt="matlab-package"></p><p>感觉和 JVM 虚拟机很类似，Matlab 提供基础环境，我们编写 Matlab 代码即可。</p><h1 id="Java-调用-Matlab-方法"><a href="#Java-调用-Matlab-方法" class="headerlink" title="Java 调用 Matlab 方法"></a>Java 调用 Matlab 方法</h1><p>在 Java 中调用 Matlab 的方法时，有三种方式。</p><p>1、functionName(int arg0, Object… agr1): Object[]</p><p>其中 arg0 表示返回数据的个数，agr1 为数组；返回值也是数组。</p><p>2、functionName(List arg0, List agr1): void</p><p>其中 arg0 、agr1 为列表；返回值为空。</p><p>3、functionName(Object[] arg0, Object[] agr1): void</p><p>其中 arg0 、agr1 为数组；返回值为空。</p><h2 id="方式一，输入返回个数"><a href="#方式一，输入返回个数" class="headerlink" title="方式一，输入返回个数"></a>方式一，输入返回个数</h2><pre><code class="lang-Java">// 定义输出结果  Object[] results = null;  Magic magic = new Magic(); // 实例化 // &#39;2&#39; 表示 2 个输出结果，类似 results=new Object[2];  // &#39;5&#39; 表示输入的参数 results = magic.makesqr(2, 5);  // 输出第一个返回内容  System.out.println(results[0]);  // 输出第二个返回内容  System.out.println(results[1]);</code></pre><h2 id="方式二，列表参数"><a href="#方式二，列表参数" class="headerlink" title="方式二，列表参数"></a>方式二，列表参数</h2><pre><code class="lang-Java">// 定义结果List  List&lt;Object&gt; results = new ArrayList&lt;Object&gt;(2);  // 定义参数List  List&lt;Object&gt; inputs = new ArrayList&lt;Object&gt;(1);  Magic magic = null;  magic = new Magic();  // 注意:结果List要预先加入内容，Null即可  results.add(null);  results.add(null);  // 输入的参数  inputs.add(5);  // 调用方法  magic.makesqr(results, inputs);  // 显示结果  System.out.println(results.get(0));  System.out.println(results.get(1));</code></pre><h2 id="方式三，数组参数"><a href="#方式三，数组参数" class="headerlink" title="方式三，数组参数"></a>方式三，数组参数</h2><pre><code class="lang-Java">// 注意：定义输出结果的时候，要定义数组大小  Object[] results = new Object[2];  Magic magic = null;  magic = new Magic();  // 这种方式，第二参数必须为数组，而不能为可变数组  Object[] inputs = new Object[]{5};  magic.makesqr(results, inputs);  // 输出第一个返回内容  System.out.println(results[0]);  // 输出第二个返回内容  System.out.println(results[1]);</code></pre><h1 id="Java-与-Matlab-数据转换"><a href="#Java-与-Matlab-数据转换" class="headerlink" title="Java 与 Matlab 数据转换"></a>Java 与 Matlab 数据转换</h1><p>数据转换内容比较多，这里主要介绍<strong>数组</strong>的转换。</p><p>1、将 Java 数据转化为 Matlab 数据</p><p>这里以输入 <a href="https://ww2.mathworks.cn/help/javabuilder/MWArrayAPI/com/mathworks/toolbox/javabuilder/MWNumericArray.html" rel="external nofollow noopener noreferrer" target="_blank">MWNumericArray</a> 数据为例</p><p>使用 newInstance 方法实例化</p><pre><code class="lang-Java">//new int[]{11,2} 代表矩阵为 11 行 2 列的矩阵//MWClassID.DOUBLE 代表矩阵中数为 double 类型，MWComplexity.REAL 代表矩阵中是实数MWNumericArray f = MWNumericArray.newInstance(new int[]{11,2}, MWClassID.DOUBLE, MWComplexity.REAL);MWNumericArray f = MWNumericArray.newInstance(new int[]{11,2}, data, MWClassID.DOUBLE);</code></pre><p>另外一种方式：</p><pre><code class="lang-Java">int[] dims = {3, 6};double[] Adata = {1, 7, 13, 2, 8, 14, 3, 9, 15, 4, 10, 16, 5, 11, 17, 6, 12, 18};MWNumericArray A = MWNumericArray.newInstance(dims, Adata, MWClassID.DOUBLE);System.out.println(&quot;A = &quot;);System.out.println(A);</code></pre><p>2、将 Matlab 数据转化为 Java 数据</p><p>这里以返回 <a href="https://www.mathworks.com/help/javabuilder/MWArrayAPI/com/mathworks/toolbox/javabuilder/MWCellArray.html" rel="external nofollow noopener noreferrer" target="_blank">MWCellArray</a> 数据为例</p><pre><code class="lang-Java">MWCellArray cellArray = (MWCellArray) result[0];double[] output = new double[cellArray.numberOfElements()];for (int i = 1; i &lt;= cellArray.numberOfElements(); i++) {    output[i - 1] = ((double[][]) cellArray.get(i))[0][0];}System.out.print(&quot;输出数据：&quot;);System.out.println(Arrays.toString(output));</code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>输入数据为 <code>17行1列</code> 的 MWNumericArray 数据，返回 <code>1行15列</code> 的 MWCellArray 数据。</p><pre><code class="lang-Java">System.out.println(&quot;Running the JAVA client application!!&quot;);AiNet cls = null; // 调用对象MWNumericArray input = null; // 输入Object[] result = new Object[1]; // 输出结果double[] data = new double[]{ // 初始数据        3.43300000000000,        3.40500000000000,        3.37200000000000,        3.35700000000000,        3.34800000000000,        3.31500000000000,        3.28800000000000,        3.28000000000000,        3.26800000000000,        3.24600000000000,        3.23900000000000,        3.24600000000000,        3.25800000000000,        3.27100000000000,        3.28200000000000,        3.28600000000000,        3.30000000000000};input = MWNumericArray.newInstance(new int[]{17, 1}, data, MWClassID.DOUBLE);System.out.print(&quot;输入数据：&quot;);System.out.println(Arrays.toString(input.getDoubleData()));try {    cls = new AiNet();    result = cls.Net(1, input);    MWCellArray cellArray = (MWCellArray) result[0];    double[] output = new double[cellArray.numberOfElements()];    for (int i = 1; i &lt;= cellArray.numberOfElements(); i++) {        output[i - 1] = ((double[][]) cellArray.get(i))[0][0];    }    System.out.print(&quot;输出数据：&quot;);    System.out.println(Arrays.toString(output));    MWArray.disposeArray(output);} catch (MWException e) {    e.printStackTrace();} finally {    MWArray.disposeArray(input);    MWArray.disposeArray(result);    if (cls != null) {        cls.dispose();    }}</code></pre><p>注意使用 MWArray.disposeArray() 方法释放资源。</p><blockquote><p>参考资料<br>1、Java调用MATLAB - 窃·格瓦拉 - CSDN博客<br><a href="https://blog.csdn.net/golden1314521/article/details/43526581" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/golden1314521/article/details/43526581</a><br>2、Java调用Matlab方法的三种方式 - 非技术流 - ITeye博客<br><a href="http://xiaolongfeixiang.iteye.com/blog/1893621" rel="external nofollow noopener noreferrer" target="_blank">http://xiaolongfeixiang.iteye.com/blog/1893621</a><br>3、ML02<em>09_calling_java_from_MATLAB_CH.ppt<br><a href="http://read.pudn.com/downloads85/doc/329263/matlab%E8%AE%B2%E4%B9%89/ML02(11-28)/ML02_09_calling_java_from_MATLAB_CH.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://read.pudn.com/downloads85/doc/329263/matlab%E8%AE%B2%E4%B9%89/ML02(11-28)/ML02_09_calling_java_from_MATLAB_CH.pdf</a><br>4、Java调用Matlab程序 - 移动的天坑的个人空间 - 开源中国<br><a href="https://my.oschina.net/pierrecai/blog/829641" rel="external nofollow noopener noreferrer" target="_blank">https://my.oschina.net/pierrecai/blog/829641</a><br>5、JAVA调用matlab程序 输入输出数据转换 - 简书<br><a href="https://www.jianshu.com/p/c008bd9d5a25" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c008bd9d5a25</a><br>6、(1)在java中使用matlab的函数</em>东东-forest_新浪博客<br><a href="http://blog.sina.com.cn/s/blog_86aea377010171yq.html" rel="external nofollow noopener noreferrer" target="_blank">http://blog.sina.com.cn/s/blog_86aea377010171yq.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Java 调用 Matlab 程序（Java 和 Matlab 混合编程）流程方法。&lt;/p&gt;&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;p&gt;1、 Java 
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="Matlab" scheme="https://www.wshunli.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Glide 图片加载框架源码解析</title>
    <link href="https://www.wshunli.com/posts/c47606cc.html"/>
    <id>https://www.wshunli.com/posts/c47606cc.html</id>
    <published>2018-09-17T05:18:23.000Z</published>
    <updated>2019-01-04T09:27:07.545Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。<strong>本文内容基于 Glide 4.7.1 版本</strong>。</p><p>Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、可扩展的图片解码管道，以及自动的资源池技术。<a href="https://muyangmin.github.io/glide-docs-cn/" rel="external nofollow noopener noreferrer" target="_blank">https://muyangmin.github.io/glide-docs-cn/</a></p><p>Glide 支持拉取，解码和展示视频快照，图片，和 GIF 动画。Glide 的 API 是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide 使用的是一个定制化的基于 HttpUrlConnection 的栈，但同时也提供了与 Google Volley 和 Square OkHttp 快速集成的工具库。</p><h1 id="Glide-的简单使用"><a href="#Glide-的简单使用" class="headerlink" title="Glide 的简单使用"></a>Glide 的简单使用</h1><p>前面有比较详细的介绍，这里不再赘述。</p><p>Android 图片加载框架 Glide 简单使用 | CirGIS</p><p><a href="https://www.wshunli.com/posts/d82d8606.html">https://www.wshunli.com/posts/d82d8606.html</a></p><h1 id="Glide-的源码解析"><a href="#Glide-的源码解析" class="headerlink" title="Glide 的源码解析"></a>Glide 的源码解析</h1><p>1、我们先看 Glide 的 with() 方法</p><pre><code class="lang-Java">  @NonNull  public static RequestManager with(@NonNull Context context) {    return getRetriever(context).get(context);  }  @NonNull  public static RequestManager with(@NonNull Activity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull FragmentActivity activity) {    return getRetriever(activity).get(activity);  }  @NonNull  public static RequestManager with(@NonNull Fragment fragment) {    return getRetriever(fragment.getActivity()).get(fragment);  }  @NonNull  public static RequestManager with(@NonNull View view) {    return getRetriever(view.getContext()).get(view);  }</code></pre><p>未完待续。。</p><blockquote><p>参考资料<br>1、Glide源码分析 | lightSky’Blog<br><a href="http://www.lightskystreet.com/2015/10/12/glide_source_analysis/" rel="external nofollow noopener noreferrer" target="_blank">http://www.lightskystreet.com/2015/10/12/glide_source_analysis/</a><br>2、Android Glide源码解析 - 简书<br><a href="https://www.jianshu.com/p/0c383eaa5675" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c383eaa5675</a><br>3、Android Glide源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/10/10/android-glide/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/10/10/android-glide/</a><br>4、Android源码分析：手把手带你分析 Glide的缓存功能 - CSDN博客<br><a href="https://blog.csdn.net/carson_ho/article/details/79256892" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/carson_ho/article/details/79256892</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Glide 图片加载框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Glide 4.7.1 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Glide 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。Glide 提供了易用的 API，高性能、可
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="Glide" scheme="https://www.wshunli.com/tags/Glide/"/>
    
      <category term="图片加载" scheme="https://www.wshunli.com/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/2bda06ba.html"/>
    <id>https://www.wshunli.com/posts/2bda06ba.html</id>
    <published>2018-09-16T01:38:40.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 Retrofit 2.4.0 版本</strong>。</p><p>Type-safe HTTP client for Android and Java by Square, Inc. <a href="http://square.github.io/retrofit/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/retrofit/</a></p><p>前面介绍过 OkHttp ，Retrofit 是对 OkHttp 网络请求框架的封装，前者专注于接口的封装，后者专注于真正的网络请求。</p><p><img src="https://img.wshunli.com/Android/Retrofit/Retrofit_OkHttp.png" alt="封装流程图"></p><p>应用程序通过 Retrofit 请求网络，实际上是由 Retrofit 接口层封装请求参数、Header、Url 等信息，由 OkHttp 完成实际的请求操作；在服务端返回数据后，OkHttp 将原始的结果交给 Retrofit，Retrofit 根据用户的需求对结果进行解析。</p><h1 id="Retrofit-的简单使用"><a href="#Retrofit-的简单使用" class="headerlink" title="Retrofit 的简单使用"></a>Retrofit 的简单使用</h1><p>参考官网的介绍：</p><p>1、创建 HTTP API 接口</p><pre><code class="lang-Java">public interface GitHubService {  @GET(&quot;users/{user}/repos&quot;)  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><p>2、创建 Retrofit 实例，并实现接口实例</p><pre><code class="lang-Java">Retrofit retrofit = new Retrofit.Builder()    .baseUrl(&quot;https://api.github.com/&quot;)    .build();GitHubService service = retrofit.create(GitHubService.class);</code></pre><p>3、创建请求实例</p><pre><code class="lang-Java">Call&lt;List&lt;Repo&gt;&gt; call = service.listRepos(&quot;wshunli&quot;);</code></pre><p>4、发送网络请求</p><pre><code class="lang-Java">// 同步请求call.execute();// 异步请求call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() {    @Override    public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) {    }    @Override    public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) {        Log.d(TAG, &quot;onFailure: &quot;);    }});</code></pre><p>和 OkHttp 流程差不多，特别是发送请求方法名字都没有变。</p><h1 id="Retrofit-的源码分析"><a href="#Retrofit-的源码分析" class="headerlink" title="Retrofit 的源码分析"></a>Retrofit 的源码分析</h1><p>Retrofit 网络请求完整的流程图如下：</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_full_process.min.png" alt="Retrofit 流程图"></p><p>下面详细介绍。</p><h2 id="创建-Retrofit-实例"><a href="#创建-Retrofit-实例" class="headerlink" title="创建 Retrofit 实例"></a>创建 Retrofit 实例</h2><p>Retrofit 实例化，也是使用的建造者模式。</p><p><img src="https://img.wshunli.com/Android/Retrofit/retrofit_builder.png" alt="retrofit_builder"></p><p>我们先看 Builder 成员变量的含义：</p><pre><code class="lang-Java">// Retrofit#Builderpublic static final class Builder {// 当前系统环境private final Platform platform;// 网络请求器的工厂private @Nullable okhttp3.Call.Factory callFactory;// 网络请求地址private HttpUrl baseUrl;// 数据转换器工厂集合private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();// 网络请求适配器工厂集合private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();// 回调方法执行器private @Nullable Executor callbackExecutor;// 标志位private boolean validateEagerly;</code></pre><p>1、首先构造函数中通过 <code>Platform.get()</code> 初始化了平台参数</p><pre><code class="lang-Java">Builder(Platform platform) {    this.platform = platform;}public Builder() {    this(Platform.get());}Builder(Retrofit retrofit) {    platform = Platform.get();    callFactory = retrofit.callFactory;    baseUrl = retrofit.baseUrl;    converterFactories.addAll(retrofit.converterFactories);    // Remove the default BuiltInConverters instance added by build().    converterFactories.remove(0);    callAdapterFactories.addAll(retrofit.callAdapterFactories);    // Remove the default, platform-aware call adapter added by build().    callAdapterFactories.remove(callAdapterFactories.size() - 1);    callbackExecutor = retrofit.callbackExecutor;    validateEagerly = retrofit.validateEagerly;}</code></pre><p>我们可以看下判断方法：</p><pre><code class="lang-Java">// Platformclass Platform {  private static final Platform PLATFORM = findPlatform();  static Platform get() {    return PLATFORM;  }  private static Platform findPlatform() {    try {      Class.forName(&quot;android.os.Build&quot;);      if (Build.VERSION.SDK_INT != 0) {        return new Android();      }    } catch (ClassNotFoundException ignored) {    }    try {      Class.forName(&quot;java.util.Optional&quot;);      return new Java8();    } catch (ClassNotFoundException ignored) {    }    return new Platform();  }  /* 省略部分无关代码 */}</code></pre><p>后面如果有需要，我们也可以直接拷贝。</p><p>2、然后设置 Retrofit 所需的参数即可</p><pre><code class="lang-Java">public Builder baseUrl(String baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    HttpUrl httpUrl = HttpUrl.parse(baseUrl);    if (httpUrl == null) {    throw new IllegalArgumentException(&quot;Illegal URL: &quot; + baseUrl);    }    return baseUrl(httpUrl);}public Builder baseUrl(HttpUrl baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    List&lt;String&gt; pathSegments = baseUrl.pathSegments();    if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) {    throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl);    }    this.baseUrl = baseUrl;    return this;}/** Add converter factory for serialization and deserialization of objects. */public Builder addConverterFactory(Converter.Factory factory) {    converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}public Builder addCallAdapterFactory(CallAdapter.Factory factory) {    callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;));    return this;}</code></pre><p>3、最后是 build() 方法</p><pre><code class="lang-Java">public Retrofit build() {    if (baseUrl == null) {    throw new IllegalStateException(&quot;Base URL required.&quot;);    }    okhttp3.Call.Factory callFactory = this.callFactory;    if (callFactory == null) {    callFactory = new OkHttpClient();    }    Executor callbackExecutor = this.callbackExecutor;    if (callbackExecutor == null) {    callbackExecutor = platform.defaultCallbackExecutor();    }    // Make a defensive copy of the adapters and add the default Call adapter.    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);    callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));    // Make a defensive copy of the converters.    List&lt;Converter.Factory&gt; converterFactories =        new ArrayList&lt;&gt;(1 + this.converterFactories.size());    // Add the built-in converter factory first. This prevents overriding its behavior but also    // ensures correct behavior when using converters that consume all types.    converterFactories.add(new BuiltInConverters());    converterFactories.addAll(this.converterFactories);    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);}</code></pre><h2 id="创建-API-实例"><a href="#创建-API-实例" class="headerlink" title="创建 API 实例"></a>创建 API 实例</h2><p>获取 API 实例使用 Retrofit 的 <code>create()</code> 方法</p><pre><code class="lang-Java">// Retrofit#create()public &lt;T&gt; T create(final Class&lt;T&gt; service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {        eagerlyValidateMethods(service);    }    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },        new InvocationHandler() {            private final Platform platform = Platform.get();            @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)                throws Throwable {            // If the method is a method from Object then defer to normal invocation.            if (method.getDeclaringClass() == Object.class) {                return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {                return platform.invokeDefaultMethod(method, service, proxy, args);            }            ServiceMethod&lt;Object, Object&gt; serviceMethod =                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);            OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);            return serviceMethod.adapt(okHttpCall);            }        });}</code></pre><p>创建 API 实例使用的是 <strong>动态代理</strong> 设计模式。</p><h2 id="创建请求实例"><a href="#创建请求实例" class="headerlink" title="创建请求实例"></a>创建请求实例</h2><p>创建请求实例，跟钱买你的动态代理有关。</p><pre><code class="lang-Java">// Retrofit#create()ServiceMethod&lt;Object, Object&gt; serviceMethod =    (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.adapt(okHttpCall);</code></pre><p>1、<code>loadServiceMethod()</code> 方法</p><p>一个 <code>ServiceMethod</code> 对应于一个 API 接口的一个方法，<code>loadServiceMethod()</code> 方法负责加载 <code>ServiceMethod</code></p><pre><code class="lang-Java">// Retrofit#loadServiceMethod()ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) {    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) {        result = serviceMethodCache.get(method);        if (result == null) {        result = new ServiceMethod.Builder&lt;&gt;(this, method).build();        serviceMethodCache.put(method, result);        }    }    return result;}</code></pre><p>2、<code>OkHttpCall</code> 类</p><p><code>OkHttpCall</code> 实现了 <code>retrofit2.Call</code> ，我们通常会使用它的 <code>execute()</code> 和 <code>enqueue()</code> 接口。</p><pre><code class="lang-Java">OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) {    this.serviceMethod = serviceMethod;    this.args = args;}</code></pre><p>构造方法也没有什么好看的。</p><h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>发送网络请求其实也就是 <code>OkHttpCall</code> 类中的方法。</p><p>1、<strong>同步请求</strong> 使用 <code>execute()</code> 方法</p><pre><code class="lang-Java">// OkHttpCall#execute()@Override public Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        if (creationFailure != null) {            if (creationFailure instanceof IOException) {                throw (IOException) creationFailure;            } else if (creationFailure instanceof RuntimeException) {                throw (RuntimeException) creationFailure;            } else {                throw (Error) creationFailure;            }        }        call = rawCall;        if (call == null) {            try {                call = rawCall = createRawCall();            } catch (IOException | RuntimeException | Error e) {                throwIfFatal(e); //  Do not assign a fatal error to creationFailure.                creationFailure = e;                throw e;            }        }    }    if (canceled) {        call.cancel();    }    return parseResponse(call.execute());}</code></pre><p>这里就是 Retrofit 和 OkHttp 交互的核心了，分为三步：</p><p>（1）创建 <code>okhttp3.Call</code> ，包括构造参数</p><pre><code class="lang-Java">private okhttp3.Call createRawCall() throws IOException {    okhttp3.Call call = serviceMethod.toCall(args);    if (call == null) {        throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    }    return call;}</code></pre><p>（2）执行网络请求，也就是 OkHttp 的同步网络请求</p><pre><code class="lang-Java">call.execute()</code></pre><p>（3）解析返回的结果</p><pre><code class="lang-Java">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {    ResponseBody rawBody = rawResponse.body();    // Remove the body&#39;s source (the only stateful object) so we can pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))        .build();    int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) {        try {        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);        } finally {        rawBody.close();        }    }    if (code == 204 || code == 205) {        rawBody.close();        return Response.success(null, rawResponse);    }    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);    try {        T body = serviceMethod.toResponse(catchingBody);        return Response.success(body, rawResponse);    } catch (RuntimeException e) {        // If the underlying source threw an exception, propagate that rather than indicating it was        // a runtime exception.        catchingBody.throwIfCaught();        throw e;    }}</code></pre><p>2、<strong>异步请求</strong> 使用 <code>enqueue()</code> 方法</p><pre><code class="lang-Java">@Override public void enqueue(final Callback&lt;T&gt; callback) {    checkNotNull(callback, &quot;callback == null&quot;);    okhttp3.Call call;    Throwable failure;    synchronized (this) {        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);        executed = true;        call = rawCall;        failure = creationFailure;        if (call == null &amp;&amp; failure == null) {        try {            call = rawCall = createRawCall();        } catch (Throwable t) {            throwIfFatal(t);            failure = creationFailure = t;        }        }    }    if (failure != null) {        callback.onFailure(this, failure);        return;    }    if (canceled) {        call.cancel();    }    call.enqueue(new okhttp3.Callback() {        @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {        Response&lt;T&gt; response;        try {            response = parseResponse(rawResponse);        } catch (Throwable e) {            callFailure(e);            return;        }        try {            callback.onResponse(OkHttpCall.this, response);        } catch (Throwable t) {            t.printStackTrace();        }        }        @Override public void onFailure(okhttp3.Call call, IOException e) {        callFailure(e);        }        private void callFailure(Throwable e) {        try {            callback.onFailure(OkHttpCall.this, e);        } catch (Throwable t) {            t.printStackTrace();        }        }    });}</code></pre><p>我们可以看到和同步请求是一致的，实际请求交给了 <code>okhttp3.Call#enqueue(Callback responseCallback)</code> 来实现，并在它的 <code>callback</code> 中调用 <code>parseResponse()</code> 解析响应数据，并转发给传入的 <code>callback</code> 。</p><p>Retrofit 源码就先介绍到这里了，后面有机会再详细介绍。</p><blockquote><p>参考资料<br>1、Retrofit分析-漂亮的解耦套路 - 简书<br><a href="https://www.jianshu.com/p/45cb536be2f4" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/45cb536be2f4</a><br>2、Android：手把手带你 深入读懂 Retrofit 2.0 源码 - 简书<br><a href="https://www.jianshu.com/p/0c055ad46b6c" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/0c055ad46b6c</a><br>3、Retrofit源码分析（超详细） - 简书<br><a href="https://www.jianshu.com/p/097947afddaf" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/097947afddaf</a><br>4、拆轮子系列：拆 Retrofit - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/06/25/Understand-Retrofit/</a><br>5、Retrofit源码解析 | mundane的幻想空间<br><a href="https://mundane799699.github.io/2018/03/13/retrofit-analysis/" rel="external nofollow noopener noreferrer" target="_blank">https://mundane799699.github.io/2018/03/13/retrofit-analysis/</a><br>6、Retrofit源码解析 - 掘金<br><a href="https://juejin.im/post/5acee62c6fb9a028df22ffee" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5acee62c6fb9a028df22ffee</a><br>7、Retrofit源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="https://yuqirong.me/2017/08/03/Retrofit源码解析/" rel="external nofollow noopener noreferrer" target="_blank">https://yuqirong.me/2017/08/03/Retrofit源码解析/</a><br>8、android-cn/android-open-project-analysis<br><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit</a><br>9、【Android】Retrofit源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79933220" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79933220</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 Retrofit 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 Retrofit 2.4.0 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Type-safe HTTP client for Android and Java by Square, In
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Retrofit" scheme="https://www.wshunli.com/tags/Retrofit/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 网络框架源码解析</title>
    <link href="https://www.wshunli.com/posts/5bd2f229.html"/>
    <id>https://www.wshunli.com/posts/5bd2f229.html</id>
    <published>2018-09-13T08:28:11.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。<strong>本文内容基于 OkHttp 3.11.0 版本</strong>。</p><p>网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。</p><p>只是停留在应用层面，会使用一些框架是不行的，还需要深入源码、剖析结构。</p><p>An HTTP+HTTP/2 client for Android and Java applications. <a href="http://square.github.io/okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://square.github.io/okhttp/</a></p><blockquote><p>支持 HTTP/2 协议，允许连接到同一个主机地址的所有请求共享 Socket 。<br>在 HTTP/2 协议不可用的情况下，通过连接池减少请求的延迟。<br>支持 GZip 透明压缩，减少传输的数据包大小。<br>支持响应缓存，避免同一个重复的网络请求。</p></blockquote><h1 id="OkHttp-的简单使用"><a href="#OkHttp-的简单使用" class="headerlink" title="OkHttp 的简单使用"></a>OkHttp 的简单使用</h1><p>一般情况下，对于网络框架有两种常见的使用场景，同步请求和异步请求。</p><p><strong>同步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();Log.d(TAG, &quot;onCreate: &quot; + response.body().string());</code></pre><p><strong>异步请求</strong>：</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {        Log.d(TAG, &quot;onCreate: &quot; + response.body().string());    }});</code></pre><p>同步请求和异步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><h1 id="OkHttp-的源码分析"><a href="#OkHttp-的源码分析" class="headerlink" title="OkHttp 的源码分析"></a>OkHttp 的源码分析</h1><p>OkHttp 网络请求完整的流程图如下：</p><div align="center"><img src="https://img.wshunli.com/Android/OkHttp/okhttp_full_process.min.png" title="OkHttp 流程图" alt="OkHttp 流程图"></div><p>下面详细介绍。</p><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步请求，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，最后执行 execute() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);Response response = call.execute();</code></pre><h3 id="创建-OkHttpClient-对象"><a href="#创建-OkHttpClient-对象" class="headerlink" title="创建 OkHttpClient 对象"></a>创建 OkHttpClient 对象</h3><p>我们先看 OkHttp 的构造函数：</p><pre><code class="lang-Java">public OkHttpClient() {  this(new Builder());}</code></pre><p>这里是直接实例化，实质上是使用 <strong>建造者模式</strong> 构建 OkHttpClient 实例。</p><p>下面是 OkHttpClient 内部类 Builder 的构造方法：</p><pre><code class="lang-Java">public Builder() {  dispatcher = new Dispatcher();  protocols = DEFAULT_PROTOCOLS;  connectionSpecs = DEFAULT_CONNECTION_SPECS;  eventListenerFactory = EventListener.factory(EventListener.NONE);  proxySelector = ProxySelector.getDefault();  cookieJar = CookieJar.NO_COOKIES;  socketFactory = SocketFactory.getDefault();  hostnameVerifier = OkHostnameVerifier.INSTANCE;  certificatePinner = CertificatePinner.DEFAULT;  proxyAuthenticator = Authenticator.NONE;  authenticator = Authenticator.NONE;  connectionPool = new ConnectionPool();  dns = Dns.SYSTEM;  followSslRedirects = true;  followRedirects = true;  retryOnConnectionFailure = true;  connectTimeout = 10_000;  readTimeout = 10_000;  writeTimeout = 10_000;  pingInterval = 0;}public OkHttpClient build() {  return new OkHttpClient(this);}</code></pre><p>这里 <code>OkHttpClient.Builder</code> 有很多参数，后面再介绍。</p><h3 id="创建-Request-对象"><a href="#创建-Request-对象" class="headerlink" title="创建 Request 对象"></a>创建 Request 对象</h3><p>和 OkHttpClient 类似，Request 也是是使用 <strong>建造者模式</strong> 创建实例。</p><pre><code class="lang-Java">public Builder() {  this.method = &quot;GET&quot;;  this.headers = new Headers.Builder();}public Request build() {  if (url == null) throw new IllegalStateException(&quot;url == null&quot;);  return new Request(this);}</code></pre><p>其中配置默认请求方法为 <code>GET</code> ，还有一些头部的默认参数。</p><h3 id="创建-Call-对象"><a href="#创建-Call-对象" class="headerlink" title="创建 Call 对象"></a>创建 Call 对象</h3><p>OkHttpClient 实现了 <code>Call.Factory</code> ，负责根据请求创建新的 Call 对象。</p><pre><code class="lang-Java">@Override public Call newCall(Request request) {  return RealCall.newRealCall(this, request, false /* for web socket */);}</code></pre><p>Call 只是个接口，实际是实例化的 RealCall 对象。</p><pre><code class="lang-Java">private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  this.client = client;  this.originalRequest = originalRequest;  this.forWebSocket = forWebSocket;  this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);}static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {  // Safely publish the Call instance to the EventListener.  RealCall call = new RealCall(client, originalRequest, forWebSocket);  call.eventListener = client.eventListenerFactory().create(call);  return call;}</code></pre><h3 id="发送同步网络请求"><a href="#发送同步网络请求" class="headerlink" title="发送同步网络请求"></a>发送同步网络请求</h3><p>发送请求也是在 <code>RealCall</code> 的 <code>execute()</code> 方法中执行的。</p><pre><code class="lang-Java">// RealCall#execute()@Override public Response execute() throws IOException {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  try {    client.dispatcher().executed(this);    Response result = getResponseWithInterceptorChain();    if (result == null) throw new IOException(&quot;Canceled&quot;);    return result;  } catch (IOException e) {    eventListener.callFailed(this, e);    throw e;  } finally {    client.dispatcher().finished(this);  }}</code></pre><p>在这里主要做了四件事：</p><p>1、检查 Call 是否执行过，没有执行将 <code>executed</code> 赋值为 true ，保证每个请求只执行一次；<br>2、使用 <code>client.dispatcher().executed(this)</code> 来进行实际的请求；<br>3、调用 <code>getResponseWithInterceptorChain()</code> 方法，获取请求响应的结果；<br>4、最后 <code>dispatcher</code> 结束自己。</p><pre><code class="lang-Java">// Dispatcher#executed()/** Used by {@code Call#execute} to signal it is in-flight. */synchronized void executed(RealCall call) {  runningSyncCalls.add(call);}</code></pre><p>在同步请求中 <code>dispatcher</code> 只是负责判断请求执行的状态，在异步请求中参与内容过多。</p><p>下面我们来看 <code>getResponseWithInterceptorChain()</code> 方法：</p><pre><code class="lang-Java">Response getResponseWithInterceptorChain() throws IOException {  // Build a full stack of interceptors.  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();  interceptors.addAll(client.interceptors()); // 加入用户自定义的拦截器  interceptors.add(retryAndFollowUpInterceptor); // 重试和重定向拦截器  interceptors.add(new BridgeInterceptor(client.cookieJar())); // 加入转化请求响应的拦截器  interceptors.add(new CacheInterceptor(client.internalCache())); // 加入缓存拦截器  interceptors.add(new ConnectInterceptor(client)); // 加入连接拦截器  if (!forWebSocket) {      interceptors.addAll(client.networkInterceptors()); // 加入用户自定义的网络拦截器  }  interceptors.add(new CallServerInterceptor(forWebSocket)); // 加入请求响应的拦截器  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,          originalRequest, this, eventListener, client.readTimeoutMillis());  // 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象  return chain.proceed(originalRequest);}</code></pre><p>我们都知道，拦截器是 OkHttp 的精髓。</p><p>1、<code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；<br>2、<code>RetryAndFollowUpInterceptor</code> 是用来重试和重定向的拦截器，在下面我们会讲到；<br>3、<code>BridgeInterceptor</code> 是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；<br>4、<code>CacheInterceptor</code> 是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；<br>5、<code>ConnectInterceptor</code> 用来建立连接的拦截器；<br>6、<code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ；<br>7、<code>CallServerInterceptor</code>是真正向服务器发出请求且得到响应的拦截器；</p><p>最后在聚合了这些拦截器后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器，利用的就是 <strong>责任链模式</strong> 。</p><font font="" size="3" color="#FF0000">下面介绍 OkHttp 中的 拦截器</font><p>拦截器 <code>Interceptor</code> 是 OkHttp 的核心，<strong>实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来</strong>，每一个功能都只是一个 <code>Interceptor</code>，它们再连接成一个 <code>Interceptor.Chain</code>，环环相扣，最终圆满完成一次网络请求。</p><div align="center"><img src="https://img.wshunli.com/Android/OkHttp/okhttp_interceptors.jpg" title="OkHttp 拦截器" alt="OkHttp 拦截器"></div><p>1、<code>RealInterceptorChain</code> 拦截器链</p><p>拦截器链 <code>RealInterceptorChain</code> 是真正把这些拦截器串起来的一个角色，调用 <code>proceed()</code> 方法</p><pre><code class="lang-Java">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,    RealConnection connection) throws IOException {  if (index &gt;= interceptors.size()) throw new AssertionError();  calls++;  // If we already have a stream, confirm that the incoming request will use it.  if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must retain the same host and port&quot;);  }  // If we already have a stream, confirm that this is the only call to chain.proceed().  if (this.httpCodec != null &amp;&amp; calls &gt; 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must call proceed() exactly once&quot;);  }  // Call the next interceptor in the chain.  // 得到下一次对应的 RealInterceptorChain  RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,      connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,      writeTimeout);  // 当前次数的 interceptor  Interceptor interceptor = interceptors.get(index);  // 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法  Response response = interceptor.intercept(next);  // Confirm that the next interceptor made its required call to chain.proceed().  // 确认下一次的 interceptor 调用过 chain.proceed()  if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptor        + &quot; must call proceed() exactly once&quot;);  }  // Confirm that the intercepted response isn&#39;t null.  if (response == null) {    throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);  }  if (response.body() == null) {    throw new IllegalStateException(        &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);  }  return response;}</code></pre><p>在代码中是一次次链式调用拦截器。</p><p>2、<code>RetryAndFollowUpInterceptor</code> 重试和重定向的拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request request = chain.request();  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Call call = realChain.call();  EventListener eventListener = realChain.eventListener();  StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),      createAddress(request.url()), call, eventListener, callStackTrace);  this.streamAllocation = streamAllocation;  int followUpCount = 0;  Response priorResponse = null;  while (true) {    // 如果取消，就释放资源    if (canceled) {      streamAllocation.release();      throw new IOException(&quot;Canceled&quot;);    }    Response response;    boolean releaseConnection = true;    try {      // 调用下一个拦截器      response = realChain.proceed(request, streamAllocation, null, null);      releaseConnection = false;    } catch (RouteException e) {      // The attempt to connect via a route failed. The request will not have been sent.      // 路由连接失败，请求将不会被发送      if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {        throw e.getFirstConnectException();      }      releaseConnection = false;      continue;    } catch (IOException e) {      // An attempt to communicate with a server failed. The request may have been sent.      // 服务器连接失败，请求可能已被发送      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);      if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;      releaseConnection = false;      continue;    } finally {      // We&#39;re throwing an unchecked exception. Release any resources.      // 抛出未检查的异常，释放资源      if (releaseConnection) {        streamAllocation.streamFailed(null);        streamAllocation.release();      }    }    // Attach the prior response if it exists. Such responses never have a body.    if (priorResponse != null) {      response = response.newBuilder()          .priorResponse(priorResponse.newBuilder()                  .body(null)                  .build())          .build();    }    // 如果不需要重定向，那么 followUp 为空，会根据响应码判断    Request followUp;    try {      followUp = followUpRequest(response, streamAllocation.route());    } catch (IOException e) {      streamAllocation.release();      throw e;    }    // 释放资源，返回 response    if (followUp == null) {      if (!forWebSocket) {        streamAllocation.release();      }      return response;    }    // 关闭 response 的 body    closeQuietly(response.body());    if (++followUpCount &gt; MAX_FOLLOW_UPS) {      streamAllocation.release();      throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);    }    if (followUp.body() instanceof UnrepeatableRequestBody) {      streamAllocation.release();      throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());    }    // response 和 followUp 比较是否为同一个连接    // 若为重定向就销毁旧连接，创建新连接    if (!sameConnection(response, followUp.url())) {      streamAllocation.release();      streamAllocation = new StreamAllocation(client.connectionPool(),          createAddress(followUp.url()), call, eventListener, callStackTrace);      this.streamAllocation = streamAllocation;    } else if (streamAllocation.codec() != null) {      throw new IllegalStateException(&quot;Closing the body of &quot; + response          + &quot; didn&#39;t close its backing stream. Bad interceptor?&quot;);    }    // 将重定向操作得到的新请求设置给 request    request = followUp;    priorResponse = response;  }}</code></pre><p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p><p>3、<code>BridgeInterceptor</code> 桥街和适配拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  Request userRequest = chain.request();  Request.Builder requestBuilder = userRequest.newBuilder();  // 将用户友好的 request 构造为发送给服务器的 request  RequestBody body = userRequest.body();  // 若有请求体，则构造  if (body != null) {    MediaType contentType = body.contentType();    if (contentType != null) {      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());    }    long contentLength = body.contentLength();    if (contentLength != -1) {      requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);    } else {      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);      requestBuilder.removeHeader(&quot;Content-Length&quot;);    }  }  if (userRequest.header(&quot;Host&quot;) == null) {    requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));  }  if (userRequest.header(&quot;Connection&quot;) == null) {    requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);  }  // If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing  // the transfer stream.  // 使用 gzip 压缩  boolean transparentGzip = false;  if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {    transparentGzip = true;    requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);  }  // 设置 cookie  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());  if (!cookies.isEmpty()) {    requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));  }  // 设置 UA  if (userRequest.header(&quot;User-Agent&quot;) == null) {    requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());  }  // 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse  Response networkResponse = chain.proceed(requestBuilder.build());  // 保存 networkResponse 的 cookie  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());  // 将 networkResponse 构造为对用户友好的 response  Response.Builder responseBuilder = networkResponse.newBuilder()      .request(userRequest);  // 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体  if (transparentGzip      &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))      &amp;&amp; HttpHeaders.hasBody(networkResponse)) {    GzipSource responseBody = new GzipSource(networkResponse.body().source());    Headers strippedHeaders = networkResponse.headers().newBuilder()        .removeAll(&quot;Content-Encoding&quot;)        .removeAll(&quot;Content-Length&quot;)        .build();    responseBuilder.headers(strippedHeaders);    String contentType = networkResponse.header(&quot;Content-Type&quot;);    responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));  }  return responseBuilder.build();}</code></pre><p>在 <code>BridgeInterceptor</code> 这一步，先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</p><p>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</p><p>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</p><p>4、<code>CacheInterceptor</code> 缓存拦截器</p><p>分析 <code>CacheInterceptor</code> 拦截器 <code>intercept()</code> 方法的源代码</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {    // 得到 request 对应缓存中的 response    Response cacheCandidate = cache != null            ? cache.get(chain.request())            : null;    // 获取当前时间，会和之前缓存的时间进行比较    long now = System.currentTimeMillis();    // 得到缓存策略    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();    Request networkRequest = strategy.networkRequest;    Response cacheResponse = strategy.cacheResponse;    // 追踪缓存，其实就是计数    if (cache != null) {        cache.trackResponse(strategy);    }    // 缓存不适用，关闭    if (cacheCandidate != null &amp;&amp; cacheResponse == null) {        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&#39;t applicable. Close it.    }    // If we&#39;re forbidden from using the network and the cache is insufficient, fail.    // 禁止网络并且没有缓存的话，返回失败    if (networkRequest == null &amp;&amp; cacheResponse == null) {        return new Response.Builder()                .request(chain.request())                .protocol(Protocol.HTTP_1_1)                .code(504)                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)                .body(Util.EMPTY_RESPONSE)                .sentRequestAtMillis(-1L)                .receivedResponseAtMillis(System.currentTimeMillis())                .build();    }    // If we don&#39;t need the network, we&#39;re done.    // 不用网络请求，返回缓存    if (networkRequest == null) {        return cacheResponse.newBuilder()                .cacheResponse(stripBody(cacheResponse))                .build();    }    Response networkResponse = null;    try {        // 交给下一个拦截器，返回 networkResponse        networkResponse = chain.proceed(networkRequest);    } finally {        // If we&#39;re crashing on I/O or otherwise, don&#39;t leak the cache body.        if (networkResponse == null &amp;&amp; cacheCandidate != null) {            closeQuietly(cacheCandidate.body());        }    }    // 如果我们同时有缓存和 networkResponse ，根据情况使用    if (cacheResponse != null) {        if (networkResponse.code() == HTTP_NOT_MODIFIED) {            Response response = cacheResponse.newBuilder()                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())                    .cacheResponse(stripBody(cacheResponse))                    .networkResponse(stripBody(networkResponse))                    .build();            networkResponse.body().close();            // 更新原来的缓存至最新            // Update the cache after combining headers but before stripping the            // Content-Encoding header (as performed by initContentStream()).            cache.trackConditionalCacheHit();            cache.update(cacheResponse, response);            return response;        } else {            closeQuietly(cacheResponse.body());        }    }    Response response = networkResponse.newBuilder()            .cacheResponse(stripBody(cacheResponse))            .networkResponse(stripBody(networkResponse))            .build();    // 保存之前未缓存的缓存    if (cache != null) {        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {            // Offer this request to the cache.            CacheRequest cacheRequest = cache.put(response);            return cacheWritingResponse(cacheRequest, response);        }        if (HttpMethod.invalidatesCache(networkRequest.method())) {            try {                cache.remove(networkRequest);            } catch (IOException ignored) {                // The cache cannot be written.            }        }    }    return response;}</code></pre><p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p><p>5、<code>ConnectInterceptor</code> 拦截器</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Request request = realChain.request();  StreamAllocation streamAllocation = realChain.streamAllocation();  // We need the network to satisfy this request. Possibly for validating a conditional GET.  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);  HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);  RealConnection connection = streamAllocation.connection();  return realChain.proceed(request, streamAllocation, httpCodec, connection);}</code></pre><p>实际上建立连接就是创建了一个 <code>HttpCodec</code> 对象，它是对 <code>HTTP</code> 协议操作的抽象，有两个实现：<code>Http1Codec</code> 和 <code>Http2Codec</code>，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。</p><p>6、<code>CallServerInterceptor</code> 拦截器，发送和接收数据</p><pre><code class="lang-Java">@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  HttpCodec httpCodec = realChain.httpStream();  StreamAllocation streamAllocation = realChain.streamAllocation();  RealConnection connection = (RealConnection) realChain.connection();  Request request = realChain.request();      long sentRequestMillis = System.currentTimeMillis();  // 整理请求头并写入  httpCodec.writeRequestHeaders(request);  Response.Builder responseBuilder = null;  // 检查是否为有 body 的请求方法  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {      // If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100      // Continue&quot; response before transmitting the request body. If we don&#39;t get that, return what      // we did get (such as a 4xx response) without ever transmitting the request body.      // 如果有 Expect: 100-continue 在请求头中，那么要等服务器的响应      if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {          httpCodec.flushRequest();          responseBuilder = httpCodec.readResponseHeaders(true);      }      if (responseBuilder == null) {          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.          // 写入请求体          Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);          request.body().writeTo(bufferedRequestBody);          bufferedRequestBody.close();      } else if (!connection.isMultiplexed()) {          // If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP/1 connection from          // being reused. Otherwise we&#39;re still obligated to transmit the request body to leave the          // connection in a consistent state.          streamAllocation.noNewStreams();      }  }  httpCodec.finishRequest();  // 得到响应头  if (responseBuilder == null) {      responseBuilder = httpCodec.readResponseHeaders(false);  }  // 构造 response  Response response = responseBuilder          .request(request)          .handshake(streamAllocation.connection().handshake())          .sentRequestAtMillis(sentRequestMillis)          .receivedResponseAtMillis(System.currentTimeMillis())          .build();  int code = response.code();  // 如果为 web socket 且状态码是 101 ，那么 body 为空  if (forWebSocket &amp;&amp; code == 101) {      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.      response = response.newBuilder()              .body(Util.EMPTY_RESPONSE)              .build();  } else {      // 读取 body      response = response.newBuilder()              .body(httpCodec.openResponseBody(response))              .build();  }  // 如果请求头中有 close 那么断开连接  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))          || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {      streamAllocation.noNewStreams();  }  // 抛出协议异常  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {      throw new ProtocolException(              &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());  }  return response;}</code></pre><p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>和同步请求类似，先实例化 OkHttpClient 和 Request 对象，然后使用 OkHttpClient 对象的 newCall() 方法创建 Call 对象，只不过最后执行 enqueue() 方法，整体和网络请求的思路相似。</p><pre><code class="lang-Java">OkHttpClient okHttpClient = new OkHttpClient.Builder().build();Request request = new Request.Builder().url(&quot;https://wshunli.com&quot;).build();Call call = okHttpClient.newCall(request);call.enqueue(new Callback() {    @Override    public void onFailure(Call call, IOException e) {    }    @Override    public void onResponse(Call call, Response response) throws IOException {    }});</code></pre><p>异步请求在 <code>Callback</code> 回调中获取响应，有 <code>onResponse()</code> 、 <code>onFailure()</code> 两个方法。</p><h3 id="发送异步网络请求"><a href="#发送异步网络请求" class="headerlink" title="发送异步网络请求"></a>发送异步网络请求</h3><p>前面三个步骤完全一致，我们从发送异步网络请求开始，异步请求是调用 <code>RealCall</code> 实例的 <code>enqueue()</code> 方法。。</p><pre><code class="lang-Java">// RealCall#enqueue()@Override public void enqueue(Callback responseCallback) {  synchronized (this) {    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);    executed = true;  }  captureCallStackTrace();  eventListener.callStart(this);  client.dispatcher().enqueue(new AsyncCall(responseCallback));}</code></pre><p>这里使用 <code>Dispatcher</code> 分发器我来处理请求。</p><pre><code class="lang-Java">// Dispatcher#enqueue()synchronized void enqueue(AsyncCall call) {  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {    runningAsyncCalls.add(call);    executorService().execute(call);  } else {    readyAsyncCalls.add(call);  }}</code></pre><p>实质上异步网络请求是在 <code>Dispatcher</code> 中做到任务调度。</p><font font="" size="3" color="#FF0000">下面介绍 OkHttp 中的 任务调度</font><p>我们来看 <code>Dispatcher</code> 类的源代码。</p><pre><code class="lang-Java">public final class Dispatcher {  private int maxRequests = 64;  private int maxRequestsPerHost = 5;  private @Nullable Runnable idleCallback;  /** Executes calls. Created lazily. */  // 线程池的实现  private @Nullable ExecutorService executorService;  /** Ready async calls in the order they&#39;ll be run. */  // 就绪等待网络请求的异步队列  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running asynchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的异步队列  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();  /** Running synchronous calls. Includes canceled calls that haven&#39;t finished yet. */  // 正在执行网络请求的同步队列  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();  public Dispatcher(ExecutorService executorService) {    this.executorService = executorService;  }  public Dispatcher() {  }  // 创建线程池  public synchronized ExecutorService executorService() {    if (executorService == null) {      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,          new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));    }    return executorService;  }  /* 省略部分无关代码*/  synchronized void enqueue(AsyncCall call) {    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {      runningAsyncCalls.add(call);      executorService().execute(call);    } else {      readyAsyncCalls.add(call);    }  }  /* 省略部分无关代码*/}</code></pre><p>异步请求是放在线程池中执行的，如果最大异步请求数小于 64 并且 单个 HOST 的异步请求数小于 5 ，将请求添加到 <code>runningAsyncCalls</code> 中，否则添加到 <code>readyAsyncCalls</code> 中。</p><p>我们来看添加进线程池的 <code>AsyncCall</code> 类，实际上 <code>AsyncCall</code> 是继承自 <code>NamedRunnable</code> 的 <code>RealCall</code> 内部类。<code>NamedRunnable</code> 是实现了 <code>Runnable</code> 接口的抽象类。</p><pre><code class="lang-Java">final class AsyncCall extends NamedRunnable {  private final Callback responseCallback;  AsyncCall(Callback responseCallback) {    super(&quot;OkHttp %s&quot;, redactedUrl());    this.responseCallback = responseCallback;  }  String host() {    return originalRequest.url().host();  }  Request request() {    return originalRequest;  }  RealCall get() {    return RealCall.this;  }  @Override protected void execute() {    boolean signalledCallback = false;    try {      // 和同步请求相同，调用拦截器，得到响应      Response response = getResponseWithInterceptorChain();      if (retryAndFollowUpInterceptor.isCanceled()) {        signalledCallback = true;        responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));      } else {        signalledCallback = true;        responseCallback.onResponse(RealCall.this, response);      }    } catch (IOException e) {      if (signalledCallback) {        // Do not signal the callback twice!        Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);      } else {        eventListener.callFailed(RealCall.this, e);        responseCallback.onFailure(RealCall.this, e);      }    } finally {      // 在 runningAsyncCalls 中移除      client.dispatcher().finished(this);    }  }}</code></pre><p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p><p>不同的是在得到 <code>Response</code> 后，进行结果的回调。</p><p>在 <code>AsyncCall</code> 的最后调用了 <code>Dispatcher</code> 的 <code>finished()</code> 方法。</p><pre><code class="lang-Java">// Dispatcher#finished()/** Used by {@code AsyncCall#run} to signal completion. */void finished(AsyncCall call) {  finished(runningAsyncCalls, call, true);}/** Used by {@code Call#execute} to signal completion. */void finished(RealCall call) {  finished(runningSyncCalls, call, false);}private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) {  int runningCallsCount;  Runnable idleCallback;  synchronized (this) {    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#39;t in-flight!&quot;);    // 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中    if (promoteCalls) promoteCalls();    runningCallsCount = runningCallsCount();    idleCallback = this.idleCallback;  }  if (runningCallsCount == 0 &amp;&amp; idleCallback != null) {    idleCallback.run();  }}</code></pre><p>这里所做的工作就是把执行过的 Call 移除，然后将 <code>readyAsyncCalls</code> 中的 Call 移动到 <code>runningAsyncCalls</code> 中并加入线程池中。</p><blockquote><p>基本上 OkHttp 的请求响应的流程就介绍完了，主要是关于 OkHttp 的 <strong>拦截器链</strong> 和 <strong>任务调度</strong> 原理。</p></blockquote><p>还有很多细节没有涉及，需要花费很大的精力，才能理解分析透彻，后面有机会再介绍。</p><blockquote><p>参考资料：<br>1、拆轮子系列：拆 OkHttp - Piasy的博客 | Piasy Blog<br><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.piasy.com/2016/07/11/Understand-OkHttp/</a><br>2、OkHttp源码解析 | 俞其荣的博客 | Qirong Yu’s Blog<br><a href="http://yuqirong.me/2017/07/25/OkHttp源码解析/" rel="external nofollow noopener noreferrer" target="_blank">http://yuqirong.me/2017/07/25/OkHttp源码解析/</a><br>3、OkHttp源码分析 - 掘金<br><a href="https://juejin.im/post/5af4482951882567286064e6" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5af4482951882567286064e6</a><br>4、okhttp源码分析（一）——基本流程（超详细） - 简书<br><a href="https://www.jianshu.com/p/37e26f4ea57b" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/37e26f4ea57b</a><br>5、OKHttp源码解析 | Frodo’s Blog<br><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" rel="external nofollow noopener noreferrer" target="_blank">http://frodoking.github.io/2015/03/12/android-okhttp/</a><br>6、OkHttp 源码解析（一）：基本流程 - Coding - SegmentFault 思否<br><a href="https://segmentfault.com/a/1190000012656606" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000012656606</a><br>7、【Android】OkHttp源码分析 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/79175824" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/79175824</a><br>8、深入浅出 OkHttp 源码 - DiyCode<br><a href="https://www.diycode.cc/topics/640" rel="external nofollow noopener noreferrer" target="_blank">https://www.diycode.cc/topics/640</a><br>9、Okhttp框架源码分析 - 简书<br><a href="https://www.jianshu.com/p/18a4861600d1" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/18a4861600d1</a><br>10、OkHttp 3.7源码分析（一）——整体架构 - CSDN博客<br><a href="https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/asiaLIYAZHOU/article/details/72598320</a><br>11、okhttp网络框架源码解析 - CSDN博客<br><a href="https://blog.csdn.net/fanguangjun123/article/details/78621585" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/fanguangjun123/article/details/78621585</a><br>12、OKHttp网络框架源码解析（一）okHttp框架同步异步请求流程和源码分析 - CSDN博客<br><a href="https://blog.csdn.net/qq_24675479/article/details/79483193" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_24675479/article/details/79483193</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍 OkHttp 网络框架，包含简单的使用和源码解析。&lt;strong&gt;本文内容基于 OkHttp 3.11.0 版本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;网上关于 OkHttp 源码解析的文章有很多，我在这里参考他们的资料，形成自己的知识体系。&lt;/p&gt;&lt;p&gt;只是停留在应用
      
    
    </summary>
    
      <category term="源码解析" scheme="https://www.wshunli.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://www.wshunli.com/tags/Android/"/>
    
      <category term="源码解析" scheme="https://www.wshunli.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="网络框架" scheme="https://www.wshunli.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
      <category term="OkHttp" scheme="https://www.wshunli.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》编程题目 Java 实现（01-10）</title>
    <link href="https://www.wshunli.com/posts/25842bb5.html"/>
    <id>https://www.wshunli.com/posts/25842bb5.html</id>
    <published>2018-09-11T13:07:05.000Z</published>
    <updated>2019-01-04T09:27:07.553Z</updated>
    
    <content type="html"><![CDATA[<p>《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。</p><p>笔试中的重要性不必多说，面试官还总是喜欢让手写代码。</p><p>1、赋值运算函数</p><p>2、单例设计模式</p><p>在设计模式中有详细的介绍，这里不再赘述，请移步：</p><p><a href="https://www.wshunli.com/posts/d1c4534.html">https://www.wshunli.com/posts/d1c4534.html</a></p><p>3、二维数组中查找目标值</p><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>（1）直接暴力查找</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    for (int[] anArray : array) {        for (int anAnArray : anArray) {            if (anAnArray == target) return true;        }    }    return false;}</code></pre><p>（2）从右上角/左下角的元素出发</p><pre><code class="lang-Java">public boolean Find(int target, int[][] array) {    int row = array.length;    int col = array[0].length;    for (int i = 0, j = col - 1; i &lt; row &amp;&amp; j &gt;= 0; ) {        int value = array[i][j];        if (value == target) return true;        if (value &lt; target) i++;        if (value &gt; target) j--;    }    return false;}</code></pre><p>4、替换字符串中的空格</p><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成 “%20” 。</p></blockquote><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;);}</code></pre><p>这个太偷懒了，不那么偷懒：</p><pre><code class="lang-Java">public String replaceSpace(StringBuffer str) {    StringBuilder builder = new StringBuilder();    String string = str.toString();    for (int i = 0; i &lt; string.length(); i++) {        char charAt = string.charAt(i);        if (charAt == &#39; &#39;) {            builder.append(&quot;%20&quot;);        } else {            builder.append(charAt);        }    }    return builder.toString();}</code></pre><p>5、从尾到头打印链表</p><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList 。</p></blockquote><p>（1）借助堆栈的“后进先出”实现</p><pre><code class="lang-Java">/***    public class ListNode {*        int val;*        ListNode next = null;*        ListNode(int val) {*            this.val = val;*        }*    }*/public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    Stack&lt;Integer&gt; integers = new Stack&lt;&gt;();    while (listNode != null) {        integers.push(listNode.val);        listNode = listNode.next;    }    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (!integers.isEmpty()) {        arrayList.add(integers.pop());    }    return arrayList;}</code></pre><p>（2）借助递归实现</p><pre><code class="lang-Java">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    if (listNode != null) {        this.printListFromTailToHead(listNode.next);        arrayList.add(listNode.val);    }    return arrayList;}</code></pre><p>（3）使用 Collections 的 reverse 方法</p><pre><code class="lang-Java">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();    while (listNode != null) {        arrayList.add(listNode.val);        listNode = listNode.next;    }    Collections.reverse(arrayList);    return arrayList;}</code></pre><p>6、由前序和中序遍历重建二叉树</p><p>7、用两个栈实现队列<br>8、求旋转数组的最小数字<br>9、斐波那契数列的第n项（青蛙跳台阶）<br>10、二进制中1的个数<br>11、数值的整数次方<br>12、打印1到最大的n位数<br>13、O(1)时间删除链表节点<br>14、使数组中的奇数位于偶数前面<br>15、找链表中倒数第K个节点<br>16、输出反转后的链表<br>17、合并两个有序链表<br>18、判断二叉树A中是否包含子树B<br>19、二叉树的镜像<br>20、顺时针打印矩阵<br>21、包含min函数的栈<br>22、判断一个栈是否是另一个栈的弹出序列<br>23、层序遍历二叉树<br>24、后序遍历二叉搜索树<br>25、二叉树中和为某值的路径<br>26、复杂链表的复制<br>27、二叉搜索树转换为双向链表<br>28、打印字符串中所有字符的排列<br>29、数组中出现次数超过一半的数字<br>30、找出最小的K个数<br>31、连续子数组的最大和<br>32、从1到整数n中1出现的次数<br>33、把数组中的数排成一个最小的数<br>34、求第N个丑数<br>35、第一个出现一次的字符<br>36、数组中逆序对的个数<br>37、两个链表的第一个公共节点<br>38、数字在排序数组中出现的次数<br>39、二叉树的深度<br>40、数组中只出现一次的两个数，而其他数都出现两次。<br>41、和为s的连续整数序列<br>42、翻转字符串<br>43、n个骰子的点数及出现的概率44. 扑克牌的顺子<br>44、圆圈中最后剩下的数<br>45、1+2+3+…+n的和<br>46、不用加减乘除做加法<br>47、不能被继承的类<br>48、字符串转换为整数<br>49、树中两个节点的最低公共祖先<br>50、找出重复的数<br>51、构建乘积数组<br>52、正则表达式匹配<br>53、表示数值的字符串<br>54、字符流中第一个不重复的字符<br>55、链表中环的入口节点<br>56、删除链表中重复的节点<br>57、二叉树的下一个节点<br>58、对称的二叉树<br>59、按之字形顺序打印二叉树<br>60、把二叉树打印成多行<br>61、序列化二叉树<br>62、二叉搜索树的第K个节点<br>63、数据流中的中位数<br>64、滑动窗口的最大值<br>65、矩阵中的路径<br>66、机器人的运动范围</p><blockquote><p>参考资料<br>1、剑指Offer<em>编程题</em>牛客网<br><a href="https://www.nowcoder.com/ta/coding-interviews" rel="external nofollow noopener noreferrer" target="_blank">https://www.nowcoder.com/ta/coding-interviews</a><br>2、【剑指offer】Java版代码（完整版） - CSDN博客<br><a href="https://blog.csdn.net/baiye_xing/article/details/78428561" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/baiye_xing/article/details/78428561</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《剑指Offer》编程题目 Java 实现，老是看书学习理论知识不太行，还得动手写代码啊。&lt;/p&gt;&lt;p&gt;笔试中的重要性不必多说，面试官还总是喜欢让手写代码。&lt;/p&gt;&lt;p&gt;1、赋值运算函数&lt;/p&gt;&lt;p&gt;2、单例设计模式&lt;/p&gt;&lt;p&gt;在设计模式中有详细的介绍，这里不再赘述，请移
      
    
    </summary>
    
      <category term="语言基础" scheme="https://www.wshunli.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指Offer》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十四）观察者模式</title>
    <link href="https://www.wshunli.com/posts/58b1d741.html"/>
    <id>https://www.wshunli.com/posts/58b1d741.html</id>
    <published>2018-09-10T12:19:14.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/14.Observer.png" title="观察者模式" alt="观察者模式"></div><p>观察者模式所涉及的角色有：</p><p>(1) 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p><p>(2) 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p><p>(3) 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>(4) 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers(String newState) {        for (Observer observer : list) {            observer.update(newState);        }    }}</code></pre><p>2、具体主题角色类</p><pre><code class="lang-Java">public class ConcreteSubject extends Subject {    private String state;    public String getState() {        return state;    }    public void change(String newState) {        state = newState;        System.out.println(&quot;ConcreteSubject：&quot; + state);        this.nodifyObservers(state);//状态发生改变，通知各个观察者    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(String state);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    private String observerState;//观察者的状态    @Override    public void update(String state) {        /**         * 更新观察者的状态，使其与目标的状态保持一致         */        observerState = state;        System.out.println(&quot;ConcreteObserver：&quot; + observerState);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p>当主题对象的状态改变时，将通知所有观察者，观察者接收到主题对象的通知后，将可以进行其他操作，进行响应。</p><p><strong>推模型和拉模型</strong>：</p><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><p>（1）推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><p>（2）拉模型：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把 <strong>主题对象自身</strong> 通过 update() 方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><p>前面就是典型的推模型，下面介绍拉模型。</p><p>1、抽象主题角色类</p><pre><code class="lang-Java">public abstract class Subject {    private List&lt;Observer&gt; list = new ArrayList&lt;&gt;();    /**     * 注册观察者对象     *     * @param observer 观察者对象     */    public void attach(Observer observer) {        list.add(observer);        System.out.println(&quot;Attached an observer&quot;);    }    /**     * 删除观察者对象     *     * @param observer 观察者对象     */    public void detach(Observer observer) {        list.remove(observer);        System.out.println(&quot;Detached an observer&quot;);    }    /**     * 通知所有注册的观察者对象     */    public void nodifyObservers() {        for (Observer observer : list) {            observer.update(this);        }    }}</code></pre><p>3、抽象观察者角色类</p><pre><code class="lang-Java">public interface Observer {    public void update(Subject subject);}</code></pre><p>4、具体观察者角色类</p><pre><code class="lang-Java">public class ConcreteObserver implements Observer {    @Override    public void update(Subject subject) {        String state = ((ConcreteSubject) subject).getState();        System.out.println(&quot;ConcreteObserver：&quot; + state);    }}</code></pre><p>5、观察者模式的使用</p><pre><code class="lang-Java">public class ObserverPatternMain {    public static void main(String[] args) {        ConcreteSubject subject = new ConcreteSubject();        ConcreteObserver observer = new ConcreteObserver();        subject.attach(observer);        subject.change(&quot;New State&quot;);        subject.detach(observer);        subject.change(&quot;New State&quot;);    }}</code></pre><p><strong>两种模式的比较</strong>：</p><p>（1）推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</p><p>（2）推模型可能会使得观察者对象难以复用，因为观察者的 update() 方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的 update() 方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update() 方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p><p><strong>观察者模式的优缺点</strong>：</p><p>优点：观察者和被观察者是抽象耦合的；建立一套触发机制。<br>缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch14" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch14</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之观察者模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;观察者模式（Observer Pattern）是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。&lt;/p&gt;&lt;h1 id=&quot;观
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十三）享元模式</title>
    <link href="https://www.wshunli.com/posts/180f2df5.html"/>
    <id>https://www.wshunli.com/posts/180f2df5.html</id>
    <published>2018-09-10T10:43:03.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/13.Flyweight.png" title="享元模式" alt="享元模式"></div><p>享元模式所涉及到的角色如下：</p><p>(1) 抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p><p>(2) 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p><p>(3) 享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p><p>1、创建一个接口</p><pre><code class="lang-Java">public interface Shape {    void draw();}</code></pre><p>2、创建实现接口的实体类</p><pre><code class="lang-Java">public class Circle implements Shape {    private String color;    private int x;    private int y;    private int radius;    public Circle(String color) {        this.color = color;    }    public void setX(int x) {        this.x = x;    }    public void setY(int y) {        this.y = y;    }    public void setRadius(int radius) {        this.radius = radius;    }    @Override    public void draw() {        System.out.println(&quot;Circle: Draw() [Color : &quot; + color                + &quot;, x : &quot; + x + &quot;, y :&quot; + y + &quot;, radius :&quot; + radius);    }}</code></pre><p>3、创建一个工厂，生成基于给定信息的实体类的对象</p><pre><code class="lang-Java">public class ShapeFactory {    private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;();    public static Shape getCircle(String color) {        Circle circle = (Circle) circleMap.get(color);        if (circle == null) {            circle = new Circle(color);            circleMap.put(color, circle);            System.out.println(&quot;Creating circle of color : &quot; + color);        }        return circle;    }}</code></pre><p>4、享元模式的使用</p><pre><code class="lang-Java">public class FlyweightPatternMain {    private static final String colors[] =            {&quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot;};    public static void main(String[] args) {        for (int i = 0; i &lt; 20; ++i) {            Circle circle =                    (Circle) ShapeFactory.getCircle(getRandomColor());            circle.setX(getRandomX());            circle.setY(getRandomY());            circle.setRadius(100);            circle.draw();        }    }    private static String getRandomColor() {        return colors[(int) (Math.random() * colors.length)];    }    private static int getRandomX() {        return (int) (Math.random() * 100);    }    private static int getRandomY() {        return (int) (Math.random() * 100);    }}</code></pre><p><strong>享元模式的优缺点</strong>：</p><p>优点：系统有大量相似对象；需要缓冲池的场景。<br>缺点：注意划分外部状态和内部状态，否则可能会引起线程安全问题，这些类必须有一个工厂对象加以控制。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch13" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch13</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之享元模式 - java_my_life - 博客园<br><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html</a><br>2、设计模式读书笔记——享元模式 - chenssy - 博客园<br><a href="https://www.cnblogs.com/chenssy/p/3330555.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chenssy/p/3330555.html</a><br>3、享元模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/flyweight-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/flyweight-pattern.html</a><br>4、JAVA设计模式-享元模式（Flyweight） - 简书<br><a href="https://www.jianshu.com/p/f88b903a166a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f88b903a166a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。&lt;/p&gt;&lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;he
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十二）桥接模式</title>
    <link href="https://www.wshunli.com/posts/f75ecf9a.html"/>
    <id>https://www.wshunli.com/posts/f75ecf9a.html</id>
    <published>2018-09-10T09:09:30.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/12.Bridge.png" title="桥接模式" alt="桥接模式"></div><p>桥接模式包含如下角色：</p><p>(1) Abstraction：抽象类，抽象部分的接口。通常在这个对象里面，要维护一个实现部分的对象引用，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。Shape<br>(2) RefinedAbstraction：扩充抽象类，扩展抽象部分的接口，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。Circle<br>(3) Implementor：实现类接口，定义实现部分的接口，这个接口不用和 Abstraction 里面的方法一致，通常是由 Implementor 接口提供基本的操作，而 Abstraction 里面定义的是基于这些基本操作的业务方法，也就是说 Abstraction 定义了基于这些基本操作的较高层次的操作。DrawAPI<br>(4) ConcreteImplementor：具体实现类，真正实现 Implementor 接口的对象。GreenCircle、RedCircle</p><p>1、创建桥接实现接口</p><pre><code class="lang-Java">public interface DrawAPI {    void drawCircle(int radius, int x, int y);}</code></pre><p>2、创建实现了 DrawAPI 接口的实体桥接实现类</p><pre><code class="lang-Java">public class GreenCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}public class RedCircle implements DrawAPI {    @Override    public void drawCircle(int radius, int x, int y) {        System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;                + radius + &quot;, x: &quot; + x + &quot;, &quot; + y + &quot;]&quot;);    }}</code></pre><p>3、使用 DrawAPI 接口创建抽象类 Shape</p><pre><code class="lang-Java">public abstract class Shape {    protected DrawAPI drawAPI;    protected Shape(DrawAPI drawAPI) {        this.drawAPI = drawAPI;    }    public abstract void draw();}</code></pre><p>4、创建实现了 Shape 接口的实体类</p><pre><code class="lang-Java">public class Circle extends Shape {    private int x, y, radius;    public Circle(DrawAPI drawAPI, int x, int y, int radius) {        super(drawAPI);        this.x = x;        this.y = y;        this.radius = radius;    }    @Override    public void draw() {        drawAPI.drawCircle(radius, x, y);    }}</code></pre><p>5、使用 Shape 和 DrawAPI 类画出不同颜色的圆</p><pre><code class="lang-Java">public class BridgePatternMain {    public static void main(String[] args) {        Shape redCircle = new Circle(new RedCircle(), 100, 100, 10);        Shape greenCircle = new Circle(new GreenCircle(), 100, 100, 10);        redCircle.draw();        greenCircle.draw();    }}</code></pre><p><strong>桥接模式的优缺点</strong>：</p><p>优点：抽象和实现的分离；优秀的扩展能力；实现细节对客户透明。<br>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch12" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch12</a></p><blockquote><p>参考资料<br>1、Java设计模式之十五（桥接模式） - CSDN博客<br><a href="https://blog.csdn.net/shaopeng5211/article/details/8827507" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/shaopeng5211/article/details/8827507</a><br>2、JAVA设计模式之 桥接模式【Bridge Pattern】 - CSDN博客<br><a href="https://blog.csdn.net/janice0529/article/details/44102637" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/janice0529/article/details/44102637</a><br>3、java中的桥接模式 - 简书<br><a href="https://www.jianshu.com/p/c71562c98258" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c71562c98258</a><br>4、讲故事，学（Java）设计模式—桥接模式 - ImportNew<br><a href="http://www.importnew.com/6857.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.importnew.com/6857.html</a><br>5、桥接模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/bridge-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/bridge-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。&lt;/p&gt;&lt;h1 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十一）组合模式</title>
    <link href="https://www.wshunli.com/posts/fb6e1df3.html"/>
    <id>https://www.wshunli.com/posts/fb6e1df3.html</id>
    <published>2018-09-10T08:40:17.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/11.Composite.png" title="组合模式" alt="组合模式"></div><p>组合模式的包含角色：</p><p>(1) Component 抽象构件角色，定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。<br>(2) Leaf 叶子构件，叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。<br>(3) Composite 树枝构件，树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。</p><p>1、抽象构件角色</p><pre><code class="lang-Java">public abstract class Component {    public void operation() {        System.out.println(&quot;Component.operation()&quot;);    }}</code></pre><p>2、树枝构件</p><pre><code class="lang-Java">public class Composite extends Component {    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;&gt;();    public void add(Component component) {        componentArrayList.add(component);    }    public void remove(Component component) {        componentArrayList.remove(component);    }    public ArrayList&lt;Component&gt; getChildren() {        return this.componentArrayList;    }}</code></pre><p>3、树叶构件</p><pre><code class="lang-Java">public class Leaf extends Component {    @Override    public void operation() {        System.out.println(&quot;Leaf.operation()&quot;);    }}</code></pre><p>4、组合模式的使用</p><pre><code class="lang-Java">public class CompositeMain {    public static void main(String[] args) {        Composite root = new Composite();        root.operation();        Composite branch = new Composite();        root.add(branch);        Leaf leaf1 = new Leaf();        Leaf leaf2 = new Leaf();        branch.add(leaf1);        branch.add(leaf2);        display(root);    }    public static void display(Composite root) {        for (Component component : root.getChildren()) {            if (component instanceof Leaf) {                component.operation();            } else {                display((Composite) component);            }        }    }}</code></pre><p><strong>组合模式的优缺点</strong>：</p><p>优点：高层模块调用简单；节点自由增加。<br>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch11" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch11</a></p><blockquote><p>参考资料<br>1、JAVA设计模式十七—Composite(组合模式) - CSDN博客<br><a href="https://blog.csdn.net/hfmbook/article/details/7693069" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/hfmbook/article/details/7693069</a><br>2、Java设计模式—组合模式 - CSDN博客<br><a href="https://blog.csdn.net/qq_25827845/article/details/52496522" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/qq_25827845/article/details/52496522</a><br>3、组合模式 | 菜鸟教程<br><a href="http://www.runoob.com/design-pattern/composite-pattern.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.runoob.com/design-pattern/composite-pattern.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。&lt;/p&gt;&lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（十）代理模式</title>
    <link href="https://www.wshunli.com/posts/b4b3761.html"/>
    <id>https://www.wshunli.com/posts/b4b3761.html</id>
    <published>2018-09-10T08:12:52.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p>代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/10.Proxy.png" title="代理模式" alt="代理模式"></div><p>代理模式一般涉及到的角色有：</p><p>(1) 抽象角色：声明真实对象和代理对象的共同接口；<br>(2) 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装；<br>(3) 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p><p>1、抽象对象角色</p><pre><code class="lang-Java">public abstract class AbstractObject {    public abstract void operation();}</code></pre><p>2、目标对象角色</p><pre><code class="lang-Java">public class RealObject extends AbstractObject {    @Override    public void operation() {        System.out.println(&quot;RealObject.operation()&quot;);    }}</code></pre><p>3、代理对象角色</p><pre><code class="lang-Java">public class ProxyObject extends AbstractObject {    RealObject realObject = new RealObject();    @Override    public void operation() {        //调用目标对象之前可以做相关操作        System.out.println(&quot;before&quot;);        realObject.operation();        //调用目标对象之后可以做相关操作        System.out.println(&quot;after&quot;);    }}</code></pre><p>4、代理模式的使用</p><pre><code class="lang-Java">public class ProxyMain {    public static void main(String[] args) {        AbstractObject object = new ProxyObject();        object.operation();    }}</code></pre><p><strong>代理模式的优缺点</strong>：</p><p>优点：给对象增加了本地化的扩展性，增加了存取操作控制。<br>缺点：会产生多余的代理类。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch10" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch10</a></p><blockquote><p>参考资料<br>1、Java设计模式之代理模式(Proxy) - CSDN博客<br><a href="https://blog.csdn.net/liangbinny/article/details/18656791" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/liangbinny/article/details/18656791</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理模式(Proxy Pattern)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。&lt;/p&gt;&lt;p&gt;代理模式的英文叫做 Proxy 或 Surrogate ，它是一种对象结构型模式。&lt;/p&gt;&lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（九）装饰者模式</title>
    <link href="https://www.wshunli.com/posts/d95b685e.html"/>
    <id>https://www.wshunli.com/posts/d95b685e.html</id>
    <published>2018-09-10T06:37:20.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>动态的给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/9.Decorator.png" title="装饰者模式" alt="装饰者模式"></div><p>一般来说装饰者模式有下面几个参与者：</p><p>(1) Component：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为。<br>(2) ConcreteComponent：定义具体对象，即被装饰者。<br>(3) Decorator：抽象装饰者，继承自 Component ，从外类来扩展 ConcreteComponent 。对于 ConcreteComponent 来说，不需要知道 Decorator 的存在，Decorator 是一个接口或抽象类<br>(4) ConcreteDecorator：具体装饰者，用于扩展 ConcreteComponent 。</p><p>1、抽象构件角色 Component</p><pre><code class="lang-Java">public interface Component {    public void sampleOperation();}</code></pre><p>2、具体构件角色 ConcreteComponent</p><pre><code class="lang-Java">public class ConcreteComponent implements Component {    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteComponent.sampleOperation()&quot;);    }}</code></pre><p>3、装饰角色 Decorator</p><pre><code class="lang-Java">public class Decorator implements Component {    Component component;    public Decorator(Component component) {        this.component = component;    }    @Override    public void sampleOperation() {        // 委派给构件        component.sampleOperation();    }}</code></pre><p>4、具体装饰角色 ConcreteDecorator</p><pre><code class="lang-Java">public class ConcreteDecoratorA extends Decorator {    public ConcreteDecoratorA(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorA.sampleOperation() end&quot;);    }}public class ConcreteDecoratorB extends Decorator {    public ConcreteDecoratorB(Component component) {        super(component);    }    @Override    public void sampleOperation() {        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() start&quot;);        super.sampleOperation();        System.out.println(&quot;ConcreteDecoratorB.sampleOperation() end&quot;);    }}</code></pre><p>5、装饰者模式的使用</p><pre><code class="lang-Java">public class DecoratorMain {    public static void main(String[] args) {        ConcreteComponent concreteComponent = new ConcreteComponent();        ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(concreteComponent);        concreteDecoratorA.sampleOperation();        ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(concreteComponent);        concreteDecoratorB.sampleOperation();    }}</code></pre><p><strong>装饰者模式的优缺点</strong>：</p><p>优点：装饰模式可以提供比继承更多的灵活性；通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>缺点：使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch09" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch09</a></p><blockquote><p>参考资料<br>1、学习、探究Java设计模式——装饰者模式 - CSDN博客<br><a href="https://blog.csdn.net/a553181867/article/details/52108423" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/a553181867/article/details/52108423</a><br>2、Java设计模式之装饰者模式(Decorator pattern) - 简书<br><a href="https://www.jianshu.com/p/c26b9b4a9d9e" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/c26b9b4a9d9e</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;装饰者模式 (Decorator Pattern) 在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;&lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（八）外观模式</title>
    <link href="https://www.wshunli.com/posts/82583d16.html"/>
    <id>https://www.wshunli.com/posts/82583d16.html</id>
    <published>2018-09-10T06:10:36.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。</p><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/8.Facade.png" title="外观模式" alt="外观模式"></div><p>外观模式包含如下两个角色：</p><p>(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p><p>(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p><p>1、创建子系统角色类</p><pre><code class="lang-Java">public class ModuleA {    public void testA() {        System.out.println(&quot;ModuleA.testA()&quot;);    }}public class ModuleB {    public void testB() {        System.out.println(&quot;ModuleB.testB()&quot;);    }}public class ModuleC {    public void testC() {        System.out.println(&quot;ModuleC.testC()&quot;);    }}</code></pre><p>2、创建外观角色类</p><pre><code class="lang-Java">public class Facade {    public void test() {        ModuleA a = new ModuleA();        a.testA();        ModuleB b = new ModuleB();        b.testB();        ModuleC c = new ModuleC();        c.testC();    }}</code></pre><p>3、外观模式使用</p><pre><code class="lang-Java">public class FacadeMain {    public static void main(String[] args) {        Facade facade = new Facade();        facade.test();    }}</code></pre><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</p><p><strong>外观模式的优缺点</strong>：</p><p>优点：客户代码将变得很简单，与之关联的对象也很少；降低了大型软件系统中的编译依赖性。<br>缺点：不能很好地限制客户使用子系统类；增加新的子系统可能需要修改外观类或客户端的源代码。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch08" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch08</a></p><blockquote><p>参考资料<br>1、深入浅出外观模式（一） · 设计模式Java版<br><a href="https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html" rel="external nofollow noopener noreferrer" target="_blank">https://quanke.gitbooks.io/design-pattern-java/深入浅出外观模式（一）.html</a><br>2、浅谈JAVA设计模式之——外观模式(Facade) - CSDN博客<br><a href="https://blog.csdn.net/l1028386804/article/details/45568655" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/l1028386804/article/details/45568655</a><br>3、java中的外观模式（门面模式） - 简书<br><a href="https://www.jianshu.com/p/1424c90ca255" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/1424c90ca255</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;外观模式(Facade Pattern)通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式又称为门面模式，它是一种对象结构型模式。&lt;/p&gt;&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式（七）适配器模式</title>
    <link href="https://www.wshunli.com/posts/69ceed63.html"/>
    <id>https://www.wshunli.com/posts/69ceed63.html</id>
    <published>2018-09-10T01:13:31.000Z</published>
    <updated>2019-01-04T09:27:07.549Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</p><p>适配器模式有 <strong>类的适配器模式和对象的适配器模式</strong> 两种不同的形式。</p><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类的适配器模式把适配的类的 API 转换成为目标类的 API 。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ClassAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，提供一个中间环节，即类 Adapter ，把 Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是继承关系，这决定了这个适配器模式是类的。</p><p>模式所涉及的角色有：</p><p>(1)目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</p><p>(2)源(Adapee)角色：现在需要适配的接口。</p><p>(3)适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色 ClassAdapter 扩展了 Adaptee ,同时又实现了目标(Target)接口。</p><pre><code class="lang-Java">public class ClassAdapter extends Adaptee implements Target {    /**     * 由于源类Adaptee没有方法sampleOperation2()     * 因此适配器补充上这个方法     */    @Override    public void sampleOperation2() {        System.out.println(&quot;ClassAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的 API 转换成为目标类的 API。</p><p>与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到 Adaptee 类，而是使用委派关系连接到 Adaptee 类。</p><div align="center"><img src="https://img.wshunli.com/DesignPatterns/设计模式之禅/7.ObjectAdapter.png" title="适配器模式" alt="适配器模式"></div><p>在上图中可以看出，Adaptee 类并没有 sampleOperation2() 方法，而客户端则期待这个方法。</p><p>为使客户端能够使用 Adaptee 类，需要提供一个包装(Wrapper)类 Adapter。这个包装类包装了一个 Adaptee 的实例，从而此包装类能够把Adaptee 的 API 与 Target 类的 API 衔接起来。Adapter 与 Adaptee 是委派关系，这决定了适配器模式是对象的。</p><p>1、目标角色</p><pre><code class="lang-Java">public interface Target {    /**     * 这是源类Adaptee也有的方法     */    public void sampleOperation1();    /**     * 这是源类Adapteee没有的方法     */    public void sampleOperation2();}</code></pre><p>2、源角色</p><pre><code class="lang-Java">public class Adaptee {    public void sampleOperation1() {        System.out.println(&quot;Adaptee.sampleOperation1()&quot;);    }}</code></pre><p>3、适配器角色</p><pre><code class="lang-Java">public class ObjectAdapter {    private Adaptee adaptee;    public ObjectAdapter(Adaptee adaptee) {        this.adaptee = adaptee;    }    /**     * 源类Adaptee有方法sampleOperation1     * 因此适配器类直接委派即可     */    public void sampleOperation1() {        this.adaptee.sampleOperation1();    }    /**     * 源类Adaptee没有方法sampleOperation2     * 因此由适配器类需要补充此方法     */    public void sampleOperation2() {        System.out.println(&quot;ObjectAdapter.sampleOperation2()&quot;);    }}</code></pre><h2 id="类适配器和对象适配器的权衡"><a href="#类适配器和对象适配器的权衡" class="headerlink" title="类适配器和对象适配器的权衡"></a>类适配器和对象适配器的权衡</h2><p>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。</p><p>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p><p>在 Android 开发过程中, ListView 的 Adapter 是我们最为常见的类型之一。</p><p><strong>适配器模式的优缺点</strong>：</p><p>优点：更好的复用性、更好的扩展性。<br>缺点：过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p><p><strong>本文实现源码</strong>：<a href="https://github.com/wshunli/design-patterns/tree/master/src/ch07" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wshunli/design-patterns/tree/master/src/ch07</a></p><blockquote><p>参考资料<br>1、《JAVA与模式》之适配器模式 - java_my_life - 博客园<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a><br>2、JAVA学习笔记—策略设计模式与适配器模式 - tongye - 博客园<br><a href="https://www.cnblogs.com/tongye/p/6676039.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/tongye/p/6676039.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;适配器模式（Adapter）把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;&lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://www.wshunli.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://www.wshunli.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="https://www.wshunli.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="https://www.wshunli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="《设计模式之禅》" scheme="https://www.wshunli.com/tags/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B/"/>
    
  </entry>
  
</feed>
