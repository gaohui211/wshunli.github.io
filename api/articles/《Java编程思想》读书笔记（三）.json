{"title":"《Java编程思想》读书笔记（三）","slug":"《Java编程思想》读书笔记（三）","date":"2017-11-28T13:15:08.000Z","updated":"2018-03-30T14:42:27.052Z","comments":true,"path":"api/articles/《Java编程思想》读书笔记（三）.json","excerpt":"《Java编程思想》读书笔记 —— 类与接口。","covers":["https://img.wshunli.com/Java/Java编程思想/访问控制.png-hexo.png"],"content":"<p>《Java编程思想》读书笔记 —— 类与接口。</p><a id=\"more\"></a><h1 id=\"第5章-初始化与清理\"><a href=\"#第5章-初始化与清理\" class=\"headerlink\" title=\"第5章 初始化与清理\"></a>第5章 初始化与清理</h1><p>1.构造器初始化 initialize()<br>Java 采用构造器（constructor）<code>初始化</code>和<code>创建</code>对象，两个过程捆绑在一起。<br>类中没有构造器即构造函数时，编译器会自动创建一个默认构造器；反之，则不会自动创建。</p><p>2.方法重载：每个重载方法都有一个独一无二的参数类型列表。</p><p>3.this 关键字只能在方法内部使用，表示“调用方法的那个对象”。<br>static 方法就是没有 this 的方法，可以在没有创建对象的情况下仅仅通过类名本身调用 static 方法。</p><p>4.垃圾回收 finalize()</p><ul><li>对象可能不被垃圾回收。</li><li>垃圾回收并不等于“析构”。</li><li>垃圾回收只与内存有关。</li></ul><p>5.成员初始化及构造器初始化<br>Java 尽力保证：所有变量在使用前都能的到恰当的初始化。</p><p>6.初始化顺序：在类的内部，成员变量会在任何方法（包括构造器）调用之前初始化。<br>含静态数据的初始化：先静态对象后非静态对象。</p><p>7.声明数组变量</p><pre><code class=\"Java\">int[] a;   // 首选的方法\nint a[];  // 效果相同，但不是首选方法\n</code></pre><p>初始化：</p><pre><code class=\"Java\">int[] a = new int[5];\nint[] a = {1, 2, 3, 4, 5};\n</code></pre><p>可变参数列表：</p><pre><code class=\"Java\">void fun (Object... args){\n  for(Object obj : args){\n    system.out.printf(obj + &quot;&quot;);\n  }\n}\n</code></pre><p>8.枚举类型 enum</p><pre><code class=\"Java\">public enum Spiiness{\n  NOT, MILD, MEDIUM, HOT, FLAMING\n}\n</code></pre><h1 id=\"第6章-访问权限控制\"><a href=\"#第6章-访问权限控制\" class=\"headerlink\" title=\"第6章 访问权限控制\"></a>第6章 访问权限控制</h1><p>访问权限（由大到小）：public、protected、包访问权限和 private 。</p><ul><li>default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li></ul><p><img src=\"https://img.wshunli.com/Java/Java编程思想/访问控制.png-hexo.png\" alt=\"访问控制\"></p><h1 id=\"第7章-复用类\"><a href=\"#第7章-复用类\" class=\"headerlink\" title=\"第7章 复用类\"></a>第7章 复用类</h1><p>复用代码有两种方法：在新类中产生现有类的对象（组合）；按照现有类的类型创建新类（继承）。</p><p>1.组合，将对象的引用置于新类中即可。</p><p>2.继承，使用 extends 实现，导出类自动获得基类的所有域和方法。</p><p>没有参数的初始化构建过程，从基类“向外”扩散；带参数的构造器使用 super 显式地调用基类构造器语句。</p><p>3.代理是一种介于组合和继承的中庸之道，将成员对象置于构造地类中（类似组合），与此同时在新类中暴露该成员对象的所有方法（类似继承）。</p><pre><code class=\"Java\">public class SpaceShipDelegation {\n  private String name;\n  private SpaceShipControls controls =\n    new SpaceShipControls();\n  public SpaceShipDelegation(String name) {\n    this.name = name;\n  }\n  // Delegated methods:\n  public void back(int velocity) {\n    controls.back(velocity);\n  }\n  public void forward(int velocity) {\n    controls.forward(velocity);\n  }\n  public static void main(String[] args) {\n    SpaceShipDelegation protector =\n      new SpaceShipDelegation(&quot;NSEA Protector&quot;);\n    protector.forward(100);\n  }\n}\n</code></pre><p>4.向上转型<br>新类和基类之间的关系，新类是现有类的一种类型。<br>基类所有的方法和属性在导出类中也同样存在，导出类可以转化为基类，即向上转型。</p><p>5.final 关键字，指“这是无法改变的”，可用在 <strong>数据、方法和类</strong> 上。</p><p>final 数据：一个永不改变的编译常量；一个运行时被初始化的值，而不希望被改变。<br>final 方法：方法锁定，在继承中保持行为不变，并且不会被覆盖；效率。<br>final 类：不允许继承。</p><p>final 强调不允许改变，static 强调只有一份。</p><p>6.初始化及类的加载</p><pre><code class=\"Java\">//: reusing/Beetle.java\n// The full process of initialization.\nimport static net.mindview.util.Print.*;\n\nclass Insect {\n  private int i = 9;\n  protected int j;\n  Insect() {\n    print(&quot;i = &quot; + i + &quot;, j = &quot; + j);\n    j = 39;\n  }\n  private static int x1 =\n    printInit(&quot;static Insect.x1 initialized&quot;);\n  static int printInit(String s) {\n    print(s);\n    return 47;\n  }\n}\n\npublic class Beetle extends Insect {\n  private int k = printInit(&quot;Beetle.k initialized&quot;);\n  public Beetle() {\n    print(&quot;k = &quot; + k);\n    print(&quot;j = &quot; + j);\n  }\n  private static int x2 =\n    printInit(&quot;static Beetle.x2 initialized&quot;);\n  public static void main(String[] args) {\n    print(&quot;Beetle constructor&quot;);\n    Beetle b = new Beetle();\n  }\n}\n/* Output:\nstatic Insect.x1 initialized\nstatic Beetle.x2 initialized\nBeetle constructor\ni = 9, j = 0\nBeetle.k initialized\nk = 47\nj = 39\n*/\n</code></pre><h1 id=\"第8章-多态\"><a href=\"#第8章-多态\" class=\"headerlink\" title=\"第8章 多态\"></a>第8章 多态</h1><p>多态作用是消除类型之间的耦合关系，允许将多种类型视为同一类型处理。</p><p>1.方法调用绑定</p><p>将一个方法调用同一个方法主题关联起来被称作绑定：<br>前期绑定：在程序执行前进行绑定；<br>后期绑定：运行时根据对象的类型进行绑定。</p><p>Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定</p><pre><code class=\"Java\">public class Shape {\n    public void draw() {}\n    public void erase() {}\n}\nclass Circle extends Shape {\n    public void draw() { System.out.println(&quot;Circle.draw()&quot;); }\n    public void erase() { System.out.println(&quot;Circle.erase()&quot;); } \n}\nclass Square extends Shape {\n    public void draw() { System.out.println(&quot;Square.draw()&quot;); }\n    public void erase() { System.out.println(&quot;Square.erase()&quot;); } \n}\npublic static void main(String[] args) {\n    Shape shape = new Circle();\n    shape.draw();\n}\n/* Output:\nCircle.draw()\n*/\n</code></pre><p>因为继承，将 Shape 引用指向一个新创建的 Circle 对象不会有任何问题；<br>又因为时后期绑定，会使得程序能够正确调用 Circle.draw() 。</p><h1 id=\"第9章-接口\"><a href=\"#第9章-接口\" class=\"headerlink\" title=\"第9章 接口\"></a>第9章 接口</h1><p>接口和内部类为我们提供了一种将接口和实现分离的更加结构化的方法。</p><p>1.抽象类和抽象方法</p><p>抽象方法是不完整的，仅有声明而没有方法体。</p><pre><code class=\"Java\">abstract void f();\n</code></pre><p>包含抽象方法的类叫做抽象类；如果一个类包含一个或多个抽象方法，该类必须被定义为抽象的。</p><p>继承自抽象类的新类需要提供所有抽象方法的定义，否则也是抽象类。</p><p>2.接口</p><p>interface 关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。<br>要让一个类遵循特定接口或者一组接口，需要使用 implements 关键字。</p><pre><code class=\"Java\">interface Instrument {\n    int VALUE = 5;//final &amp;&amp; static\n    void play(String s);\n    void adjust();\n}\n\nclass Wind implements Instrument {\n    public void play(String s) {\n        System.out.print(&quot;Wind.play()&quot;);\n    }\n    public void adjust() {\n        System.out.println(&quot;&quot;Wind.adjust()&quot;&quot;);\n    }\n}\n</code></pre><ul><li>接口中的方法默认是 public 的，不需要显式声明为 public 的；</li><li>接口中的任何域都自动是 static 和 final 的；</li><li>当要实现一个接口时，在接口中被定义的方法必须被显式声明为 public 的，否则只能得到默认的包访问权限。</li></ul><h1 id=\"第10章-内部类\"><a href=\"#第10章-内部类\" class=\"headerlink\" title=\"第10章 内部类\"></a>第10章 内部类</h1><p>将一个类的定义放在另一个类的定义的内部，这就是内部类。</p><pre><code class=\"Java\">public class Parcel1 {\n  class Destination {\n    private String label;\n    Destination(String whereTo) {\n      label = whereTo;\n    }\n    String readLabel() { return label; }\n  }\n  // Using inner classes looks just like\n  // using any other class, within Parcel1:\n  public void ship(String dest) {\n    Destination d = new Destination(dest);\n    System.out.println(d.readLabel());\n  }\n  public static void main(String[] args) {\n    Parcel1 p = new Parcel1();\n    p.ship(&quot;Tasmania&quot;);\n  }\n}\n/* Output:\nTasmania\n*/\n</code></pre><p>1.内部类不仅是一种名字隐藏和组织代码的模式，还拥有与其他外围类的所有元素的访问权限。</p><p>2.使用 .this 与 .new</p><p>.this 用来生成对外围对象的引用。</p><pre><code class=\"Java\">public class DotThis {\n  void f() { System.out.println(&quot;DotThis.f()&quot;); }\n  public class Inner {\n    public DotThis outer() {\n      return DotThis.this;\n      // A plain &quot;this&quot; would be Inner&#39;s &quot;this&quot;\n    }\n  }\n  public Inner inner() { return new Inner(); }\n  public static void main(String[] args) {\n    DotThis dt = new DotThis();\n    DotThis.Inner dti = dt.inner();\n    dti.outer().f();\n  }\n}\n/* Output:\nDotThis.f()\n*/\n</code></pre><p>.new 用来创建外部类对象的内部类对象。</p><pre><code class=\"Java\">public class DotNew {\n  public class Inner {}\n  public static void main(String[] args) {\n    DotNew dn = new DotNew();\n    DotNew.Inner dni = dn.new Inner();\n  }\n}\n</code></pre><p>3.匿名内部类</p><pre><code class=\"Java\">public class Parcel7 {\n  public Contents contents() {\n    return new Contents() { // Insert a class definition\n      private int i = 11;\n      public int value() { return i; }\n    }; // Semicolon required in this case\n  }\n  public static void main(String[] args) {\n    Parcel7 p = new Parcel7();\n    Contents c = p.contents();\n  }\n}\n</code></pre><p>4.嵌套类</p><p>如果不需要内部类对象与外部类对象之间的联系，内部类声明可为 static ，通常称为嵌套类。</p><ul><li>创建嵌套类对象并不需要其外围对象。</li><li>不能从嵌套类对象中访问非静态的外围类对象。</li></ul><p>5.闭包和回调</p><p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。</p><p>回调（Callback）程序在特定时间自己回头调用预先实现的方法。</p><blockquote><p>参考资料<br>1、Java 修饰符<br><a href=\"http://www.runoob.com/java/java-modifier-types.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.runoob.com/java/java-modifier-types.html</a><br>2、《Java编程思想》读书笔记 第九章 接口<br><a href=\"https://zhuanlan.zhihu.com/p/25597956\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://zhuanlan.zhihu.com/p/25597956</a><br>3、Java—内部类（二）—实现闭包与回调<br><a href=\"http://blog.csdn.net/yuwenhao07/article/details/53607117\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/yuwenhao07/article/details/53607117</a></p></blockquote>","categories":[{"name":"移动端技术","path":"api/categories/移动端技术.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《Java编程思想》","path":"api/tags/《Java编程思想》.json"}]}