{"title":"《Java编程思想》读书笔记（十）","slug":"《Java编程思想》读书笔记（十）","date":"2018-03-09T07:02:07.000Z","updated":"2018-04-15T14:51:54.743Z","comments":true,"path":"api/articles/《Java编程思想》读书笔记（十）.json","excerpt":"《Java编程思想》读书笔记 —— 并发。","covers":null,"content":"<p>《Java编程思想》读书笔记 —— 并发。</p><a id=\"more\"></a><h1 id=\"第21章-并发\"><a href=\"#第21章-并发\" class=\"headerlink\" title=\"第21章 并发\"></a>第21章 <strong>并发</strong></h1><p>Java 是一种多线程语言，并且提出了并发问题。</p><p>并发解决的问题大致可分为两类：速度，设计的可管理性。</p><h2 id=\"基本的线程机制\"><a href=\"#基本的线程机制\" class=\"headerlink\" title=\"基本的线程机制\"></a>基本的线程机制</h2><p>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。<strong>一个线程就是在进程中的一个单一的顺序控制流</strong>，因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有其自己的 CPU 一样。其底层机制是切分 CPU 的时间。</p><p>1、定义任务</p><p>线程可以驱动任务，因此你需要一种描述任务的方式，这可以由 Runnable 接口来提供。</p><pre><code class=\"Java\">public class LiftOff implements Runnable {\n  protected int countDown = 10; // Default\n  private static int taskCount = 0;\n  private final int id = taskCount++;\n  public LiftOff() {}\n  public LiftOff(int countDown) {\n    this.countDown = countDown;\n  }\n  public String status() {\n    return &quot;#&quot; + id + &quot;(&quot; +\n      (countDown &gt; 0 ? countDown : &quot;Liftoff!&quot;) + &quot;), &quot;;\n  }\n  public void run() {\n    while(countDown-- &gt; 0) {\n      System.out.print(status());\n      Thread.yield();\n    }\n  }\n} ///:~\n</code></pre><p><code>Thread.yield()</code> 的调用是对线程调度器的一种建议，建议线程调度器切换任务。</p><p>当从 Runnable 导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处–它不会产生任何内在的线程能力。要实现线程行为，你必须显式将一个线程附着在线程上。</p><pre><code class=\"Java\">public class MainThread {\n  public static void main(String[] args) {\n    LiftOff launch = new LiftOff();\n    launch.run();\n  }\n} /* Output:\n#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),\n*///:~\n</code></pre><p>2、Thread 类</p><p>将 Runnable 对象转变为工作任务的传统方式是把它提交给一个 Thread 构造器。下面的示例展示了如何用 Thread 来驱动 LiftOff 对象。</p><pre><code class=\"Java\">public class BasicThreads {\n  public static void main(String[] args) {\n    Thread t = new Thread(new LiftOff());\n    t.start();\n    System.out.println(&quot;Waiting for LiftOff&quot;);\n  }\n} /* Output: (90% match)\nWaiting for LiftOff\n#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),\n*///:~\n</code></pre><p>3、使用 Executor</p><pre><code class=\"Java\">import java.util.concurrent.*;\npublic class CachedThreadPool {\n  public static void main(String[] args) {\n    ExecutorService exec = Executors.newCachedThreadPool();\n    for(int i = 0; i &lt; 5; i++)\n      exec.execute(new LiftOff());\n    exec.shutdown();\n  }\n} /* Output: (Sample)\n#0(9), #0(8), #1(9), #2(9), #3(9), #4(9), #0(7), #1(8), #2(8), #3(8), #4(8), #0(6), #1(7), #2(7), #3(7), #4(7), #0(5), #1(6), #2(6), #3(6), #4(6), #0(4), #1(5), #2(5), #3(5), #4(5), #0(3), #1(4), #2(4), #3(4), #4(4), #0(2), #1(3), #2(3), #3(3), #4(3), #0(1), #1(2), #2(2), #3(2), #4(2), #0(Liftoff!), #1(1), #2(1), #3(1), #4(1), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),\n*///:~\n</code></pre><p><code>CachedThreadPool</code> 将为每个任务都创建一个线程，是合理得 Executor 的首选。</p><p><code>FixedThreadPool</code> 可以一次性预先执行代价高昂的线程分配，限制了线程数量。不用为每个任务都固定的付出创建线程的开销，所以省时间。限制线程数量的好处在于防止线程的滥用。</p><p><code>SingleThreadExecutor</code> 用于希望在另一个线程中连续运行的任何事物（长期存活的任务）。例如监听进入的套接字连接的任务（他只有一个线程）。</p><p>4、从任务中产生返回值</p><p>在 Java SE5 中引入的 Callable 是一种具有类型参数的泛型，它的类型参数表示的是从方法 call() 中返回的值的类型，并且必须使用ExecutorService.submit() 方法调用它。</p><pre><code class=\"Java\">import java.util.concurrent.*;\nimport java.util.*;\n\nclass TaskWithResult implements Callable&lt;String&gt; {\n  private int id;\n  public TaskWithResult(int id) {\n    this.id = id;\n  }\n  public String call() {\n    return &quot;result of TaskWithResult &quot; + id;\n  }\n}\n\npublic class CallableDemo {\n  public static void main(String[] args) {\n    ExecutorService exec = Executors.newCachedThreadPool();\n    ArrayList&lt;Future&lt;String&gt;&gt; results =\n      new ArrayList&lt;Future&lt;String&gt;&gt;();\n    for(int i = 0; i &lt; 10; i++)\n      results.add(exec.submit(new TaskWithResult(i)));\n    for(Future&lt;String&gt; fs : results)\n      try {\n        // get() blocks until completion:\n        System.out.println(fs.get());\n      } catch(InterruptedException e) {\n        System.out.println(e);\n        return;\n      } catch(ExecutionException e) {\n        System.out.println(e);\n      } finally {\n        exec.shutdown();\n      }\n  }\n} /* Output:\nresult of TaskWithResult 0\nresult of TaskWithResult 1\nresult of TaskWithResult 2\nresult of TaskWithResult 3\nresult of TaskWithResult 4\nresult of TaskWithResult 5\nresult of TaskWithResult 6\nresult of TaskWithResult 7\nresult of TaskWithResult 8\nresult of TaskWithResult 9\n*///:~\n</code></pre><p>5、休眠<br>影响任务行为的一种简单方法是调用 sleep()，这将使任务中止执行给定的时间。<br>sleep会使得线程睡眠（即阻塞），这使得线程调度器可以切换到另一个线程，进而驱动另一个任务。</p><p>6、优先级<br>调度器将倾向于优先权更高的线程先执行（执行的频率高），但 CPU 处理线程集的顺序还是不确定的。<br>可以通过 Thread.currentThread().setPriority(int) 设置优先级，getPriority()获取优先级。</p><p>7、让步<br>让步通过调用yield()方法来做出（<strong>不过这只是一个暗示，没有任何机制保证它将会被采纳</strong>）。<br>对于任何重要的控制或在调整应用时，都不能依赖于yield()。</p><p>8、后台线程<br>当所有非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。</p><p>必须在线程启动之前调用 setDaemon() 方法，才能把它设置为后台线程。即：</p><pre><code class=\"Java\">Thread daemon = new Thread(new SimpleDaemons());\ndaemon.setDaemon(true);\ndaemon.start();\n</code></pre><h2 id=\"共享受限资源\"><a href=\"#共享受限资源\" class=\"headerlink\" title=\"共享受限资源\"></a>共享受限资源</h2><p>关键字 <code>synchronized</code> 为防止资源冲突提供内置支持。</p><blockquote><p>参考资料<br>1、java编程思想（读书笔记）：21.并发 - CSDN博客<br><a href=\"http://blog.csdn.net/he_world/article/details/52902701\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/he_world/article/details/52902701</a><br>2、《Java编程思想》——并发读书笔记 - CSDN博客<br><a href=\"http://blog.csdn.net/qq_35362055/article/details/78135854\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/qq_35362055/article/details/78135854</a><br>3、Java编程思想读书笔记一：并发 - CSDN博客<br><a href=\"http://blog.csdn.net/jiankunking/article/details/54799830\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/jiankunking/article/details/54799830</a></p></blockquote>","categories":[{"name":"移动端技术","path":"api/categories/移动端技术.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《Java编程思想》","path":"api/tags/《Java编程思想》.json"}]}