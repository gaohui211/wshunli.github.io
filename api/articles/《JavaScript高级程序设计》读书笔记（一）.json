{"title":"《JavaScript高级程序设计》读书笔记（一）","slug":"《JavaScript高级程序设计》读书笔记（一）","date":"2017-10-29T09:51:02.000Z","updated":"2018-03-23T14:38:57.666Z","comments":true,"path":"api/articles/《JavaScript高级程序设计》读书笔记（一）.json","excerpt":"《JavaScript高级程序设计》读书笔记","covers":["https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象.png","https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象2.png","https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-原型链.png"],"content":"<p>《JavaScript高级程序设计》读书笔记</p><a id=\"more\"></a><p>从今天开始阅读 《JavaScript高级程序设计》（第三版）。</p><p>按照图灵社区推荐的阅读规划：</p><pre><code class=\"HTML\">(一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。(1-7章)\n(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。(8-14章)\n(三) 学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。(15-16章)\n(四) 学习在浏览器中进行实际开发时的错误调试技巧。(17章)\n(五) 学习JavaScript对各数据载体的操作方法（如JSON、XML），学会Ajax的使用方法。(18-21章)\n(六) 学习JavaScript的一些高级技巧及实践方案。(22-25章)\n</code></pre><p><strong>(一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。</strong>(1-7章)</p><h1 id=\"第一章-JavaScript-简介\"><a href=\"#第一章-JavaScript-简介\" class=\"headerlink\" title=\"第一章 JavaScript 简介\"></a>第一章 JavaScript 简介</h1><p>一个完整的 JavaScript 实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。</p><p>ECMAScript：提供核心语言功能；<br>DOM：提供访问和操作网页内容的方法和接口；<br>BOM：提供与浏览器交互的方法和接口。</p><h1 id=\"第二章-在-HTML-中使用-JavaScript\"><a href=\"#第二章-在-HTML-中使用-JavaScript\" class=\"headerlink\" title=\"第二章 在 HTML 中使用 JavaScript\"></a>第二章 在 HTML 中使用 JavaScript</h1><p>HTML 4.01 为 <code>&lt;script&gt;</code> 元素定义了6个属性：async、charset、defer、language（废弃）、src、type 。</p><p>在不存在 defer 和 async 属性时，浏览器都会按照不同<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它们依次进行解析。</p><p>标签的位置：为了避免浏览器在呈现页面时出现明显的延迟，现代Web应用程序一般都把全部 JavaScript 引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p><p>延迟脚本：defer 属性表明脚本在执行时不会影响页面的构造，告诉浏览器立即下载文件，但脚本会被延迟到整个页面都解析完毕后再运行；只适用于外部脚本文件。</p><pre><code class=\"JavaScript\">&lt;script defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>异步脚本：async 属性表示当前脚本不必等待其他脚本，也不必阻塞文档呈现，告诉浏览器立即下载文件，且并不保证标记为 async 的脚本按照他们的先后顺序执行；只适用于外部脚本文件。</p><pre><code class=\"JavaScript\">&lt;script async src=&quot;example1.js&quot;&gt;&lt;/script&gt;\n&lt;script async src=&quot;example2.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p><blockquote><p>页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载；而 load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded)。</p></blockquote><h1 id=\"第三章-基本概念\"><a href=\"#第三章-基本概念\" class=\"headerlink\" title=\"第三章 基本概念\"></a>第三章 基本概念</h1><p>本章内容：语法、数据类型、操作符、控制流语句、函数。<br>其中内容和 Java 类似的部分，不再记笔记。</p><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>区分大小写：ECMAScript 中的一切都区分大小写。</p><p>ECMAScript 5 引入严格模式。在整个脚本中启用严格模式，在顶部添加 <code>&quot;use strict&quot;;</code></p><p>给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</p><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>ECMAScript 中有5种基本数据类型：Undefined、Null、Boolean、Number、String。<br>还有1种复杂数据类型：Object，Object 本质是一组无序的键值对组成。</p><p><code>typeof 操作符</code>：用来检测变量的数据类型。<br>“undefined”：未定义、”boolean”：布尔值、”string”：字符串、”number”：数值、”object”：对象或 null、 “function”：函数</p><blockquote><p>检测 null 值返回 “Object”、检测函数返回 “function” 。</p></blockquote><p><strong>Undefined 类型</strong>：使用 var 声明变量但未对其初始化时，这个变量的值就是 undefined。</p><blockquote><p>对未声明的变量只能只能执行一项操作，即使用 tyoeof 检测其数据类型，返回 undefined 值。</p></blockquote><p><strong>Null 类型</strong>：null 值表示一个空对象指针；只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。</p><blockquote><p>undefined 表示未初始化的变量；null 表示空对象指针；<code>null == undefined</code> 。</p></blockquote><p><strong>Boolean 类型</strong>：其他类型转换为 Boolean 类型，使用函数 Boolean()。</p><p><strong>Number 类型</strong>：表示整数和浮点数值。</p><p>NaN 即非数值（Not a Number）是一个特殊的数值，表示一个原本要返回数值的操作未返回数值的情况。</p><blockquote><p>任何涉及 NaN 的操作都会返回 NaN；NaN与任何值都不等，包括 NaN 本身。<br>NaN 类型可以使用 isNaN() 函数检测。</p></blockquote><p>数值转换：有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()。<br>Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p><p><code>Number()</code> 函数转换：null和空字符串返回 0；undefined和无法转换的字符串返回 NaN ；对象依次尝试调用 valueOf()、toString()方法，根据函数返回值进行转换。<br><code>parseInt()</code> 函数转换：忽略字符前的空格，找到第一个非空格字符；如果第一个字符不是数字字符或者负号，返回 NaN ；继续解析遇到非数字字符为止。可选第二个参数指定进制。<br><code>parseFloat()</code> 函数转换：和 parseInt() 函数类似，但是字符串中的第一个小数点是有效的。</p><p><strong>String 类型</strong>：符串是不可变的，要改变要先删除。<br>其他类型转换为 String 类型，使用函数 toString() 或 String() 或加一个空字符串（<code>&quot;&quot;</code>）。</p><blockquote><p>数值、布尔值、对象、字符串值 都有 toString() 方法。null、undefined 值没有。<br>String() ：null 返回 <code>&quot;null&quot;</code> ， undefined 返回 <code>&quot;undefined&quot;</code>。其他调用 toString() 方法。</p></blockquote><p><strong>Object 类型</strong>：一组数据（属性）和功能（方法）的组合。</p><p>创建对象的方法：</p><pre><code class=\"JavaScript\">var o = new Object();\n</code></pre><p>在 ECMAScript 中，Object 类型是其他所有实例的基础，Object 类型具有的属性和方法也同样存在于更具体的对象中。<br>Object 的每个实例（对象）都具有下列属性和方法：</p><ul><li>constructor：保留着用于创建当前对象的函数即构造函数；</li><li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在；</li><li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型；</li><li>propertyIsEnumerable()；toLocaleString()；</li><li>toString()：返回对象的字符串表示；</li><li>valueOf()：返回对象的字符串、数值或布尔值表示。</li></ul><h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><p>操作符包括：算数操作符、位操作符、关系操作符、相等操作符。</p><p>用法和概念基本和 Java 一致，相同部分不再记笔记。</p><p>在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。</p><pre><code class=\"JavaScript\">&quot;23&quot;&lt;&quot;3&quot; //true\n</code></pre><p>相等操作符基本规则：<br>null == undefined，且不转换；<br>对象除非指向同一个否则互相不等；<br>操作值是数值，则另一个值转换为数值进行比较；<br>操作值是布尔值，则将布尔值转换为数值再进行比较，false转换为0,true转换为1。</p><pre><code class=\"JavaScript\">true == 1 ; //true\ntrue == 2 ; //false\nNaN == NaN ; //false\nNaN != NaN ; //true\n</code></pre><p>全等和不全等：两个操作数未经转换就相等为<strong>全等</strong>；转换之后相等为<strong>非全等</strong>。</p><pre><code class=\"JavaScript\">&quot;23&quot; == 23 ; //true\n&quot;23&quot; === 23 ; //false\n</code></pre><h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><p>for-in 语句可以用来枚举对象的属性。</p><pre><code class=\"JavaScript\">for (property in expression) {\n  ...\n}\n</code></pre><p>break 和 continue 语句与 label 语句联合使用：多发生在循环嵌套的情况下。</p><pre><code class=\"JavaScript\">var num = 0;\noutermost:\nfor (var i = 0; i &lt; 10; i++) {\n  for (var j = 0; j &lt; 10; j++) {\n    if (i == 5 &amp;&amp; j ==5) {\n      break outermost;\n    }\n    num++;\n  }\n}\nconsole.log(num);  // 55\n</code></pre><h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数参数：参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。<br>在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p><p>没有重载：ECMAScript 函数不能像传统意义上那样实现重载。如果在ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p><h1 id=\"第四章-变量、作用域和内存问题\"><a href=\"#第四章-变量、作用域和内存问题\" class=\"headerlink\" title=\"第四章 变量、作用域和内存问题\"></a>第四章 变量、作用域和内存问题</h1><p>JavaScript 变量的特征：本质是松散类型，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。</p><h2 id=\"基本类型和引用类型的值\"><a href=\"#基本类型和引用类型的值\" class=\"headerlink\" title=\"基本类型和引用类型的值\"></a>基本类型和引用类型的值</h2><p>基本类型指的是简单的数据段，而引用数据类型指那些可能由多个值构成的对象。<br>Undefined、Null、Boolean、Number 和 String 这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。<br>引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p><p><strong>动态的属性</strong>：对引用类型可添加属性和方法，也可改变和删除其属性和方法；对基本类型也能添加属性，但基本类型并不会保存，操作是无效的。</p><p><strong>复制变量值</strong>：从一个变量向另一个变量复制值，基本类型会创建新值并复制到新变量；而引用类型只会复制指向对象的指针，新旧变量会相互影响。</p><p><strong>传递参数</strong>：函数的参数是按值传递时的，即把函数外部的值复制给函数内部的参数（参数实际上是函数的局部变量），就和把值从一个变量复制到另一个变量一样。<br>基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样，复制的是一个指向对象的指针。</p><pre><code class=\"JavaScript\">function setName(obj){\n  obj.name = &#39;Nicholas&#39;;\n  obj = new Object();\n  obj.name = &#39;Greg&#39;;\n}\nvar person = new Object();\nsetName(person);\nconsole.log(person.name);  // =&gt; Nicholas\n</code></pre><p>对于引用类型，当把参数名指向新的内存空间，再对其做添加属性等操作，不会影响到原来传递的那个对象，所以不是按引用传递参数。</p><p><strong>检测类型</strong>：instanceof 根据原型链，检测变量是什么引用类型的实例。</p><p>检测基本数据类型 typeof 非常有用，但如果变量是对象或 null ，typeof 只能返回 “Object” 。</p><h2 id=\"执行环境和作用域\"><a href=\"#执行环境和作用域\" class=\"headerlink\" title=\"执行环境和作用域\"></a>执行环境和作用域</h2><p><strong>执行环境</strong>：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。有全局执行环境和局部（函数）执行环境之分。</p><p><strong>作用域链</strong>：搜索变量和函数的作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。</p><p><strong>延长作用域链</strong>：try-catch 语句的 catch 块和 with 语句。</p><p><strong>没有块级作用域</strong>：由花括号封闭的代码没有自己的作用域。如 if 、for 语句中只是在语句的执行环境中（全局或函数）。</p><p>查询标识符：从作用域链的前端开始，向上逐级查询，找到后搜索结果停止，没有找到则一直追溯到全局环境的变量对象。</p><h2 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h2><p>JavaScript 具有自动垃圾回收机制，即执行环境会负责管理代码执行过程中使用的内存。</p><p>最常用的方法有标记清除和引用计数。</p><p><strong>管理内存</strong>：最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。解除一个值的引用并不意味着自动回收该值所占用的内存——解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><h1 id=\"第五章-引用类型\"><a href=\"#第五章-引用类型\" class=\"headerlink\" title=\"第五章 引用类型\"></a>第五章 引用类型</h1><p>引用类型的值（对象）是引用类型（类、对象定义）的一个实例。</p><h2 id=\"Object-类型\"><a href=\"#Object-类型\" class=\"headerlink\" title=\"Object 类型\"></a>Object 类型</h2><p>创建对象：</p><pre><code class=\"JavaScript\">// 1、使用 Object 构造函数\nvar person = new Object();\nperson.name = &quot;Nicholas&quot;;\nperson.age = 29;\n// 2、对象字面量表示法\nvar person = {\n    name : &quot;Nicholas&quot;,\n    age : 29\n};\n// 属性名可以使用字符串\nvar person = {\n    &quot;name&quot; : &quot;Nicholas&quot;,\n    &quot;age&quot; : 29,\n    5 : true //自动转换为字符串\n};\n// 与 new Object() 等价\nvar person = {};\nperson.name = &quot;Nicholas&quot;;\nperson.age = 29;\n</code></pre><p>访问对象属性：</p><pre><code class=\"JavaScript\">// 1、点表示法\nperson.name\n// 2、方括号表示法\nperson[&quot;name&quot;]\n\n// 通过变量访问\nvar n = &#39;name&#39;;\nconsole.log(person[n]);\n// 包含语法错误的字符\nonsole.log(person[&#39;first name&#39;];\n</code></pre><h2 id=\"Array-类型\"><a href=\"#Array-类型\" class=\"headerlink\" title=\"Array 类型\"></a>Array 类型</h2><p>ECMAScript 数组的每项可保存任何类型的数据，没项类型可不同；大小可自动调整。</p><p>创建数组：</p><pre><code class=\"JavaScript\">var a1 = new Array();\nvar a2 = new Array(20);\nvar a3 = new Array(&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;);\n\nvar a4 = [];\nvar a5 = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;];\n</code></pre><p><strong>检测数组</strong>：Array.isArray() 方法可检测对象是不是数组。</p><p><strong>转换方法</strong>：toLocaleString()、toString()和 valueOf()方法。</p><p>toLocaleString()、toString() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。<br>toLocaleString() 方法为了取得每一项的值，调用的是每一项的 toLocaleString() 方法。<br><code>valueOf()</code> 方法返回的还是数组。</p><pre><code class=\"JavaScript\">var person1 = {\n  toLocaleString : function () {\n      return &quot;Nikolaos&quot;;\n  },\n  toString : function() {\n      return &quot;Nicholas&quot;;\n  }\n};\n\nvar person2 = {\n  toLocaleString : function () {\n      return &quot;Grigorios&quot;;\n  },\n  toString : function() {\n      return &quot;Greg&quot;;\n  }\n};\n\nvar people = [person1, person2];\nconsole.log(people);                      //Nicholas,Greg\nconsole.log(people.toString());           //Nicholas,Greg\nconsole.log(people.toLocaleString());     //Nikolaos,Grigorios\n</code></pre><p><code>join()</code> 方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p><pre><code class=\"JavaScript\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\nconsole.log(colors.join(&quot;,&quot;));      //red,green,blue\nconsole.log(colors.join(&quot;||&quot;));     //red||green||blue\n</code></pre><p><strong>栈方法</strong>：push() 和 pop() 方法。</p><p><code>push()</code> 方法接收任意数量的参数，把他们逐个加到数组末尾，并返回修改后的数组长度。<br><code>pop()</code> 方法从数组末尾移除最后一项，减少数组长度，然后返回移除项。</p><p><strong>队列方法</strong>：shift() 和 unshift() 方法。</p><p><code>shift()</code> 从数据前端取项方法。类比 pop() 。<br><code>unshift()</code> 从数组前端添加项。类比 push() 。</p><p><strong>重排序方法</strong>：reverse() 和 sort() 方法。</p><p><code>reverse()</code> 反转数组项的顺序。<br><code>sort()</code> 默认升序排列数组项，调用每项的 toString() 转型方法，然后比较字符串。</p><p>sort() 方法可以接受一个比较函数作为参数。比较函数接受两个参数，第一个参数在第二个之前返回负数。</p><pre><code class=\"JavaScript\">// 从小到大：\nfunction compare(value1, value2) {\n    if (value1 &lt; value2) {\n        return -1;\n    } else if (value1 &gt; value2) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\nvar values = [0, 1, 5, 10, 15];\nvalues.sort(compare);\nconsole.log(values);    //0,1,5,10,15\n\n// 或者\nfunction compare(value1, value2) {\n    return value1 &lt; value2;\n}\n\nvar values = [0, 1, 5, 10, 15];\nvalues.sort(compare);\nconsole.log(values);    //0,1,5,10,15\n</code></pre><p><strong>操作方法</strong> ：concat() slice() splice() 。</p><p><code>concat()</code> 添加项。创建新数组。</p><pre><code class=\"JavaScript\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\nvar colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);\n\nconsole.log(colors);     //red,green,blue\nconsole.log(colors2);    //red,green,blue,yellow,black,brown\n</code></pre><p><code>slice()</code> 截取。创建新数组。</p><p>在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</p><pre><code class=\"JavaScript\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];\nvar colors2 = colors.slice(1);\nvar colors3 = colors.slice(1,4);\n\nconsole.log(colors2);   //green,blue,yellow,purple\nconsole.log(colors3);   //green,blue,yellow\n</code></pre><p><code>splice()</code> 删除插入替换。改变原数组。</p><p>三个参数：起始位置、要删除的项数、要插入的项。<br>第三个不传是删除功能，第二个为 0 是插入功能，都有则替换。<br>返回：删除的项。</p><pre><code class=\"JavaScript\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\nvar removed = colors.splice(0,1);              //remove the first item\nconsole.log(colors);     //green,blue\nconsole.log(removed);    //red - one item array\n\nremoved = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);  //insert two items at position 1\nconsole.log(colors);     //green,yellow,orange,blue\nconsole.log(removed);    //empty array\n\nremoved = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);    //insert two values, remove one\nconsole.log(colors);     //green,red,purple,orange,blue\nconsole.log(removed);    //yellow - one item array\n</code></pre><p><strong>位置方法</strong>：indexOf() lastIndexOf() 接收两个参数：要查找的项和（可选）查找起点位置的索引；indexOf()从前往后查找，lastIndexOf()从后往前查找；返回要查找的项的位置，没找到则返回 -1。</p><p><strong>迭代方法</strong>：两个参数：在每项运行的函数和（可选的）作用域对象；其中函数接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。</p><p>every()：对数组中的每一项运行给定函数，如果该函数对<strong>每一项</strong>都返回true，则返回true。有返回false的项时就不会再对后面的项检测了，直接返回false。<br>some()：对数组中的每一项运行给定函数，如果该函数对<strong>任一项</strong>返回true，则返回true。有返回true的项时就不再对后面的项检测了，直接返回ture。</p><p>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</p><p>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。本质上与使用 for 循环迭代数组一样。</p><pre><code class=\"JavaScript\">var a = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n\nvar everyResult = a.every(function (item, index, array) {\n  return (item &gt; 2);\n});\nconsole.log(everyResult);  // false\n\nvar someResult = a.some(function (item, index, array) {\n  return (item &gt; 2);\n});\nconsole.log(someResult);  // true\n\nvar filterResult = a.filter(function (item, index, array) {\n  return (item &gt; 2);\n});\nconsole.log(filterResult);  // [3, 4, 5, 4, 3]\n\nvar mapResult = a.map(function (item, index, array) {\n  return (item * 2);\n});\nconsole.log(mapResult);  // [2, 4, 6, 8, 10, 8, 6, 4, 2]\n\nvar forEachResult = a.forEach(function (item, index, array) {\n  console.log(item);\n});\nconsole.log(forEachResult);  // undefined\n</code></pre><p><strong>缩小方法</strong>（递归方法）：reduce() 和 reduceRight() 迭代数组的所有项，然后构建一个最终返回的值；reduce()方法从前往后，reduceRight()从后往前。<br>reduce() 和 reduceRight() 接收两个参数：一个在每项上调用的函数和（可选的）作为缩小基础的初始值。其中函数接收4个参数：前一个值、当前值、项的索引和数组对象。函数的返回值又会作为第一个参数自动传给下一项。</p><pre><code class=\"JavaScript\">var values = [1,2,3,4,5];\nvar sum = values.reduce(function(prev, cur, index, array){\n  return prev + cur;\n},1);\nconsole.log(sum); //16\n</code></pre><h2 id=\"Date-类型\"><a href=\"#Date-类型\" class=\"headerlink\" title=\"Date 类型\"></a>Date 类型</h2><p>创建日期对象：</p><pre><code class=\"JavaScript\">var now = new Date();\nvar date = new Date(2005, 4, 5, 17, 55, 55);  // 2005年5月5日下午5点55分55秒\n</code></pre><p>获取调用时的日期和时间和毫秒数：</p><pre><code class=\"JavaScript\">var start = Date.now();\ndoSomething();\nvar stop = Date.now();\nvar result = stop - start;\n</code></pre><p>日期的格式化方法：</p><pre><code class=\"JavaScript\">var date = new Date(2015, 2, 5, 17, 55, 55);\ndate.toString();  // &quot;Thu Mar 05 2015 17:55:55 GMT+0800 (CST)&quot;\ndate.toDateString();  // &quot;Thu Mar 05 2015&quot;\ndate.toTimeString();  // &quot;17:55:55 GMT+0800 (CST)&quot;\ndate.toLocaleString();  // &quot;2015/3/5 下午5:55:55&quot;\ndate.toLocaleDateString();  // &quot;2015/3/5&quot;\ndate.toLocaleTimeString();  // &quot;下午5:55:55&quot;\n</code></pre><h2 id=\"RegExp-类型\"><a href=\"#RegExp-类型\" class=\"headerlink\" title=\"RegExp 类型\"></a>RegExp 类型</h2><p>创建正则表达式：</p><pre><code class=\"JavaScript\">var exp1 = / pattern / flags ;\nvar exp2 = new RegExp(&#39;pattern&#39;, &#39;flags&#39;);\n</code></pre><p>模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。<br>标志（flags）用以标明正则表达式的行为。正则表达式的匹配模式支持下列3 个标志：</p><ul><li>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li><li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li><li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li></ul><p>RegExp 实例方法：</p><p><code>exec()</code>：返回第一个匹配项信息的数组，数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串；还包含两个额外的属性，index 和 input。<br><code>test()</code>：在模式与该参数匹配的情况下返回true，否则返回false。</p><p>正则表达式：<a href=\"http://www.runoob.com/regexp/regexp-tutorial.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.runoob.com/regexp/regexp-tutorial.html</a></p><h2 id=\"Function-类型\"><a href=\"#Function-类型\" class=\"headerlink\" title=\"Function 类型\"></a>Function 类型</h2><p>函数实际上是对象。函数名实际上是指向函数对象的指针。<br>每个函数都是 Function 类型的实例，而且与其他引用类型一样具有属性和方法。</p><pre><code class=\"JavaScript\">// 函数声明\nfunction sum (num1, num2){\n  return num1 + num2;\n}\n// 函数表达式\nvar sum = function(num1, num2){\n  return num1 + num2;\n};\n// 使用构造函数，不推荐\nvar sum = new Function(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;);\n</code></pre><p><strong>函数声明与函数表达式</strong>：解释器会率先读取函数声明，并使其在执行任何代码之前可用（函数声明提升）；函数表达式必须等到解释器执行到它所在行才会真正被解释执行。</p><pre><code class=\"JavaScript\">// 函数声明\nconsole.log(sum(10,10));\nfunction sum (num1, num2){\n  return num1 + num2;\n}\n// 函数表达式\nconsole.log(sum(10,10));// Uncaught TypeError: sum is not a function\nvar sum = function(num1, num2){\n  return num1 + num2;\n};\n</code></pre><p><strong>作为值的函数</strong>：因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。</p><p><strong>函数的内部属性</strong>：arguments 、this 。</p><p><code>arguments</code>: 是一个类数组对象，包含着传入函数中的所有参数。</p><pre><code class=\"JavaScript\">function factorial(num){\n    if (num &lt;= 1) {\n        return 1;\n    } else {\n        return num * factorial(num-1)\n    }\n}\n\nfunction factorial(num){\n    if (num &lt;= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num-1)\n    }\n}\n</code></pre><p>arguments 的属性 callee 指向拥有此 arguments 的函数。</p><pre><code class=\"JavaScript\">// 无论引用函数时使用的什么名字，都可以保证正常完成递归。\nvar trueFactorial = factorial;\n\nfactorial = function(){\n    return 0;\n};\nconsole.log(trueFactorial(5));   //120\nconsole.log(factorial(5));       //0\n</code></pre><p><code>this</code> 引用的是函数据以执行的环境对象。</p><p>在全局作用域中调用函数，this 引用的是全局对象 window；<br>把函数赋给对象 o 并调用时，this 引用的就是对象 o 。</p><p>caller : 调用当前函数的函数的引用，返回后者的源代码。</p><p><strong>函数的属性和方法</strong>：</p><p>函数的两个属性：length 和 prototype 。</p><p><code>length</code>：表示函数希望接收的命名参数的个数。</p><p><code>prototype</code>: 对于ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。不可枚举。</p><p>函数的两个非继承而来的方法：apply() 和 call() 。在特定的作用域中调用函数。</p><p><code>apply()</code>：接受两个参数，运行函数的作用于和参数数组。</p><pre><code class=\"JavaScript\">function sum(num1, num2){\n    return num1 + num2;\n}\n// 参数数组可以是 Array 的实例，也可以是 arguments 对象。\nfunction callSum1(num1, num2){\n    return sum.apply(this, arguments);\n}\nfunction callSum2(num1, num2){\n    return sum.apply(this, [num1, num2]);\n}\nconsole.log(callSum1(10,10));   //20\nconsole.log(callSum2(10,10));   //20\n</code></pre><p><code>call()</code>：必须明确地传入每个参数。</p><pre><code class=\"JavaScript\">function sum(num1, num2){\n    return num1 + num2;\n}\nfunction callSum(num1, num2){\n    return sum.call(this, num1, num2);\n}\nconsole.log(callSum(10,10));   //20\n</code></pre><p>apply() 和 call() 真正强大的地方是能够扩充函数赖以运行的作用域。而使用它们来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。</p><pre><code class=\"JavaScript\">window.color = &quot;red&quot;;\nvar o = { color: &quot;blue&quot; };\nfunction sayColor(){\n    console.log(this.color);\n}\nsayColor();            //red\nsayColor.call(this);   //red\nsayColor.call(window); //red\nsayColor.call(o);      //blue\n</code></pre><p><code>bind()</code> 方法会创建一个函数的实例，其 this 值会绑定到传给 bind() 函数的值。</p><pre><code class=\"JavaScript\">var objectSayColor = sayColor.bind(o);\nobjectSayColor();   //blue\n</code></pre><h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>Boolean 类型、Number 类型、String 类型。</p><h2 id=\"单体内置对象\"><a href=\"#单体内置对象\" class=\"headerlink\" title=\"单体内置对象\"></a>单体内置对象</h2><p>Global 对象、Math 对象。</p><h1 id=\"第六章-面向对象的程序设计\"><a href=\"#第六章-面向对象的程序设计\" class=\"headerlink\" title=\"第六章 面向对象的程序设计\"></a>第六章 面向对象的程序设计</h1><p>对象：无序属性的集合，其属性可以包含基本值、对象或者函数。</p><h2 id=\"理解对象\"><a href=\"#理解对象\" class=\"headerlink\" title=\"理解对象\"></a>理解对象</h2><p>属性在创建时都带了一些特征值（characteristic），JavaScript 通过这些特征值来定义他们的行为。</p><p>ECMAScript 中有两种属性：数据属性和访问器属性。<br>描述属性的各种特征，是为了实现JavaScript引擎用的，不能直接访问。</p><p><strong>数据属性</strong>：</p><ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li><li>[[Writeable]]：表示能否修改属性的值。</li><li>[[Value]]：包含这个属性的数据值。</li></ul><p><strong>访问器属性</strong>：</p><ul><li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为数据属性。</li><li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</li><li>[[Get]]：在读取属性时调用的函数。</li><li>[[Set]]：在写入属性时调用的函数。</li></ul><p><strong>定义及读取特性</strong>：Object.defineProperty() Object.defineProperties()；Object.getOwnPropertyDescriptor() 。</p><h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><p>虽然使用 Object 构造函数或者对象字面量可以创建单个对象，但使用同一接口创建很多对象，会产生大量的重复代码。</p><p><strong>工厂模式</strong>：使用函数来封装以特定接口来创建对象。</p><pre><code class=\"JavaScript\">function createPerson(name,age,job){\n  var o=new Object();\n  o.name=name;\n  o.age=age;\n  o.job=job;\n  o.sayName=function(){\n    console.log(this.name);\n  };\n  return o;\n}\nvar person1=createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;);\n</code></pre><p><strong>构造函数模式</strong>：</p><pre><code class=\"JavaScript\">function Person(name,age,job){\n  this.name=name;\n  this.age=age;\n  this.job=job;\n  this.sayName=function(){\n    console.log(this.name);\n  };\n}\nvar person1=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);\n</code></pre><p>要创建Person的实例，必须使用new操作符。用这种方式调用构造函数需要4个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象。</li></ol><p>构造函数和其他函数唯一的区别，就是在于调用他们的方式不同。<br>任何函数，只要通过 new 操作符来调用，那么它就可以作为构造函数。</p><p><strong>原型模式</strong>：</p><p>创建的每一个函数都有一个 prototype（原型）属性，指向一个对象；这个对象（原型对象 ）的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>prototype 就是通过调用构造函数而创建的实例的原型对象。好处是可以让所有的实例共享原型对象包含的属性和方法，不用在构造函数里面定义实例的信息，而是直接添加到原型对象中。</p><pre><code class=\"JavaScript\">function Person(){\n}\n\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName();   //&quot;Nicholas&quot;\n\nvar person2 = new Person();\nperson2.sayName();   //&quot;Nicholas&quot;\n\nconsole.log(person1.sayName == person2.sayName);  //true\n</code></pre><p>1.理解原型对象：</p><p>只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，指向原型对象；<br>默认所有原型对象都会获得一个 <code>constructor</code> 属性，指向 <code>prototype</code> 属性所在函数（构造函数）；<br>调用构造函数创建实例后，实例内部将包含一个指针 <code>[[Prototype]]</code> 或者 <code>__proto__</code> 指向构造函数的原型对象。</p><p><img src=\"https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象.png\" alt=\"向对象的程序设计-理解原型对象\"></p><pre><code class=\"JavaScript\">···\n// 使用 isPrototype() 来检测构造函数的原型对象和实例对象之间是否有关系\nconsole.log(Person.prototype.isPrototypeOf(person1));  //true\nconsole.log(Person.prototype.isPrototypeOf(person2));  //true\n// Object.getPrototypeOf() 返回实例对象的原型\nif (Object.getPrototypeOf){\n    console.log(Object.getPrototypeOf(person1) == Person.prototype);  //true\n    console.log(Object.getPrototypeOf(person1).name);  //&quot;Nicholas&quot;\n}\n</code></pre><p>当代码读取某个对象的属性时，先从对象实例本身开始，若没有找到才会在原型对象中查找。</p><p>当为对象实例添加属性时，这个属性会屏蔽掉原型对象中的同名属性，即使将这个属性设置为 null ，也只会在实例中设置这个属性。不过使用 delete 操作符可以完全删除实例属性，使得可以重新访问原型中的属性。</p><pre><code class=\"JavaScript\">···\nperson1.name = &quot;Greg&quot;;\nconsole.log(person1.name);   //&quot;Greg&quot; - 来自实例\nconsole.log(person2.name);   //&quot;Nicholas&quot; - 来自原型\n\ndelete person1.name;\nconsole.log(person1.name);   //&quot;Nicholas&quot; - 来自原型\n\n// 使用 hasOwnProperty() 来检测属性存在于实例中还是原型中\nconsole.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型\nperson1.name = &quot;Greg&quot;;\nconsole.log(person1.hasOwnProperty(&quot;name&quot;)); // true - 来自实例\ndelete person1.name;\nconsole.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型\n</code></pre><p>实例与原型的关系：<br><img src=\"https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-理解原型对象2.png\" alt=\"向对象的程序设计-理解原型对象2\"></p><p>2.原型与 in 操作符：单独使用和在 for-in 循环中使用。</p><pre><code class=\"JavaScript\">···\n// 单独使用时无论属性在原型还是在实例中都返回 true\nconsole.log(&quot;name&quot; in person1); // true\nperson1.name = &quot;Greg&quot;;\nconsole.log(&quot;name&quot; in person1);   //true\n\n// for-in 循环时，返回的是所有能通过对象访问的、可枚举的属性；同样也包括原型和实例中的。\nfor (var prop in person1) {\n  console.log(prop);  // name age job sayName\n}\n</code></pre><p>Object.keys() 方法可以取得对象上所有可枚举的实例属性。</p><pre><code class=\"JavaScript\">···\nvar keys = Object.keys(Person.prototype);\nconsole.log(keys);   //&quot;name,age,job,sayName&quot;\n</code></pre><p>Object.getOwnPropertyNames() 方法可以得到所有实例属性，无论其是否可枚举。</p><pre><code class=\"JavaScript\">···\nvar keys = Object.getOwnPropertyNames(Person.prototype);\nconsole.log(keys);   //&quot;constructor,name,age,job,sayName&quot;\n</code></pre><p>3.更简单的原型语法：</p><pre><code class=\"JavaScript\">function Person(){\n}\n// 本质是重写了默认的 prototype 对象\n// constructor 属性指向 Object\nPerson.prototype = {\n    name : &quot;Nicholas&quot;,\n    age : 29,\n    job: &quot;Software Engineer&quot;,\n    sayName : function () {\n        console.log(this.name);\n    }\n};\nconsole.log(friend instanceof Object);  //true\nconsole.log(friend instanceof Person);  //true\nconsole.log(friend.constructor == Person);  //false\nconsole.log(friend.constructor == Object);  //true\n</code></pre><p>为解决 constructor 无法确定对象类型的问题：</p><pre><code class=\"JavaScript\">function Person(){\n}\n// 方法1：\nPerson.prototype = {\n    // 使 constructor 属性指向构造函数\n    constructor : Person,\n    name : &quot;Nicholas&quot;,\n    age : 29,\n    job: &quot;Software Engineer&quot;,\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n\n// 方法2：\nPerson.prototype = {\n    name : &quot;Nicholas&quot;,\n    age : 29,\n    job: &quot;Software Engineer&quot;,\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n// 设置 constructor 属性不可枚举\nObject.defineProperty(Person.prototype.&quot;constructor&quot;){\n  enumerable : false,\n  value: Person\n}\n\n// 结果相同\nvar friend = new Person();\nconsole.log(friend instanceof Object);  //true\nconsole.log(friend instanceof Person);  //true\nconsole.log(friend.constructor == Person);  //true\nconsole.log(friend.constructor == Object);  //false\n</code></pre><p>4.原型的动态性：</p><p>我们对原型的修改都能立刻反映到实例上。<br>但是重写原型，实例对象还是指向原来的原型，不会指向新重写的原型对象。<br>重写原型切断了新的原型和之前已经存在的对象实例间的联系。</p><p>5.原型对象的问题：原型对象中讯在引用类型的属性，会使所有实例共享该引用。</p><p><strong>组合使用构造函数和原型模式</strong>：</p><p>构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。</p><pre><code class=\"JavaScript\">function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];\n}\n\nPerson.prototype = {\n    constructor: Person,\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nperson1.friends.push(&quot;Van&quot;);\n\nconsole.log(person1.friends);    //&quot;Shelby,Court,Van&quot;\nconsole.log(person2.friends);    //&quot;Shelby,Court&quot;\nconsole.log(person1.friends === person2.friends);  //false\nconsole.log(person1.sayName === person2.sayName);  //true\n</code></pre><p>实例属性都是在构造函数中定义的，每个实例都会有自己的一份实例属性的副本。</p><p><strong>动态原型模式</strong>：将原型信息封装在构造函数中。</p><pre><code class=\"JavaScript\">function Person(name, age, job){\n    //properties\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    //methods\n    if (typeof this.sayName != &quot;function&quot;){\n        Person.prototype.sayName = function(){\n            console.log(this.name);\n        };\n    }\n}\n\nvar friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nfriend.sayName();\n</code></pre><p><code>寄生构造函数模式</code>、<code>稳妥构造函数模式</code>。</p><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>ECMAScript 只支持<strong>实现继承</strong>，主要依靠原型链来实现。</p><p><strong>原型链</strong>：利用原型将一个引用类型继承另一个引用类型的属性和方法。</p><pre><code class=\"JavaScript\">function SuperType(){\n    this.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n};\n\nfunction SubType(){\n    this.subproperty = false;\n}\n//继承 SuperType\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function (){\n    return this.subproperty;\n};\n\nvar instance = new SubType();\nconsole.log(instance.getSuperValue());   //true\n</code></pre><p>实例以及构造函数和原型之间的关系：</p><p><img src=\"https://img.wshunli.com/JavaScript/JavaScript高级程序设计/1/向对象的程序设计-原型链.png\" alt=\"向对象的程序设计-原型链\"></p><p>getSuperValue() 方法仍然在 SuperType.prototype 中，但 property 位于 SubType.prototype 中。<br>因为我们重写了 SubType 的原型，新原型即 SuperType 的实例；property 是实例的属性，getSuperValue() 则是 SuperType 原型的方法。</p><p>1.注意默认原型：函数的默认原型是 Object 实例，因此默认原型会包含指针指向 Object.prototype 。</p><p>2.确定实例与原型的关系：</p><pre><code class=\"JavaScript\">console.log(instance instanceof Object);      //true\nconsole.log(instance instanceof SuperType);   //true\nconsole.log(instance instanceof SubType);     //true\nconsole.log(Object.prototype.isPrototypeOf(instance));    //true\nconsole.log(SuperType.prototype.isPrototypeOf(instance)); //true\nconsole.log(SubType.prototype.isPrototypeOf(instance));   //true\n</code></pre><p>3.谨慎地定义方法：给原型添加方法一定要在替换原型之后；也不能使用字面量创建原型方法。</p><p>4.原型链问题：引用类型的原型属性会被所有实例共享；不能向超类传递参数。</p><p><strong>借用构造函数</strong>：通过 apply() 或 call() 方法在新创建的对象上执行超类的构造函数。</p><pre><code class=\"JavaScript\">function SuperType(){\n    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];\n}\n\nfunction SubType(){\n    //继承自 SuperType\n    SuperType.call(this);\n}\n\nvar instance1 = new SubType();\ninstance1.colors.push(&quot;black&quot;);\nconsole.log(instance1.colors);    //&quot;red,blue,green,black&quot;\n\nvar instance2 = new SubType();\nconsole.log(instance2.colors);    //&quot;red,blue,green&quot;\n</code></pre><p>通过 apply() 或 call() 方法在 SubType 实例的环境下调用了 SuperType 构造函数。</p><p>1.传递参数：</p><pre><code class=\"JavaScript\">function SuperType(name){\n    this.name = name;\n}\nfunction SubType(){\n    //继承自 SuperType，传递参数\n    SuperType.call(this, &quot;Nicholas&quot;);\n    //实例属性\n    this.age = 29;\n}\nvar instance = new SubType();\nconsole.log(instance.name);    //&quot;Nicholas&quot;;\nconsole.log(instance.age);     //29\n</code></pre><p>2.问题： 和构造函数模式类似，方法都在构造函数中定义，无法复用。</p><p><strong>组合继承</strong>：JavaScript中最常用的继承。融合了原型链和构造函数的优点。</p><pre><code class=\"JavaScript\">function SuperType(name){\n    this.name = name;\n    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];\n}\nSuperType.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nfunction SubType(name, age){\n    SuperType.call(this, name);\n    this.age = age;\n}\n\nSubType.prototype = new SuperType();\nSubType.prototype.sayAge = function(){\n    console.log(this.age);\n};\n\nvar instance1 = new SubType(&quot;Nicholas&quot;, 29);\ninstance1.colors.push(&quot;black&quot;);\nconsole.log(instance1.colors);  //&quot;red,blue,green,black&quot;\ninstance1.sayName();      //&quot;Nicholas&quot;;\ninstance1.sayAge();       //29\n\nvar instance2 = new SubType(&quot;Greg&quot;, 27);\nconsole.log(instance2.colors);  //&quot;red,blue,green&quot;\ninstance2.sayName();      //&quot;Greg&quot;;\ninstance2.sayAge();       //27\n</code></pre><p><code>原型式继承</code>、<code>寄生式继承</code>、<code>寄生组合式继承</code>。</p><h1 id=\"第七章-函数表达式\"><a href=\"#第七章-函数表达式\" class=\"headerlink\" title=\"第七章 函数表达式\"></a>第七章 函数表达式</h1><p>定义函数的方法有两种：<a href=\"#Function-类型\">函数声明与函数表达式</a>。</p><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身函数构成。</p><pre><code class=\"JavaScript\">function factorial(num){\n    if (num &lt;= 1){\n        return 1;\n    } else {\n        return num * factorial(num-1);\n    }\n}\n\nvar anotherFactorial = factorial;\nfactorial = null;\nconsole.log(anotherFactorial(4));  //error! - factorial 已经不是函数\n</code></pre><p>解决办法是使用命名函数表达式：</p><pre><code class=\"JavaScript\">function factorial = (function f(num){\n    if (num &lt;= 1){\n        return 1;\n    } else {\n        return num * f(num-1);\n    }\n});\n</code></pre><h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p><strong>闭包</strong> 是有权访问另一个函数作用域中的变量的函数。</p><p>1.闭包和变量:闭包只能取得函数中任何变量的最后一个值。</p><pre><code class=\"JavaScript\">function createFunctions(){\n    var result = new Array();\n    for (var i=0; i &lt; 10; i++){\n        result[i] = function(){\n            return i;\n        };\n    }\n    return result;\n}\n</code></pre><p>其中每个函数都引用着保存变量 i 的同一个变量对象,所以函数内部返回的值都是 10 。</p><pre><code class=\"JavaScript\">function createFunctions(){\n    var result = new Array();\n    for (var i=0; i &lt; 10; i++){\n        result[i] = function(num){\n            return function(){\n                return num;\n            };\n        }(i);\n    }\n    return result;\n}\n</code></pre><p>2.关于 this 对象:匿名函数通常具有全局性,因此其 this 对象通常指向 windows 。</p><pre><code class=\"JavaScript\">var name = &quot;The Window&quot;;\nvar object = {\n    name : &quot;My Object&quot;,\n    getNameFunc : function(){\n        return function(){\n            return this.name;\n        };\n    }\n};\nconsole.log(object.getNameFunc()());  //&quot;The Window&quot; 在非严格模式下\n</code></pre><p>this 的值有时候会意外发生改变。</p><pre><code class=\"JavaScript\">var name = &quot;The Window&quot;;\nvar object = {\n    name : &quot;My Object&quot;,\n    getName: function(){\n        return this.name;\n    }\n};\nconsole.log(object.getName());     //&quot;My Object&quot;\nconsole.log((object.getName)());   //&quot;My Object&quot;\nconsole.log((object.getName = object.getName)());   //&quot;The Window&quot; 在严格模式下\n}\n</code></pre><p>第三个其实是重写了 getName 方法,this 值就指向全局了。</p><h2 id=\"模仿块级作用域\"><a href=\"#模仿块级作用域\" class=\"headerlink\" title=\"模仿块级作用域\"></a>模仿块级作用域</h2><p>JavaScript 没有块级作用域(私有作用域)的概念,可使用匿名函数方法模仿。</p><pre><code class=\"JavaScript\">(function () {\n    ...\n})();\n</code></pre><h2 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h2><p>JavaScript 没有私有成员的概念,所有对象属性都是公有的,但是有个私有变量的概念,也就是函数中定义的变量。</p><pre><code class=\"JavaScript\">function Person(name){\n    this.getName = function(){\n        return name;\n    };\n    this.setName = function (value) {\n        name = value;\n    };\n}\nvar person = new Person(&quot;Nicholas&quot;);\nconsole.log(person.getName());   //&quot;Nicholas&quot;\nperson.setName(&quot;Greg&quot;);\nconsole.log(person.getName());   //&quot;Greg&quot;\n</code></pre><p>创建 Person 实例只能 通过 getName() 和 setName() 方法访问内部变量,但是针对每个实例都会创建一组新方法。</p><p>1.静态私有变量</p><pre><code class=\"JavaScript\">(function(){\n    var name = &quot;&quot;;\n    Person = function(value){\n        name = value;\n    };\n    Person.prototype.getName = function(){\n        return name;\n    };\n    Person.prototype.setName = function (value){\n        name = value;\n    };\n})();\n\nvar person1 = new Person(&quot;Nicholas&quot;);\nconsole.log(person1.getName());   //&quot;Nicholas&quot;\nperson1.setName(&quot;Greg&quot;);\nconsole.log(person1.getName());   //&quot;Greg&quot;\n\nvar person2 = new Person(&quot;Michael&quot;);\nconsole.log(person1.getName());   //&quot;Michael&quot;\nconsole.log(person2.getName());   //&quot;Michael&quot;\n</code></pre><p>初始化未声明的变量,总会创建一个全局变量。严格模式下报错。</p><p>示例代码中 name 变成了一个静态的,所有实例共享的属性。</p><p>2.模块模式</p><p>模块模式是为单例创建私有变量和特权方法。单例即只有一个实例的对象。</p><pre><code class=\"JavaScript\">function BaseComponent(){\n}\nfunction OtherComponent(){\n}\nvar application = function(){\n    //私有变量和方法\n    var components = new Array();\n    //初始化\n    components.push(new BaseComponent());\n    //公共接口\n    return {\n        getComponentCount : function(){\n            return components.length;\n        },\n        registerComponent : function(component){\n            if (typeof component == &quot;object&quot;){\n                components.push(component);\n            }\n        }\n    };\n}();\n\napplication.registerComponent(new OtherComponent());\nconsole.log(application.getComponentCount());  //2\n</code></pre><p>3.增强的模块模式</p><p>针对单例必须是某种类型的实例,同时还对其添加属性或方法的情况。</p><pre><code class=\"JavaScript\">function BaseComponent(){\n}\nfunction OtherComponent(){\n}\nvar application = function(){\n    //私有变量和方法\n    var components = new Array();\n    //初始化\n    components.push(new BaseComponent());\n    //创建 application 的一个局部副本\n    var app = new BaseComponent();\n    //公共接口\n    app.getComponentCount = function(){\n        return components.length;\n    };\n    app.registerComponent = function(component){\n        if (typeof component == &quot;object&quot;){\n            components.push(component);\n        }\n    };\n    //返回副本\n    return app;\n}();\n\nconsole.log(application instanceof BaseComponent);\napplication.registerComponent(new OtherComponent());\nconsole.log(application.getComponentCount());  //2\n</code></pre>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《JavaScript高级程序设计》","path":"api/tags/《JavaScript高级程序设计》.json"}]}