{"title":"《第一行代码》读书笔记（三）","slug":"《第一行代码》读书笔记（三）","date":"2017-12-27T07:05:30.000Z","updated":"2018-03-12T15:39:23.940Z","comments":true,"path":"api/articles/《第一行代码》读书笔记（三）.json","excerpt":"《第一行代码》读书笔记 – 应用组件之 Service","covers":["https://img.wshunli.com/Android/第一行代码/3.Handler.png","https://img.wshunli.com/Android/第一行代码/3.service_lifecycle.png"],"content":"<p>《第一行代码》读书笔记 – 应用组件之 Service</p><a id=\"more\"></a><h1 id=\"第10章-后台默默的劳动者\"><a href=\"#第10章-后台默默的劳动者\" class=\"headerlink\" title=\"第10章 后台默默的劳动者\"></a>第10章 后台默默的劳动者</h1><p>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。</p><p>服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。</p><h2 id=\"Android-多线程编程\"><a href=\"#Android-多线程编程\" class=\"headerlink\" title=\"Android 多线程编程\"></a>Android 多线程编程</h2><p>Android 多线程 和 Java 多线程基本相同。</p><p>定义一个线程只需要新建一个类继承自 Thread 或者 实现 Runnable 接口，然后重写或者实现 run() 方法。</p><pre><code class=\"Java\">new Thread(new Runnable() {\n    @Override\n    public void run() {\n      // 异步操作\n    }\n}).start();\n</code></pre><p>1、Service 与 Thread 的区别：</p><p>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。<br>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。<br>Thread 是程序执行的最小单元，可以用 Thread 来执行一些异步的操作。</p><p><a href=\"http://blog.csdn.net/wei_chong_chong/article/details/52251193\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/wei_chong_chong/article/details/52251193</a></p><p>2、在子线程中更新 UI</p><p>(1) Activity 的 runOnUiThread() 方法</p><pre><code class=\"Java\">runOnUiThread(new Runnable() {\n    @Override\n    public void run() {\n        // 更新 UI 操作\n    }\n});\n</code></pre><p>(2) View.post(Runnable r)</p><pre><code class=\"Java\">textView.post(new Runnable() {\n    @Override\n    public void run() {\n        // 更新 UI 操作\n    }\n});\n</code></pre><p>其中 <code>textView</code> 可替换为其他 View 。</p><p>(3) Handler</p><p>新建 Handler 对象，重写 handleMessage() 方法，对 Message 进行处理。</p><pre><code class=\"Java\">private Handler handler = new Handler() {\n    public void handleMessage(Message msg) {\n        switch (msg.what) {\n            case UPDATE_TEXT:\n                textView.setText(&quot;Nice to meet you!&quot;);\n        }\n    }\n};\n</code></pre><p>在子线程中使用 Hander 对象发送 Message 对象即可。</p><pre><code class=\"Java\">Message message = new Message();\nmessage.what = UPDATE_TEXT;\nhandler.sendMessage(message);\n</code></pre><p>3、异步消息处理机制</p><p>Message：消息，其中包含了消息ID，消息处理对象及处理的数据等，由MessageQueue统一列队，终由 Handler 处理。<br>Handler：处理者，负责 Message 的发送及处理。使用 Handler 时，需要实现 handleMessage(Message msg) 方法来对特定的 Message 进行处理，例如更新 UI 等。<br>MessageQueue：消息队列，用来存放 Handler 发送过来的消息，并按照 FIFO 规则执行。当然，存放 Message 并非实际意义的保存，而是将 Message 以链表的方式串联起来的，等待 Looper 的抽取。<br>Looper：消息泵，不断地从 MessageQueue 中抽取 Message 执行。因此，一个 MessageQueue 需要一个 Looper。</p><p><strong>Handler 的工作机制</strong>简单来说是这样的：</p><p>首先在主线程中新建 Handler 对象，并重写 handleMessage() 方法。然后当子线程中想更新 UI 时，就创建一个 Message 对象，并通过 Handler 将消息发送出去。之后消息会被添加到 MessageQueue 中等待被处理，而 Looper 则会一直尝试从 MessageQueue 中取出待处理的消息，最后分发回 Handler 的 handlerMessage() 方法中。</p><p><img src=\"https://img.wshunli.com/Android/第一行代码/3.Handler.png\" alt=\"Handler\"></p><p><a href=\"https://www.jianshu.com/p/9e4d1fab0f36\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.jianshu.com/p/9e4d1fab0f36</a><br><a href=\"http://blog.csdn.net/guolin_blog/article/details/9991569\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p><p>4、AsyncTask 的基本用法</p><p>AsyncTask 是一个抽象类，我们创建一个子类继承它。</p><p>AsyncTask 可以指定三个泛型参数：</p><p>(1) Params，在执行 AsyncTask 时需要传入的参数。<br>(2) Progress，后台计算过程中的进度单元类型。<br>(3) Result，后台运行的结果类型。</p><pre><code class=\"Java\">private class AsyncTaskDemo extends AsyncTask&lt;Void, Integer, Boolean&gt; {\n\n    @Override\n    protected Boolean doInBackground(Void... voids) {\n        return true;\n    }\n}\n</code></pre><p>AsyncTask 常用的方法：</p><p><code>onPreExecute()</code> 此方法会在后台任务执行前被调用，用于进行一些准备工作。<br><code>doInBackground(Params… params)</code> 此方法中定义要执行的后台任务，在这个方法中可以调用 publishProgress() 来更新任务进度（publishProgress 内部会调用 onProgressUpdate 方法）。<br><code>onProgressUpdate(Progress… values)</code> 由 publishProgress() 内部调用，表示任务进度更新。<br><code>onPostExecute(Result result)</code> 后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果。<br><code>onCancelled()</code> 此方法会在后台任务被取消时被调用。</p><h2 id=\"服务的基本用法\"><a href=\"#服务的基本用法\" class=\"headerlink\" title=\"服务的基本用法\"></a>服务的基本用法</h2><h3 id=\"创建服务\"><a href=\"#创建服务\" class=\"headerlink\" title=\"创建服务\"></a>创建服务</h3><p>要创建服务，您必须创建 Service 的子类（或使用它的一个现有子类），并且在使用清单文件声明服务。</p><pre><code class=\"Java\">public class HelloService extends Service {\n    public HelloService() {\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // TODO: Return the communication channel to the service.\n        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);\n    }\n}\n</code></pre><h3 id=\"启动及停止服务\"><a href=\"#启动及停止服务\" class=\"headerlink\" title=\"启动及停止服务\"></a>启动及停止服务</h3><p>通过将 Intent（指定要启动的服务）传递给 startService()，从 Activity 或其他应用组件启动服务。Android 系统调用服务的 onStartCommand() 方法，并向其传递 Intent。（切勿直接调用 onStartCommand()。）</p><pre><code class=\"Java\">Intent intent = new Intent(this, HelloService.class);\nstartService(intent);\n</code></pre><p>服务必须通过调用 stopSelf() 自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。<br>一旦请求使用 stopSelf() 或 stopService() 停止服务，系统就会尽快销毁服务。</p><pre><code class=\"Java\">Intent intent = new Intent(this, HelloService.class);\nstopService(intent);\n</code></pre><h3 id=\"活动与服务进行通信\"><a href=\"#活动与服务进行通信\" class=\"headerlink\" title=\"活动与服务进行通信\"></a>活动与服务进行通信</h3><p>Activity 与 Service 进行通信可以通过创建 Binder 对象来实现。</p><p>创建 Bindler 的子类，然后在内部提供自定义的方法，在 Service 的 onBind() 方法中返回 Bindler 对象。</p><pre><code class=\"Java\">public class HelloService extends Service {\n\n    private static final String TAG = &quot;HelloService&quot;;\n    private DownloadBinder mBinder = new DownloadBinder();\n\n    public HelloService() {\n    }\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        // TODO: Return the communication channel to the service.\n        return mBinder;\n    }\n\n    class DownloadBinder extends Binder {\n        public void startDownlaod() {\n            Log.d(TAG, &quot;startDownlaod: &quot;);\n        }\n\n        public int getProgress() {\n            Log.d(TAG, &quot;getProgress: &quot;);\n            return 0;\n        }\n    }\n}\n</code></pre><p>然后 绑定 Activity 和 Service ，就可以调用 Binder 提供的方法了。</p><p>1、首先创建 ServiceConnection 的匿名类，重写方法。</p><pre><code class=\"java\">private HelloService.DownloadBinder downloadBinder;\nprivate ServiceConnection connection = new ServiceConnection() {\n    @Override\n    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {\n        downloadBinder = (HelloService.DownloadBinder) iBinder;\n        downloadBinder.startDownlaod();\n        downloadBinder.getProgress();\n    }\n    @Override\n    public void onServiceDisconnected(ComponentName componentName) {\n\n    }\n};\n</code></pre><p>2、然后使用 bindService() 方法绑定 Service 。</p><pre><code class=\"Java\">bindService(new Intent(this, MyService.class), connection, BIND_AUTO_CREATE);\n</code></pre><h2 id=\"服务的声明周期\"><a href=\"#服务的声明周期\" class=\"headerlink\" title=\"服务的声明周期\"></a>服务的声明周期</h2><p>服务生命周期（从创建到销毁）可以遵循两条不同的路径：</p><ul><li>启动服务</li></ul><p>该服务在其他组件调用 startService() 时创建，然后无限期运行，且必须通过调用 stopSelf() 来自行停止运行。此外，其他组件也可以通过调用 stopService() 来停止服务。服务停止后，系统会将其销毁。</p><ul><li>绑定服务</li></ul><p>该服务在另一个组件（客户端）调用 bindService() 时创建。然后，客户端通过 IBinder 接口与服务进行通信。客户端可以通过调用 unbindService() 关闭连接。</p><p><img src=\"https://img.wshunli.com/Android/第一行代码/3.service_lifecycle.png\" alt=\"3.service_lifecycle\"></p><h2 id=\"前台服务\"><a href=\"#前台服务\" class=\"headerlink\" title=\"前台服务\"></a>前台服务</h2><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知。</p><p>要请求让服务运行于前台，在 Service 中调用 startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification。例如：</p><pre><code class=\"Java\">Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());\nIntent notificationIntent = new Intent(this, ExampleActivity.class);\nPendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);\nnotification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);\nstartForeground(ONGOING_NOTIFICATION_ID, notification);\n</code></pre><h2 id=\"IntentService\"><a href=\"#IntentService\" class=\"headerlink\" title=\"IntentService\"></a>IntentService</h2><p>IntentService 是一种异步的、可以自动停止的服务。</p><p>IntentService 执行以下操作：</p><ul><li>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</li><li>创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。</li><li>在处理完所有启动请求后停止服务，因此您永远不必调用 stopSelf()。</li><li>提供 onBind() 的默认实现（返回 null）。</li><li>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。</li></ul><p>综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。</p><pre><code class=\"Java\">public class HelloIntentService extends IntentService {\n\n  /**\n   * A constructor is required, and must call the super IntentService(String)\n   * constructor with a name for the worker thread.\n   */\n  public HelloIntentService() {\n      super(&quot;HelloIntentService&quot;);\n  }\n\n  /**\n   * The IntentService calls this method from the default worker thread with\n   * the intent that started the service. When this method returns, IntentService\n   * stops the service, as appropriate.\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // Normally we would do some work here, like download a file.\n      // For our sample, we just sleep for 5 seconds.\n      try {\n          Thread.sleep(5000);\n      } catch (InterruptedException e) {\n          // Restore interrupt status.\n          Thread.currentThread().interrupt();\n      }\n  }\n}\n</code></pre><blockquote><p>参考资料<br>1、Service | Android Developers<br><a href=\"https://developer.android.com/guide/components/services.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://developer.android.com/guide/components/services.html</a><br>2、Service与Thread区别 - CSDN博客<br><a href=\"http://blog.csdn.net/wei_chong_chong/article/details/52251193\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/wei_chong_chong/article/details/52251193</a><br>3、android的消息机制——Handler机制 - 简书<br><a href=\"https://www.jianshu.com/p/9e4d1fab0f36\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.jianshu.com/p/9e4d1fab0f36</a><br>4、Android异步消息处理机制完全解析，带你从源码的角度彻底理解 - CSDN博客<br><a href=\"http://blog.csdn.net/guolin_blog/article/details/9991569\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/guolin_blog/article/details/9991569</a></p></blockquote>","categories":[{"name":"移动端技术","path":"api/categories/移动端技术.json"}],"tags":[{"name":"Android","path":"api/tags/Android.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《第一行代码》","path":"api/tags/《第一行代码》.json"}]}