{"title":"《ECMAScript6入门》读书笔记（一）","slug":"《ECMAScript6入门》读书笔记（一）","date":"2017-11-05T03:36:26.000Z","updated":"2018-04-10T14:49:55.442Z","comments":true,"path":"api/articles/《ECMAScript6入门》读书笔记（一）.json","excerpt":"《ECMAScript6入门》读书笔记","covers":null,"content":"<p>《ECMAScript6入门》读书笔记</p><a id=\"more\"></a><p>《JavaScript高级程序设计》中学习了前八章，后面是一些 DOM 相关的知识，现在开始学习 ES6 语法。</p><p><a href=\"http://es6.ruanyifeng.com/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《ECMAScript6入门》</a> 作者：阮一峰。</p><h1 id=\"第1章-ECMAScript6-简介\"><a href=\"#第1章-ECMAScript6-简介\" class=\"headerlink\" title=\"第1章 ECMAScript6 简介\"></a>第1章 ECMAScript6 简介</h1><p>ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等。</p><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码。<br>ESLint 用于静态检查代码的语法和风格；Mocha 则是一个测试框架。</p><h1 id=\"第2章-let-和-const-命令\"><a href=\"#第2章-let-和-const-命令\" class=\"headerlink\" title=\"第2章 let 和 const 命令\"></a>第2章 let 和 const 命令</h1><h2 id=\"let-命令\"><a href=\"#let-命令\" class=\"headerlink\" title=\"let 命令\"></a>let 命令</h2><p>let 命令只在其所在的代码块内有效。</p><pre><code class=\"JavaScript\">{\n  let a = 10;\n  var b = 1;\n}\n\nconsole.log(a); // ReferenceError: a is not defined.\nconsole.log(b); // 1\n</code></pre><p>前面闭包中有说：闭包只能取得函数中任何变量的最后一个值。</p><pre><code class=\"JavaScript\">var a = [];\nfor (var i = 0; i &lt; 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n</code></pre><p>使用 let 声明的变量仅在块级作用域内有效。</p><pre><code class=\"JavaScript\">var a = [];\nfor (let i = 0; i &lt; 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n</code></pre><p>其实 i 仅在当前循环有效。每循环一次就是一个新的变量。</p><p><strong>1.不存在变量提升</strong>：var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined；let 变量声明前使用会报错。</p><pre><code class=\"JavaScript\">console.log(c); // ReferenceError: a is not defined.\nconsole.log(d); // undefined\n\nlet c;\nvar d;\n</code></pre><p><strong>2.暂时性死区</strong>：在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。</p><pre><code class=\"JavaScript\">var tmp = 123;\nif (true) {\n  tmp = &#39;abc&#39;; // ReferenceError\n  let tmp;\n}\n</code></pre><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><p><strong>3.不允许重复声明</strong>：let 不允许在相同作用域内，重复声明同一个变量。也不能在函数内部重新声明参数。</p><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>第一种场景，内层变量可能会覆盖外层变量；第二种场景，用来计数的循环变量泄露为全局变量。</p><p>let 实际上为 JavaScript 新增了块级作用域。</p><pre><code class=\"JavaScript\">function f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n</code></pre><p>内部代码块可以定义外层作用域的同名变量；外层作用域无法读取内层作用域的变量，也不受内层代码块的影响。</p><p><strong>块级作用域与函数声明</strong>：ES6 允许在块级作用域之中声明函数，但函数在块级作用域之外不可引用。<br>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><h2 id=\"const-命令\"><a href=\"#const-命令\" class=\"headerlink\" title=\"const 命令\"></a>const 命令</h2><p>const声明一个只读的常量。一旦声明，就必须立即初始化，常量的值不能改变。</p><pre><code class=\"JavaScript\">const PI = 3.1415;\nconsole.log(PI); // 3.1415\nPI = 3; // TypeError: Assignment to constant variable.\nconst foo; // SyntaxError: Missing initializer in const declaration\n</code></pre><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。<br>const 命令声明的常量也是不提升；同样存在暂时性死区，只能在声明的位置后面使用；并且不可重复声明。</p><p><strong>本质</strong>：const 其实是变量指向的内存地址不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），等同于常量。但对于复合类型的数据（主要是对象和数组），变量保存的只是一个指针，const 只能保证这个指针是固定的。</p><pre><code class=\"JavaScript\">const foo = {};\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: &quot;foo&quot; is read-only\n</code></pre><p>如果真的想将对象冻结，应该使用 <code>Object.freeze</code> 方法。</p><pre><code class=\"JavaScript\">const foo = Object.freeze({});\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n</code></pre><h2 id=\"顶层对象的属性\"><a href=\"#顶层对象的属性\" class=\"headerlink\" title=\"顶层对象的属性\"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 中，顶层对象的属性与全局变量是等价的。</p><pre><code class=\"JavaScript\">window.a = 1;\nconsole.log(a); // 1\nb = 2;\nconsole.log(window.b); // 2\n</code></pre><p>ES6 规定 let、const、class 命令声明的全局变量，不属于顶层对象的属性。</p><pre><code class=\"JavaScript\">var a = 1;\n// 如果在 Node 的 REPL 环境，可以写成 global.a\n// 或者采用通用方法，写成 this.a\nconsole.log(window.a) // 1\nlet b = 1;\nconsole.log(window.b) // undefined\n</code></pre><h1 id=\"第3章-变量的解构赋值\"><a href=\"#第3章-变量的解构赋值\" class=\"headerlink\" title=\"第3章 变量的解构赋值\"></a>第3章 变量的解构赋值</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对 <strong>变量</strong> 进行赋值，这被称为解构。</p><h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><pre><code class=\"JavaScript\">let [a, b, c] = [1, 2, 3];\n</code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><pre><code class=\"JavaScript\">// 右边比左边少，解构不成功，值为 undefined\nlet [bar, foo] = [1]; // undefined,undefined\n// 右边比左边多，不完全解构\nlet [x, y] = [1, 2, 3]; //1,2\n</code></pre><p><strong>默认值</strong>：解构赋值允许指定默认值。</p><pre><code class=\"JavaScript\">let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // &#39;a&#39;,&#39;b&#39;\nlet [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // &#39;a&#39;,&#39;b&#39;\n// 只有数组成员 严格等于 undefined 时，默认值才会生效\nlet [x = 1] = [null]; // null\n</code></pre><h2 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class=\"JavaScript\">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; //&quot;aaa&quot;,&quot;bbb&quot;\nlet { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // undefined\n</code></pre><p>对象的属性没有次序；变量必须与属性同名，才能取到正确的值。</p><p>变量名与属性名不一致:真正被赋值的是后者，而不是前者。</p><pre><code class=\"JavaScript\">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };\nconsole.log(baz); // &quot;aaa&quot;\n</code></pre><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。</p><p>实际上，对象的解构时下面形式的简写：</p><pre><code class=\"JavaScript\">let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 完整形式\nlet { foo     , bar      } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 简写形式\n</code></pre><p>嵌套赋值：</p><pre><code class=\"JavaScript\">let obj = {};\nlet arr = [];\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\nconsole.log(obj); // {prop:123}\nconsole.log(arr); // [true]\n</code></pre><p>对象的解构也可以指定默认值。同样严格等于 undefined 才生效。</p><pre><code class=\"JavaScript\">let {x = 3} = {};\nconsole.log(x); // 3\nlet {x: y = 3} = {};\nconsole.log(y); // 3\n</code></pre><p>如果要将一个已经声明的变量用于解构赋值，必须用括号包裹，不能让花括号处于行首。</p><pre><code class=\"JavaScript\">let x;\n{x} = {x: 1}; // 错误的写法\n({x} = {x: 1}); // 正确的写法\n</code></pre><h2 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><pre><code class=\"JavaScript\">// 字符串可以看做数组进行结构\nconst [a, b, c, d, e] = &#39;hello&#39;;    // a:&quot;h&quot;, b:&quot;e&quot;, c:&quot;l&quot;, d:&quot;l&quot;, e:&quot;o&quot;,\n// 字符串作为类数组对象，拥有length属性。\nlet {length : len} = &#39;hello&#39;;       // len:5\n</code></pre><h2 id=\"数值和布尔值的解构赋值\"><a href=\"#数值和布尔值的解构赋值\" class=\"headerlink\" title=\"数值和布尔值的解构赋值\"></a>数值和布尔值的解构赋值</h2><p>数值和布尔值也能进行解构，两者会先转为对象，剩下的就是匹配对象中的方法</p><pre><code class=\"JavaScript\">let {toString: s} = 123;\ns === Number.prototype.toString  // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n\n// undefined和null不能转为对象，没有属性\nlet { prop: x } = undefined;     // TypeError\nlet { prop: y } = null;          // TypeError\n</code></pre><h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p><pre><code class=\"JavaScript\">function add([x, y]){\n  return x + y;\n}\nadd([1, 2]); // 3\n</code></pre><p>函数 add() 的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引。</p><p>函数参数的解构也可以使用默认值。</p><pre><code class=\"JavaScript\">function move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3});       // [3, 0]\nmove({});           // [0, 0]\nmove();             // [0, 0]\n</code></pre><p>下面代码是为函数 move() 的参数指定默认值。</p><pre><code class=\"JavaScript\">function move({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3});       // [3, undefined]\nmove({});           // [undefined, undefined]\nmove();             // [0, 0] - 无参数，默认值生效\n</code></pre><h2 id=\"圆括号问题\"><a href=\"#圆括号问题\" class=\"headerlink\" title=\"圆括号问题\"></a>圆括号问题</h2><p>ES6 规定，但凡有可能产生歧义，就不能使用圆括号。以下3种情况下不能用圆括号：</p><p>1.变量声明语句</p><pre><code class=\"JavaScript\">let [(a)] = [1];\nlet {x: (c)} = {};\nlet { o: ({ p: p }) } = { o: { p: 2 } };\n</code></pre><p>2.函数参数</p><pre><code class=\"JavaScript\">function f([(z)]) { return z; }\nfunction f([z,(x)]) { return x; }\n</code></pre><p>3.赋值语句的模式</p><pre><code class=\"JavaScript\">[(b)] = [3]; // 正确，数组的解构赋值根据索引来，与括号无关\n({ p: (d) } = {}); // 正确，p 是模式，但 d 不是模式。\n</code></pre><h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><p>1.<strong>交换变量的值</strong></p><pre><code class=\"javascript\">let x = 1;\nlet y = 2;\n[x, y] = [y, x];\n</code></pre><p>2.<strong>从函数返回多个值</strong></p><pre><code class=\"javascript\">// 返回一个数组\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n// 返回一个对象\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n</code></pre><p>3.<strong>函数参数的定义</strong></p><pre><code class=\"javascript\">// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n</code></pre><p>4.<strong>提取JSON数据</strong></p><pre><code class=\"javascript\">let jsonData = {\n  id: 42,\n  status: &quot;OK&quot;,\n  data: [867, 5309]\n};\nlet { id, status, data: number } = jsonData;\nconsole.log(id, status, number);\n// 42, &quot;OK&quot;, [867, 5309]\n</code></pre><p>5.<strong>函数参数的默认值</strong></p><pre><code class=\"javascript\">jQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n}) {\n  // ... do stuff\n};\n</code></pre><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p>6.<strong>遍历 Map 结构</strong></p><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><pre><code class=\"javascript\">const map = new Map();\nmap.set(&#39;first&#39;, &#39;hello&#39;);\nmap.set(&#39;second&#39;, &#39;world&#39;);\n\nfor (let [key, value] of map) {\n  console.log(key + &quot; is &quot; + value);\n}\n// first is hello\n// second is world\n\n// 如果只想获取键名或键值，可以写成下面这样。\nfor (let [key] of map) { ... }// 获取键名\nfor (let [,value] of map) { ...}// 获取键值\n</code></pre><p>7.<strong>输入模块的指定方法</strong></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><pre><code class=\"javascript\">const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);\n</code></pre>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《ECMAScript6入门》","path":"api/tags/《ECMAScript6入门》.json"}]}