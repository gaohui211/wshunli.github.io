{"title":"《ECMAScript6入门》读书笔记（二）","slug":"《ECMAScript6入门》读书笔记（二）","date":"2017-11-05T12:01:26.000Z","updated":"2018-04-12T14:50:56.707Z","comments":true,"path":"api/articles/《ECMAScript6入门》读书笔记（二）.json","excerpt":"《ECMAScript6入门》读书笔记","covers":null,"content":"<p>《ECMAScript6入门》读书笔记</p><a id=\"more\"></a><p>ES6 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><h1 id=\"字符、数值、正则的扩展\"><a href=\"#字符、数值、正则的扩展\" class=\"headerlink\" title=\"字符、数值、正则的扩展\"></a>字符、数值、正则的扩展</h1><p>第4章 字符串的扩展：<a href=\"http://es6.ruanyifeng.com/#docs/string\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://es6.ruanyifeng.com/#docs/string</a><br>第5章 数值的扩展：<a href=\"http://es6.ruanyifeng.com/#docs/array\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://es6.ruanyifeng.com/#docs/array</a><br>第6章 正则的扩展：<a href=\"http://es6.ruanyifeng.com/#docs/regex\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://es6.ruanyifeng.com/#docs/regex</a></p><h1 id=\"第7章-数组的扩展\"><a href=\"#第7章-数组的扩展\" class=\"headerlink\" title=\"第7章 数组的扩展\"></a>第7章 数组的扩展</h1><h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><p>扩展运算符是三个点（<code>...</code>），将一个数组转为用逗号分隔的参数序列。</p><pre><code class=\"JavaScript\">console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5\n\nfunction push(array, ...items) {\n  array.push(...items);\n}\n\nfunction add(x, y) {\n  return x + y;\n}\nconst numbers = [4, 38];\nadd(...numbers); // 42\n</code></pre><h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><pre><code class=\"JavaScript\">let arrayLike = {\n    &#39;0&#39;: &#39;a&#39;,\n    &#39;1&#39;: &#39;b&#39;,\n    &#39;2&#39;: &#39;c&#39;,\n    length: 3\n};\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n// ES6的写法\nlet arr2 = Array.from(arrayLike);    // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n</code></pre><h2 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h2><p>Array.of 方法用于将一组值，转换为数组。</p><pre><code class=\"JavaScript\">Array.of(3, 11, 8) // [3,11,8]\n</code></pre><h2 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h2><p>数组实例的 copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</p><pre><code class=\"JavaScript\">Array.prototype.copyWithin(target, start = 0, end = this.length)\n</code></pre><p>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p><pre><code class=\"JavaScript\">[1, 2, 3, 4, 5].copyWithin(0, 3);\n// [4, 5, 3, 4, 5]\n</code></pre><h2 id=\"find-amp-findIndex\"><a href=\"#find-amp-findIndex\" class=\"headerlink\" title=\"find() &amp; findIndex()\"></a>find() &amp; findIndex()</h2><p>数组实例的 find() 方法，用于找出第一个符合条件的数组成员。<br>它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。</p><pre><code class=\"JavaScript\">[1, 5, 10, 15].find(function(value, index, arr) {\n  return value &gt; 9;\n}) // 10\n</code></pre><p>find() 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><pre><code class=\"JavaScript\">[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value &gt; 9;\n}) // 2\n</code></pre><p>findIndex() 方法的用法与 find() 方法非常类似，返回第一个符合条件的数组成员的位置</p><h2 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill()\"></a>fill()</h2><p>数组实例的 fill() 方法使用给定值，填充一个数组。</p><pre><code class=\"JavaScript\">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7); // [7, 7, 7]\nnew Array(3).fill(7); // [7, 7, 7]\n// 第二个和第三个参数，用于指定填充的起始位置和结束位置。\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2); // [&#39;a&#39;, 7, &#39;c&#39;]\n</code></pre><h2 id=\"entries-，keys-和-values\"><a href=\"#entries-，keys-和-values\" class=\"headerlink\" title=\"entries()，keys() 和 values()\"></a>entries()，keys() 和 values()</h2><p>ES6 提供三个新的方法 – entries()，keys() 和 values() – 用于遍历数组。<br>可以用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p><pre><code class=\"JavaScript\">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {\n  console.log(index);\n}\n// 0\n// 1\nfor (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {\n  console.log(elem);\n}\n// &#39;a&#39;\n// &#39;b&#39;\nfor (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {\n  console.log(index, elem);\n}\n// 0 &quot;a&quot;\n// 1 &quot;b&quot;\n</code></pre><h2 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes()\"></a>includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p><pre><code class=\"JavaScript\">[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, NaN].includes(NaN) // true\n// 第二个参数表示搜索的起始位置，默认为0\n[1, 2, 3].includes(3, 3);  // false\n</code></pre><h2 id=\"数组的空位\"><a href=\"#数组的空位\" class=\"headerlink\" title=\"数组的空位\"></a>数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。</p><pre><code class=\"JavaScript\">Array(3) // [, , ,]\n</code></pre><p>ES6 明确将空位转为 undefined。</p><pre><code class=\"JavaScript\">Array.from([&#39;a&#39;,,&#39;b&#39;]); // [ &quot;a&quot;, undefined, &quot;b&quot; ]\n</code></pre><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p><h1 id=\"第8章-函数的扩展\"><a href=\"#第8章-函数的扩展\" class=\"headerlink\" title=\"第8章 函数的扩展\"></a>第8章 函数的扩展</h1><h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><pre><code class=\"JavaScript\">function log(x, y = &#39;World&#39;) {\n  console.log(x, y);\n}\nlog(&#39;Hello&#39;)          // Hello World\nlog(&#39;Hello&#39;, &#39;China&#39;) // Hello China\nlog(&#39;Hello&#39;, &#39;&#39;)      // Hello\n</code></pre><p>参数默认值是惰性求值的。</p><p><strong>与解构赋值默认值结合使用</strong>：</p><p>函数默认值生效：当前参数没有传值或传值为 undefined ；<br>解构赋值默认值生效：当前参数传值或没有传值而默认值与 undefined 严格相等。</p><pre><code class=\"JavaScript\">// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n\nm1()               // [0, 0]\nm2()               // [0, 0]\n\nm1( {x: 3, y: 8} ) // [3, 8]\nm2( {x: 3, y: 8} ) // [3, 8]\n\nm1( {x: 3} )       // [3, 0]\nm2( {x: 3} )       // [3, undefined]\n\nm1( {} )           // [0, 0];\nm2( {} )           // [undefined, undefined]\n\nm1( {z: 3} )       // [0, 0]\nm2( {z: 3} )       // [undefined, undefined]\n</code></pre><p>区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><p><strong>参数默认值的位置</strong>：</p><p>定义了默认值的参数应该是函数的尾参数，否则这个参数不能省略。</p><pre><code class=\"JavaScript\">// 例一：默认值的参数在前\nfunction f(x = 1, y) {\n  console.log([x, y]);\n}\nf();             // [1, undefined]\nf(2);            // [2, undefined]\nf(, 1);          // 报错\nf(undefined, 1); // [1, 1]\n// 例二：默认值的参数在后\nfunction f(x , y= 1) {\n  console.log([x, y]);\n}\nf();             // [undefined, 1]\nf(2);            // [2, 1]\nf(2, );          // [2, 1]\nf(2, undefined); // [2, 1]\n</code></pre><p>undefined 能触发默认值，null 不能。</p><pre><code class=\"JavaScript\">function foo(x = 5, y = 6) {\n  console.log(x, y);\n}\nfoo(undefined, null); // 5 null\n</code></pre><p><strong>函数的 length 属性</strong>：没有指定默认值的参数个数。</p><p><strong>作用域</strong>：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。</p><pre><code class=\"JavaScript\">var x = 1;\nfunction f(x, y = x) {\n  console.log(y);\n}\nf();  // undefined\nf(2); // 2\n// x 没有定义，所以指向外部全局变量 x\nlet x = 1;\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\nf();  // 1\nf(3); // 3\n</code></pre><p>更复杂的例子：</p><pre><code class=\"JavaScript\">var x = 1; // 全局变量\nfunction foo(x, y = function() { x = 2; }) { //函数参数作用域\n  var x = 3; // 函数内部变量\n  y();\n  console.log(x);\n}\nfoo();          // 3 - 第5行\nconsole.log(x); // 1\n</code></pre><h2 id=\"rest-参数\"><a href=\"#rest-参数\" class=\"headerlink\" title=\"rest 参数\"></a>rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数。</p><pre><code class=\"JavaScript\">function add(...values) {\n  let sum = 0;\n  for (var val of values) {\n    sum += val;\n  }\n  return sum;\n}\nadd(2, 5, 3); // 10\n</code></pre><p>rest 参数搭配的变量为数组，arguments 为类似数组的对象。<br>rest 参数之后不能再有其他参数；函数的 length 属性，也不包括 rest 参数。</p><h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><h2 id=\"name-属性\"><a href=\"#name-属性\" class=\"headerlink\" title=\"name 属性\"></a>name 属性</h2><p>函数的 name 属性，返回该函数的函数名。</p><pre><code class=\"JavaScript\">function foo() {}\nfoo.name // &quot;foo&quot;\nvar f = function () {};\nf.name // &quot;&quot; - ES5\nf.name // &quot;f&quot; - ES6\n</code></pre><h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><pre><code class=\"JavaScript\">var sum = (num1, num2) =&gt; num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n</code></pre><p>箭头函数有几个使用注意点：<br>（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。<br>（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</p><pre><code class=\"JavaScript\">function foo() {\n  setTimeout(() =&gt; {\n    console.log(&#39;id:&#39;, this.id);\n  }, 100);\n}\nvar id = 21;\nfoo.call({ id: 42 }); // id: 42\n</code></pre><p>箭头函数 this 指向定义时所在的对象。</p><pre><code class=\"JavaScript\">function Timer() {\n  this.s1 = 0;\n  this.s2 = 0;\n  setInterval(() =&gt; this.s1++, 1000); // 箭头函数\n  setInterval(function () {           // 普通函数\n    this.s2++;\n  }, 1000);\n}\nvar timer = new Timer();\nsetTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100); // s1: 3\nsetTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100); // s2: 0\n</code></pre><p>前者的 this 绑定定义时所在的作用域（即Timer函数），后者的 this 指向运行时所在的作用域（即全局对象）。</p><p>this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。</p><pre><code class=\"JavaScript\">// ES6\nfunction foo() {\n  setTimeout(() =&gt; {\n    console.log(&#39;id:&#39;, this.id);\n  }, 100);\n}\n// ES5\nfunction foo() {\n  var _this = this;\n  setTimeout(function () {\n    console.log(&#39;id:&#39;, _this.id);\n  }, 100);\n}\n</code></pre><p>由于没有 this，因而也不存在通过 bind()、call()、apply() 来改变 this 的指向。</p><p><strong>嵌套的箭头函数</strong>：箭头函数内部，还可以再使用箭头函数。</p><pre><code class=\"JavaScript\">let insert = (value) =&gt; ({into: (array) =&gt; ({after: (afterValue) =&gt; {\n  array.splice(array.indexOf(afterValue) + 1, 0, value);\n  return array;\n}})});\n// 等价于\nfunction insert(value) {\n  return {into: function (array) {\n    return {after: function (afterValue) {\n      array.splice(array.indexOf(afterValue) + 1, 0, value);\n      return array;\n    }};\n  }};\n}\n// 结果相同\ninsert(2).into([1, 3]).after(1); //[1, 2, 3]\n</code></pre><h2 id=\"双冒号运算符\"><a href=\"#双冒号运算符\" class=\"headerlink\" title=\"双冒号运算符\"></a>双冒号运算符</h2><p>函数绑定运算符是并排的两个冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><pre><code class=\"JavaScript\">foo::bar;\n// 等同于\nbar.bind(foo);\n</code></pre><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p><pre><code class=\"JavaScript\">var method = obj::obj.foo;\n// 等同于\nvar method = ::obj.foo;\n</code></pre><p>双冒号运算符的运算结果，还是一个对象，因此可以采用链式写法。</p><pre><code class=\"JavaScript\">let { find, html } = jake;\ndocument.querySelectorAll(&quot;div.myClass&quot;)\n::find(&quot;p&quot;)\n::html(&quot;hahaha&quot;);\n</code></pre><h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用（Tail Call）是指某个函数的最后一步是调用另一个函数。</p><pre><code class=\"JavaScript\">function f(x) {\n  if (x &gt; 0) {\n    return m(x)\n  }\n  return n(x);\n}\n</code></pre><p><strong>尾调用优化</strong>：即只保留内层函数的调用帧。</p><p>函数调用会在内存形成一个调用记录即“调用帧”，如果函数 A 调用函数 B ，还会形成一个 B 的调用帧，依次类推形成一个调用栈。</p><p>如果函数存在尾调用，只保留最后的函数的调用帧即可，这将大大节省内存。</p><pre><code class=\"JavaScript\">function f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n// 等同于\ng(3);\n</code></pre><p>执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p><p>注意，只有不再用到外层函数的内部变量才能进行“尾调用优化”。<br>下面函数就不会进行“尾调用优化”。</p><pre><code class=\"JavaScript\">function addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n</code></pre><p><strong>尾递归</strong>：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><pre><code class=\"JavaScript\">function factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\nfactorial(5) // 120\n// 改写成尾递归\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\nfacorial(5, 1) // 120\n</code></pre><h2 id=\"函数参数的尾逗号\"><a href=\"#函数参数的尾逗号\" class=\"headerlink\" title=\"函数参数的尾逗号\"></a>函数参数的尾逗号</h2><p>ES2017 允许函数的最后一个参数有尾逗号。</p><pre><code class=\"JavaScript\">function clownsEverywhere(\n  param1,\n  param2,\n) { /* ... */ }\nclownsEverywhere(\n  &#39;foo&#39;,\n  &#39;bar&#39;,\n);\n</code></pre><h1 id=\"第9章-对象的扩展\"><a href=\"#第9章-对象的扩展\" class=\"headerlink\" title=\"第9章 对象的扩展\"></a>第9章 对象的扩展</h1><h2 id=\"属性的简洁表示法\"><a href=\"#属性的简洁表示法\" class=\"headerlink\" title=\"属性的简洁表示法\"></a>属性的简洁表示法</h2><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p><pre><code class=\"JavaScript\">const foo = &#39;bar&#39;;\nconst baz = {foo};\n// 等同于\nconst baz = {foo: foo};\n</code></pre><p>除了属性简写，方法也可以简写。</p><pre><code class=\"JavaScript\">const o = {\n  method() {\n    return &quot;Hello!&quot;;\n  }\n};\n// 等同于\nconst o = {\n  method: function() {\n    return &quot;Hello!&quot;;\n  }\n};\n</code></pre><h2 id=\"属性名表达式\"><a href=\"#属性名表达式\" class=\"headerlink\" title=\"属性名表达式\"></a>属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p><pre><code class=\"JavaScript\">// 方法一\nobj.foo = true;\n// 方法二\nobj[&#39;a&#39; + &#39;bc&#39;] = 123;\n</code></pre><p>如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。<br>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名。</p><pre><code class=\"JavaScript\">let lastWord = &#39;last word&#39;;\nconst a = {\n  &#39;first word&#39;: &#39;hello&#39;,\n  [lastWord]: &#39;world&#39;\n};\na[&#39;first word&#39;] // &quot;hello&quot;\na[lastWord] // &quot;world&quot;\na[&#39;last word&#39;] // &quot;world&quot;\n</code></pre><p>表达式还可以用于定义方法名。</p><pre><code class=\"JavaScript\">let obj = {\n  [&#39;h&#39; + &#39;ello&#39;]() {\n    return &#39;hi&#39;;\n  }\n};\nobj.hello(); // hi\n</code></pre><p>注意：属性名表达式与简洁表示法不能同时使用；属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 <code>[object Object]</code>。</p><h2 id=\"方法的-name-属性\"><a href=\"#方法的-name-属性\" class=\"headerlink\" title=\"方法的 name 属性\"></a>方法的 name 属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p><pre><code class=\"JavaScript\">const person = {\n  sayName() {\n    console.log(&#39;hello!&#39;);\n  },\n};\nperson.sayName.name   // &quot;sayName&quot;\n</code></pre><h2 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h2><p>ES6 提出“Same-value equality”（同值相等）算法，用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。。</p><pre><code class=\"JavaScript\">Object.is(&#39;foo&#39;, &#39;foo&#39;); // true\nObject.is({}, {});       // false\n</code></pre><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><pre><code class=\"JavaScript\">+0 === -0           // true\nNaN === NaN         // false\nObject.is(+0, -0)   // false\nObject.is(NaN, NaN) // true\n</code></pre><h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h2><p>Object.assign() 方法用于对象的合并，将源对象（source）的所有<strong>可枚举属性</strong>，复制到目标对象（target）。</p><pre><code class=\"JavaScript\">const target = { a: 1 };\nconst source1 = { b: 2 };\nconst source2 = { c: 3 };\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n</code></pre><p>Object.assign() 方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>如果 undefined 或 null 作为第一个参数会报错，在之后则会跳过；<br>数值、布尔值可以被转换成包装对象，但依然会被忽略；<br>字符串转对象会被拆分成数组，除了原始值会被拷贝到<code>[[PrimitiveValue]]</code>属性中，每个字符都是可枚举的实义属性，因此是有效的。</p><pre><code class=\"JavaScript\">const v1 = &#39;abc&#39;;\nconst v2 = true;\nconst v3 = 10;\nconst obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }\n</code></pre><p>Object.assign() 只拷贝对象的自有属性，属性名为 Symbol 的属性也会被拷贝，继承属性和不可枚举的属性不会被拷贝。<br>Object.assign() 执行的是浅拷贝，对于同名属性会直接覆盖而非合并。<br>Object.assign() 可以用于处理数组，但会把数组转换成属性名为 0、1、2…… 的对象，并依次替换。</p><h2 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors()\"></a>Object.getOwnPropertyDescriptors()</h2><p>ES2017 引入了 <code>Object.getOwnPropertyDescriptors()</code> ，返回指定对象所有自身属性（非继承属性）的描述对象。</p><h2 id=\"Object-setPrototypeOf-，Object-getPrototypeOf\"><a href=\"#Object-setPrototypeOf-，Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()，Object.getPrototypeOf()\"></a>Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p><code>__proto__属性</code>:（前后各两个下划线），用来读取或设置当前对象的prototype对象。</p><p><strong>Object.setPrototypeOf()</strong>: 作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数对象本身。<br><strong>Object.getPrototypeOf()</strong>: 读取一个对象的原型对象。</p><h2 id=\"Object-keys-，Object-values-，Object-entries\"><a href=\"#Object-keys-，Object-values-，Object-entries\" class=\"headerlink\" title=\"Object.keys()，Object.values()，Object.entries()\"></a>Object.keys()，Object.values()，Object.entries()</h2><p>ES5 引入了 Object.keys() 来返回一个数组，其成员是参数对象的可枚举的自有属性的键名。<br>ES2017 跟着引入了 Object.values() 和 Object.entries() 用于返回属性对应的值，以及以键值对数组的形式返回。<br>可以配合 for…of 循环使用。</p><h2 id=\"属性的可枚举性和遍历\"><a href=\"#属性的可枚举性和遍历\" class=\"headerlink\" title=\"属性的可枚举性和遍历\"></a>属性的可枚举性和遍历</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。</p><p><strong>可枚举性</strong>：描述对象的 enumerable 属性，如果该属性为false，就表示某些操作会忽略当前属性。</p><p>for…in 循环、Object.keys()、JSON.stringify()、Object.assign() 忽略 enumerable 为 false 的属性。</p><p>ES6 一共有5种方法可以遍历对象的属性。</p><ol><li><code>for...in</code>：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li><li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</li><li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</li><li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li><li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li></ol><p>以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><h2 id=\"super-关键字\"><a href=\"#super-关键字\" class=\"headerlink\" title=\"super 关键字\"></a>super 关键字</h2><p>ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。</p><h2 id=\"对象的扩展运算符\"><a href=\"#对象的扩展运算符\" class=\"headerlink\" title=\"对象的扩展运算符\"></a>对象的扩展运算符</h2><p>ES2017 将这个运算符引入了对象。</p><p><strong>解构赋值</strong>:对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。</p><pre><code class=\"JavaScript\">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n</code></pre><p>解构赋值必须是最后一个参数，否则会报错。</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><p><strong>扩展运算符</strong>:</p><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><pre><code class=\"JavaScript\">let z = { a: 3, b: 4 };\nlet n = { ...z }; // { a: 3, b: 4 }\n</code></pre><p>扩展运算符可以用于合并两个对象。</p><pre><code class=\"JavaScript\">let ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre><code class=\"JavaScript\">let newVersion = {\n  ...previousVersion,\n  name: &#39;New Name&#39; // Override the name property\n};\n</code></pre><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><pre><code class=\"JavaScript\">let aWithDefaults = { x: 1, y: 2, ...a };\n// 等同于\nlet aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);\nlet aWithDefaults = Object.assign({ x: 1, y: 2 }, a);\n</code></pre><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p><pre><code class=\"JavaScript\">// 空对象没有任何效果\n{...{}, a: 1} // { a: 1 }\n// 忽略 null 和 undefined\nlet emptyObject = { ...null, ...undefined }; // 不报错\n</code></pre>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《ECMAScript6入门》","path":"api/tags/《ECMAScript6入门》.json"}]}