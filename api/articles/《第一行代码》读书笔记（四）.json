{"title":"《第一行代码》读书笔记（四）","slug":"《第一行代码》读书笔记（四）","date":"2018-03-12T10:13:45.000Z","updated":"2018-05-03T15:02:50.585Z","comments":true,"path":"api/articles/《第一行代码》读书笔记（四）.json","excerpt":"《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver","covers":null,"content":"<p>《第一行代码》读书笔记 – 应用组件之 BroadcastReceiver</p><a id=\"more\"></a><h1 id=\"第5章-全局大喇叭\"><a href=\"#第5章-全局大喇叭\" class=\"headerlink\" title=\"第5章 全局大喇叭\"></a>第5章 全局大喇叭</h1><p>BroadcastReceiver，广播接收者，它是一个系统全局的监听器，用于监听系统全局的 Broadcast 消息，所以它可以很方便的进行系统组件之间的通信。</p><p>BroadcastReceiver 属于系统级的监听器，它拥有自己的进程，只要存在与之匹配的 Broadcast 被以 Intent 的形式发送出来，BroadcastReceiver 就会被激活。</p><p>广播的使用场景：<br>（1）同一 APP 具有多进程的不同组件之间的信息通信。<br>（2）不同 APP 之间的组件之间信息通信。</p><p>Android中的广播分为两种类型，标准广播和有序广播</p><p>（1）标准广播<br>标准广播是一种完全异步执行的广播，在广播发出后所有的广播接收器会在同一时间接收到这条广播，之间没有先后顺序，效率比较高，且无法被截断。<br>（2）有序广播<br>有序广播是一种同步执行的广播，在广播发出后同一时刻只有一个广播接收器能够接收到， 优先级高的广播接收器会优先接收，当优先级高的广播接收器的 onReceiver() 方法运行结束后，广播才会继续传递，且前面的广播接收器可以选择截断广播，这样后面的广播接收器就无法接收到这条广播了。</p><h2 id=\"接收系统广播\"><a href=\"#接收系统广播\" class=\"headerlink\" title=\"接收系统广播\"></a>接收系统广播</h2><h3 id=\"动态注册\"><a href=\"#动态注册\" class=\"headerlink\" title=\"动态注册\"></a>动态注册</h3><p>动态注册 BroadcastReceiver 是在代码中定义并设置好一个 IntentFilter 对象，然后在需要注册的地方调用 Context.registerReceiver() 方法，调用 Context.unregisterReceiver() 方法取消注册，此时就不需要在清单文件中注册。</p><pre><code class=\"Java\">public class MainActivity extends AppCompatActivity {\n    private static final String TAG = &quot;MainActivity&quot;;\n    private IntentFilter intentFilter;\n    private NetWorkBroadcastReceiver netWorkBroadcastReceiver;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        intentFilter = new IntentFilter();\n        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);\n\n        netWorkBroadcastReceiver = new NetWorkBroadcastReceiver();\n        registerReceiver(netWorkBroadcastReceiver, intentFilter);\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unregisterReceiver(netWorkBroadcastReceiver);\n    }\n\n    class NetWorkBroadcastReceiver extends BroadcastReceiver{\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Log.d(TAG, &quot;onReceive: &quot;+&quot;network changes&quot;);\n        }\n    }\n}\n</code></pre><p>动态注册广播接收器可以自由地控制注册与注销，但是必须程序启动之后才能收到广播，因为注册的逻辑是写在 onCreate() 方法中。</p><h3 id=\"静态注册\"><a href=\"#静态注册\" class=\"headerlink\" title=\"静态注册\"></a>静态注册</h3><p>静态注册即在清单文件中为 BroadcastReceiver 进行注册，使用 &lt; receiver &gt; 标签声明，并在标签内用 &lt; intent-filter &gt; 标签设置过滤器。</p><p>这种形式的 BroadcastReceiver 的生命周期伴随着整个应用，如果这种方式处理的是系统广播，那么不管应用是否在运行，该广播接收器都能接收到该广播。</p><pre><code class=\"Java\">public class BootCompleteReceiver extends BroadcastReceiver {\n    private static final String TAG = &quot;BootCompleteReceiver&quot;;\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Log.d(TAG, &quot;onReceive: &quot;+&quot;Boot Complete&quot;);\n    }\n}\n</code></pre><p>manifest 文件中声明：</p><pre><code class=\"XML\">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;\n\n&lt;receiver\n    android:name=&quot;.BootCompleteReceiver&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><h2 id=\"发送自定义广播\"><a href=\"#发送自定义广播\" class=\"headerlink\" title=\"发送自定义广播\"></a>发送自定义广播</h2><p>前面是同通过广播接收器接收系统广播，接下来是发送自定义广播。</p><p>首先注册广播接收器，这里选择静态注册方法：</p><pre><code class=\"Java\">public class CustomReceiver extends BroadcastReceiver {\n    private static final String TAG = &quot;CustomReceiver&quot;;\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Log.d(TAG, &quot;onReceive: &quot;+&quot;接收到自定义广播&quot;);\n    }\n}\n</code></pre><p>然后在 manifest 中声明 广播接收器：</p><pre><code class=\"XML\">&lt;receiver\n    android:name=&quot;.CustomReceiver&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;com.wshunli.broadcastreceiverdemo.CUSTOM_BROADCAST&quot; /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><h3 id=\"发送标准广播\"><a href=\"#发送标准广播\" class=\"headerlink\" title=\"发送标准广播\"></a>发送标准广播</h3><p>发送标准广播调用的是 sendBroadcast(Intent) 方法</p><pre><code class=\"Java\">sendBroadcast(new Intent(&quot;com.wshunli.broadcastreceiverdemo.CUSTOM_BROADCAST&quot;));\n</code></pre><h3 id=\"发送有序广播\"><a href=\"#发送有序广播\" class=\"headerlink\" title=\"发送有序广播\"></a>发送有序广播</h3><p>发送有序广播调用的是 sendOrderedBroadcast(Intent , String) 方法，String 参数值在自定义权限时使用。</p><pre><code class=\"Java\">sendOrderedBroadcast(new Intent(&quot;com.wshunli.broadcastreceiverdemo.CUSTOM_BROADCAST&quot;),null);\n</code></pre><p>Receiver 接收广播时不仅因为 “priority” 属性存在先后顺序，且 Receiver 之间也能够传递数据。</p><p>此外，BroadcastReceiver 也能调用 abortBroadcast() 方法截断广播，这样低优先级的广播接收器就无法接收到广播了。</p><h2 id=\"使用本地广播\"><a href=\"#使用本地广播\" class=\"headerlink\" title=\"使用本地广播\"></a>使用本地广播</h2><p>之前发送和接收到的广播全都是属于系统全局广播，即发出的广播可以被其他应用接收到，而且也可以接收到其他应用发送出的广播，这样可能会有不安全因素。</p><p>因此，在某些情况下可以采用本地广播机制，使用这个机制发出的广播只能在应用内部进行传递，而且广播接收器也只能接收本应用内自身发出的广播。</p><p>本地广播是使用 LocalBroadcastManager 来对广播进行管理。</p><p>首先，创建一个 BroadcastReceiver 用于接收本地广播：</p><pre><code class=\"Java\">class LocalReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Log.d(TAG, &quot;onReceive: &quot; + &quot;LocalReceiver&quot;);\n    }\n}\n</code></pre><p>然后使用 LocalBroadcastManager 注册或者注销 广播接收器：</p><pre><code class=\"Java\">private IntentFilter intentFilter;\nprivate LocalReceiver localReceiver;\nprivate LocalBroadcastManager localBroadcastManager;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    intentFilter = new IntentFilter();\n    intentFilter.addAction(&quot;com.wshunli.broadcastreceiverdemo.LOCAL_BROADCAST&quot;);\n    localReceiver = new LocalReceiver();\n\n    localBroadcastManager = LocalBroadcastManager.getInstance(this);\n    localBroadcastManager.registerReceiver(localReceiver, intentFilter);\n}\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    localBroadcastManager.unregisterReceiver(localReceiver);\n}\n</code></pre><p>最后通过 LocalBroadcastManager 发送本地广播：</p><pre><code class=\"Java\">localBroadcastManager.sendBroadcast(new Intent(&quot;com.wshunli.broadcastreceiverdemo.LOCAL_BROADCAST&quot;));\n</code></pre><p>需要注意的是，本地广播是无法通过静态注册的方式来接收的，因为静态注册广播主要是为了在程序未启动的情况下也能接收广播，而本地广播是应用自己发送的，此时应用肯定是启动的了。</p><p>本地广播的优势：<br>（1）发送的广播不会离开我们的应用程序，所以不必担心机密数据泄露；<br>（2）其他程序的广播也无法发送到我们程序内部，不用担心会有安全漏洞；<br>（3）本地广播比发送系统全局广播将更加有效。</p><blockquote><p>参考资料<br>1、Broadcasts | Android Developers<br><a href=\"https://developer.android.com/guide/components/broadcasts.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://developer.android.com/guide/components/broadcasts.html</a><br>2、Android之BroadcastReceiver | 吴小龙同學<br><a href=\"http://wuxiaolong.me/2015/11/03/BroadcastReceiver/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://wuxiaolong.me/2015/11/03/BroadcastReceiver/</a><br>3、Android BroadcastReceiver使用详解 - 简书<br><a href=\"https://www.jianshu.com/p/f348f6d7fe59\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.jianshu.com/p/f348f6d7fe59</a><br>4、Android深入四大组件（四）广播的注册、发送和接收过程 | 刘望舒的博客<br><a href=\"http://liuwangshu.cn/framework/component/4-broadcastreceiver.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://liuwangshu.cn/framework/component/4-broadcastreceiver.html</a></p></blockquote>","categories":[{"name":"移动端技术","path":"api/categories/移动端技术.json"}],"tags":[{"name":"Android","path":"api/tags/Android.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《第一行代码》","path":"api/tags/《第一行代码》.json"}]}