{"title":"《Java编程思想》读书笔记（四）","slug":"《Java编程思想》读书笔记（四）","date":"2017-12-03T11:07:09.000Z","updated":"2018-04-22T14:56:15.955Z","comments":true,"path":"api/articles/《Java编程思想》读书笔记（四）.json","excerpt":"《Java编程思想》读书笔记 —— 集合。","covers":["https://img.wshunli.com/Java/Java编程思想/Java容器.png","https://img.wshunli.com/Java/Java编程思想/Java容器1.png"],"content":"<p>《Java编程思想》读书笔记 —— 集合。</p><a id=\"more\"></a><p>这部分只是还是挺重要的，面试题里面有好多。</p><p>第11章 <strong>持有对象</strong></p><p>Java 容器类提供了完善的方法保存对象，并经其划分为 <strong>Collection</strong> 和 <strong>Map</strong> 两个不同的概念。</p><p><img src=\"https://img.wshunli.com/Java/Java编程思想/Java容器.png\" alt=\"Java容器\"></p><p><strong>Collection</strong> 一个独立的元素序列；<strong>Map</strong> 一组成对的“键值对”对象。</p><h1 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h1><p>1.<strong>Collection</strong> 一个独立的元素序列，这些元素服从一条或者多条规则。</p><p>List 必须按照插入的顺序保存元素，而 Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序。</p><pre><code class=\"java\">public class SimpleCollection {\n  public static void main(String[] args) {\n    Collection&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;();\n    for(int i = 0; i &lt; 10; i++)\n      c.add(i); // Autoboxing\n    for(Integer i : c)\n      System.out.print(i + &quot;, &quot;);\n  }\n}\n/* Output:\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n*/\n</code></pre><p>2.Arrays 和 Collections 类有很多实用的方法，可以在 Collection 中添加一组元素。</p><pre><code class=\"Java\">public class AddingGroups {\n  public static void main(String[] args) {\n    Collection&lt;Integer&gt; collection =\n      new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5));\n    Integer[] moreInts = { 6, 7, 8, 9, 10 };\n    collection.addAll(Arrays.asList(moreInts));\n    // Runs significantly faster, but you can&#39;t\n    // construct a Collection this way:\n    Collections.addAll(collection, 11, 12, 13, 14, 15);\n    Collections.addAll(collection, moreInts);\n    // Produces a list &quot;backed by&quot; an array:\n    List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20);\n    list.set(1, 99); // OK -- modify an element\n    // list.add(21); // Runtime error because the\n                     // underlying array cannot be resized.\n  }\n}\n</code></pre><p>Arrays.asList() 接受一个数组或者可变参数列表，并将之转换为 List 对象。<br>需要注意的是，此种方式获得的 List 对象，由于底层实现仍然是数组，在添加或者删除元素时会出现 UnsupportedOperationException 异常。</p><p>Collections.addAll() 接收一个 Collection 对象、一个数组或者是可变参数列表作为参数，得到新的 Collection 对象。</p><p>3.容器的打印</p><pre><code class=\"Java\">public class PrintingContainers {\n  static Collection fill(Collection&lt;String&gt; collection) {\n    collection.add(&quot;rat&quot;);\n    collection.add(&quot;cat&quot;);\n    collection.add(&quot;dog&quot;);\n    collection.add(&quot;dog&quot;);\n    return collection;\n  }\n  static Map fill(Map&lt;String,String&gt; map) {\n    map.put(&quot;rat&quot;, &quot;Fuzzy&quot;);\n    map.put(&quot;cat&quot;, &quot;Rags&quot;);\n    map.put(&quot;dog&quot;, &quot;Bosco&quot;);\n    map.put(&quot;dog&quot;, &quot;Spot&quot;);\n    return map;\n  }    \n  public static void main(String[] args) {\n    print(fill(new ArrayList&lt;String&gt;()));\n    print(fill(new LinkedList&lt;String&gt;()));\n    print(fill(new HashSet&lt;String&gt;()));\n    print(fill(new TreeSet&lt;String&gt;()));\n    print(fill(new LinkedHashSet&lt;String&gt;()));\n    print(fill(new HashMap&lt;String,String&gt;()));\n    print(fill(new TreeMap&lt;String,String&gt;()));\n    print(fill(new LinkedHashMap&lt;String,String&gt;()));\n  }\n}\n/* Output:\n[rat, cat, dog, dog]\n[rat, cat, dog, dog]\n[dog, cat, rat]\n[cat, dog, rat]\n[rat, cat, dog]\n{dog=Spot, cat=Rags, rat=Fuzzy}\n{cat=Rags, dog=Spot, rat=Fuzzy}\n{rat=Fuzzy, cat=Rags, dog=Spot}\n*/\n</code></pre><p>Collection 打印出来的内容用 [ ] 括住，Map 打印出来的内容用 { } 括住。</p><h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>List 接口在 Collection 基础上添加了大量的方法。可分为 ArrayList 和 LinkedList 两种。</p><p><strong>ArrayList</strong> 数据结构采用的是线性表，优势是访问和查询十分方便，但添加和删除的时候效率很低。<br><strong>LinkedList</strong> 数据结构采用的是链表，优势是删除和添加的效率很高，但随机访问元素时效率较 ArrayList 类低。</p><p>List 重要价值在于提供了一种可修改的序列。</p><p>contains(Object o) 确定某个对象是否在列表中。<br>remove(int index) 移除指定位置上的元素。<br>indexOf() 返回列表中首次出现指定元素的索引，如果不包含该元素，返回-1。</p><p>LikedList 增加了可以使其用作栈、队列或双端队列的方法。</p><pre><code class=\"Java\">public class Stack&lt;T&gt; {\n    private LinkedList&lt;T&gt; storage = new LinkedList&lt;&gt;();\n    public void push(T v){\n        storage.addFirst(v);\n    }\n    public T peek(){\n        return storage.getFirst();\n    }\n    public T pop(){\n        return storage.removeFirst();\n    }\n    public boolean empty(){\n        return storage.isEmpty();\n    }\n    public String toString(){\n        return storage.toString();\n    }\n}\n</code></pre><p>LikedList 具有直接实现栈（LIFO）的所有功能的方法。</p><p>addFirst(E e)/addLast(E e)：将元素添加到列表的开头/结尾<br>getFirst()/element()：返回列表的第一个元素<br>peek()/peekFirst()：获取但不移除列表的第一个元素<br>offer(E e)/offerLast(E e)：将元素插入到列表末尾</p><h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><p>队列是典型的先进先出（FIFO）的容器。</p><pre><code class=\"Java\">public class QueueDemo {\n    public static void printQ(Queue queue) {\n  while(queue.peek() != null)\n      System.out.print(queue.remove() + &quot; &quot;);\n  System.out.println();\n    }\n    public static void main(String[] args) {\n  Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();\n  Random random = new Random(47);\n  for(int i = 0; i &lt; 10; i++)\n      queue.offer(random.nextInt(i+10));\n  printQ(queue);\n  Queue&lt;Character&gt; qCharacters = new LinkedList&lt;Character&gt;();\n  for(char c : &quot;Brontosaurus&quot;.toCharArray())\n      qCharacters.offer(c);\n  printQ(qCharacters);\n    }\n}\n/* Output:\n 8 1 1 1 5 14 3 1 0 1\n B r o n t o s a u r u s\n*/\n</code></pre><p>LinkedList 提供了方法以支持队列的行为，并且它实现了 Queue 接口，<br>因此 LinkedList 可以用作 Queue 的一种实现，也可以将 LinkedList 向上转型为 Queue 。</p><p><strong>PriorityQueue</strong> 优先级队列声明下一个弹出的元素是最需要的元素(具有最高的优先级)，可以确保当调用 peek()、poll() 和 remove() 方法时，获取的元素将是队列中优先级最高的元素。</p><pre><code class=\"java\">PriorityQueue priorityQueue = new PriorityQueue&lt;Integer&gt;(\n  inis.size(),Collections.reverseOrder()\n);\n</code></pre><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>Set 具有与 Collection 完全一样的接口，实际上就是 Collection ，只是行为不同。</p><p><strong>HashSet</strong> 数据结构采用的是散列表，主要是设计用来做高性能集运算的，例如对两个集合求交集、并集、差集等。<br>集合中包含一组不重复出现且无特性顺序的元素，其值是不可重复与无序的。</p><p>LinkedHashSet 的核心概念相对于 HashSet 来说就是一个可以保持顺序的Set集合。</p><p><strong>TreeSet</strong> 数据结构使用的是红黑树，性能上低于HashSet，用于排序。</p><h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>Map：一组成对的“键值对”对象，允许使用键来查找值；<br>映射表允许我们使用另一个对象来查找某个对象，它被称为“关联数组”，因为它将某些对象与另外一些对象关联在了一起，或者被称为“字典”</p><pre><code class=\"Java\">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();\n</code></pre><p>get(Object o)：返回指定键所映射的值，如果不包含该键的映射关系，返回 null 。<br>put(K key, V value)：将指定的值与此映射中的指定键关联，如果已经存在映射关系，更新值。<br>hashCode()：返回此映射的哈希码值。</p><h2 id=\"Map-的三种实现\"><a href=\"#Map-的三种实现\" class=\"headerlink\" title=\"Map 的三种实现\"></a>Map 的三种实现</h2><p>HashMap：基于“拉链法”实现的散列表，一般用于单线程中，不是线程安全的。<br>HashTable：基于“拉链法”实现的散列表，一般用于多线程中，是线程安全的。<br>TreeMap：有序的散列表，通过红黑树实现的，一般用于单线程中存储有序的映射。</p><h1 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h1><p>迭代器，用于遍历容器，JDK源码如下：</p><pre><code class=\"Java\">package java.util;\nimport java.util.function.Consumer;\npublic interface Iterator&lt;E&gt; {\n    boolean hasNext();\n    E next();\n    default void remove() {\n        throw new UnsupportedOperationException(&quot;remove&quot;);\n    }\n    default void forEachRemaining(Consumer&lt;? super E&gt; action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n</code></pre><p>Java 的 Iterator 只能单向移动：</p><pre><code class=\"Java\">public class SimpleIteration {\n  public static void main(String[] args) {\n    List&lt;Pet&gt; pets = Pets.arrayList(12);\n    Iterator&lt;Pet&gt; it = pets.iterator();\n    while(it.hasNext()) {\n      Pet p = it.next();\n      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);\n    }\n    System.out.println();\n    // A simpler approach, when possible:\n    for(Pet p : pets)\n      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);\n    System.out.println();    \n    // An Iterator can also remove elements:\n    it = pets.iterator();\n    for(int i = 0; i &lt; 6; i++) {\n      it.next();\n      it.remove();\n    }\n    System.out.println(pets);\n  }\n}\n/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster\n[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]\n*/\n</code></pre><p>Iterator() 要求容器返回一个Iterator。Iterator 准备好返回序列的第一个元素。<br>next() 获得序列中的下一个元素。<br>hasNext() 检查序列中是否还有元素。<br>remove() 将迭代器新近返回的元素删除。</p><h2 id=\"ListIterator\"><a href=\"#ListIterator\" class=\"headerlink\" title=\"ListIterator\"></a>ListIterator</h2><p>ListIterator 是 Iterator 的一个子类，只能用于各种List的访问。<br>ListIterator 可以双向移动，可以产生当前位置的前一个和后一个元素的索引，并且可以使用 set() 方法，将最近访问过的元素进行替换。<br>此外，还可以通过 listIterator(int index) 的方法，获得一个一开始就指向 index 位置的 ListIterator。</p><h1 id=\"Foreach-与迭代器\"><a href=\"#Foreach-与迭代器\" class=\"headerlink\" title=\"Foreach 与迭代器\"></a>Foreach 与迭代器</h1><p>foreach 语法主要用于数组，同样可以用于 Collection 对象。</p><pre><code class=\"Java\">public class ForEachCollections {\n  public static void main(String[] args) {\n    Collection&lt;String&gt; cs = new LinkedList&lt;String&gt;();\n    Collections.addAll(cs,\n      &quot;Take the long way home&quot;.split(&quot; &quot;));\n    for(String s : cs)\n      System.out.print(&quot;&#39;&quot; + s + &quot;&#39; &quot;);\n  }\n}\n/* Output:\n&#39;Take&#39; &#39;the&#39; &#39;long&#39; &#39;way&#39; &#39;home&#39;\n*/\n</code></pre><p>因为 java SE5 引入了 Iterable 接口，该接口包含产生 Iterator 的 iterator 方法，<br>并且 Iterable 接口被 foreach 用来造序列中移动。</p><p>第17章 <strong>容器深入研究</strong></p><p><img src=\"https://img.wshunli.com/Java/Java编程思想/Java容器1.png\" alt=\"Java容器\"></p><p>现在还不太深入，后面再看。</p><blockquote><p>参考资料<br>1、Java 容器知识整理 - FullStackDeveloper - SegmentFault<br><a href=\"https://segmentfault.com/a/1190000002903035\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://segmentfault.com/a/1190000002903035</a><br>2、Java编程思想读书笔记——持有对象 - CSDN博客<br><a href=\"http://blog.csdn.net/baidu_21088863/article/details/78175347\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/baidu_21088863/article/details/78175347</a><br>3、Java编程思想第四版读书笔记——第十一章 持有对象 - CSDN博客<br><a href=\"http://blog.csdn.net/severusyue/article/details/49491441\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/severusyue/article/details/49491441</a><br>4、深入Java源码解析容器类List、Set、Map - 简书<br><a href=\"http://www.jianshu.com/p/047e33fdefd2\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.jianshu.com/p/047e33fdefd2</a><br>5、《Java编程思想》读书笔记 第十一章 持有对象 02 Map<br><a href=\"https://zhuanlan.zhihu.com/p/25816448\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://zhuanlan.zhihu.com/p/25816448</a></p></blockquote>","categories":[{"name":"移动端技术","path":"api/categories/移动端技术.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《Java编程思想》","path":"api/tags/《Java编程思想》.json"}]}