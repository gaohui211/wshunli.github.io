{"title":"《JavaScript高级程序设计》读书笔记（五）","slug":"《JavaScript高级程序设计》读书笔记（五）","date":"2017-11-08T13:12:48.000Z","updated":"2018-03-28T14:41:07.690Z","comments":true,"path":"api/articles/《JavaScript高级程序设计》读书笔记（五）.json","excerpt":"《JavaScript高级程序设计》读书笔记","covers":null,"content":"<p>《JavaScript高级程序设计》读书笔记</p><a id=\"more\"></a><p><strong>(五) 学习 JavaScript 对各数据载体的操作方法（如JSON、XML），学会 Ajax 的使用方法。</strong>(18-21章)</p><h1 id=\"第十八章-JavaScript-与-XML\"><a href=\"#第十八章-JavaScript-与-XML\" class=\"headerlink\" title=\"第十八章 JavaScript 与 XML\"></a>第十八章 JavaScript 与 XML</h1><h2 id=\"浏览器对-XML-DOM-的支持\"><a href=\"#浏览器对-XML-DOM-的支持\" class=\"headerlink\" title=\"浏览器对 XML DOM 的支持\"></a>浏览器对 XML DOM 的支持</h2><p>如何检测浏览器是否支持DOM2级XML：</p><pre><code class=\"JavaScript\">var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;,&quot;2.0&quot;);\n</code></pre><p>在支持DOM2级的浏览器中创建一个空白XML:</p><pre><code class=\"JavaScript\">var xmldom = document.implemention.createDocument(namespaceUri,root,docype);\n</code></pre><p>通过 JavaScript 处理XML时，通常只使用参数root，这个参数指定的是XML DOM文档元素的标签名。</p><pre><code class=\"JavaScript\">var xmldom = document.implementation.createDocument(&quot;&quot;,&quot;root&quot;,null);\nconsole.log(xmldom.documentElement.tagName);  //&quot;root&quot;\nvar child = xmldom.createElement(&quot;child&quot;);\nxmldom.documentElement.appendChild(child);\n</code></pre><p><strong>DOMParser 类型</strong>：将 XML 解析为 DOM 文档。</p><p><strong>XMLSerializer 类型</strong>：将 DOM 文档序列化为 XML 字符串。</p><pre><code class=\"JavaScript\">var parser = new DOMParser();\nvar xmldom = parser.parseFromString(&quot;&lt;root&gt;&lt;child/&gt;&lt;/root&gt;&quot;, &quot;text/xml&quot;);\n//convert back into XML\nvar serializer = new XMLSerializer();\nvar xml = serializer.serializeToString(xmldom);\nconsole.log(xml);\n</code></pre><h2 id=\"浏览器对XPath的支持\"><a href=\"#浏览器对XPath的支持\" class=\"headerlink\" title=\"浏览器对XPath的支持\"></a>浏览器对XPath的支持</h2><p>XPath 是设计用来在 DOM 文档中查找节点的一种手段。</p><h2 id=\"浏览器对XSLT的支持\"><a href=\"#浏览器对XSLT的支持\" class=\"headerlink\" title=\"浏览器对XSLT的支持\"></a>浏览器对XSLT的支持</h2><p>XSLT 是与 XML 相关的一种技术，它利用 XPath 将文档从一种表现形式转换成另一种表现形式。</p><h1 id=\"第十九章-E4X\"><a href=\"#第十九章-E4X\" class=\"headerlink\" title=\"第十九章 E4X\"></a>第十九章 E4X</h1><p>E4X 本身不是一门语言，它只是 ECMAScript 语言的可选扩展。<br>就其本身而言，E4X 为处理 XML 定义了新的语法，也定义了特定于 XML 的对象。</p><h1 id=\"第二十章-JSON\"><a href=\"#第二十章-JSON\" class=\"headerlink\" title=\"第二十章 JSON\"></a>第二十章 JSON</h1><p>JSON（Javascript Object Notaion，Javascript对象表示法）是一种数据格式。</p><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>JSON有3种类型的值：简单值、对象 和 数组。</p><ul><li>简单值：字符串、数值、布尔值、null（JSON不支持JavaScript的特殊值undefined）。</li><li>对象：一组无序键值对。值可为简单值，或对象和数组。</li><li>数组：一组有序值的列表。值可为简单值，或对象和数组。</li></ul><p>JSON不支持变量、函数 和 对象实例。</p><p><strong>简单值</strong>：最简单的 JSON 数据形式就是简单值。</p><pre><code class=\"JSON\">6\n&quot;Hello World!&quot; //必须为双引号\n</code></pre><p>布尔值和 null 也是有效的 JSON 数据形式，但简单值往往是复杂数据结构的一部分。</p><p><strong>对象</strong>：</p><pre><code class=\"JSON\">// JavaScript对象字面量：\nvar object = {\n  &quot;name&quot;: &quot;Nicholas&quot;,\n  &quot;age&quot;: 29\n};\n// JSON 表示方式如下：\n{\n  &quot;name&quot;: &quot;Nicholas&quot;,\n  &quot;age&quot;: 29\n}\n</code></pre><p>JSON 对象 与 JavaScript 的对象字面量相比：首先，没有声明变量（JSON 中没有变量的概念）；其次，没有末尾的分号；JSON 对象的属性必须加双引号。</p><p><strong>数组</strong>：JSON 数组采用的就是 JavaScript 中的数组字面量形式。</p><pre><code class=\"JSON\">// JavaScript 中的数组字面量：\nvar values = [25, &quot;hi&quot;, true];\n// JSON 表示数组：\n[25, &quot;hi&quot;, true]\n</code></pre><h2 id=\"解析与序列化\"><a href=\"#解析与序列化\" class=\"headerlink\" title=\"解析与序列化\"></a>解析与序列化</h2><p>ECMAScript5 对解析 JSON 进行了规范，定义了全局对象 JSON。</p><p>JSON 对象有两个方法：stringify() 和 parse()，分别用于把 JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。</p><pre><code class=\"JavaScript\">var book = {\n        title: &quot;Professional JavaScript&quot;,\n        authors: [\n            &quot;Nicholas C. Zakas&quot;\n        ],\n        edition: 3,\n        year: 2011\n    };\nvar jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);\nconsole.log(jsonText);\n// {&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:[&quot;Nicholas C. Zakas&quot;],&quot;edition&quot;:3,&quot;year&quot;:2011}\nvar bookCopy =JSON.parse(jsonText);\n</code></pre><p><strong>序列化选项</strong>: JSON.stringify() 除了要序列化的 JavaScript 对象外，还可以接收另外两个参数指定以不同的方式序列化。<br>第一个参数是数据，第二个参数是个过滤器，可以是一个数组或函数；第三个参数是一个选项，表示是否在 JSON 字符串中保留缩进。</p><p>1.过滤结果：</p><p>如果过滤器参数是<strong>数组</strong>，那么 JSON.stringify()的结果中将只包含数组中列出的属性。</p><pre><code class=\"JavaScript\">var jsonText = JSON.stringify(book, [&quot;title&quot;, &quot;edition&quot;]);\n//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;edition&quot;:3}\n</code></pre><p>如果过滤器参数是<strong>函数</strong>，传入的函数接收两个参数，属性（键）名和属性值。</p><pre><code class=\"JavaScript\">var jsonText = JSON.stringify(book, function(key, value){\n   switch(key){\n       case &quot;authors&quot;:\n           return value.join(&quot;,&quot;)\n       case &quot;year&quot;:\n           return 5000;\n       case &quot;edition&quot;:\n           return undefined;\n       default:\n           return value;\n   }\n});\n//{&quot;title&quot;:&quot;Professional JavaScript&quot;,&quot;authors&quot;:&quot;Nicholas C. Zakas&quot;,&quot;year&quot;:5000}\n</code></pre><p>2.字符串缩进</p><p>JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。<br>如果这个参数是一个<strong>数值</strong>，那它表示的是每个级别缩进的空格数。</p><pre><code class=\"JavaScript\">var jsonText = JSON.stringify(book, null, 4);\n</code></pre><p>结果：</p><pre><code class=\"JSON\">{\n    &#39;title&#39;: &#39;Professional JavaScript&#39;,\n    &#39;authors&#39;: [\n        &#39;Nicholas C. Zakas&#39;\n    ],\n    &#39;edition&#39;: 3,\n    &#39;year&#39;: 2011\n}\n</code></pre><p>如果缩进参数是一个字符串而非数值，则这个字符串将在 JSON 字符串中被用作缩进字符（不再使用空格）。</p><pre><code class=\"JavaScript\">var jsonText = JSON.stringify(book, null, &quot; - -&quot;);\n</code></pre><p>结果：</p><pre><code class=\"JSON\">{\n - -&#39;title&#39;: &#39;Professional JavaScript&#39;,\n - -&#39;authors&#39;: [\n - - - -&#39;Nicholas C. Zakas&#39;\n - -],\n - -&#39;edition&#39;: 3,\n - -&#39;year&#39;: 2011\n}\n</code></pre><p>缩进字符串最长不能超过 10 个字符长。如果字符串长度超过了 10 个，结果中将只出现前 10 个字符。</p><p>3.toJSON()方法</p><p>给对象自定义 toJSON() 方法，返回其自身的 JSON 数据格式。</p><pre><code class=\"JavaScript\">var book = {\n        &quot;title&quot;: &quot;Professional JavaScript&quot;,\n        &quot;authors&quot;: [\n            &quot;Nicholas C. Zakas&quot;\n        ],\n        edition: 3,\n        year: 2011,\n        toJSON: function(){\n            return this.title;\n        }\n    };\nvar jsonText = JSON.stringify(book);\nconsole.log(jsonText);\n</code></pre><p>假设把一个对象传入 JSON.stringify()，序列化该对象的顺序如下：<br>(1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。<br>(2) 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第(1)步返回的值。<br>(3) 对第(2)步返回的每个值进行相应的序列化。<br>(4) 如果提供了第三个参数，执行相应的格式化。</p><p><strong>解析选项</strong>：JSON.parse() 方法也可以接收另一个参数，该参数是一个函数（还原函数），将在每个键值对儿上调用。<br>如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</p><pre><code class=\"JavaScript\"> var book = {\n        &quot;title&quot;: &quot;Professional JavaScript&quot;,\n        &quot;authors&quot;: [\n            &quot;Nicholas C. Zakas&quot;\n        ],\n        edition: 3,\n        year: 2011,\n        releaseDate: new Date(2011, 11, 1)\n    };\nvar jsonText = JSON.stringify(book);\nconsole.log(jsonText);\nvar bookCopy = JSON.parse(jsonText, function(key, value){\n    if (key == &quot;releaseDate&quot;){\n        return undefined;\n    } else {\n        return value;\n    }\n});\nconsole.log(&quot;releaseDate&quot; in bookCopy);\n</code></pre><h1 id=\"第二十一章-Ajax-与-Comet\"><a href=\"#第二十一章-Ajax-与-Comet\" class=\"headerlink\" title=\"第二十一章 Ajax 与 Comet\"></a>第二十一章 Ajax 与 Comet</h1><p>Ajax(Asynchronous Javascript + XML)技术的核心是 XMLHttpRequest 对象，即: XHR。<br>它所指的仅仅是<strong>无须刷新页面即可从服务器端获取数据</strong>的技术，其通信与数据格式无关，并不一定是 XML 数据。</p><h2 id=\"XMLHttpRequest-对象\"><a href=\"#XMLHttpRequest-对象\" class=\"headerlink\" title=\"XMLHttpRequest 对象\"></a>XMLHttpRequest 对象</h2><p><strong>XHR的用法</strong>：</p><p>使用 XMLHttpRequest 构造函数来创建 XHR 对象。</p><pre><code class=\"JavaScript\">var xhr = new XMLHttpRequest();\n</code></pre><p>使用 XHR对象的时候，要调用的第一个方法是open()，它接受3个参数:</p><ol><li>要发送请求的类型，如: get/post</li><li>请求的 url</li><li>是否异步发送请求，这个参数是一个布尔值</li></ol><p>再调用 send() 方法，才会真正发起 ajax 请求。</p><pre><code class=\"JavaScript\">xhr.open(&#39;get&#39;, &#39;example.php&#39;, false)\nxhr.send(null);\n</code></pre><p>本例中的请求是同步的，Javascript 代码会等到服务器响应之后再执行。<br>收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性有:</p><ul><li>responseText: 作为响应主体被返回的文本。</li><li>responseXML: 如果响应的内容类型是 “text/xml” 或者 “application/xml”，那么这个属性中将保存着包含响应数据的 XML DOM 文档。</li><li>status: 响应的 HTTP 状态。</li><li>statusText: HTTP 状态的说明。</li></ul><p>发送异步请求：JavaScript 继续执行而不必等待。<br>此时，我们可以检测readyState属性，该属性表示请求/响应过程的当前活动阶段。它的可取值有如下几种：</p><ul><li>0: 未初始化。 尚未调用 open() 方法。</li><li>1: 启动。 已经调用open()方法，但，尚未调用send()方法。</li><li>2: 发送。 已经调用send()方法，但，尚未接收到响应。</li><li>3: 接收。 已经接收到部分响应数据。</li><li>4: 完成。 已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p>readyState 属性的每一次变化，都会触发一次 readyStateChange 事件，我们可以利用这个事件来检测 readyState 值。</p><pre><code class=\"JavaScript\">var xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function(){\n    if(xhr.readyState == 4){\n        if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){\n            console.log(xhr.responseText);\n        }\n        else{\n            console.log(&#39;fail, &#39; + xhr.status);\n        }\n    }\n}\nxhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);\nxhr.send(null);\n</code></pre><p>在接收到响应之前，可以调用 abort() 方法来取消异步请求。</p><pre><code class=\"JavaScript\">xhr.abort();\n</code></pre><p><strong>HTTP 头部信息</strong>：XHR 对象提供了操作头部信息的方法，包括对请求头部和响应头部的操作。</p><p>默认情况下，发送XHR请求的同时，还会发送以下头部信息:</p><ul><li>Accept: 浏览器能够处理的内容类型</li><li>Accept-Charset: 浏览器能够显示的字符集</li><li>Accept-Encoding: 浏览器能够处理的压缩编码</li><li>Accept-Language: 浏览器当前设置的语言</li><li>Connection: 浏览器与服务器之间的连接类型</li><li>Cookie: 当前页面的任何Cookie</li><li>Host: 发出请求的页面，所在的域</li><li>Referer: 发出请求的页面的URI</li><li>User-Agent: 浏览器的用户代理字符串</li></ul><p>setRequestHeader()：自定义的头部信息。</p><pre><code class=\"JavaScript\">xhr.open(&#39;get&#39;, &#39;example.txt&#39;, true);\nxhr.setRequestHeader(&quot;MySite&quot;, &quot;wshunli.com&quot;);\nxhr.send(null);\n</code></pre><p>getResponseHeader()：获取响应头部信息。</p><pre><code class=\"JavaScript\">var mySite = xhr.getResponseHeader(&#39;MySite&#39;); // wshunli.com\n</code></pre><p>getAllResponseHeaders()：在服务器端，也可以利用头部信息向浏览器发送额外的结构化数据。</p><pre><code class=\"JavaScript\">var allHeaders = xhr.getAllResponseHeaders();\n// 返回内容\nDate: Sun, 14 Nov 2004 18:04:22 GMT\nServer: Apache/1.3.29 (Unix)\nVary: Accept\nX-Powerd-By: PHP/4.3.8\nConnection: close\nContent-Type: text/html; charset=iso-8859-1\n</code></pre><p><strong>GET 请求</strong>：向服务器查询某些信息。</p><pre><code class=\"JavaScript\">xhr.open(&quot;get&quot;, &quot;example.php?name1=value1&amp;name2=value2&quot;, true);\n</code></pre><p><strong>POST 请求</strong>：向服务器发送应该被保存的数据。</p><pre><code class=\"JavaScript\">xhr.open(&quot;post&quot;, &quot;post.php&quot;, true);\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);\nvar form = document.getElementById(&quot;my-form&quot;);\nxhr.send(serialize(form));\n</code></pre><h2 id=\"XMLHttpRequest-2-级\"><a href=\"#XMLHttpRequest-2-级\" class=\"headerlink\" title=\"XMLHttpRequest 2 级\"></a>XMLHttpRequest 2 级</h2><p><strong>FormData</strong>：</p><p>XMLHttpRequest 2 级定义了 FormData 类型，来处理表单数据的序列化，以及创建与表单格式相同的数据。</p><pre><code class=\"JavaScript\">var data = new FormData();\n// 添加键值对\ndata.append(&#39;site&#39;, &#39;wshunli.com&#39;);\n// 直接传入表单元素\nvar data = new FormData(document.forms[0]);\n</code></pre><p>创建 FromData 的实例后，就可以传给 XHR 的 send() 方法。</p><pre><code class=\"JavaScript\">var xhr = new XMLHttpRequest();\n ···\nvar form = document.getElementById(&#39;site-info&#39;);\nxhr.send(new FormData(form));\n</code></pre><p>XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。</p><p><strong>超时设定</strong>：</p><p>XHR 对象添加了一个 timeout 属性，表示请求在等待多少毫秒之后就终止。</p><pre><code class=\"JavaScript\">var xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function(){\n    try{\n        if(xhr.readyState == 4){\n            if( (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){\n                console.log(xhr.responseText);\n            }\n            else{\n                console.log(&#39;fail, &#39; + xhr.status);\n            }\n        }\n    }\n    catch(ex){\n    }\n}\nxhr.open(&#39;get&#39;, &#39;example.php&#39;, true);\nxhr.timeout = 1000; // 1秒超时，仅适用IE8+\nxhr.ontimeout = function(){\n    console.log(&#39;fail, timeout&#39;);\n}\nxhr.send(null);\n</code></pre><p>在给 timeout 设置一个数值后，如果在规定时间内浏览器没有接收到响应信息，就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。<br>如果在超时终止请求之后再访问 status 属性，就会导致错误。因此，将相关的代码封装到 try-catch 语句中。</p><p><strong>overrideMimeType() 方法</strong>：重写 XHR 响应的 MIME 类型。</p><pre><code class=\"JavaScript\">var xhr = createXHR();\nxhr.open(&#39;get&#39;, &#39;text.php&#39;, true);\nxhr.overrideMimeType(&#39;text/xml&#39;);\nxhr.send(null);\n</code></pre><h2 id=\"进度事件\"><a href=\"#进度事件\" class=\"headerlink\" title=\"进度事件\"></a>进度事件</h2><p>进度事件包括以下6个：</p><ul><li>loadstart: 在接收到响应数据的第一个字节时触发</li><li>progress: 在接收响应期间持续不断地触发</li><li>error: 在请求发生错误时触发</li><li>abort: 在因为调用 abort() 方法而终止连接时触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 在通信完成或者触发 error、abort 或 load 事件之后触发</li></ul><p>每个请求都从触发 loadstart 事件开始，接下来是一个或多个 progress 事件，然后触发 error、abort 或者 load 事件中的一个，最后以触发 loadend 事件结束。</p><p><strong>load 事件</strong>：响应接收完毕后将触发 load 事件，因此就没有必要再去检查 readyState 属性了。</p><p><strong>progress 事件</strong>：progress 事件会在浏览器接收新数据的过程中周期性地被触发。</p><pre><code class=\"JavaScript\">var xhr = createXHR();\nxhr.onload = function(){\n    if( (xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300) || xhr.status ==304 ){\n        console.log(xhr.responseText);\n    }\n    else{\n        console.log(&#39;fail, &#39; + xhr.status);\n    }\n}\nxhr.onprogress = function(event){\n    var statusDiv = document.getElementById(&#39;status&#39;);\n    if( event.lengthComputable ){\n        statusDiv.innerHTML = &#39;Received &#39; + event.position + &#39; of &#39; + event.totalSize + &#39; bytes&#39;;\n    }\n}\nxhr.open(&#39;get&#39;, &#39;progress.php&#39;, true);\nxhr.send(null);\n</code></pre><p>onprogress 事件处理程序，会接收到一个event对象，其 target 属性是 XHR 对象。<br>event 对象还包含了另外3个额外属性：lengthComputable、position、totalSize。</p><ul><li>lengthComputable 是一个布尔值，它表示进度信息是否可用；</li><li>position 表示已经接收的字节数；</li><li>totalSize 表示根据 Content-Length 响应头确定的预期字节数。</li></ul><h2 id=\"跨域资源共享\"><a href=\"#跨域资源共享\" class=\"headerlink\" title=\"跨域资源共享\"></a>跨域资源共享</h2><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）：使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。IE中要使用XDR对象实现，其他浏览器XHR对象原生支持。</p><pre><code class=\"JavaScript\">// 发送请求附加 Origin 头部\nOrigin: http://www.wshunli.com\n// 响应请求\nAccess-Control-Allow-Origin: http://www.wshunli.com\n</code></pre><p><strong>图像 Ping</strong>：动态创建图像经常用于图像 Ping 。</p><pre><code class=\"JavaScript\">var img = new Image();\nimg.onload = img.onerror = function(){\n    console.log(&#39;Done&#39;);\n}\nimg.src = &#39;http://www.wshunli.com/test?action=click&#39;;\n</code></pre><p>我们可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。</p><p><strong>JSOUP</strong>：(JSON with padding，填充式 JSON 或参数式 JSON) 它看起来与 JSON 非常相似，只不过是被包含在函数调用中的 JSON。</p><pre><code class=\"JavaScript\">function handleResponse(response){\n    console.log(&quot;You&#39;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);\n}\nvar script = document.createElement(&quot;script&quot;);\nscript.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;\ndocument.body.insertBefore(script, document.body.firstChild);\n</code></pre><p><strong>Comet</strong>: 一种服务器向页面推送数据的技术。</p><p>实现Comet有 2 种方式: 长轮询和流。<br>1.长轮询是相对于传统轮询(短轮询)而言的，传统轮询即浏览器定时向服务器发送请求，查看是否有数据更新。<br>而长轮询则是，页面向服务器发起一个请求后，服务器一直保持连接打开，直到有数据可以发送。<br>发送完数据后，浏览器关闭连接，随即又向服务器发起一个新的请求。<br>这一过程在页面打开期间一直持续不断。<br>2.另外一种实现 Comet 的方式就是HTTP流。流的特点是，在页面的整个生命周期内只有使用一个HTTP连接。<br>也就是说，浏览器向服务器发送一个请求后，服务器保持连接打开，然后周期性地向浏览器发送数据</p><p><strong>服务器发送事件</strong>：SSE(Server-Sent Events)服务器发送事件，是围绕只读 Comet 交互推出的 API 或者模式。</p><p><strong>Web Sockets</strong>：Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。</p><p>创建 Web Sockets，可以先实例一个 WebSocket 对象并传入要连接 URL:</p><pre><code class=\"JavaScript\">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);\n</code></pre><p>实例化 WebSocket 对象之后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket也有一个表示当前状态的 readyState 属性。</p><ul><li>WebSocket.OPENING (0) : 正在建立连接</li><li>WebSocket.OPEN (1): 已经建立连接</li><li>WebSocket.CLOSING (2): 正在关闭连接</li><li>WebSocket.CLOSE (3): 已经关闭连接</li></ul><p>WebSocket 没有 readystatechange 事件，readyState 的值永远从0开始。<br>要关闭 Web Socket 连接，可以在任何时候调用close()方法。<br>调用该方法后，readyState 的值立即变为2(正在关闭)，当成功关闭连接后变为3。</p><pre><code class=\"JavaScript\">socket.close();\n</code></pre><p>发送和接收数据：Web Socket 打开之后就可以通过连接发送和接收数据。</p><pre><code class=\"JavaScript\">var socket = new WebSocket(&#39;ws://www.wshunli.com/socket.php&#39;);\nsocket.send(&quot;Hello World!&quot;);\n</code></pre><p>Web Socket 只能通过连接发送纯文本数据，对于复杂数据必须进行序列化。</p><pre><code class=\"JavaScript\">socket.onmessage = function(event){\n    var data = event.data;\n}\n</code></pre><p>当服务器向客户端发来消息时，WebSocket 对象就会触发 message 事件。</p><p>WebSocket 对象的其他事件：<br>WebSocket对象还有其他3个事件，在连接生命周期的不同阶段触发。</p><ul><li>open: 在成功建立连接时触发</li><li>error: 在发生错误时触发，连接不能持续</li><li>close: 在连接关闭时触发</li></ul><pre><code class=\"JavaScript\">var socket = new WebSocket(&#39;ws://www.wshunli.com/server.php&#39;);\nsocket.onopen = function(){\n    console.log(&#39;WebSocket Opened.&#39;)\n}\nsocket.onerror = function(){\n    console.log(&#39;WebSocket Error.&#39;)\n}\nsocket.onclose = function(){\n    console.log(&#39;WebSocket Closed.&#39;)\n}\n</code></pre><p>其中只有 close 事件的event的对象有额外的信息。这个事件的事件对象有3个额外属性: wasClean、code 和 reason。<br>其中，wasClean 是一个布尔值，表示连接是否已经明确关闭；code 是服务器返回的数值状态码；而 reason 是一个字符串，包含服务器发回的信息。</p><pre><code class=\"JavaScript\">socket.onclose = function(event){\n    console.log(event.wasClean + &#39;,&#39; + event.code + &#39;,&#39; + event.reason);\n}\n</code></pre>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《JavaScript高级程序设计》","path":"api/tags/《JavaScript高级程序设计》.json"}]}