{"title":"《Java编程思想》读书笔记（七）","slug":"《Java编程思想》读书笔记（七）","date":"2017-12-04T13:54:10.000Z","updated":"2018-04-21T14:55:33.430Z","comments":true,"path":"api/articles/《Java编程思想》读书笔记（七）.json","excerpt":"《Java编程思想》读书笔记 —— 类型信息及泛型。","covers":null,"content":"<p>《Java编程思想》读书笔记 —— 类型信息及泛型。</p><a id=\"more\"></a><h1 id=\"第14章-类型信息\"><a href=\"#第14章-类型信息\" class=\"headerlink\" title=\"第14章 类型信息\"></a>第14章 类型信息</h1><p>RTTI (Run-Time Type Identification, 运行时类型识别) 是 Java 中非常有用的机制。</p><pre><code class=\"Java\">abstract class Shape {\n  void draw() { System.out.println(this + &quot;.draw()&quot;); }\n  abstract public String toString();\n}\nclass Circle extends Shape {\n  public String toString() { return &quot;Circle&quot;; }\n}\nclass Square extends Shape {\n  public String toString() { return &quot;Square&quot;; }\n}\npublic class Shapes {\n  public static void main(String[] args) {\n    List&lt;Shape&gt; shapeList = Arrays.asList(\n      new Circle(), new Square()\n    );\n    for(Shape shape : shapeList) shape.draw();\n  }\n}\n/* Output:\nCircle.draw()\nSquare.draw()\n*/\n</code></pre><p>在Java运行时，RTTI 维护类的相关信息，识别一个对象的类型。</p><p>1.Class 对象</p><p>类是程序的一部分，每个类都有一个Class对象。</p><pre><code class=\"Java\">interface HasBatteries {}\ninterface Waterproof {}\ninterface Shoots {}\nclass Toy {\n  // Comment out the following default constructor\n  // to see NoSuchMethodError from (*1*)\n  Toy() {}\n  Toy(int i) {}\n}\nclass FancyToy extends Toy\nimplements HasBatteries, Waterproof, Shoots {\n  FancyToy() { super(1); }\n}\npublic class ToyTest {\n  static void printInfo(Class cc) {\n    print(&quot;Class name: &quot; + cc.getName() + // 全限定的类型\n      &quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;); // Class 对象是否表示某接口\n    print(&quot;Simple name: &quot; + cc.getSimpleName()); // 不含包名的类名\n    print(&quot;Canonical name : &quot; + cc.getCanonicalName()); // 含包名的类名\n  }\n  public static void main(String[] args) {\n    Class c = null;\n    try {\n      c = Class.forName(&quot;typeinfo.toys.FancyToy&quot;); // 获取 Class 对象的引用\n    } catch(ClassNotFoundException e) {\n      print(&quot;Can&#39;t find FancyToy&quot;);\n      System.exit(1);\n    }\n    printInfo(c);\n    for(Class face : c.getInterfaces()) // 获取 Class 对象中包含的接口\n      printInfo(face);\n    Class up = c.getSuperclass(); // 获取 Class 对象的直接基类\n    Object obj = null;\n    try {\n      // Requires default constructor:\n      obj = up.newInstance(); // 实现虚拟构造器\n    } catch(InstantiationException e) {\n      print(&quot;Cannot instantiate&quot;);\n      System.exit(1);\n    } catch(IllegalAccessException e) {\n      print(&quot;Cannot access&quot;);\n      System.exit(1);\n    }\n    printInfo(obj.getClass());\n  }\n} /* Output:\nClass name: typeinfo.toys.FancyToy is interface? [false]\nSimple name: FancyToy\nCanonical name : typeinfo.toys.FancyToy\nClass name: typeinfo.toys.HasBatteries is interface? [true]\nSimple name: HasBatteries\nCanonical name : typeinfo.toys.HasBatteries\nClass name: typeinfo.toys.Waterproof is interface? [true]\nSimple name: Waterproof\nCanonical name : typeinfo.toys.Waterproof\nClass name: typeinfo.toys.Shoots is interface? [true]\nSimple name: Shoots\nCanonical name : typeinfo.toys.Shoots\nClass name: typeinfo.toys.Toy is interface? [false]\nSimple name: Toy\nCanonical name : typeinfo.toys.Toy\n*/\n</code></pre><p>2.类加载器是通过判断这个类包含的Class对象是否已经加载来判断它是否已经加载过这个类。为使用类而做的准备工作实际上包括三个步骤：</p><p>1 加载。这个由类加载器去完成。查找相关的字节码，并从这些字节码中创建一个Class对象。<br>2 链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且必须的话将解析这个类创建的对其他类的引用。<br>3 初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了静态方法或者静态域进行首次引用时才执行。</p><pre><code class=\"Java\">class Initable {\n  static final int staticFinal = 47;\n  static final int staticFinal2 =\n    ClassInitialization.rand.nextInt(1000);\n  static {\n    System.out.println(&quot;Initializing Initable&quot;);\n  }\n}\nclass Initable2 {\n  static int staticNonFinal = 147;\n  static {\n    System.out.println(&quot;Initializing Initable2&quot;);\n  }\n}\nclass Initable3 {\n  static int staticNonFinal = 74;\n  static {\n    System.out.println(&quot;Initializing Initable3&quot;);\n  }\n}\npublic class ClassInitialization {\n  public static Random rand = new Random(47);\n  public static void main(String[] args) throws Exception {\n    Class initable = Initable.class;\n    System.out.println(&quot;After creating Initable ref&quot;);\n    // Does not trigger initialization:\n    System.out.println(Initable.staticFinal);\n    // Does trigger initialization:\n    System.out.println(Initable.staticFinal2);\n    // Does trigger initialization:\n    System.out.println(Initable2.staticNonFinal);\n    Class initable3 = Class.forName(&quot;Initable3&quot;);\n    System.out.println(&quot;After creating Initable3 ref&quot;);\n    System.out.println(Initable3.staticNonFinal);\n  }\n} /* Output:\nAfter creating Initable ref\n47\nInitializing Initable\n258\nInitializing Initable2\n147\nInitializing Initable3\nAfter creating Initable3 ref\n74\n*/\n</code></pre><p>3.instanceof</p><p>返回一个布尔值，判断对象是不是某个特定类型的实例。</p><pre><code class=\"Java\">x instanceof Boy\n</code></pre><p>4.反射：运行时的类信息</p><p>反射机制是在运行状态中，<br>对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取的信息以及动态调用对象的方法的功能称为反射。</p><p>5.动态代理</p><p>代理是一本基本的设计模式；代理通常充当着中间人的角色。</p><h1 id=\"第15章-泛型\"><a href=\"#第15章-泛型\" class=\"headerlink\" title=\"第15章 泛型\"></a>第15章 泛型</h1><p>Java SE5 泛型实现了参数化类型的概念，使代码可以应用于多种类型。</p><p>泛型的出现，最引人注目的原因是为了创造容器类</p><p>一个只能持有单个对象的类：</p><pre><code class=\"Java\">public class Holder {\n  private Automobile a;\n  public Holder(Automobile a) { this.a = a; }\n  Automobile get() { return a; }\n}\n</code></pre><p>显然，Holder 类的重用性很差，只能持有 Automobile 类对象。</p><h2 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h2><pre><code class=\"Java\">public class Holder3&lt;T&gt; {\n  private T a;\n  public Holder3(T a) { this.a = a; }\n  public void set(T a) { this.a = a; }\n  public T get() { return a; }\n  public static void main(String[] args) {\n    Holder3&lt;Automobile&gt; h3 =\n      new Holder3&lt;Automobile&gt;(new Automobile());\n    Automobile a = h3.get(); // No cast needed\n    // h3.set(&quot;Not an Automobile&quot;); // Error\n    // h3.set(1); // Error\n  }\n}\n</code></pre><p>告诉编译器使用什么类型，然后编译器帮你处理一切细节。</p><h2 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h2><p>泛型也可以应用于接口；例如生成器，这是一种专门负责创建对象的类。</p><p>生成器接口定义如下：</p><pre><code class=\"Java\">public interface Generator&lt;T&gt; { T next(); }\n</code></pre><p>实现生成器接口</p><pre><code class=\"Java\">public class CoffeeGenerator\nimplements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt; {\n  private Class[] types = { Latte.class, Mocha.class,\n    Cappuccino.class, Americano.class, Breve.class, };\n  private static Random rand = new Random(47);\n  public CoffeeGenerator() {}\n  // For iteration:\n  private int size = 0;\n  public CoffeeGenerator(int sz) { size = sz; }\n  public Coffee next() {\n    try {\n      return (Coffee)\n        types[rand.nextInt(types.length)].newInstance();\n      // Report programmer errors at run time:\n    } catch(Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  class CoffeeIterator implements Iterator&lt;Coffee&gt; {\n    int count = size;\n    public boolean hasNext() { return count &gt; 0; }\n    public Coffee next() {\n      count--;\n      return CoffeeGenerator.this.next();\n    }\n    public void remove() { // Not implemented\n      throw new UnsupportedOperationException();\n    }\n  };\n  public Iterator&lt;Coffee&gt; iterator() {\n    return new CoffeeIterator();\n  }\n  public static void main(String[] args) {\n    CoffeeGenerator gen = new CoffeeGenerator();\n    for(int i = 0; i &lt; 5; i++)\n      System.out.println(gen.next());\n    for(Coffee c : new CoffeeGenerator(5))\n      System.out.println(c);\n  }\n} /* Output:\nAmericano 0\nLatte 1\nAmericano 2\nMocha 3\nMocha 4\nBreve 5\nAmericano 6\nLatte 7\nCappuccino 8\nCappuccino 9\n*/\n</code></pre><h2 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h2><p>一个基本指导原则：无论何时，只要你能做到，你就应该使用泛型方法。</p><pre><code class=\"Java\">public class GenericMethods {\n  public &lt;T&gt; void f(T x) {\n    System.out.println(x.getClass().getName());\n  }\n  public static void main(String[] args) {\n    GenericMethods gm = new GenericMethods();\n    gm.f(&quot;&quot;);\n    gm.f(1);\n    gm.f(1.0);\n    gm.f(1.0F);\n    gm.f(&#39;c&#39;);\n    gm.f(gm);\n  }\n} /* Output:\njava.lang.String\njava.lang.Integer\njava.lang.Double\njava.lang.Float\njava.lang.Character\nGenericMethods\n*/\n</code></pre><p>泛型方法与可变参数列表能够很好地共存:</p><pre><code class=\"Java\">public class GenericVarargs {\n  public static &lt;T&gt; List&lt;T&gt; makeList(T... args) {\n    List&lt;T&gt; result = new ArrayList&lt;T&gt;();\n    for(T item : args)\n      result.add(item);\n    return result;\n  }\n  public static void main(String[] args) {\n    List&lt;String&gt; ls = makeList(&quot;A&quot;);\n    System.out.println(ls);\n    ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\n    System.out.println(ls);\n    ls = makeList(&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;));\n    System.out.println(ls);\n  }\n} /* Output:\n[A]\n[A, B, C]\n[, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]\n*/\n</code></pre><blockquote><p>参考资料<br>1、《Java编程思想》读书笔记 第十四章 01 类型信息<br><a href=\"https://zhuanlan.zhihu.com/p/26081790\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://zhuanlan.zhihu.com/p/26081790</a><br>2、《java编程思想》14章类型信息 读书笔记 - CSDN博客<br><a href=\"http://blog.csdn.net/L2HL2H/article/details/51120480\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://blog.csdn.net/L2HL2H/article/details/51120480</a><br>3、《Java编程思想》读书笔记 第十四章 02 反射<br><a href=\"https://zhuanlan.zhihu.com/p/26190300\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://zhuanlan.zhihu.com/p/26190300</a><br>4、Java泛型详解 | ZiWenXie<br><a href=\"https://www.ziwenxie.site/2017/03/01/java-generic/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://www.ziwenxie.site/2017/03/01/java-generic/</a></p></blockquote>","categories":[{"name":"移动端技术","path":"api/categories/移动端技术.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《Java编程思想》","path":"api/tags/《Java编程思想》.json"}]}