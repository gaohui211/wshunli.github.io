{"title":"《JavaScript高级程序设计》读书笔记（二）","slug":"《JavaScript高级程序设计》读书笔记（二）","date":"2017-11-05T03:18:50.000Z","updated":"2018-04-19T14:55:25.953Z","comments":true,"path":"api/articles/《JavaScript高级程序设计》读书笔记（二）.json","excerpt":"《JavaScript高级程序设计》读书笔记","covers":["https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/DOM节点关系.png","https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流.jpg"],"content":"<p>《JavaScript高级程序设计》读书笔记</p><a id=\"more\"></a><p><strong>(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。</strong>(8-14章)</p><h1 id=\"第八章-BOM\"><a href=\"#第八章-BOM\" class=\"headerlink\" title=\"第八章 BOM\"></a>第八章 BOM</h1><h2 id=\"window-对象\"><a href=\"#window-对象\" class=\"headerlink\" title=\"window 对象\"></a>window 对象</h2><p>BOM 的核心对象是 window，表示浏览器的实例。既是范文浏览器窗口的接口，又是 ECMAScript 规定的 Global 对象。</p><p><strong>全局作用域</strong>：全局作用域中声明的变量函数会变成 window 对象的属性和方法。</p><p><strong>窗口关系及框架</strong>：若页面中包含框架，则每个框架都有自己的 window 对象，并且保存在 frames 集合中。</p><p>top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。<br>parent 对象始终指向当前框架的直接上层框架。<br>self 对象始终指向 window。</p><p>所有这些对象都是 window 对象的属性。</p><p><strong>窗口位置</strong>：IE、Safari、Opera、Chrome 提供 screenLeft 和 screenTop 属性，FireFox 提供 screenX 和 screenY 属性，分别用于表示窗口相对于屏幕左边和上边的位置。</p><p><strong>窗口大小</strong>：innerWidth、innerHeight、outerWidth、outerHeight</p><p><strong>导航和打开窗口</strong>: window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。</p><p>接受 4 个参数：要加载的URL、窗口目标、一个特性字符串、一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。</p><p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p><p><strong>间歇调用和超时调用</strong>：JavaScript 是单线程语言，但允许通过设置超时时间和间歇时间调度代码在特定的时刻执行。</p><p>超时调用 setTimeout()：指定的时间过后执行代码。</p><pre><code class=\"JavaScript\">var timeoutId=setTimeout(function(){\n    console.log(&quot;Hello world!&quot;);\n},1000);\n//取消超时调用\nclearTimeout(timeoutId);\n</code></pre><p>间歇调用 setInterval()：指定的时间间隔重复执行代码。</p><p><strong>系统对话框</strong>：alert()、confirm()、prompt()</p><h2 id=\"location-对象\"><a href=\"#location-对象\" class=\"headerlink\" title=\"location 对象\"></a>location 对象</h2><p>location 对象不仅提供与当前窗口中加载的文档有关信息，还提供了一些导航功能。<br>即是 window 对象的属性，也是 document 对象的属性。</p><p>除直接修改 location 对象属性外 assign()、replace()、reload() 方法也可以改变当前加载页面。</p><pre><code class=\"JavaScript\">location.assign(&quot;http://www.wshunli.com&quot;);\n// 等价于\nwindow.location=&quot;htttp://www.wshunli.com&quot;;\nlocation.href=&quot;htttp://www.wshunli.com&quot;;\n\nlocation.replace=&quot;htttp://www.wshunli.com&quot;;// 无法返回前一个页面\nlocation.reload();// 重新加载页面\n</code></pre><h2 id=\"navigator-对象\"><a href=\"#navigator-对象\" class=\"headerlink\" title=\"navigator 对象\"></a>navigator 对象</h2><p>navigator 对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。</p><h2 id=\"screen-对象\"><a href=\"#screen-对象\" class=\"headerlink\" title=\"screen 对象\"></a>screen 对象</h2><p>screen 对象用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息 ，如像素高度和宽度等。每个浏览器中的screen对象都包含着不同过的属性，支持也不同。</p><h2 id=\"history-对象\"><a href=\"#history-对象\" class=\"headerlink\" title=\"history 对象\"></a>history 对象</h2><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此每个浏览器窗口、每个标签乃至每个框架，都有自己的history 对象与特定的 window 对象关联。</p><h1 id=\"第九章-客户端检测\"><a href=\"#第九章-客户端检测\" class=\"headerlink\" title=\"第九章 客户端检测\"></a>第九章 客户端检测</h1><p>客户端检测主要包括：<br>能力检测：浏览器的特定能力；<br>怪癖检测：浏览器实际中存在的 bug ；<br>用户代理检测：通过检测用户代理字符串识别浏览器。</p><p>尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案。</p><h1 id=\"第十章-DOM\"><a href=\"#第十章-DOM\" class=\"headerlink\" title=\"第十章 DOM\"></a>第十章 DOM</h1><h2 id=\"节点层次\"><a href=\"#节点层次\" class=\"headerlink\" title=\"节点层次\"></a>节点层次</h2><p>DOM 将任何HTML或XML文档描绘成一个由多层节点构成的树形结构。总共有 12 种节点，其中常用的有 4 种。</p><p>Node.ELEMENT_NODE(1) - 元素节点<br>Node.ATTRIBUTE_NODE(2) - 特性（属性）节点<br>Node.TEXT_NODE(3) - 文本节点<br>Node.COMMENT_NODE(8) - 注释节点</p><p>DOM 节点关系：</p><p><img src=\"https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/DOM节点关系.png\" alt=\"DOM节点关系\"></p><p><strong>Document 类型</strong>：JavaScript通过Document类型表示文档；浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面，且也是window对象的一个属性，因此可以将其作为全局对象来访问。</p><p>文档属性：<br>document.title：取得当前页面的标题，也可以修改标题。<br>document.URL：页面完整的URL；<br>document.domain：只包含页面的域名；<br>document.referrer：保存着链接到当前页面的那个页面的 URL。<br>文档方法：<br>document.getElementById()<br>document.getElementsByTagName()<br>document.getElementsByName()<br>特殊集合：<br>document.anchors：包含文档中所有带name特性的<code>&lt;a&gt;</code>元素；<br>document.forms：包含文档中所有<code>&lt;form&gt;</code>元素；<br>document.img：包含文档中所有<code>&lt;img&gt;</code>元素；<br>document.links：包含文档中所有带href特性的<code>&lt;a&gt;</code>元素。</p><p><strong>Element 类型</strong>：Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。</p><p>特性（属性）操作：getAttribute()、setAttribute()、removeAttribute()<br>创建元素：document.createElement()</p><p><strong>Text 类型</strong>：文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。</p><p>创建文本节点：document.createTextNode()</p><p>规范文本节点：父元素上调用 normalize()，其实就是将元素的相邻文本节点合并成一个节点。</p><pre><code class=\"JavaScript\">var element = document.createElement(&quot;div&quot;);\nelement.className = &quot;message&quot;;\nvar textNode = document.createTextNode(&quot;Hello world!&quot;);\nelement.appendChild(textNode);\nvar anotherTextNode = document.createTextNode(&quot;Yippee!&quot;);\nelement.appendChild(anotherTextNode);\ndocument.body.appendChild(element);\n\nconsole.log(element.childNodes.length);  //2\nelement.normalize();\nconsole.log(element.childNodes.length);  //1\nconsole.log(element.firstChild.nodeValue);  //&quot;Hello World!Yippee!&quot;\n</code></pre><p>分割文本节点：spiltText()</p><pre><code class=\"JavaScript\">var element=document.createElement(&quot;div&quot;);\nelement.className=&quot;message&quot;;\nvar textNode=docuemnt.createTextNode(&quot;Hello World!&quot;);\nelement.appendChild(textNode);\ndocument.body.appendChild(element);\n\nvar newNode=element.firstChild.spiltText(5);\nconsole.log(element.firstChild.nodeValue); //&quot;Hello&quot;\nconsole.log(newNode.nodeValue);            //&quot; World&quot;\nconsole.log(element.childNodes.length);    //2\n</code></pre><p><strong>Attr 类型</strong>：元素的特性（属性）在 DOM 中以 Attr 类型来表示。<br>Attr对象有3个属性：name、value和specified。<br>其中，name是特性名称，value是特性的值，specified是一个布尔值，用以区别特性是在代码中指定的还是默认的。</p><p><strong>Comment 类型</strong>：注释在 DOM 中是通过 Comment 类型来表示的。</p><p><strong>其他节点类型</strong>：</p><p>Node.CDATA_SECTION_NODE(4)<br>Node.ENTITY_REFERENCE_NODE(5)<br>Node.ENTITY_NODE(6)<br>Node.PROCESSING_INSTRUCTION_NODE(7)<br>Node.DOCUMENT_NODE(9)<br>Node.DOCUMENT_TYPE_NODE(10)<br>Node.DOCUMENT_FRAGMENT_NODE(11)<br>Node.NOTATION_NODE(12)</p><h2 id=\"DOM-操作技术\"><a href=\"#DOM-操作技术\" class=\"headerlink\" title=\"DOM 操作技术\"></a>DOM 操作技术</h2><p>利用 JavaScript 代码、CSS 样式、表格修改 DOM 元素的结构、属性、内容的技术。</p><p>动态脚本：<code>&lt;script&gt;</code><br>动态样式：<code>&lt;link&gt;</code>,<code>&lt;style&gt;</code><br>操作表格：<code>&lt;table&gt;</code></p><h1 id=\"第十一章-DOM-扩展\"><a href=\"#第十一章-DOM-扩展\" class=\"headerlink\" title=\"第十一章 DOM 扩展\"></a>第十一章 DOM 扩展</h1><p>DOM扩展主要包含两方面：Selector API，HTML5</p><h2 id=\"选择符-API\"><a href=\"#选择符-API\" class=\"headerlink\" title=\"选择符 API\"></a>选择符 API</h2><p>querySelector() ：接收一个 CSS 选择符，返回匹配的第一个元素；<br>querySelectorAll() ：返回 NodeList 对象。</p><pre><code class=\"JavaScript\">// 取得ID为&quot;myDIV&quot;的元素\nvar myDIV = document.querySelector(&quot;#myDiv&quot;);\n// 取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName(&quot;em&quot;))\nvar ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;);\n</code></pre><h2 id=\"元素遍历\"><a href=\"#元素遍历\" class=\"headerlink\" title=\"元素遍历\"></a>元素遍历</h2><p>Element Traversal 规范为 DOM <strong>元素</strong>新定义了5个属性：<br>childElementCount：返回子元素的个数（不包括文本节点和注释）<br>firstElementChild：指向第一个子元素，firstChild元素版<br>lastElementChild：指向最后一个子元素，lastChild元素版<br>previousElementSibling：指向前一个同辈元素，previousSibling元素版<br>nextElementSibling：指向后一个同辈元素，nextSibling元素版</p><h2 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h2><p><strong>与类相关的扩展</strong>：</p><p>getElementsByClassName()：返回带有特定类的所有元素的 NodeList。<br>classList属性：HTML5为所有元素添加 classList属性。</p><p><strong>焦点管理</strong>：HTML5也添加了辅助管理DOM焦点的功能。<br>document.activeElement 属性，始终会引用 DOM 中当前获得焦点的元素。<br>document.hasFocus()方法，确定文档是否获得了焦点。</p><pre><code class=\"JavaScript\">var button = document.getElementById(&quot;myButton&quot;);\nbutton.focus();\nconsole.log(document.activeElement === button); // true\nconsole.log(document.hasFocus()); // true\n</code></pre><p><strong>HTMLDocument 的变化</strong>：</p><p>readyState 属性：document.readyState 指示文档是否加载完成。<br>loading：正在加载文档；complete：已经加载完文档。</p><p>head 属性：document.head 属性可以获得<code>&lt;head&gt;</code>元素。</p><p><strong>字符集属性</strong>：</p><p>document.charset：表示文档中实际使用的字符集。<br>document.defaultCharset：当前文档的默认字符集。</p><p><strong>自定义数据属性</strong>：</p><p>HTML5规定可以为元素添加非标准的属性，以此为元素提供与渲染无关的信息。<br>每个自定义数据属性，都要为其添加前缀data-。可通过 dataset 属性访问自定义属性的值。</p><pre><code class=\"JavaScript\">&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myName=&quot;nicholas&quot;&gt;&lt;/div&gt;\n// 访问上述div元素的自定义属性\nvar div = document.getElementById(&quot;myDiv&quot;);\n// 访问自定义属性值时，属性名前不必加data-前缀\nvar appId = div.dataset.appId;\n</code></pre><p><strong>插入标记</strong>：</p><p>innerHTML 属性：<br>在读模式下，innerHTML属性返回调用元素的所有子节点HTML标记。<br>在写模式下，innerHTML属性会根据指定的值创建新的DOM树，然后用新DOM树替换调用元素原先的所有子节点。</p><p>outerHTML 属性：<br>在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。<br>在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。</p><p>insertAdjacentHTML() 方法：<br>语法：insertAdjacentHTML(插入位置，要插入的HTML文本)<br>插入位置必须是下列四个值之一：</p><ul><li>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素</li><li>“afterend”，在当前元素之后插入一个紧邻的同辈元素</li><li>“afterbegin”，给当前元素插入第一个子元素（不管当前元素是否有无子元素）</li><li>“beforeend”，给当前元素插入最后一个子元素（不管当前元素是否有无子元素）</li></ul><p><strong>scrollIntoView() 方法</strong>：所有元素均可调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</p><h1 id=\"第十二章-DOM2-和-DOM3\"><a href=\"#第十二章-DOM2-和-DOM3\" class=\"headerlink\" title=\"第十二章 DOM2 和 DOM3\"></a>第十二章 DOM2 和 DOM3</h1><p>DOM1级主要定义的是HTML和XML文档的底层结构。DOM2 和DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。</p><h1 id=\"第十三章-事件\"><a href=\"#第十三章-事件\" class=\"headerlink\" title=\"第十三章 事件\"></a>第十三章 事件</h1><h2 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。</p><p>事件冒泡（event bubbling）：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。<br>事件捕获（event capturing）:不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件。</p><p><img src=\"https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流.jpg\" alt=\"事件-事件流\"></p><p>事件流包括三个阶段：<br>事件捕获阶段：首先发生，为截获事件提供了机会。<br>处于目标阶段：实际的目标接收到事件。<br>事件冒泡阶段：在此阶段可以对事件做出响应。</p><p><img src=\"https://img.wshunli.com/JavaScript/JavaScript高级程序设计/2/事件-事件流三个阶段.jpg\" alt=\"事件-事件流三个阶段\"></p><h2 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h2><p>事件是用户或浏览器自身执行的某种动作（比如click、load、mouseover等）<br>事件处理程序（事件侦听器）是响应某个事件的函数。<br>事件处理程序的名字以“on”开头，如click事件的事件处理程序是onclick。</p><p><strong>HTML事件处理程序</strong>：</p><p>为元素添加一个与事件处理程序同名的属性，该属性的值是能够执行的JS代码或JS函数。</p><pre><code class=\"JavaScript\">&lt;script type=&quot;text/javascript&quot;&gt;\n    function showMessage() {\n        console.log(&quot;Hello world&quot;);\n    }\n&lt;/script&gt;\n&lt;input type=&quot;button&quot; value=&quot;Clicke Me&quot; onclick=&quot;showMessage()&quot; /&gt;\n</code></pre><p><strong>DOM0级事件处理程序</strong>：</p><p>将一个函数赋值给一个事件处理程序属性。</p><pre><code class=\"JavaScript\">var btn = document.getElementById(&quot;myBtn&quot;);\n// 为按钮指定onclick事件处理程序\nbtn.onclick = function(){\n    console.log(&quot;Clicked&quot;);\n}\n// 删除事件处理程序\nbtn.onclick = null;\n</code></pre><p><strong>DOM2级事件处理程序</strong>：</p><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()、removeEventListener() 。</p><pre><code class=\"JavaScript\">var btn = document.getElementById(&quot;myBtn&quot;);\n//定义事件处理程序函数\nvar handler = function(){\n    console.log(this.id);\n}\nbtn.addEventListener(&quot;click&quot;, handler, false);\nbtn.removeEventListener(&quot;click&quot;, handler, false);\n</code></pre><p>true：在捕获阶段调用事件处理程序；false：在冒泡阶段调用事件处理程序。</p><h2 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h2><p>触发DOM上的某个事件时，会产生一个event事件对象，该对象包含着所有与事件有关的信息。</p><p>兼容DOM（DOM0级和DOM2级）的浏览器将event对象传入到事件处理程序中。</p><pre><code class=\"JavaScript\">var btn = document.getElementById(&quot;myBtn&quot;);\nbtn.onclick = function(event){\n    console.log(event.type);  //&quot;click&quot;\n};\nbtn.addEventListener(&quot;click&quot;, function(event){\n    console.log(event.type);  //&quot;click&quot;\n}, false);\n</code></pre><p><strong>属性/方法</strong>：</p><p>currentTarget：正在处理事件的那个元素<br>target：事件的目标<br>type：事件类型<br>cancelable：可以阻止特定事件的默认行为<br>preventDefault()：阻止特定事件的默认行为<br>stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡<br>eventPhase：事件出于事件流的阶段 捕获阶段为1 处于目标对象为2 冒泡阶段为3</p><h2 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h2><p>UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件、合成事件、变动事件。</p><h1 id=\"第十四章-表单脚本\"><a href=\"#第十四章-表单脚本\" class=\"headerlink\" title=\"第十四章 表单脚本\"></a>第十四章 表单脚本</h1><p>在HTML中，表单是由 <code>&lt;form&gt;</code> 元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。</p>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"《JavaScript高级程序设计》","path":"api/tags/《JavaScript高级程序设计》.json"}]}