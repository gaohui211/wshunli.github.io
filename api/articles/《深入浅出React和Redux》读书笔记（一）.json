{"title":"《深入浅出React和Redux》读书笔记（一）","slug":"《深入浅出React和Redux》读书笔记（一）","date":"2017-11-10T05:40:03.000Z","updated":"2018-04-14T14:51:42.876Z","comments":true,"path":"api/articles/《深入浅出React和Redux》读书笔记（一）.json","excerpt":"发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。","covers":["https://img.wshunli.com/React/深入浅出React和Redux/React技术栈.png-hexo.png","https://img.wshunli.com/React/深入浅出React和Redux/first-react-app.png-hexo.png","https://img.wshunli.com/React/深入浅出React和Redux/React组件生命周期.png-hexo.png"],"content":"<p>发现马上就要入前端的大坑了。ES6入门内容很多还没看完，现在先学习 React 吧。</p><a id=\"more\"></a><p>之间就简单地使用 <a href=\"https://reactjs.org\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">React</a> 搭建过一次 Demo ，借这次机会把 React 给搞定了，至少能写个简单的界面。</p><p><img src=\"https://img.wshunli.com/React/深入浅出React和Redux/React技术栈.png-hexo.png\" alt=\"React技术栈\"></p><p>看着这 React技术栈 ，还是压力山大啊。</p><p>这次选了两本书 《深入浅出React和Redux》 和 《React全栈》。书都很新也很薄，这次先看一本入门。</p><h1 id=\"第1章-React-新的前端思维方式\"><a href=\"#第1章-React-新的前端思维方式\" class=\"headerlink\" title=\"第1章 React 新的前端思维方式\"></a>第1章 React 新的前端思维方式</h1><p>首先使用 <code>creat-react-app</code> 创建一个 React 应用。</p><p>在确认 Node.js 和 npm 安装好之后，在命令行执行以下命令安装 <code>creat-react-app</code> 工具。</p><pre><code class=\"Shell\">npm install -g create-react-app\ncreate-react-app first-react-app\nnpm start\n</code></pre><p>浏览器会自动打开 <a href=\"http://localhost:3000/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://localhost:3000/</a> 显示如下界面：</p><p><img src=\"https://img.wshunli.com/React/深入浅出React和Redux/first-react-app.png-hexo.png\" alt=\"first-react-app\"></p><p>我们来看一下 first-react-app 的目录结构：</p><p><img src=\"https://img.wshunli.com/React/深入浅出React和Redux/first-react-app2.png-hexo.png\" alt=\"first-react-app\"></p><p>在开发过程中，我们主要关注 src 目录的内容。</p><p>其中 <code>src/index.js</code> 文件是应用的入口文件：</p><pre><code class=\"JSX\">import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &#39;./index.css&#39;;\nimport App from &#39;./App&#39;;\nimport registerServiceWorker from &#39;./registerServiceWorker&#39;;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));\nregisterServiceWorker();\n</code></pre><p>这里的代码渲染了一个 App 组件，效果就是首页界面。<br>我们看下 App 组件是怎么定义的，在 <code>src/App.js</code> 文件中：</p><pre><code class=\"JSX\">import React, { Component } from &#39;react&#39;;\nimport logo from &#39;./logo.svg&#39;;\nimport &#39;./App.css&#39;;\n\nclass App extends Component {\n  render() {\n    return (\n      &lt;div className=&quot;App&quot;&gt;\n        &lt;header className=&quot;App-header&quot;&gt;\n          &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;\n        &lt;/header&gt;\n        &lt;p className=&quot;App-intro&quot;&gt;\n          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.\n        &lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default App;\n</code></pre><p>React 应用实际上依赖很复杂的技术栈，我们使用 <code>creat-react-app</code> 避免一开始就浪费太多精力配置技术栈。</p><p>我们启动 React 的命令是 <code>npm start</code> ，在 <code>package.json</code> 中：</p><pre><code class=\"JS\">  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;react-scripts start&quot;,\n    &quot;build&quot;: &quot;react-scripts build&quot;,\n    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,\n    &quot;eject&quot;: &quot;react-scripts eject&quot;\n  }\n</code></pre><p>npm build 可以创建生产环境优化代码；<br>npm teat 用于单元测试；<br>npm eject 把 react-scripts 技术栈配置都弹射到应用顶层，不可逆。</p><h2 id=\"添加-React-组件\"><a href=\"#添加-React-组件\" class=\"headerlink\" title=\"添加 React 组件\"></a>添加 React 组件</h2><p>仿照着增加一个新的 React 组件。同样在 src 目录新建文件 <code>ClickCounter.js</code> 写入如下代码：</p><pre><code class=\"JSX\">import React, { Component } from &#39;react&#39;;\n\nclass ClickCounter extends Component {\n\n  constructor(props) {\n    super(props);\n    this.onClickButton = this.onClickButton.bind(this);\n    this.state = {\n      count: 0\n    }\n  }\n\n  onClickButton() {\n    this.setState({count: this.state.count + 1});\n  }\n\n  render() {\n    const counterStyle = {\n      margin: &#39;16px&#39;\n    }\n    return (\n      &lt;div style={counterStyle}&gt;\n        &lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;\n        &lt;div&gt;\n          Click Count: &lt;span id=&quot;clickCount&quot;&gt;{this.state.count}&lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default ClickCounter;\n</code></pre><p>修改 <code>src/index.js</code> 文件：</p><pre><code class=\"JSX\">import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &#39;./index.css&#39;;\nimport ClickCounter from &#39;./ClickCounter&#39;;\nimport registerServiceWorker from &#39;./registerServiceWorker&#39;;\n\nReactDOM.render(&lt;ClickCounter /&gt;, document.getElementById(&#39;root&#39;));\nregisterServiceWorker();\n</code></pre><p>其中在 index.js 中使用 import 导入 ClickCounter 组件，替代之前的 App 组件。</p><pre><code class=\"JSX\">import ClickCounter from &#39;./ClickCounter&#39;;\n</code></pre><p>在 ClickCounter.js 的第一行我们以同样的方式引入 React 和 Component 。</p><pre><code class=\"JSX\">import React, { Component } from &#39;react&#39;;\n</code></pre><p>Component 为所有组件的基类，提供很多组件共有的功能。</p><pre><code class=\"JSX\">class ClickCounter extends Component {}\n</code></pre><p>React 没有在代码中直接使用，但在 JSX 使用的范围内必须有 React，因为 JSX 最终会被转译成依赖 React 的表达式。</p><p><strong>JSX</strong>：JSX 是 JavaScript 的一种扩展语法，使我们能够在 JavaScript 中编写类似 HTML 的代码。<br>JSX 的基本语法规则：遇到 HTML 标签（以&lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。</p><p>首先，在 JSX 中使用的元素不限于 HTML 元素，可以是 React 组件。而区分二者的方法是首字母是否大写。<br>其次，在 JSX 中可以通过 onClick 这样的方式为元素添加事件处理函数。</p><pre><code class=\"JSX\">&lt;button onClick={this.onClickButton}&gt;Click Me&lt;/button&gt;\n</code></pre><h2 id=\"React-的工作方式\"><a href=\"#React-的工作方式\" class=\"headerlink\" title=\"React 的工作方式\"></a>React 的工作方式</h2><p>React的理念归结为一个公式：UI=render(data) 。</p><p>用户看到的界面（UI）是一个函数（render）的执行结果，只接受数据（data）作为参数。这是一个纯函数，即输出只依赖于输入的函数，两次函数的调用如果输入相同，那么输出也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。</p><p>对于开发者来说，重要的是区分开哪些属于data ，哪些属于render ，想要更新用户界面，要做的就是更新data ，用户界面自然会做出响应，所以React 实践的也是“响应式编程”（ Reactive Programming ）的思想。</p><p><strong>Virtual DOM</strong>：是对DOM树的抽象，它并不触及浏览器部分，只是存在于 JavaScript 空间的树形结构，每次在渲染 React 组件，React 会对前后两次产生的 Virtual DOM 进行比较，最后只有发生了改变的地方会被重新渲染。</p><blockquote><p>总而言之，React利用函数式编程的思维来解决用户界面渲染的问题，强制所有组件都以数据驱动渲染的模式进行开发。</p></blockquote><h1 id=\"第2章-设计高质量的-React-组件\"><a href=\"#第2章-设计高质量的-React-组件\" class=\"headerlink\" title=\"第2章 设计高质量的 React 组件\"></a>第2章 设计高质量的 React 组件</h1><p>作为软件设计的通则，组件的划分要满足高内聚（High Cohesion ）和低搞合（ Low Coupling）的原则。</p><h2 id=\"React-组件的数据\"><a href=\"#React-组件的数据\" class=\"headerlink\" title=\"React 组件的数据\"></a>React 组件的数据</h2><p>React 组件的数据分为两种， prop 和 state。</p><p>prop 是组件的对外接口， state 是组件的内部状态，对外用 prop ，内部用 state 。</p><h3 id=\"React-的-prop\"><a href=\"#React-的-prop\" class=\"headerlink\" title=\"React 的 prop\"></a>React 的 prop</h3><p>prop ( property 的简写）是外部传递给组件的数据， React 组件通过定义自己能够接受的 prop 就定义了自己的对外公共接口。</p><pre><code class=\"JSX\">&lt;SampleButton\nid= &quot;sample&quot; borderWidth={2} onClick={onButtonClick}\nstyle={{color :\"red\"}}\n/&gt;\n</code></pre><p>当 prop 的值不是字符串类型时，在 JSX 中必须用花括号 {} 包住，<br>所以 style 的值有两层花括号，外层花括号代表是 JSX 的语法，内层的花括号代表这是一个对象常量。</p><pre><code class=\"JSX\">class ControlPanel extends Component {\n  render() {\n    console.log(&#39;enter ControlPanel render&#39;);\n    return (\n      &lt;div&gt;\n        &lt;Counter caption=&quot;First&quot; initValue={0}/&gt;\n        &lt;Counter caption=&quot;Second&quot; initValue={10} /&gt;\n        &lt;Counter caption=&quot;Third&quot; initValue={20} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre><p>上面是给 prop 赋值，下面读取 prop 的值：</p><pre><code class=\"JSX\">class Counter extends Component {\n\n  constructor(props) {\n    console.log(&#39;enter constructor: &#39; + props.caption);\n    super(props);\n\n    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);\n    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);\n\n    this.state = {\n      count: props.initValue || 0\n    }\n  }\n  ···\n</code></pre><p>在构造函数中可以通过参数 props 获得传人 prop 值，在其他函数中则可以通过 <code>this.props</code> 访问传人 prop 的值。</p><pre><code class=\"JSX\">  ···\n render() {\n    console.log(&#39;enter render &#39; + this.props.caption);\n    const {caption} = this.props;\n    return (\n      &lt;div&gt;\n        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;\n        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;\n        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n</code></pre><p><strong>propTypes 检查</strong>：组件声明接口规范，即组件支持的 prop 及其格式。</p><pre><code class=\"JSX\">Counter.propTypes = {\n  caption: PropTypes.string.isRequired,\n  initValue: PropTypes.number\n};\n</code></pre><p>建议在开发阶段使用，产品环境下去除。</p><h3 id=\"React-的-state\"><a href=\"#React-的-state\" class=\"headerlink\" title=\"React 的 state\"></a>React 的 state</h3><p>state 代表组件的内部状态。</p><p>1、初始化 state</p><p>通常在组件的构造函数结尾处初始化 state 。</p><pre><code class=\"JSX\">constructor(props) {\n    ···\n    this.state = {\n      count: props.initValue || 0\n    }\n  }\n</code></pre><p>React 的 defaultProps 给 prop 默认初始值：</p><pre><code class=\"JSX\">Counter.defaultProps = {\n  initValue: 0\n}\n// this.state 可省去判断\nthis.state = {\n  count: props.initValue\n}\n</code></pre><p>2、读取更新 state</p><p>this.state 读取 state<br>this.setState 更新 state</p><pre><code class=\"JSX\">onClickIncrementButton() {\n  this.setState({count: this.state.count + 1});\n}\n</code></pre><h3 id=\"prop-和state-的区别\"><a href=\"#prop-和state-的区别\" class=\"headerlink\" title=\"prop 和state 的区别\"></a>prop 和state 的区别</h3><ul><li>prop 用于定义外部接口， state 用于记录内部状态；</li><li>prop 的赋值在外部世界使用组件时， state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变的。</li></ul><p>组件是绝不应该去修改传人的 props 值，否则会影响其他组件。</p><h2 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h2><p>React 严格定义了组件的生命周期，生命周期可能会经历如下三个过程：</p><ul><li>装载过程（ Mount ），也就是把组件第一次在DOM 树中渲染的过程；</li><li>更新过程（ Update ），当组件被重新渲染的过程；</li><li>卸载过程（ Unmount ），组件从DOM 中删除的过程。</li></ul><p>三种不同的过程， React 库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个 React 组件，实际上就是定制这些生命周期函数。</p><p><img src=\"https://img.wshunli.com/React/深入浅出React和Redux/React组件生命周期.png-hexo.png\" alt=\"React组件生命周期\"></p><p><a href=\"https://reactjs.org/docs/react-component.htm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://reactjs.org/docs/react-component.htm</a></p><h3 id=\"装载过程\"><a href=\"#装载过程\" class=\"headerlink\" title=\"装载过程\"></a>装载过程</h3><p>当组件第一次渲染的时候，依次调用的函数如下：</p><ul><li>constructor()</li><li>getlnitialState()</li><li>getDefaultProps()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ul><p>1、constructor()<br>ES6 中类的构造函数，主要是初始化 state 和绑定成员函数的 this 环境。</p><p>2、getlnitialState() 和 getDefaultProps()<br>getlnitialState() 返回值用来初始化组件的 this.state ，getDefaultProps() 返回值用来作为 prop 的初始值。<br>这两个方法只有用 React.createClass 方法创建组件类时才会生效。</p><pre><code class=\"JSX\">const Sample = React.createClass({\n  getInitialState() {\n    console.log(&#39;enter getInitialState&#39;);\n  }\n  getDefaultProps() {\n    console.log(&#39;enter getDefaultProps&#39;);\n  }\n});\n</code></pre><p>而在 ES6 中使用 defaultProps 指定初试 prop 初始值。</p><pre><code class=\"JSX\">const Sample extends React.Component({\n  constructor(props) {\n    super(props);\n    this.state = {foo: &quot;bar&quot;}\n  }\n}\n\nSample.defaultProps = {\n  return {sampleProp: 0}\n};\n</code></pre><p>React.createClass 已经被 Facebook 官方逐渐废弃。</p><p>3、render()</p><p>render() 函数在 React 中必须实现，其他生命周期函数在 React.Component 中都有默认实现。</p><p>render() 并不做实际的渲染动作，只是返回 JSX 描述的结构，最终由 React 操作渲染过程。<br>不需要渲染界面可以返回 null 或者 false 。</p><p>4、componentWillMount() 和 componentDidMount()</p><p>在装载过程中，componentWillMount() 会在调用 render() 函数之前被调用， componentDidMount() 会在调用 render() 函数之后被调用。</p><p>componentWillMount() 是将要装载，虽然还没有渲染出来结果，但是修改组件状态已经晚了。<br>componentDidMount() 是 render() 函数返回的内容已经渲染好了，组件已经被装载在 DOM 树上了。</p><p>componentWilIMount() 和 componentDidMount() 这对兄弟函数还有一个区别：<br>componentWillMount() 可以在服务器端被调用，也可以在浏览器端被调用；<br>而componentDidMount() 只能在浏览器端被调用，在服务器端使用 React 的时候不会被调用。</p><h3 id=\"更新过程\"><a href=\"#更新过程\" class=\"headerlink\" title=\"更新过程\"></a>更新过程</h3><p>当组件的 props 或者 state 被修改的时候，就会引发组件的更新过程。<br>更新过程会依次调用下面的生命周期函数：</p><ul><li>componentWillReceiveProps(nextProps)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>componentWillUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><p>1、componentWillReceiveProps(nextProps)</p><p>只要是父组件的 render() 函数被调用，在 render() 函数里面被谊染的子组件就会经历更新过程，<br>不管父组件传给子组件的 props 有没有改变，都会触发子组件的 componentWillReceiveProps() 函数。</p><p>componentWillReceiveProps(nextProps) 适合根据新的 props 值（也就是参数 nextProps ）来计算出是不是要更新内部状态state 。</p><p>注意，更新组件内部状态的方法 this.setState() 方法触发的更新过程不会调用这个函数，否则会导致 componentWillReceiveProps 再次被调用，陷入死循环。</p><p>当组件的 props 发生改变：</p><pre><code class=\"TXT\">&quot;componentWillReceiveProps&quot;\n&quot;shouldComponentUpdate&quot;\n&quot;componentWillUpdate&quot;\n&quot;render&quot;\n&quot;componentDidUpdate&quot;\n</code></pre><p>当组件的 state 发生改变：</p><pre><code class=\"TXT\">&quot;shouldComponentUpdate&quot;\n&quot;componentWillUpdate&quot;\n&quot;render&quot;\n&quot;componentDidUpdate&quot;\n</code></pre><p>当父组件导致子组件重新渲染：</p><pre><code class=\"TXT\">&quot;componentWillReceiveProps&quot;\n&quot;shouldComponentUpdate&quot;\n&quot;componentWillUpdate&quot;\n&quot;render&quot;\n&quot;componentDidUpdate&quot;\n</code></pre><p>2、shouldComponentUpdate(nextProps, nextState)</p><p>shouldComponentUpdate() 函数决定组件是否需要渲染，返回布尔值。</p><pre><code class=\"JSX\">shouldComponentUpdate(nextProps, nextState) {\n  return (nextProps.caption !== this.props.caption) ||\n         (nextState.count !== this.state.count);\n}\n</code></pre><p>3、componentWillUpdate() 和 componentDidUpdate()</p><p>当组件的 shouldComponentUpdate() 函数返回 true ,React 接下来依次调用对应组件的 componentWillUpdate()、render() 和 componentDidUpdate() 函数。</p><p>和装载过程不同的是，当在服务器端使用 React 渲染时，二者都可以在服务端调用。</p><h3 id=\"卸载过程\"><a href=\"#卸载过程\" class=\"headerlink\" title=\"卸载过程\"></a>卸载过程</h3><p>componentWillUnmount() 表示组件要从 DOM 树上删除掉之前，比较适合做一些清理工作。</p><h2 id=\"案例展示\"><a href=\"#案例展示\" class=\"headerlink\" title=\"案例展示\"></a>案例展示</h2><p><code>ControlPanel.js</code></p><pre><code class=\"JSX\">import React, { Component } from &#39;react&#39;;\nimport Counter from &#39;./Counter.js&#39;;\n\nconst style = {\n  margin: &#39;20px&#39;\n};\n\nclass ControlPanel extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.onCounterUpdate = this.onCounterUpdate.bind(this);\n\n    this.initValues = [ 0, 10, 20];\n\n    const initSum = this.initValues.reduce((a, b) =&gt; a+b, 0);\n    this.state = {\n      sum: initSum\n    };\n  }\n\n  onCounterUpdate(newValue, previousValue) {\n    const valueChange = newValue - previousValue;\n    this.setState({ sum: this.state.sum + valueChange});\n  }\n\n  render() {\n    return (\n      &lt;div style={style}&gt;\n        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;First&quot; /&gt;\n        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Second&quot; initValue={this.initValues[1]} /&gt;\n        &lt;Counter onUpdate={this.onCounterUpdate} caption=&quot;Third&quot; initValue={this.initValues[2]} /&gt;\n        &lt;hr/&gt;\n        &lt;div&gt;Total Count: {this.state.sum}&lt;/div&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default ControlPanel;\n</code></pre><p><code>Counter.js</code></p><pre><code class=\"JSX\">import React, { Component, PropTypes } from &#39;react&#39;;\n\nconst buttonStyle = {\n  margin: &#39;10px&#39;\n};\n\nclass Counter extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.onClickIncrementButton = this.onClickIncrementButton.bind(this);\n    this.onClickDecrementButton = this.onClickDecrementButton.bind(this);\n\n    this.state = {\n      count: props.initValue\n    }\n  }\n\n  onClickIncrementButton() {\n    this.updateCount(true);\n  }\n\n  onClickDecrementButton() {\n    this.updateCount(false);\n  }\n\n  updateCount(isIncrement) {\n    const previousValue = this.state.count;\n    const newValue = isIncrement ? previousValue + 1 : previousValue - 1;\n\n    this.setState({count: newValue})\n    this.props.onUpdate(newValue, previousValue)\n  }\n\n  render() {\n    const {caption} = this.props;\n    return (\n      &lt;div&gt;\n        &lt;button style={buttonStyle} onClick={this.onClickIncrementButton}&gt;+&lt;/button&gt;\n        &lt;button style={buttonStyle} onClick={this.onClickDecrementButton}&gt;-&lt;/button&gt;\n        &lt;span&gt;{caption} count: {this.state.count}&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nCounter.propTypes = {\n  caption: PropTypes.string.isRequired,\n  initValue: PropTypes.number,\n  onUpdate: PropTypes.func\n};\n\nCounter.defaultProps = {\n  initValue: 0,\n  onUpdate: f =&gt; f //什么都不做的函数\n};\n\nexport default Counter;\n</code></pre><blockquote><p>参考资料<br>1、React.Component - React<br><a href=\"https://reactjs.org/docs/react-component.htm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://reactjs.org/docs/react-component.htm</a><br>2、React组件生命周期<br><a href=\"https://nsne.github.io/2017/02/15/react-component-lifecycle/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://nsne.github.io/2017/02/15/react-component-lifecycle/</a></p></blockquote>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"React","path":"api/tags/React.json"},{"name":"《深入浅出React和Redux》","path":"api/tags/《深入浅出React和Redux》.json"}]}