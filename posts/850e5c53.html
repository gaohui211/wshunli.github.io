<!DOCTYPE html><html style="display:none" lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><script>window.materialVersion="1.5.5",window.oldVersion=["codestartv1","1.3.4","1.4.0","1.4.0b1","1.5.0"]</script><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.wshunli.com/source"><link rel="dns-prefetch" href="https://cdn1.lncld.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="dns-prefetch" href="https://lib.baomitu.com"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="renderer" content="webkit"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>图解数据结构（Java语言实现） - CirGIS 博客</title><link rel="icon shortcut" type="image/ico" href="/favicon.ico"><link rel="icon" href="/favicon.ico"><meta name="format-detection" content="telephone=no"><meta name="description" itemprop="description" content="wshunli`s Blog!"><meta name="keywords" content="wshunli CirGIS,Java,数据结构与算法,数据结构"><meta name="theme-color" content="#606266"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]--><script>window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}},lsloader.removeLS=function(e){try{localStorage.removeItem(e)}catch(e){}},lsloader.setLS=function(e,t){try{localStorage.setItem(e,t)}catch(e){}},lsloader.getLS=function(e){var t="";try{t=localStorage.getItem(e)}catch(e){t=""}return t},versionString="/*"+(window.materialVersion||"unknownVersion")+"*/",lsloader.clean=function(){try{for(var e=[],t=0;t<localStorage.length;t++)e.push(localStorage.key(t));e.forEach(function(e){var n=lsloader.getLS(e);window.oldVersion&&window.oldVersion.reduce(function(e,t){return e||-1!==n.indexOf("/*"+t+"*/")},!1)&&lsloader.removeLS(e)})}catch(e){}},lsloader.clean(),lsloader.load=function(e,t,n,s){var a;if("boolean"==typeof n&&(s=n,n=void 0),s=s||!1,n=n||function(){},(a=this.getLS(e))&&-1===a.indexOf(versionString))return this.removeLS(e),void this.requestResource(e,t,n,s);if(a){if(a.split(versionString)[0]!=t)return console.log("reload:"+t),this.removeLS(e),void this.requestResource(e,t,n,s);a=a.split(versionString)[1],s?(this.jsRunSequence.push({name:e,code:a}),this.runjs(t,e,a)):(document.getElementById(e).appendChild(document.createTextNode(a)),n())}else this.requestResource(e,t,n,s)},lsloader.requestResource=function(t,n,e,s){var a=this;s?this.iojs(n,t,function(e,t,n){a.setLS(t,e+versionString+n),a.runjs(e,t,n)}):this.iocss(n,t,function(e){document.getElementById(t).appendChild(document.createTextNode(e)),a.setLS(t,n+versionString+e)},e)},lsloader.iojs=function(e,t,n){var s=this;s.jsRunSequence.push({name:t,code:""});try{var a=new XMLHttpRequest;a.open("get",e,!0),a.onreadystatechange=function(){if(4==a.readyState){if((200<=a.status&&a.status<300||304==a.status)&&""!=a.response)return void n(e,t,a.response);s.jsfallback(e,t)}},a.send(null)}catch(n){s.jsfallback(e,t)}},lsloader.iocss=function(e,t,n,s){var a=this;try{var o=new XMLHttpRequest;o.open("get",e,!0),o.onreadystatechange=function(){if(4==o.readyState){if((200<=o.status&&o.status<300||304==o.status)&&""!=o.response)return n(o.response),void s();a.cssfallback(e,t,s)}},o.send(null)}catch(n){a.cssfallback(e,t,s)}},lsloader.iofonts=function(e,t,n,s){var a=this;try{var o=new XMLHttpRequest;o.open("get",e,!0),o.onreadystatechange=function(){if(4==o.readyState){if((200<=o.status&&o.status<300||304==o.status)&&""!=o.response)return n(o.response),void s();a.cssfallback(e,t,s)}},o.send(null)}catch(n){a.cssfallback(e,t,s)}},lsloader.runjs=function(e,t,n){if(t&&n)for(var s in this.jsRunSequence)this.jsRunSequence[s].name==t&&(this.jsRunSequence[s].code=n);if(this.jsRunSequence[0]&&this.jsRunSequence[0].code&&"failed"!=this.jsRunSequence[0].status)(a=document.createElement("script")).appendChild(document.createTextNode(this.jsRunSequence[0].code)),a.type="text/javascript",document.getElementsByTagName("head")[0].appendChild(a),this.jsRunSequence.shift(),0<this.jsRunSequence.length&&this.runjs();else if(this.jsRunSequence[0]&&"failed"==this.jsRunSequence[0].status){var a,o=this;(a=document.createElement("script")).src=this.jsRunSequence[0].path,a.type="text/javascript",this.jsRunSequence[0].status="loading",a.onload=function(){o.jsRunSequence.shift(),0<o.jsRunSequence.length&&o.runjs()},document.body.appendChild(a)}},lsloader.tagLoad=function(e,t){this.jsRunSequence.push({name:t,code:"",path:e,status:"failed"}),this.runjs()},lsloader.jsfallback=function(e,t){if(!this.jsnamemap[t]){for(var n in this.jsnamemap[t]=t,this.jsRunSequence)this.jsRunSequence[n].name==t&&(this.jsRunSequence[n].code="",this.jsRunSequence[n].status="failed",this.jsRunSequence[n].path=e);this.runjs()}},lsloader.cssfallback=function(e,t,n){if(!this.cssnamemap[t]){this.cssnamemap[t]=1;var s=document.createElement("link");s.type="text/css",s.href=e,s.rel="stylesheet",s.onload=s.onerror=n;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(s,a)}},lsloader.runInlineScript=function(e,t){var n=document.getElementById(t).innerText;this.jsRunSequence.push({name:e,code:n}),this.runjs()}</script><script>function Queue(){this.dataStore=[],this.offer=function(e){this.debug&&console.log("Offered a Queued Function."),"function"==typeof e?this.dataStore.push(e):console.log("You must offer a function.")},this.poll=function(){return this.debug&&console.log("Polled a Queued Function."),this.dataStore.shift()},this.execNext=function(){var e=this.poll();void 0!==e&&(this.debug&&console.log("Run a Queued Function."),e())},this.debug=!1,this.startDebug=function(){this.debug=!0}}var queue=new Queue</script><style id="material_css"></style><script>void 0===window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("material_css","https://cdn.wshunli.com/source/css/material.min.css",function(){void 0===window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style id="style_css"></style><script>void 0===window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("style_css","https://cdn.wshunli.com/source/css/style.min.css",function(){void 0===window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style id="prettify_css"></style><script>void 0===window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("prettify_css","https://cdn.wshunli.com/source/css/prettify.min.css",function(){void 0===window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style id="prettify_theme"></style><script>void 0===window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("prettify_theme","https://cdn.wshunli.com/source/css/prettify/github-v2.min.css",function(){void 0===window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><style>body,html{font-family:Roboto,"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;overflow-x:hidden!important}code{font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace}a{color:#409eff}#scheme-Paradox .hot_tags-count,#scheme-Paradox .sidebar-colored .sidebar-badge,#scheme-Paradox .sidebar-colored .sidebar-header,#scheme-Paradox .sidebar_archives-count,#search-form-label:after,#search-label,.mdl-card__media{background-color:#757575!important}#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus,#scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover{color:#757575!important}#ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a,#post_entry-right-info,.sidebar-colored .sidebar-nav li:hover>a,.sidebar-colored .sidebar-nav li:hover>a i,.sidebar-colored .sidebar-nav li>a:focus i,.sidebar-colored .sidebar-nav li>a:hover,.sidebar-colored .sidebar-nav li>a:hover i,.sidebar-colored .sidebar-nav>.open>a,.sidebar-colored .sidebar-nav>.open>a:focus,.sidebar-colored .sidebar-nav>.open>a:hover{color:#757575!important}.toTop{background:#757575!important}.material-layout .material-index>.material-nav,.material-layout .material-post>.material-nav,.material-nav a{color:#757575}#scheme-Paradox .MD-burger-layer{background-color:#757575}#scheme-Paradox #post-toc-trigger-btn{color:#757575}.post-toc a:hover{color:#409eff;text-decoration:underline}#post-content h1{font-size:1.75em;border-bottom:1px solid #ddd}#post-content h2{font-size:1.5em;border-bottom:1px solid #eee}#post-content h3{font-size:1.25em}#post-content h4{font-size:1em}#post-content h5{font-size:1em}#post-content h6{color:#777;font-size:1em}a{text-decoration:none;font-weight:500}#post-content a{text-decoration:none;font-weight:400}#post-content a:hover{text-decoration:underline}.mdl-card__media{background-color:#fff!important}.disqus_click_btn{margin:0 auto!important}#comment .veditor{font-size:1em;font-family:Roboto,"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif}#post-content table{width:100%;overflow:auto;display:table;border-spacing:0;border-collapse:collapse}</style><style>body{background-color:#f5f5f5}#scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{background-color:#fff}</style><style>.fade{transition:all .8s linear;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}.fade.out{opacity:0}</style><style>@font-face{font-family:Roboto;font-style:normal;font-weight:300;src:url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-300.eot);src:local('Roboto'),local('Roboto-Normal'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-300.eot?#iefix) format('embedded-opentype'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-300.woff2) format('woff2'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-300.woff) format('woff'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-300.ttf) format('truetype'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-300.svg#Roboto) format('svg')}@font-face{font-family:Roboto;font-style:normal;font-weight:regular;src:url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-regular.eot);src:local('Roboto'),local('Roboto-Normal'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-regular.eot?#iefix) format('embedded-opentype'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-regular.woff2) format('woff2'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-regular.woff) format('woff'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-regular.ttf) format('truetype'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-regular.svg#Roboto) format('svg')}@font-face{font-family:Roboto;font-style:normal;font-weight:500;src:url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-500.eot);src:local('Roboto'),local('Roboto-Normal'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-500.eot?#iefix) format('embedded-opentype'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-500.woff2) format('woff2'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-500.woff) format('woff'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-500.ttf) format('truetype'),url(https://lib.baomitu.com/fonts/roboto/roboto-v15-latin-500.svg#Roboto) format('svg')}</style><style id="material_icons"></style><script>void 0===window.lsLoadCSSMaxNums&&(window.lsLoadCSSMaxNums=0),window.lsLoadCSSMaxNums++,lsloader.load("material_icons","https://cdn.wshunli.com/source/css/material-icons.css",function(){void 0===window.lsLoadCSSNums&&(window.lsLoadCSSNums=0),window.lsLoadCSSNums++,window.lsLoadCSSNums==window.lsLoadCSSMaxNums&&(document.documentElement.style.display="")},!1)</script><script>lsloader.load("jq_js","https://cdn.wshunli.com/source/js/jquery.min.js",!0)</script><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="CirGIS 博客"><meta name="msapplication-starturl" content="https://www.wshunli.com/posts/850e5c53.html"><meta name="msapplication-navbutton-color" content="#606266"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CirGIS 博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="apple-touch-icon" href="/favicon.ico"><meta name="google-site-verification" content="JXtW4RzgvIKoQlyN4B8PC-gd2hm7yaZo7NnrGDZHFsM"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta property="og:url" content="https://www.wshunli.com/posts/850e5c53.html"><meta property="og:type" content="blog"><meta property="og:title" content="图解数据结构（Java语言实现） | CirGIS 博客"><meta property="og:image" content="/favicon.ico"><meta property="og:description" content="wshunli`s Blog!"><meta property="og:article:tag" content="Java"><meta property="og:article:tag" content="数据结构与算法"><meta property="og:article:tag" content="数据结构"><meta property="article:published_time" content="Wed Aug 29 2018 20:41:03 GMT+0800"><meta property="article:modified_time" content="Mon Jul 15 2019 02:19:08 GMT+0800"><meta name="twitter:card" content="summary_large_image"><link rel="canonical" href="https://www.wshunli.com/posts/850e5c53.html"><script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "https://www.wshunli.com/posts/850e5c53.html",
    "headline": "图解数据结构（Java语言实现）",
    "datePublished": "Wed Aug 29 2018 20:41:03 GMT+0800",
    "dateModified": "Mon Jul 15 2019 02:19:08 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "wshunli",
        "image": {
            "@type": "ImageObject",
            "url": "/img/wshunli.min.png"
        },
        "description": "深自缄默，如云漂泊"
    },
    "publisher": {
        "@type": "Organization",
        "name": "CirGIS 博客",
        "logo": {
            "@type":"ImageObject",
            "url": "/favicon.ico"
        }
    },
    "keywords": ",Java,数据结构与算法,数据结构wshunli CirGIS",
    "description": "wshunli`s Blog!",
}</script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-72210097-1","auto"),ga("send","pageview")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a5dd3121a832e079930d6bf385c5e806";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body id="scheme-Paradox" class="lazy"><div class="material-layout mdl-js-layout has-drawer is-upgraded"><main class="material-layout__content" id="main"><div id="top"></div><button class="MD-burger-icon sidebar-toggle"><span id="MD-burger-id" class="MD-burger-layer"></span></button> <button id="post-toc-trigger-btn" class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">format_list_numbered</i></button><ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh;overflow-y:scroll"><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#数组"><span class="post-toc-number">1.</span> <span class="post-toc-text">数组</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#链表"><span class="post-toc-number">2.</span> <span class="post-toc-text">链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单向链表"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">单向链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#环形链表"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">环形链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#双向链表"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">双向链表</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#堆栈"><span class="post-toc-number">3.</span> <span class="post-toc-text">堆栈</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆栈的数组实现"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">堆栈的数组实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆栈的链表实现"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">堆栈的链表实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆栈的应用"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">堆栈的应用</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#队列"><span class="post-toc-number">4.</span> <span class="post-toc-text">队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#队列的数组实现"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">队列的数组实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#队列的链表实现"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">队列的链表实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#树状结构"><span class="post-toc-number">5.</span> <span class="post-toc-text">树状结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉树"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">二叉树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉树的存储方式"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">二叉树的存储方式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉树的遍历"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">二叉树的遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#图形结构"><span class="post-toc-number">6.</span> <span class="post-toc-text">图形结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图形介绍"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">图形介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图形的表示法"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">图形的表示法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图形的遍历"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">图形的遍历</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#生成树"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">生成树</span></a></li></ol></li></ol></ul><div class="material-post_container"><div class="material-post mdl-grid"><div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col"><div class="post_thumbnail-custom mdl-card__media mdl-color-text--grey-50" style="background-image:url(https://img.wshunli.com/数据结构与算法/data-structures.min.png)"><p class="article-headline-p">图解数据结构（Java语言实现）</p></div><div class="mdl-color-text--grey-700 mdl-card__supporting-text meta"><div id="author-avatar"><img src="/img/wshunli.min.png" width="44px" height="44px" alt="Author Avatar"></div><div><strong>wshunli</strong> <span>8月 29, 2018</span></div><div class="section-spacer"></div><button id="article-functions-qrcode-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"><i class="material-icons" role="presentation">devices other</i> <span class="visuallyhidden">devices other</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-qrcode-button"><li class="mdl-menu__item">在其它设备中阅读本文章</li><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACYUlEQVR42u3aQW7DMAwEwPz/0+0DgrhLUlJcY3wqCjvS+GASK75+Hn298PDw8PDw8PDwbsZ7xdf7U++/8MfCrVXKT+Hh4eEd4SXbShb+dE/vpTT3hoeHh3eQ92m71/dc33+9oV75uV4LDw8P7/68ajnJ/4OHh4f3JF4vbri+s1dC8PDw8L7L6zXBvdj3+tV8LWvBw8PDi3n5ds//ffR8Dw8PDy/glUeaBtuttt0Lhq7w8PDwNvCqh1vJs9VGuTd0hYeHh3cfXvWDnsSs1cDi+tWMUmo8PDy8Rbz8sCrf0NoxrKQI4eHh4Z3kVQenqh/xSWHIRw3w8PDwzvDyhrj3VDViqP4aHh4e3nne/NhpEvJWn2pORuDh4eEt5eXtbLURz4tKr9hEYQQeHh7eZl4+KDBpxPOikscWeHh4eOd580gijxuSdavRBh4eHt4deNVWO1m+d0i2IIzAw8PDW8rrDTnl7XJvcCrfW3QAhoeHh7eUl3yyCx/lOIboBb4LYlw8PDy8Ma9XEqrNd7Vl7z2Lh4eHd5LXa7Lnh1jV6DZ6QXh4eHgHefPFdoS/5RYcDw8P7yCvepTVC3wnoUbzAAwPDw9vG68amPYGtqpDWuWRLzw8PLzNvOrVa6DzNjphNGfK8PDw8Bbx5h/lvP2dDFctmynDw8PDW8TLi0G+0d6owSTAxcPDwzvPq36gd8S41RK1bHQADw8PbzOvuXBQVHrDB3h4eHj/hZfj84GD/Bc2ttR4eHh4S8OIM6UiLwx4eHh43+JVP835sVY1/J0003h4eHhneM+78PDw8PDw8PDwbnD9Aun0H+uH6N2dAAAAAElFTkSuQmCC"></ul><button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"><i class="material-icons" role="presentation">bookmark</i> <span class="visuallyhidden">bookmark</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button"><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/Java/">Java</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/数据结构/">数据结构</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul><button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"><i class="material-icons" role="presentation">share</i> <span class="visuallyhidden">share</span></button><ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button"><a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=图解数据结构（Java语言实现）&url=https://www.wshunli.com/posts/850e5c53.html&pic=https://www.wshunli.com/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external nofollow noopener noreferrer"><li class="mdl-menu__item">分享到微博</li></a><a class="post_share-link" href="https://twitter.com/intent/tweet?text=图解数据结构（Java语言实现）&url=https://www.wshunli.com/posts/850e5c53.html&via=wshunli" target="_blank" rel="external nofollow noopener noreferrer"><li class="mdl-menu__item">分享到 Twitter</li></a><a class="post_share-link" href="https://telegram.me/share/url?url=https://www.wshunli.com/posts/850e5c53.html&text=图解数据结构（Java语言实现）" target="_blank" rel="external nofollow noopener noreferrer"><li class="mdl-menu__item">分享到 Telegram</li></a></ul></div><div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out"><p>数据结构与算法一直是比较薄弱的地方，不仅在面试的时候会问相关问题、手写代码，而且在笔试的时候发挥重要作用。</p><p>这次选择看的书籍是 《图解数据结构-使用Java》 ，先入门，后面再深入学习。</p><p>算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小 n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。</p><p>线性表是 n 个元素的有限序列（n &gt;= 0），是计算机科学中一种相当基础的数据结构。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组</strong> 其实是一排紧密相邻的可读内存，并提供一个能够 <strong>直接访问</strong> 单一数据内容的计算方法。</p><p>这样能够直接通过计算，并访问任一位置的数据，即所谓的数组的 <strong>随机读取</strong> 。</p><p>当 Java 数组声明时会在内存中分配一定的暂存空间，空间大小以数据类型和数组数量为依据。</p><p>一维数据、二维数组、三维数组、n 维数组。</p><p>数组可用于矩阵、多项式等的运算。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><strong>链表</strong> 是由许多相同数据类型的元素按照特定顺序排列而成的线性表，其在内存中是不连续与随机存储的。</p><p>这样就不能像数组那样随机读取数据，而要 <strong>按照顺序</strong> 找到所需数据。</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表是由节点组成，指针方向相同的链表。其中节点由数据字段和链接字段组成。</p><p>在 Java 中，声明节点：</p><pre><code class="lang-Java">public class Node {
    int data;
    Node next;
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}
</code></pre><p>而 Java 中没有指针的概念，我们声明两个对象分别指向第一个和最后一个节点：</p><pre><code class="lang-Java">public class LinkedList {
    private Node first;
    private Node last;
    ...
}
</code></pre><p>1、<strong>单向链表的创建</strong></p><p>下面创建简单单向链表类：</p><pre><code class="lang-Java">public class LinkedList {

    private Node first;
    private Node last;

    public boolean isEmpty() {
        return first == null;
    }
    public void insert(int data) {
        Node node = new Node(data);
        if (this.isEmpty()) {
            first = node;
            last = node;
        } else {
            last.next = node;
            last = node;
        }
    }
    public void print() {
        Node current = first;
        while (current != null) {
            System.out.println(&quot;current.data=&quot; + current.data);
            current = current.next;
        }
    }
}
</code></pre><p>然后实例化链表对象即可：</p><pre><code class="lang-Java">public class Main {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();
        linkedList.insert(99);
        linkedList.insert(90);
        linkedList.insert(95);
        linkedList.print();
    }
}
</code></pre><p>这样所有节点都知道下个节点在哪里，只要有首节点的存在，就可以对整个列表进行遍历、插入及删除节点等动作。</p><p>2、<strong>单向链表节点的删除</strong></p><p>将欲删除节点的前一个节点的指针指向欲删除节点的下一个节点即可。</p><p>如果删除 <strong>首节点</strong>，将首节点的下个节点设置为首节点；如果删除 <strong>末节点</strong>，将前一个节点指向 null 即可。</p><pre><code class="lang-Java">  public void delete(Node node) {
      Node newNode;
      Node temp;
      if (first.data == node.data) {
          first = first.next;
      } else if (last.data == node.data) {
          temp = first;
          while (temp.next != last) {
              temp = temp.next;
          }
          temp.next = last.next; // temp.next = null;
          last = temp; // 设置末节点
      } else {
          newNode = first;
          temp = first;
          while (temp.data != node.data) {
              newNode = temp;
              temp = temp.next;
          }
          newNode.next = temp.next;
      }
  }
</code></pre><p>这样删除有点弊端，根据 node 节点的值判断是否是同一节点，并且没有对节点是否存在做判断。</p><p>3、<strong>单向链表节点的添加</strong></p><p>添加节点和删除节点有点类似，将前一个节点指向新添加的节点，然后将新添加节点指向下一个节点即可。</p><p>如果添加为 <strong>首节点</strong> ，将欲添加节点指向首节点；如果添加为 <strong>末节点</strong> ，将原末节点指向新节点即可。</p><pre><code class="lang-Java">public void insert(Node node) {
    Node newNode;
    Node temp;
    if (node.next == first) {
        node.next = first;
        first = node;
    } else if (node.next == null) {
        last.next = node;
        node.next = null;
    } else {
        newNode = first;
        temp = first;
        while (node.next != newNode.next) {
            temp = newNode;
            newNode = newNode.next;
        }
        temp.next = node;
        node.next = newNode;
    }
}
</code></pre><p>这样在节点位置的判断上还是有弊端的。</p><p>4、<strong>单向链表的反转</strong></p><p>面试有时候会让手写这个代码。</p><p><strong>遍历法</strong>: 从链表头部开始，逐个反转节点。</p><pre><code class="lang-Java">public Node reverse(Node head) {

    if (head == null) return null;      // 空链表
    if (head.next == null) return head; // 一个元素的链表

    Node preNode = null;
    Node nowNode = head;

    while (nowNode != null) {
        Node nextNode = nowNode.next;   // 保存下一个结点
        nowNode.next = preNode;         // 当前结点指向前一个结点
        preNode = nowNode;              // 前任结点 到现任节点
        nowNode = nextNode;             // 现任节点到下一结点
    }
    return preNode;
}
</code></pre><p><strong>递归法</strong>：从链表尾部开始，逐个反转节点。</p><pre><code class="lang-Java">public Node reverse(Node node) {
    if (node == null || node.next == null) return node;
    Node headNode = reverse(node.next);
    node.next.next = node;
    node.next = null;
    return headNode;
}
</code></pre><p>以上算法都需要传入链表的头部节点，打印时需要注意头部和尾部节点引用。</p><p>5、<strong>单向链表的串联</strong></p><p>将列表的首位节点相连即可。</p><pre><code class="lang-Java">public LinkedList connect(LinkedList list1, LinkedList list2) {
    LinkedList list = list1;
//  while (list.last.next != null) {
//     list.last = list.last.next;
//  }
    list.last.next = list2.first;
    return list;
}
</code></pre><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>我们把单向链表的尾部指向头部，整个链表就成为单向环形结构。</p><p>这里创建链表、插入节点、删除节点、链表串联都很类似。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表基本结构和单项连链表类似，至少一个节点存放数据，另外它有两个字段存放指针。</p><h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><p>堆栈是一种抽象的数据结构：只能从堆栈的 <strong>顶端</strong> 访问数据；数据访问符合 <strong>后进先出</strong> 的原则。</p><h2 id="堆栈的数组实现"><a href="#堆栈的数组实现" class="headerlink" title="堆栈的数组实现"></a>堆栈的数组实现</h2><pre><code class="lang-Java">class StackByArray { //以数组模拟堆栈的类声明
    private int[] stack; //在类中声明数组
    private int top;  //指向堆栈顶端的索引

    //StackByArray类构造函数
    public StackByArray(int stack_size) {
        stack = new int[stack_size]; //建立数组
        top = -1;
    }
    //类方法：push
    //存放顶端数据，并更正新堆栈的内容
    public boolean push(int data) {
        if (top &gt;= stack.length) { //判断堆栈顶端的索引是否大于数组大小
            System.out.println(&quot;堆栈已满，无法再加入&quot;);
            return false;
        } else {
            stack[++top] = data; //将数据存入堆栈
            return true;
        }
    }
    //类方法：empty
    //判断堆栈是否为空堆栈，是则返回true，不是则返回false
    public boolean empty() {
        if (top == -1) return true;
        else return false;
    }
    //类方法：pop
    //从堆栈取出数据
    public int pop() {
        if (empty()) //判断堆栈是否为空，如果是则返回-1值
            return -1;
        else
            return stack[top--]; //先将数据取出后，再将堆栈指针往下移
    }
}
</code></pre><h2 id="堆栈的链表实现"><a href="#堆栈的链表实现" class="headerlink" title="堆栈的链表实现"></a>堆栈的链表实现</h2><pre><code class="lang-Java">class Node //链接节点的声明
{
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class StackByLink {
    public Node front; //指向堆栈底端的指针
    public Node rear;  //指向堆栈顶端的指针

    //类方法：isEmpty()
    //判断堆栈如果为空堆栈,则front==null;
    public boolean isEmpty() {
        return front == null;
    }

    //打印堆栈内容
    public void output_of_Stack() {
        Node current = front;
        while (current != null) {
            System.out.print(&quot;[&quot; + current.data + &quot;]&quot;);
            current = current.next;
        }
        System.out.println();
    }

    //在堆栈顶端加入数据
    public void insert(int data) {
        Node newNode = new Node(data);
        if (this.isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
    }

    //在堆栈顶端删除数据
    public void pop() {
        Node newNode;
        if (this.isEmpty()) {
            System.out.print(&quot;===目前为空堆栈===\n&quot;);
            return;
        }
        newNode = front;
        if (newNode == rear) {
            front = null;
            rear = null;
            System.out.print(&quot;===目前为空堆栈===\n&quot;);
        } else {
            while (newNode.next != rear)
                newNode = newNode.next;
            newNode.next = rear.next;
            rear = newNode;
        }
    }
}
</code></pre><h2 id="堆栈的应用"><a href="#堆栈的应用" class="headerlink" title="堆栈的应用"></a>堆栈的应用</h2><p>二叉树及森林的遍历；图形的深度优先遍历；递归程序的调用及返回等等。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种抽象的数据结构：只能从队列的 <strong>两端</strong> 访问数据；数据访问符合 <strong>先进先出</strong> 的原则。</p><h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><pre><code class="lang-Java">public class ArrayQueue {
    private int[] data;
    private int size;//元素个数
    private int front;//队列中第一个对象的位置
    private int rear;//队列中当前对象的位置

    public ArrayQueue() {
        data = new int[10];
        size = 0;
        front = 0;
        rear = 0;
    }

    public void add(int t) {
        if (isFull()) {
            resize();
            front = 0;
        }
        rear = (front + size) % data.length;
        System.out.println(rear);
        data[rear] = t;
        size++;
    }

    public int remove() {
        if (isEmpty()) {
            throw new RuntimeException(&quot;队列为空!&quot;);
        }
        int tempData = data[front];
        data[front] = 0;
        front = (front + 1) % (data.length);
        size--;
        return tempData;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == data.length;
    }

    public void resize() {
        /*注意重新扩容的时候并不需要去设置size
         * 队列的大小并不能通过数组的大小直观的显示出来。
         * 但是栈就可以直观的通过数组的大小显示出来*/
        int[] tmp = new int[data.length * 2];
        System.arraycopy(data, 0, tmp, 0, data.length);
        data = tmp;
        tmp = null;//引用置为空，便于gc处理  
    }
}
</code></pre><h2 id="队列的链表实现"><a href="#队列的链表实现" class="headerlink" title="队列的链表实现"></a>队列的链表实现</h2><pre><code class="lang-Java">class QueueNode                 // 队列节点类
{
    int data;                    // 节点数据
    QueueNode next;              // 指向下一个节点

    //构造函数
    public QueueNode(int data) {
        this.data = data;
        next = null;
    }
}

class Linked_List_Queue { //队列类
    public QueueNode front; //队列的前端指针
    public QueueNode rear;  //队列的尾端指针

    //构造函数
    public Linked_List_Queue() {
        front = null;
        rear = null;
    }

    //方法enqueue:队列数据的存入
    public boolean enqueue(int value) {
        QueueNode node = new QueueNode(value); //建立节点
        //检查是否为空队列
        if (rear == null)
            front = node; //新建立的节点成为第一个节点
        else
            rear.next = node; //将节点加入到队列的尾端
        rear = node; //将队列的尾端指针指向新加入的节点
        return true;
    }

    //方法dequeue:队列数据的取出
    public int dequeue() {
        int value;
        //检查队列是否为空队列
        if (!(front == null)) {
            if (front == rear) rear = null;
            value = front.data; //将队列数据取出
            front = front.next; //将队列的前端指针指向下一个
            return value;
        } else return -1;
    }
} //队列类声明结束
</code></pre><p>环形队列、优先队列、双向队列</p><h1 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h1><p>树是一种用来表述有 <strong>分支</strong> 的数据结构，是由一个或者一个以上的节点组成的有限集合。</p><p><strong>树的专有名词</strong>：</p><p>结点度：结点子树的个数；树的度：树中最大的结点度。</p><p>叶子节点：没有子节点的节点，即度为 0 的节点。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树最多有两个子节点，即度 &lt;= 2 的树。</p><p><strong>特殊的二叉树</strong>：</p><p>1、满二叉树，树的高度为 h 树的节点为 $2^h-1$ 我们称为满二叉树。</p><p>2、完全二叉树，树的高度为 h 树的节点小于 $2^h-1$ ，但是其节点和满二叉树从左到右，从上到下的顺序一一对应。</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/二叉树-特殊的二叉树.png" alt="特殊的二叉树"></p><p>3、歪二叉树，当一个二叉树完全没有右节点/左节点时。</p><p>4、严格二叉树，每个二叉树都有非空的左右子树。成为严格二叉树。</p><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p>1、<strong>数组表示法</strong></p><p>首先将二叉树想象为满二叉树，然后依次存放入数组中，空位为 null 即可。</p><blockquote><p>以数组建立二叉树，要求小于父节点的值放在左子节点，反之放在右边。</p></blockquote><pre><code class="lang-Java">public class CH06_01 {
    public static void main(String args[]) throws IOException
    {
        int i, level;
        int data[] = {6, 3, 5, 9, 7, 8, 4, 2}; /*原始数组*/
        int btree[] = new int[16];
        for (i = 0; i &lt; 16; i++) btree[i] = 0;
        System.out.print(&quot;原始数组内容: \n&quot;);
        for (i = 0; i &lt; 8; i++)
            System.out.print(&quot;[&quot; + data[i] + &quot;] &quot;);
        System.out.println();
        for (i = 0; i &lt; 8; i++)                    /*把原始数组中的值逐一对比*/ {
            for (level = 1; btree[level] != 0; )   /*比较树根及数组内的值*/ {
                if (data[i] &gt; btree[level])        /*如果数组内的值大于树根，则往右子树比较*/
                    level = level * 2 + 1;
                else                               /*如果数组内的值小于或等于树根，则往左子树比较*/
                    level = level * 2;
            }                                      /*如果子树节点的值不为0，则再与数组内的值比较一次*/
            btree[level] = data[i];                /*把数组值放入二叉树*/
        }
        System.out.print(&quot;二叉树内容：\n&quot;);
        for (i = 1; i &lt; 16; i++)
            System.out.print(&quot;[&quot; + btree[i] + &quot;] &quot;);
        System.out.print(&quot;\n&quot;);
    }
}
</code></pre><p>2、链表表示法</p><p>二叉链表结构主要由一个数据域和两个分别指向左、右孩子的结点组成，其结构如下：</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/二叉树-链表表示法.png" alt="链表表示法"></p><p>TreeNode 及 BinaryTree 声明如下：</p><pre><code class="lang-Java">class TreeNode {
    int value;
    TreeNode left_Node;
    TreeNode right_Node;
    // TreeNode构造函数
    public TreeNode(int value) {
        this.value = value;
        this.left_Node = null;
        this.right_Node = null;
    }
}
//二叉树类声明
class BinaryTree {
    public TreeNode rootNode; //二叉树的根节点

    //构造函数:利用传入一个数组的参数来建立二叉树
    public BinaryTree(int[] data) {
        for (int i = 0; i &lt; data.length; i++)
            Add_Node_To_Tree(data[i]);
    }

    //将指定的值加入到二叉树中适当的节点
    void Add_Node_To_Tree(int value) {
        TreeNode currentNode = rootNode;
        if (rootNode == null) { //建立树根
            rootNode = new TreeNode(value);
            return;
        }
        //建立二叉树
        while (true) {
            if (value &lt; currentNode.value) { //在左子树
                if (currentNode.left_Node == null) {
                    currentNode.left_Node = new TreeNode(value);
                    return;
                } else currentNode = currentNode.left_Node;
            } else { //在右子树
                if (currentNode.right_Node == null) {
                    currentNode.right_Node = new TreeNode(value);
                    return;
                } else currentNode = currentNode.right_Node;
            }
        }
    }
}
</code></pre><p>这样增删很容易，但是不容易找到父节点，除非增加字段。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历：即“访问树中所有节点各一次”。按照二叉树特性，一律从左向右。</p><p>根据访问根节点的顺序，二叉树的遍历规则主要有四种，先根次序遍历，中根次序遍历，后根次序遍历以及层次遍历。</p><pre><code class="lang-Java">// 中序遍历
public void InOrder(TreeNode node) {
    if (node != null) {
        InOrder(node.left_Node);
        System.out.print(&quot;[&quot; + node.value + &quot;] &quot;);
        InOrder(node.right_Node);
    }
}
// 前序遍历
public void PreOrder(TreeNode node) {
    if (node != null) {
        System.out.print(&quot;[&quot; + node.value + &quot;] &quot;);
        PreOrder(node.left_Node);
        PreOrder(node.right_Node);
    }
}
// 后序遍历
public void PostOrder(TreeNode node) {
    if (node != null) {
        PostOrder(node.left_Node);
        PostOrder(node.right_Node);
        System.out.print(&quot;[&quot; + node.value + &quot;] &quot;);
    }
}
</code></pre><h1 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h1><p>图形结构是用来探讨两个顶点间是否相连的关系图，若在边上加权值，这类图成为“网络”。</p><h2 id="图形介绍"><a href="#图形介绍" class="headerlink" title="图形介绍"></a>图形介绍</h2><p>图形有两种：有向图、无向图。</p><p>图形的专业术语：</p><p>度：一个顶点所拥有边的总数。<br>入/出度：在有向图中，定点为箭头终点的边的个数为入度；出度为起点边的个数。</p><h2 id="图形的表示法"><a href="#图形的表示法" class="headerlink" title="图形的表示法"></a>图形的表示法</h2><p>1、邻接矩阵法/相邻表法</p><p>2、相邻多元列表法/索引表格法</p><h2 id="图形的遍历"><a href="#图形的遍历" class="headerlink" title="图形的遍历"></a>图形的遍历</h2><p>图形的遍历方法有两种：深度优先遍历、广度优先遍历。</p><p>1、深度优先使用递归与 <strong>堆栈</strong> 的技巧</p><p>从图形的某一顶点开始遍历，被访问过的顶点就做上已访问的记号，接着遍历此顶点的所有相邻且未访问过的顶点中的任意一个顶点，并做上已访问的记号，再以该点为新的起点继续进行先深后广的搜索。</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/图形-图的遍历.png" alt="图形-图的遍历"></p><p>（1）从起点 1 开始，将相邻的 2 3 放入堆栈</p><p>3 2</p><p>（2）将 2 取出，并将与 2 相邻且未访问的 4 5 放入堆栈</p><p>3 5 4</p><p>（3）将 4 取出，并将与 4 相邻且未访问的 8 放入堆栈</p><p>3 5 8</p><p>（4）将 8 取出，并将与 8 相邻且未访问的 5 放入堆栈</p><p>3 5 5</p><p>（5）将 5 取出，发现与 5 相邻的节点都访问过了，这里就舍去</p><p>3</p><p>（6）将 3 取出，并将与 3 相邻且未访问的 6 7 放入堆栈</p><p>7 6</p><p>（7）最后将堆栈的节点逐个判断即可。</p><p>7 7</p><p>最终遍历顺序为：1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7</p><pre><code class="lang-Java">public static void dfs(int current)
{
    run[current] = 1;
    System.out.print(&quot;[&quot; + current + &quot;]&quot;);

    while ((Head[current].first) != null) {
        if (run[Head[current].first.x] == 0) //如果顶点尚未遍历，就进行dfs的递归调用
            dfs(Head[current].first.x);
        Head[current].first = Head[current].first.next;
    }
}
</code></pre><p>2、广度优先使用递归与 <strong>队列</strong> 的技巧</p><p>从图形的某顶点开始遍历，被访问过的顶点就做上已访问的记号，接着遍历此顶点的所有相邻且未访问过的顶点中的任意个顶点，并做上已访问的记号，再以该点为新的起点继续进行先广后深的搜索。</p><p><img src="https://img.wshunli.com/数据结构与算法/图解数据结构/图形-图的遍历.png" alt="图形-图的遍历"></p><p>（1）从起点 1 开始，将相邻的 2 3 放入堆栈</p><p>2 3</p><p>（2）将 2 取出，并将与 2 相邻且未访问的 4 5 放入堆栈</p><p>3 4 5</p><p>（3）将 3 取出，并将与 3 相邻且未访问的 6 7 放入堆栈</p><p>4 5 6 7</p><p>（4）将 4 取出，并将与 4 相邻且未访问的 8 放入堆栈</p><p>5 6 7 8</p><p>（5）将 5 取出，并将与 5 相邻且未访问的 8 放入堆栈</p><p>6 7 8 8</p><p>（6）将 6 取出，并将与 6 相邻且未访问的 7 放入堆栈</p><p>7 8 8 7</p><p>（7）将 7 取出，发现与 7 相邻的节点都访问过了，这里就舍去</p><p>8 8 7</p><p>（8）最后将队列的节点逐个判断即可。</p><p>8 7</p><p>最终遍历顺序为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8</p><pre><code class="lang-Java">public void bfs(int current) {
    Node tempnode; //临时的节点指针
    enqueue(current); //将第一个顶点存入队列
    run[current] = 1; //将遍历过的顶点设定为1
    System.out.print(&quot;[&quot; + current + &quot;]&quot;); //打印该遍历过的顶点
    while (front != rear) { //判断目前是否为空队列
        current = dequeue(); //将顶点从队列中取出
        tempnode = Head[current].first; //先记录目前顶点的位置
        while (tempnode != null) {
            if (run[tempnode.x] == 0) {
                enqueue(tempnode.x);
                run[tempnode.x] = 1; //记录已遍历过
                System.out.print(&quot;[&quot; + tempnode.x + &quot;]&quot;);
            }
            tempnode = tempnode.next;
        }
    }
}
</code></pre><h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>一个图形的生成树以最少的边来连接图形中所有的顶点，且不造成回路(Cycle)的树状结构。</p><p>深度优先生成树、广度优先生成树。</p><p>MST 生成树，即在加权图（网络）上，计算路径成本最小的的生成树。有 Peim 算法和 Kruskal 算法等。</p><blockquote><p>前面一直学习的数据结构，下面排序、查找属于算法的范畴了。</p></blockquote><p>数据结构：<a href="https://www.wshunli.com/posts/850e5c53.html">https://www.wshunli.com/posts/850e5c53.html</a><br>算法：<a href="https://www.wshunli.com/posts/444e2c0f.html">https://www.wshunli.com/posts/444e2c0f.html</a></p><blockquote><p>参考资料<br>1、《图解数据结构-使用Java》<br>2、（数据结构）十分钟搞定时间复杂度（算法的时间复杂度） - 简书<br><a href="https://www.jianshu.com/p/f4cca5ce055a" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/f4cca5ce055a</a><br>3、单链表反转的两种实现（Java） - CSDN博客<br><a href="https://blog.csdn.net/acquaintanceship/article/details/73011169" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/acquaintanceship/article/details/73011169</a><br>4、data structures - Reversing a linked list in Java, recursively - Stack Overflow<br><a href="https://stackoverflow.com/questions/354875/reversing-a-linked-list-in-java-recursively" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/354875/reversing-a-linked-list-in-java-recursively</a><br>5、【算法】如何判断链表有环 - CSDN博客<br><a href="https://blog.csdn.net/u010983881/article/details/78896293" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/u010983881/article/details/78896293</a><br>6、队列的实现(JAVA) - CSDN博客<br><a href="https://blog.csdn.net/lcore/article/details/8868078" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lcore/article/details/8868078</a><br>7、树和二叉树定义、基本术语和性质 - CSDN博客<br><a href="https://blog.csdn.net/lsh_2013/article/details/43121373" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/lsh_2013/article/details/43121373</a><br>8、java数据结构与算法之树基本概念及二叉树（BinaryTree）的设计与实现 - CSDN博客<br><a href="https://blog.csdn.net/javazejian/article/details/53727333" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/javazejian/article/details/53727333</a><br>9、data structures - Difference between “Complete binary tree”, “strict binary tree”,”full binary Tree”? - Stack Overflow<br><a href="https://stackoverflow.com/questions/12359660/difference-between-complete-binary-tree-strict-binary-tree-full-binary-tre" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/12359660/difference-between-complete-binary-tree-strict-binary-tree-full-binary-tre</a><br>10、数据结构 - 图的基本术语 - CSDN博客<br><a href="https://blog.csdn.net/wangzi11322/article/details/45417081" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/wangzi11322/article/details/45417081</a><br>11、《图论》——图的存储与遍历（Java） - CSDN博客<br><a href="https://blog.csdn.net/Gamer_gyt/article/details/51498546" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/Gamer_gyt/article/details/51498546</a><br>12、Java 与图 - 简书<br><a href="https://www.jianshu.com/p/a47a147ec92c" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/a47a147ec92c</a><br>13、DFS（深度优先搜索）和BFS(广度优先搜索) - 简书<br><a href="https://www.jianshu.com/p/b086986969e6" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b086986969e6</a></p></blockquote><blockquote style="margin:2em 0 0;padding:.5em 1em;border-left:3px solid #f44336;background-color:#f5f5f5;list-style:none"><p><strong>如果本文对您有所帮助，且您手头还很宽裕，欢迎打赏赞助我，以支付网站服务器和域名费用。 <img src="https://cdn.wshunli.com/about/pay_alpha.min.png" title="您的鼓励与支持，我会铭记于心，倾于博客。" alt="https://paypal.me/wshunli"> 您的鼓励与支持是我更新的最大动力，我会铭记于心，倾于博客。</strong><br><strong>本文链接：</strong><a href="https://www.wshunli.com/posts/850e5c53.html">https://www.wshunli.com/posts/850e5c53.html</a></p></blockquote></div><div id="comment" style="padding:10px" class="vcomment"></div><script src="https://cdn.wshunli.com/source/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(i){return-1<GUEST_INFO.indexOf(i)}),notify=!1,verify=!1;new Valine({el:".vcomment",notify:notify,verify:verify,appId:"UiDq9ewdNKCHGJQyYrTFiohg-gzGzoHsz",appKey:"cuNKDo2T90xY7IjfGh21RMoQ",placeholder:"念念不忘，必有回响",pageSize:"10",avatar:"mp",lang:"zh-cn",guest_info:guest_info})</script></div><nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col"><a href="/posts/444e2c0f.html" id="post_nav-newer" class="prev-content"><button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation"><i class="material-icons">arrow_back</i></button> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新篇</a><div class="section-spacer"></div><a href="/posts/22a0081c.html" id="post_nav-older" class="next-content">旧篇 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation"><i class="material-icons">arrow_forward</i></button></a></nav></div></div><div class="sidebar-overlay"></div><aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation"><div id="sidebar-main"><div class="sidebar-header header-cover" style="background-image:url(https://cdn.wshunli.com/source/img/snow_square_tiny.png)"><div class="top-bar"></div><button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display:initial" data-upgraded=",MaterialButton,MaterialRipple"><i class="material-icons">clear_all</i> <span class="mdl-button__ripple-container"><span class="mdl-ripple"></span></span></button><div class="sidebar-image"><img src="/img/wshunli.min.png" alt="wshunli's avatar"></div><a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">admin@mail.wshunli.com <b class="caret"></b></a></div><ul class="nav sidebar-nav"><li class="dropdown"><ul id="settings-dropdown" class="dropdown-menu"><li><a href="mailto:admin@mail.wshunli.com" target="_blank" title="Email Me" rel="external nofollow noopener noreferrer"><i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i> Email Me</a></li></ul></li><li id="sidebar-first-li"><a href="/"><i class="material-icons sidebar-material-icons">home</i> 主页</a></li><li class="dropdown"><a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown"><i class="material-icons sidebar-material-icons">inbox</i> 归档 <b class="caret"></b></a><ul class="dropdown-menu"><li><a class="sidebar_archives-link" href="/archives/2019/06/">六月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/01/">一月 2019<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/12/">十二月 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/11/">十一月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/10/">十月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/09/">九月 2018<span class="sidebar_archives-count">20</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/08/">八月 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/07/">七月 2018<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/06/">六月 2018<span class="sidebar_archives-count">20</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/05/">五月 2018<span class="sidebar_archives-count">9</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/04/">四月 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/03/">三月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/01/">一月 2018<span class="sidebar_archives-count">11</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/12/">十二月 2017<span class="sidebar_archives-count">12</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/11/">十一月 2017<span class="sidebar_archives-count">20</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/10/">十月 2017<span class="sidebar_archives-count">9</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/09/">九月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/08/">八月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/07/">七月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/03/">三月 2017<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/02/">二月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/05/">五月 2016<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/04/">四月 2016<span class="sidebar_archives-count">8</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/03/">三月 2016<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/02/">二月 2016<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2016/01/">一月 2016<span class="sidebar_archives-count">13</span></a></li><li><a class="sidebar_archives-link" href="/archives/2015/12/">十二月 2015<span class="sidebar_archives-count">2</span></a></li></ul></li><li class="dropdown"><a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown"><i class="material-icons sidebar-material-icons">chrome_reader_mode</i> 分类 <b class="caret"></b></a><ul class="dropdown-menu"><li><a class="sidebar_archives-link" href="/categories/三维技术/">三维技术<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/categories/前端技术/">前端技术<span class="sidebar_archives-count">18</span></a></li><li><a class="sidebar_archives-link" href="/categories/博客维护/">博客维护<span class="sidebar_archives-count">10</span></a></li><li><a class="sidebar_archives-link" href="/categories/后端技术/">后端技术<span class="sidebar_archives-count">7</span></a></li><li><a class="sidebar_archives-link" href="/categories/持续集成/">持续集成<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/categories/数据结构与算法/">数据结构与算法<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/沉迷学术/">沉迷学术<span class="sidebar_archives-count">14</span></a></li><li><a class="sidebar_archives-link" href="/categories/源码解析/">源码解析<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/categories/瞎推荐/">瞎推荐<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/categories/移动GIS技术/">移动GIS技术<span class="sidebar_archives-count">14</span></a></li><li><a class="sidebar_archives-link" href="/categories/移动端技术/">移动端技术<span class="sidebar_archives-count">27</span></a></li><li><a class="sidebar_archives-link" href="/categories/计算机基础/">计算机基础<span class="sidebar_archives-count">8</span></a></li><li><a class="sidebar_archives-link" href="/categories/设计模式/">设计模式<span class="sidebar_archives-count">15</span></a></li><li><a class="sidebar_archives-link" href="/categories/语言基础/">语言基础<span class="sidebar_archives-count">17</span></a></li><li><a class="sidebar_archives-link" href="/categories/跨平台技术/">跨平台技术<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/categories/软件操作/">软件操作<span class="sidebar_archives-count">13</span></a></li></ul></li><li class="divider"></li><li><a href="/tags" title="标签云">标签云</a></li><li><a href="/timeline" title="时间轴">时间轴</a></li><li><a href="/books" title="我的阅读">我的阅读</a></li><li><a href="/zzupic" title="郑州大学">郑州大学</a></li><li><a href="/whupic" title="武汉大学">武汉大学</a></li><li><a href="/links" title="友情链接">友情链接</a></li><li><a href="/about" title="关于本站">关于本站</a></li><li class="divider"></li><li><a href="/archives">文章总数 <span class="sidebar-badge">168</span></a></li></ul></div></aside><div id="back-to-top" class="toTop-wrap"><a href="#top" class="toTop"><i class="material-icons footer_top-i">expand_less</i></a></div><footer class="mdl-mini-footer" id="bottom"><div class="mdl-mini-footer--left-section sns-list"><a href="https://twitter.com/wshunlime" target="_blank" rel="external nofollow noopener noreferrer"><button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter"><span class="visuallyhidden">Twitter</span></button></a><a href="https://facebook.com/wshunlime" target="_blank" rel="external nofollow noopener noreferrer"><button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook"><span class="visuallyhidden">Facebook</span></button></a><a href="https://weibo.com/wshunli" target="_blank" rel="external nofollow noopener noreferrer"><button class="mdl-mini-footer--social-btn social-btn footer-sns-weibo"><span class="visuallyhidden">Weibo</span></button></a><a href="https://github.com/wshunli" target="_blank" rel="external nofollow noopener noreferrer"><button class="mdl-mini-footer--social-btn social-btn footer-sns-github"><span class="visuallyhidden">Github</span></button></a><a href="https://t.me/wshunli" target="_blank" rel="external nofollow noopener noreferrer"><button class="mdl-mini-footer--social-btn social-btn footer-sns-telegram"><span class="visuallyhidden">Telegram</span></button></a></div><div id="copyright">Copyright&nbsp;©&nbsp;<span year></span>&nbsp;CirGIS 博客<br><div>Hosted by <a class="footer-develop-a" href="https://coding.net/register?key=IBFMJ9" title="托管于 Coding Pages" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a>. CDN by <a class="footer-develop-a" href="https://console.upyun.com/register/?invite=H1_D-bC4W" title="又拍云提供 CDN 服务" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdn.wshunli.com/source/img/upyun_logo.min.svg" style="width:44px;height:16px"> </a>.</div><div><a class="footer-develop-a" href="http://www.miitbeian.gov.cn/" rel="external nofollow noopener noreferrer" target="_blank">豫ICP备17022065号-1</a></div></div><div class="mdl-mini-footer--right-section"><div><div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a></div><div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Material</a></div></div></div></footer><script>lsloader.load("lazyload_js","https://cdn.wshunli.com/source/js/lazyload.min.js",!0)</script><script>lsloader.load("js_js","https://cdn.wshunli.com/source/js/js.min.js",!0)</script><script>lsloader.load("np_js","https://cdn.wshunli.com/source/js/nprogress.js",!0)</script><script type="text/ls-javascript" id="NProgress-script">NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#909399'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #909399, 0 0 15px #909399'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#909399',
        'border-left-color': '#909399'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);</script><script>lsloader.load("sm_js","https://cdn.wshunli.com/source/js/smoothscroll.js",!0)</script><script>var agent=navigator.userAgent.toLowerCase();0<agent.indexOf("ucbrowser")&&(document.write('<link rel="stylesheet" href="/css/uc.css">'),alert("由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。"))</script><script>lsloader.load("prettify_js","https://cdn.wshunli.com/source/js/prettify.min.js",!0)</script><script type="text/ls-javascript" id="window-load">$(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                // 影响 hexo-tag-demo 代码高亮
                $('.demobox-code-wrap pre').removeClass('linenums');
                prettyPrint();
                })</script><script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });</script><script src="https://cdn.wshunli.com/MathJax-2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/ls-javascript" id="lazy-load">// Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });</script><script>!function(e,t,n,a,c,i,o,d,s){d=function(){i=t.createElement(n),o=t.getElementsByTagName(n)[0],i.src="//widget.seniverse.com/widget/chameleon.js",i.charset="utf-8",i.async=1,o.parentNode.insertBefore(i,o)},e.ThinkPageWeatherWidgetObject=a,e[a]||(e[a]=function(){(e[a].q=e[a].q||[]).push(arguments)}),e[a].l=+new Date,e.attachEvent?e.attachEvent("onload",d):e.addEventListener("load",d,!1)}(window,document,"script","tpwidget")</script><script>function checkMobile(){return null==navigator.userAgent.match(/iPad/i)&&!(null==navigator.userAgent.match(/iphone|android|phone|mobile|wap|netfront|x11|java|opera mobi|opera mini|ucweb|windows ce|symbian|symbianos|series|webos|sony|blackberry|dopod|nokia|samsung|palmsource|xda|pieplus|meizu|midp|cldc|motorola|foma|docomo|up.browser|up.link|blazer|helio|hosin|huawei|novarra|coolpad|webos|techfaith|palmsource|alcatel|amoi|ktouch|nexian|ericsson|philips|sagem|wellcom|bunjalloo|maui|smartphone|iemobile|spice|bird|zte-|longcos|pantech|gionee|portalmmm|jig browser|hiptop|benq|haier|^lct|320x320|240x320|176x220/i))}checkMobile()||(tpwidget("init",{flavor:"bubble",location:"WW1CZDQBHSR6",geolocation:"enabled",position:"top-right",margin:"10px 10px",language:"zh-chs",unit:"c",theme:"chameleon",uid:"UBF84BD5E3",hash:"6e08d5d8c3aa65f452e1df6dd7785680"}),tpwidget("show"))</script><script>var copyrightNow=(new Date).getFullYear(),textContent=document.querySelector("span[year]");copyrightSince=2015,copyrightSince===copyrightNow||0===copyrightSince?textContent.textContent=copyrightNow:textContent.textContent=copyrightSince+" - "+copyrightNow,function(){for(var t=document.querySelectorAll('script[type="text/ls-javascript"]'),e=0;e<t.length;++e){var o=t[e];lsloader.runInlineScript(o.id,o.id)}}(),console.log("\n %c © Material Theme | Version: 1.5.5 | https://github.com/viosey/hexo-theme-material %c \n","color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;","color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;")</script></main></div><script src="https://cdn.wshunli.com/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"https://cdn.wshunli.com/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":90,"height":180,"hOffset":25,"vOffset":50},"mobile":{"show":false}});</script></body></html>