<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》读书笔记（四）]]></title>
    <url>%2Fposts%2F228afe2f.html</url>
    <content type="text"><![CDATA[《JavaScript高级程序设计》读书笔记(四) 学习在浏览器中进行实际开发时的错误调试技巧。(17章)第十七章 错误处理与调试错误处理try-catch 语句：try-catch 语句 和 Java 很类似。function testFinally(){ try { return 2; } catch (error){ return 1; } finally { return 0; } } function testWithoutFinally(){ try { return 2; } catch (error){ return 1; } } alert(testFinally()); alert(testWithoutFinally()); 我们把可能会抛出错误的语句放到 try 语句中，处理错误的代码放到 catch 块中，finally 语句块无论如何都会执行。抛出错误：与 try-catch 语句相配的还有一个 throw 操作符，用于随时抛出自定义错误 。在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时，代码才回继续执行。if (!(values instanceof Array)){ throw new Error(&quot;process(): Argument must be an array.&quot;); } 捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。常见的错误类型：类型转换错误、数据类型错误、通信错误。调试技术将消息记录到控制台：通过 console 对象向 JavaScript 控制台中写入消息。error(message): 将错误消息记录到控制台info(message): 将信息性消息记录到控制台log(message): 将一般消息记录到控制台warn(message): 将警告消息记录到控制台将消息记录到当前页面：在页面中开辟一小块区域，用以显示消息。抛出错误：自定义 assert() 函数。两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。function assert(condition, message){ if (!condition){ throw new Error(message); } } function divide(num1, num2){ assert(typeof num1 == &quot;number&quot; &amp;&amp; typeof num2 == &quot;number&quot;, &quot;divide(): Both arguments must be numbers.&quot;); return num1 / num2; } var result = divide(10, 23); result = divide(&quot;hi&quot;, 3);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
        <tag>JavaScript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》读书笔记（三）]]></title>
    <url>%2Fposts%2F95a7e74a.html</url>
    <content type="text"><![CDATA[《JavaScript高级程序设计》读书笔记学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。(15-16章)第十五章 使用 Canvas 绘图基本用法使用 &lt;canves&gt; 元素；指定 width 和 height 属性。&lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;Your browser doesn&#39;t support canvas&lt;/canvas&gt; 要在画布上绘制，还需取得绘图上下文。var drawing = document.getElementById(&quot;drawing&quot;), //make sure &lt;canvas&gt; is completely supported if (drawing.getContext){ var context = drawing.getContext(&quot;2d&quot;); } 2D 上下文填充和描边：2D 上下文的两种基本绘图操作。fillStyle 属性（填充）：指定的样式（颜色、渐变或图像）填充图形；strokeStyle 属性（描边）：只在图形边缘画线。绘制矩形：矩形是唯一一种可以直接在 2D上下文中绘制的形状。与矩形有关的方法包括fillRect()、strokeRect和clearRect()。这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形的宽度和矩形高度。Your browser doesn&apos;t support the canvas tag.!function(){var t=document.getElementById("drawing");if(t.getContext){var e=t.getContext("2d");e.fillStyle="#ff0000",e.fillRect(10,10,50,50),e.strokeStyle="rgba(0,0,255,0.5)",e.strokeRect(30,30,50,50),e.clearRect(40,40,10,10)}}()&#x7ED8;&#x5236;&#x77E9;&#x5F62;html1&lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;Your browser doesn&apos;t support the canvas tag.&lt;/canvas&gt;javascript123456789var drawing = document.getElementById(&quot;drawing&quot;);if (drawing.getContext){ var context = drawing.getContext(&quot;2d&quot;); context.fillStyle = &quot;#ff0000&quot;; context.fillRect(10, 10, 50, 50); context.strokeStyle = &quot;rgba(0,0,255,0.5)&quot;; context.strokeRect(30, 30, 50, 50); context.clearRect(40,40,10,10);}绘制路径：首先调用 beginPath() 方法；然后调用一下方法：arc(x,y,radius,startAngle,endAngle,bool);arcTo(x1,y1,x2,y2,radius);lineTo(x,y);moveTo(x,y);rect(x,y,w,h);最后调用 closePath() 方法。绘制文本：fillText(str, x, y, width);strokeText(str, x, y, width)。Your browser doesn&apos;t support the canvas tag.!function(){var t=document.getElementById("drawing2");if(t.getContext){var e=t.getContext("2d");e.beginPath(),e.arc(100,100,99,0,2*Math.PI,!1),e.moveTo(194,100),e.arc(100,100,94,0,2*Math.PI,!1),e.moveTo(100,100),e.lineTo(100,15),e.moveTo(100,100),e.lineTo(35,100),e.stroke(),e.strokeText?(e.font="bold 14px Arial",e.textAlign="center",e.textBaseline="middle",e.fillText("12",100,20),e.textAlign="start",e.fillText("12",100,40),e.textAlign="end",e.fillText("12",100,60)):console.log("Your browser doesn't support the canvas text API.")}}()&#x7ED8;&#x5236;&#x8DEF;&#x5F84;&#x548C;&#x6587;&#x672C;html1&lt;canvas id=&quot;drawing2&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;Your browser doesn&apos;t support the canvas tag.&lt;/canvas&gt;javascript12345678910111213141516171819202122232425var drawing = document.getElementById(&quot;drawing2&quot;);if (drawing.getContext){ var context = drawing.getContext(&quot;2d&quot;); context.beginPath(); context.arc(100, 100, 99, 0, 2 * Math.PI, false); context.moveTo(194, 100); context.arc(100, 100, 94, 0, 2 * Math.PI, false); context.moveTo(100,100); context.lineTo(100, 15); context.moveTo(100, 100); context.lineTo(35, 100); context.stroke(); if (context.strokeText){ context.font = &quot;bold 14px Arial&quot;; context.textAlign = &quot;center&quot;; context.textBaseline = &quot;middle&quot;; context.fillText(&quot;12&quot;, 100, 20); context.textAlign = &quot;start&quot;; context.fillText(&quot;12&quot;, 100, 40); context.textAlign = &quot;end&quot;; context.fillText(&quot;12&quot;, 100, 60); } else { console.log(&quot;Your browser doesn&apos;t support the canvas text API.&quot;); }}变换：rotate(angle): 围绕原点旋转图像angle角度。scale(scaleX, scaleY): 缩放图像。translate(x,y)：将坐标原点移到（x,y）。阴影：shadowColor()shadowOffsetX:x方向的阴影偏移量。shadowOffsetY:y方向的阴影偏移量。shadowBlur:模糊的像素数，默认为0不模糊。渐变：渐变由 CanvasGradient 实例表示。线性渐变：createLinearGradient(x1,y1,x2,y2);var gradient = context.createLinearGradient(30,30,70,70); gradient.addColorStop(0,&quot;orange&quot;); gradient.addColorStop(1, &quot;blue&quot;); context.fillStyle = gradient; context.fillRect(30, 30,70,70); 径向渐变：createRadialGradient(x1,y1,r1,x2,y2,r2);var gra = context.createRadialGradient(55,55,10,55,55,30); gra.addColorStop(0, &quot;blue&quot;); gra.addColorStop(1, &quot;orange&quot;); context.fillStyle = gra; context.fillRect(30,30,50,50); 模式：模式就是重复的图像，可以用来填充或描边图形。createPattern(img, str);img： 表示一个 HTML 的 img 元素；str： 可取值 “repeat”、“repeat-x”、“repeat-y”和“no-repeat”。var img = document.images[0]; var pattern = context.createPattern(img, &quot;repeat&quot;); context.fillStyle = pattern; context.fillRect(10,10,150,150); WebGLWebGL 是针对 Canvas 的 3D 上下文。第十六章 HTML5 脚本编程跨文档消息传递跨文档消息传递，简称XDM，指的是来自不同域的页面间传递消息。postMessage() 发送消息：var iframeWindow = document.getElementById(&quot;myFrame&quot;).contentWindow; iframeWindow.postMessage(&quot;A secret&quot;, &quot;http://www.wshunli.com&quot;); 接收消息，触发 window 对象的 message 事件，异步方式。window.addEventListener(&quot;message&quot;,function(){ if(event.origin == &quot;http://www.wshunli.com&quot;){//发送消息的文档所在的域 processMessage(event.data); //处理接收的数据 event.source.postMessage(&quot;Received!&quot;, &quot;http://github.com&quot;); //可选：向来源窗口发送回执 } },false) 媒体元素HTML5新增了 &lt;audio&gt; 和 &lt;video&gt; 两个标签。&lt;video src=&quot;conference.mpg&quot; id=&quot;muvideo&quot;&gt;video palyer not available&lt;/video&gt; &lt;audio src=&quot;song.mp3&quot; id=&quot;myAudio&quot;&gt;audio player not available&lt;/audio&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
        <tag>JavaScript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章链接问题]]></title>
    <url>%2Fposts%2F261b7c4.html</url>
    <content type="text"><![CDATA[Hexo 文章链接问题今天 搜索 一下网站，发现有个很大的问题。有很多链接 404，比如这个链接：http://www.wshunli.com/2017/10/29/《JavaScript高级程序设计》读书笔记（一）/搜索引擎跳转之后是：http://www.wshunli.com/2017/10/29/《javascript高级程序设计》读书笔记（一）/单单因为 JavaScript 大小写的问题，就找不到页面。所以在 Hexo 官网找了一下固定链接的插件。最终选择是： hexo-abbrlink ; Github ：https://github.com/rozbo/hexo-abbrlink安装插件：npm install hexo-abbrlink --save 在站点配置文件中修改 permalink ：permalink: posts/:abbrlink.html 站点配置文件中配置插件：# abbrlink config abbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex 链接效果：crc16 &amp; hex https://post.zz173.com/posts/66c8.html crc16 &amp; dec https://post.zz173.com/posts/65535.html crc32 &amp; hex https://post.zz173.com/posts/8ddf18fb.html crc32 &amp; dec https://post.zz173.com/posts/1690090958.html 更多内容参考：https://post.zz173.com/detail/hexo-abbrlink.html]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ECMAScript6入门》读书笔记（二）]]></title>
    <url>%2Fposts%2F67855b9d.html</url>
    <content type="text"><![CDATA[《ECMAScript6入门》读书笔记ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。字符、数值、正则的扩展第4章 字符串的扩展：http://es6.ruanyifeng.com/#docs/string第5章 数值的扩展：http://es6.ruanyifeng.com/#docs/array第6章 正则的扩展：http://es6.ruanyifeng.com/#docs/regex第7章 数组的扩展扩展运算符扩展运算符是三个点（...），将一个数组转为用逗号分隔的参数序列。console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5 function push(array, ...items) { array.push(...items); } function add(x, y) { return x + y; } const numbers = [4, 38]; add(...numbers); // 42 Array.from()Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。let arrayLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] // ES6的写法 let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] Array.of()Array.of 方法用于将一组值，转换为数组。Array.of(3, 11, 8) // [3,11,8] copyWithin()数组实例的 copyWithin() 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。Array.prototype.copyWithin(target, start = 0, end = this.length) target（必需）：从该位置开始替换数据。start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。[1, 2, 3, 4, 5].copyWithin(0, 3); // [4, 5, 3, 4, 5] find() &amp; findIndex()数组实例的 find() 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。[1, 5, 10, 15].find(function(value, index, arr) { return value &gt; 9; }) // 10 find() 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。[1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9; }) // 2 findIndex() 方法的用法与 find() 方法非常类似，返回第一个符合条件的数组成员的位置fill()数组实例的 fill() 方法使用给定值，填充一个数组。[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7); // [7, 7, 7] new Array(3).fill(7); // [7, 7, 7] // 第二个和第三个参数，用于指定填充的起始位置和结束位置。 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2); // [&#39;a&#39;, 7, &#39;c&#39;] entries()，keys() 和 values()ES6 提供三个新的方法 – entries()，keys() 和 values() – 用于遍历数组。可以用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) { console.log(index); } // 0 // 1 for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) { console.log(elem); } // &#39;a&#39; // &#39;b&#39; for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) { console.log(index, elem); } // 0 &quot;a&quot; // 1 &quot;b&quot; includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。[1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true // 第二个参数表示搜索的起始位置，默认为0 [1, 2, 3].includes(3, 3); // false 数组的空位数组的空位指，数组的某一个位置没有任何值。Array(3) // [, , ,] ES6 明确将空位转为 undefined。Array.from([&#39;a&#39;,,&#39;b&#39;]); // [ &quot;a&quot;, undefined, &quot;b&quot; ] 由于空位的处理规则非常不统一，所以建议避免出现空位。第8章 函数的扩展函数参数的默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。function log(x, y = &#39;World&#39;) { console.log(x, y); } log(&#39;Hello&#39;) // Hello World log(&#39;Hello&#39;, &#39;China&#39;) // Hello China log(&#39;Hello&#39;, &#39;&#39;) // Hello 参数默认值是惰性求值的。与解构赋值默认值结合使用：函数默认值生效：当前参数没有传值或传值为 undefined ；解构赋值默认值生效：当前参数传值或没有传值而默认值与 undefined 严格相等。// 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } m1() // [0, 0] m2() // [0, 0] m1( {x: 3, y: 8} ) // [3, 8] m2( {x: 3, y: 8} ) // [3, 8] m1( {x: 3} ) // [3, 0] m2( {x: 3} ) // [3, undefined] m1( {} ) // [0, 0]; m2( {} ) // [undefined, undefined] m1( {z: 3} ) // [0, 0] m2( {z: 3} ) // [undefined, undefined] 区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。参数默认值的位置：定义了默认值的参数应该是函数的尾参数，否则这个参数不能省略。// 例一：默认值的参数在前 function f(x = 1, y) { console.log([x, y]); } f(); // [1, undefined] f(2); // [2, undefined] f(, 1); // 报错 f(undefined, 1); // [1, 1] // 例二：默认值的参数在后 function f(x , y= 1) { console.log([x, y]); } f(); // [undefined, 1] f(2); // [2, 1] f(2, ); // [2, 1] f(2, undefined); // [2, 1] undefined 能触发默认值，null 不能。function foo(x = 5, y = 6) { console.log(x, y); } foo(undefined, null); // 5 null 函数的 length 属性：没有指定默认值的参数个数。作用域：一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域就会消失。var x = 1; function f(x, y = x) { console.log(y); } f(); // undefined f(2); // 2 // x 没有定义，所以指向外部全局变量 x let x = 1; function f(y = x) { let x = 2; console.log(y); } f(); // 1 f(3); // 3 更复杂的例子：var x = 1; // 全局变量 function foo(x, y = function() { x = 2; }) { //函数参数作用域 var x = 3; // 函数内部变量 y(); console.log(x); } foo(); // 3 - 第5行 console.log(x); // 1 rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数。function add(...values) { let sum = 0; for (var val of values) { sum += val; } return sum; } add(2, 5, 3); // 10 rest 参数搭配的变量为数组，arguments 为类似数组的对象。rest 参数之后不能再有其他参数；函数的 length 属性，也不包括 rest 参数。严格模式从 ES5 开始，函数内部可以设定为严格模式。ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。name 属性函数的 name 属性，返回该函数的函数名。function foo() {} foo.name // &quot;foo&quot; var f = function () {}; f.name // &quot;&quot; - ES5 f.name // &quot;f&quot; - ES6 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。var sum = (num1, num2) =&gt; num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 箭头函数有几个使用注意点：（1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。function foo() { setTimeout(() =&gt; { console.log(&#39;id:&#39;, this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 箭头函数 this 指向定义时所在的对象。function Timer() { this.s1 = 0; this.s2 = 0; setInterval(() =&gt; this.s1++, 1000); // 箭头函数 setInterval(function () { // 普通函数 this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100); // s1: 3 setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100); // s2: 0 前者的 this 绑定定义时所在的作用域（即Timer函数），后者的 this 指向运行时所在的作用域（即全局对象）。this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。// ES6 function foo() { setTimeout(() =&gt; { console.log(&#39;id:&#39;, this.id); }, 100); } // ES5 function foo() { var _this = this; setTimeout(function () { console.log(&#39;id:&#39;, _this.id); }, 100); } 由于没有 this，因而也不存在通过 bind()、call()、apply() 来改变 this 的指向。嵌套的箭头函数：箭头函数内部，还可以再使用箭头函数。let insert = (value) =&gt; ({into: (array) =&gt; ({after: (afterValue) =&gt; { array.splice(array.indexOf(afterValue) + 1, 0, value); return array; }})}); // 等价于 function insert(value) { return {into: function (array) { return {after: function (afterValue) { array.splice(array.indexOf(afterValue) + 1, 0, value); return array; }}; }}; } // 结果相同 insert(2).into([1, 3]).after(1); //[1, 2, 3] 双冒号运算符函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。foo::bar; // 等同于 bar.bind(foo); 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。var method = obj::obj.foo; // 等同于 var method = ::obj.foo; 双冒号运算符的运算结果，还是一个对象，因此可以采用链式写法。let { find, html } = jake; document.querySelectorAll(&quot;div.myClass&quot;) ::find(&quot;p&quot;) ::html(&quot;hahaha&quot;); 尾调用优化尾调用（Tail Call）是指某个函数的最后一步是调用另一个函数。function f(x) { if (x &gt; 0) { return m(x) } return n(x); } 尾调用优化：即只保留内层函数的调用帧。函数调用会在内存形成一个调用记录即“调用帧”，如果函数 A 调用函数 B ，还会形成一个 B 的调用帧，依次类推形成一个调用栈。如果函数存在尾调用，只保留最后的函数的调用帧即可，这将大大节省内存。function f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。注意，只有不再用到外层函数的内部变量才能进行“尾调用优化”。下面函数就不会进行“尾调用优化”。function addOne(a){ var one = 1; function inner(b){ return b + one; } return inner(a); } 尾递归：函数调用自身，称为递归。如果尾调用自身，就称为尾递归。function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 // 改写成尾递归 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } facorial(5, 1) // 120 函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号。function clownsEverywhere( param1, param2, ) { /* ... */ } clownsEverywhere( &#39;foo&#39;, &#39;bar&#39;, ); 第9章 对象的扩展属性的简洁表示法ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。const foo = &#39;bar&#39;; const baz = {foo}; // 等同于 const baz = {foo: foo}; 除了属性简写，方法也可以简写。const o = { method() { return &quot;Hello!&quot;; } }; // 等同于 const o = { method: function() { return &quot;Hello!&quot;; } }; 属性名表达式JavaScript 定义对象的属性，有两种方法。// 方法一 obj.foo = true; // 方法二 obj[&#39;a&#39; + &#39;bc&#39;] = 123; 如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名。let lastWord = &#39;last word&#39;; const a = { &#39;first word&#39;: &#39;hello&#39;, [lastWord]: &#39;world&#39; }; a[&#39;first word&#39;] // &quot;hello&quot; a[lastWord] // &quot;world&quot; a[&#39;last word&#39;] // &quot;world&quot; 表达式还可以用于定义方法名。let obj = { [&#39;h&#39; + &#39;ello&#39;]() { return &#39;hi&#39;; } }; obj.hello(); // hi 注意：属性名表达式与简洁表示法不能同时使用；属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 [object Object]。方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。const person = { sayName() { console.log(&#39;hello!&#39;); }, }; person.sayName.name // &quot;sayName&quot; Object.is()ES6 提出“Same-value equality”（同值相等）算法，用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。。Object.is(&#39;foo&#39;, &#39;foo&#39;); // true Object.is({}, {}); // false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。+0 === -0 // true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true Object.assign()Object.assign() 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。const target = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} Object.assign() 方法的第一个参数是目标对象，后面的参数都是源对象。如果 undefined 或 null 作为第一个参数会报错，在之后则会跳过；数值、布尔值可以被转换成包装对象，但依然会被忽略；字符串转对象会被拆分成数组，除了原始值会被拷贝到[[PrimitiveValue]]属性中，每个字符都是可枚举的实义属性，因此是有效的。const v1 = &#39;abc&#39;; const v2 = true; const v3 = 10; const obj = Object.assign({}, v1, v2, v3); console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; } Object.assign() 只拷贝对象的自有属性，属性名为 Symbol 的属性也会被拷贝，继承属性和不可枚举的属性不会被拷贝。Object.assign() 执行的是浅拷贝，对于同名属性会直接覆盖而非合并。Object.assign() 可以用于处理数组，但会把数组转换成属性名为 0、1、2…… 的对象，并依次替换。Object.getOwnPropertyDescriptors()ES2017 引入了 Object.getOwnPropertyDescriptors() ，返回指定对象所有自身属性（非继承属性）的描述对象。Object.setPrototypeOf()，Object.getPrototypeOf()__proto__属性:（前后各两个下划线），用来读取或设置当前对象的prototype对象。Object.setPrototypeOf(): 作用与proto相同，用来设置一个对象的prototype对象，返回参数对象本身。Object.getPrototypeOf(): 读取一个对象的原型对象。Object.keys()，Object.values()，Object.entries()ES5 引入了 Object.keys() 来返回一个数组，其成员是参数对象的可枚举的自有属性的键名。ES2017 跟着引入了 Object.values() 和 Object.entries() 用于返回属性对应的值，以及以键值对数组的形式返回。可以配合 for…of 循环使用。属性的可枚举性和遍历对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。可枚举性：描述对象的 enumerable 属性，如果该属性为false，就表示某些操作会忽略当前属性。for…in 循环、Object.keys()、JSON.stringify()、Object.assign() 忽略 enumerable 为 false 的属性。ES6 一共有5种方法可以遍历对象的属性。for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名。Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。首先遍历所有数值键，按照数值升序排列。其次遍历所有字符串键，按照加入时间升序排列。最后遍历所有 Symbol 键，按照加入时间升序排列。super 关键字ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。对象的扩展运算符ES2017 将这个运算符引入了对象。解构赋值:对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x // 1 y // 2 z // { a: 3, b: 4 } 解构赋值必须是最后一个参数，否则会报错。注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。扩展运算符:扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。let z = { a: 3, b: 4 }; let n = { ...z }; // { a: 3, b: 4 } 扩展运算符可以用于合并两个对象。let ab = { ...a, ...b }; // 等同于 let ab = Object.assign({}, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。let newVersion = { ...previousVersion, name: &#39;New Name&#39; // Override the name property }; 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。let aWithDefaults = { x: 1, y: 2, ...a }; // 等同于 let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a); let aWithDefaults = Object.assign({ x: 1, y: 2 }, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。// 空对象没有任何效果 {...{}, a: 1} // { a: 1 } // 忽略 null 和 undefined let emptyObject = { ...null, ...undefined }; // 不报错]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
        <tag>ECMAScript6入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ECMAScript6入门》读书笔记（一）]]></title>
    <url>%2Fposts%2Febc6af5b.html</url>
    <content type="text"><![CDATA[《ECMAScript6入门》读书笔记《JavaScript高级程序设计》中学习了前八章，后面是一些 DOM 相关的知识，现在开始学习 ES6 语法。《ECMAScript6入门》 作者：阮一峰。第1章 ECMAScript6 简介ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等。Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码。ESLint 用于静态检查代码的语法和风格；Mocha 则是一个测试框架。第2章 let 和 const 命令let 命令let 命令只在其所在的代码块内有效。{ let a = 10; var b = 1; } console.log(a); // ReferenceError: a is not defined. console.log(b); // 1 前面闭包中有说：闭包只能取得函数中任何变量的最后一个值。var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 使用 let 声明的变量仅在块级作用域内有效。var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 其实 i 仅在当前循环有效。每循环一次就是一个新的变量。1.不存在变量提升：var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined；let 变量声明前使用会报错。console.log(c); // ReferenceError: a is not defined. console.log(d); // undefined let c; var d; 2.暂时性死区：在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。var tmp = 123; if (true) { tmp = &#39;abc&#39;; // ReferenceError let tmp; } 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。3.不允许重复声明：let 不允许在相同作用域内，重复声明同一个变量。也不能在函数内部重新声明参数。块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量；第二种场景，用来计数的循环变量泄露为全局变量。let 实际上为 JavaScript 新增了块级作用域。function f1() { let n = 5; if (true) { let n = 10; } console.log(n); // 5 } 内部代码块可以定义外层作用域的同名变量；外层作用域无法读取内层作用域的变量，也不受内层代码块的影响。块级作用域与函数声明：ES6 允许在块级作用域之中声明函数，但函数在块级作用域之外不可引用。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。const 命令const声明一个只读的常量。一旦声明，就必须立即初始化，常量的值不能改变。const PI = 3.1415; console.log(PI); // 3.1415 PI = 3; // TypeError: Assignment to constant variable. const foo; // SyntaxError: Missing initializer in const declaration const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。const 命令声明的常量也是不提升；同样存在暂时性死区，只能在声明的位置后面使用；并且不可重复声明。本质：const 其实是变量指向的内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），等同于常量。但对于复合类型的数据（主要是对象和数组），变量保存的只是一个指针，const 只能保证这个指针是固定的。const foo = {}; // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop // 123 // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: &quot;foo&quot; is read-only 如果真的想将对象冻结，应该使用 Object.freeze 方法。const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 中，顶层对象的属性与全局变量是等价的。window.a = 1; console.log(a); // 1 b = 2; console.log(window.b); // 2 ES6 规定 let、const、class 命令声明的全局变量，不属于顶层对象的属性。var a = 1; // 如果在 Node 的 REPL 环境，可以写成 global.a // 或者采用通用方法，写成 this.a console.log(window.a) // 1 let b = 1; console.log(window.b) // undefined 第3章 变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对 变量 进行赋值，这被称为解构。数组的解构赋值let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。// 右边比左边少，解构不成功，值为 undefined let [bar, foo] = [1]; // undefined,undefined // 右边比左边多，不完全解构 let [x, y] = [1, 2, 3]; //1,2 默认值：解构赋值允许指定默认值。let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // &#39;a&#39;,&#39;b&#39; let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // &#39;a&#39;,&#39;b&#39; // 只有数组成员 严格等于 undefined 时，默认值才会生效 let [x = 1] = [null]; // null 对象的解构赋值解构不仅可以用于数组，还可以用于对象。let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; //&quot;aaa&quot;,&quot;bbb&quot; let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // undefined 对象的属性没有次序；变量必须与属性同名，才能取到正确的值。变量名与属性名不一致:真正被赋值的是后者，而不是前者。let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; console.log(baz); // &quot;aaa&quot; 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。实际上，对象的解构时下面形式的简写：let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 完整形式 let { foo , bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; // 简写形式 嵌套赋值：let obj = {}; let arr = []; ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true }); console.log(obj); // {prop:123} console.log(arr); // [true] 对象的解构也可以指定默认值。同样严格等于 undefined 才生效。let {x = 3} = {}; console.log(x); // 3 let {x: y = 3} = {}; console.log(y); // 3 如果要将一个已经声明的变量用于解构赋值，必须用括号包裹，不能让花括号处于行首。let x; {x} = {x: 1}; // 错误的写法 ({x} = {x: 1}); // 正确的写法 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。// 字符串可以看做数组进行结构 const [a, b, c, d, e] = &#39;hello&#39;; // a:&quot;h&quot;, b:&quot;e&quot;, c:&quot;l&quot;, d:&quot;l&quot;, e:&quot;o&quot;, // 字符串作为类数组对象，拥有length属性。 let {length : len} = &#39;hello&#39;; // len:5 数值和布尔值的解构赋值数值和布尔值也能进行解构，两者会先转为对象，剩下的就是匹配对象中的方法let {toString: s} = 123; s === Number.prototype.toString // true let {toString: s} = true; s === Boolean.prototype.toString // true // undefined和null不能转为对象，没有属性 let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。function add([x, y]){ return x + y; } add([1, 2]); // 3 函数 add() 的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引。函数参数的解构也可以使用默认值。function move({x = 0, y = 0} = {}) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, 0] move({}); // [0, 0] move(); // [0, 0] 下面代码是为函数 move() 的参数指定默认值。function move({x, y} = { x: 0, y: 0 }) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, undefined] move({}); // [undefined, undefined] move(); // [0, 0] - 无参数，默认值生效 圆括号问题ES6 规定，但凡有可能产生歧义，就不能使用圆括号。以下3种情况下不能用圆括号：1.变量声明语句let [(a)] = [1]; let {x: (c)} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; 2.函数参数function f([(z)]) { return z; } function f([z,(x)]) { return x; } 3.赋值语句的模式[(b)] = [3]; // 正确，数组的解构赋值根据索引来，与括号无关 ({ p: (d) } = {}); // 正确，p 是模式，但 d 不是模式。 用途1.交换变量的值let x = 1; let y = 2; [x, y] = [y, x]; 2.从函数返回多个值// 返回一个数组 function example() { return [1, 2, 3]; } let [a, b, c] = example(); // 返回一个对象 function example() { return { foo: 1, bar: 2 }; } let { foo, bar } = example(); 3.函数参数的定义// 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); 4.提取JSON数据let jsonData = { id: 42, status: &quot;OK&quot;, data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, &quot;OK&quot;, [867, 5309] 5.函数参数的默认值jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config }) { // ... do stuff }; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。6.遍历 Map 结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。const map = new Map(); map.set(&#39;first&#39;, &#39;hello&#39;); map.set(&#39;second&#39;, &#39;world&#39;); for (let [key, value] of map) { console.log(key + &quot; is &quot; + value); } // first is hello // second is world // 如果只想获取键名或键值，可以写成下面这样。 for (let [key] of map) { ... }// 获取键名 for (let [,value] of map) { ...}// 获取键值 7.输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
        <tag>ECMAScript6入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》读书笔记（二）]]></title>
    <url>%2Fposts%2Fd8b94418.html</url>
    <content type="text"><![CDATA[《JavaScript高级程序设计》读书笔记(二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。(8-14章)第八章 BOMwindow 对象BOM 的核心对象是 window，表示浏览器的实例。既是范文浏览器窗口的接口，又是 ECMAScript 规定的 Global 对象。全局作用域：全局作用域中声明的变量函数会变成 window 对象的属性和方法。窗口关系及框架：若页面中包含框架，则每个框架都有自己的 window 对象，并且保存在 frames 集合中。top 对象始终指向最高（最外）层的框架，也就是浏览器窗口。parent 对象始终指向当前框架的直接上层框架。self 对象始终指向 window。所有这些对象都是 window 对象的属性。窗口位置：IE、Safari、Opera、Chrome 提供 screenLeft 和 screenTop 属性，FireFox 提供 screenX 和 screenY 属性，分别用于表示窗口相对于屏幕左边和上边的位置。窗口大小：innerWidth、innerHeight、outerWidth、outerHeight导航和打开窗口: window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接受 4 个参数：要加载的URL、窗口目标、一个特性字符串、一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。间歇调用和超时调用：JavaScript 是单线程语言，但允许通过设置超时时间和间歇时间调度代码在特定的时刻执行。超时调用 setTimeout()：指定的时间过后执行代码。var timeoutId=setTimeout(function(){ console.log(&quot;Hello world!&quot;); },1000); //取消超时调用 clearTimeout(timeoutId); 间歇调用 setInterval()：指定的时间间隔重复执行代码。系统对话框：alert()、confirm()、prompt()location 对象location 对象不仅提供与当前窗口中加载的文档有关信息，还提供了一些导航功能。即是 window 对象的属性，也是 document 对象的属性。除直接修改 location 对象属性外 assign()、replace()、reload() 方法也可以改变当前加载页面。location.assign(&quot;http://www.wshunli.com&quot;); // 等价于 window.location=&quot;htttp://www.wshunli.com&quot;; location.href=&quot;htttp://www.wshunli.com&quot;; location.replace=&quot;htttp://www.wshunli.com&quot;;// 无法返回前一个页面 location.reload();// 重新加载页面 navigator 对象navigator 对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。screen 对象screen 对象用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息 ，如像素高度和宽度等。每个浏览器中的screen对象都包含着不同过的属性，支持也不同。history 对象history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window 对象的属性，因此每个浏览器窗口、每个标签乃至每个框架，都有自己的history 对象与特定的 window 对象关联。第九章 客户端检测客户端检测主要包括：能力检测：浏览器的特定能力；怪癖检测：浏览器实际中存在的 bug ；用户代理检测：通过检测用户代理字符串识别浏览器。尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案。第十章 DOM节点层次DOM 将任何HTML或XML文档描绘成一个由多层节点构成的树形结构。总共有 12 种节点，其中常用的有 4 种。Node.ELEMENT_NODE(1) - 元素节点Node.ATTRIBUTE_NODE(2) - 特性（属性）节点Node.TEXT_NODE(3) - 文本节点Node.COMMENT_NODE(8) - 注释节点DOM 节点关系：Document 类型：JavaScript通过Document类型表示文档；浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面，且也是window对象的一个属性，因此可以将其作为全局对象来访问。文档属性：document.title：取得当前页面的标题，也可以修改标题。document.URL：页面完整的URL；document.domain：只包含页面的域名；document.referrer：保存着链接到当前页面的那个页面的 URL。文档方法：document.getElementById()document.getElementsByTagName()document.getElementsByName()特殊集合：document.anchors：包含文档中所有带name特性的&lt;a&gt;元素；document.forms：包含文档中所有&lt;form&gt;元素；document.img：包含文档中所有&lt;img&gt;元素；document.links：包含文档中所有带href特性的&lt;a&gt;元素。Element 类型：Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。特性（属性）操作：getAttribute()、setAttribute()、removeAttribute()创建元素：document.createElement()Text 类型：文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。创建文本节点：document.createTextNode()规范文本节点：父元素上调用 normalize()，其实就是将元素的相邻文本节点合并成一个节点。var element = document.createElement(&quot;div&quot;); element.className = &quot;message&quot;; var textNode = document.createTextNode(&quot;Hello world!&quot;); element.appendChild(textNode); var anotherTextNode = document.createTextNode(&quot;Yippee!&quot;); element.appendChild(anotherTextNode); document.body.appendChild(element); console.log(element.childNodes.length); //2 element.normalize(); console.log(element.childNodes.length); //1 console.log(element.firstChild.nodeValue); //&quot;Hello World!Yippee!&quot; 分割文本节点：spiltText()var element=document.createElement(&quot;div&quot;); element.className=&quot;message&quot;; var textNode=docuemnt.createTextNode(&quot;Hello World!&quot;); element.appendChild(textNode); document.body.appendChild(element); var newNode=element.firstChild.spiltText(5); console.log(element.firstChild.nodeValue); //&quot;Hello&quot; console.log(newNode.nodeValue); //&quot; World&quot; console.log(element.childNodes.length); //2 Attr 类型：元素的特性（属性）在 DOM 中以 Attr 类型来表示。Attr对象有3个属性：name、value和specified。其中，name是特性名称，value是特性的值，specified是一个布尔值，用以区别特性是在代码中指定的还是默认的。Comment 类型：注释在 DOM 中是通过 Comment 类型来表示的。其他节点类型：Node.CDATA_SECTION_NODE(4)Node.ENTITY_REFERENCE_NODE(5)Node.ENTITY_NODE(6)Node.PROCESSING_INSTRUCTION_NODE(7)Node.DOCUMENT_NODE(9)Node.DOCUMENT_TYPE_NODE(10)Node.DOCUMENT_FRAGMENT_NODE(11)Node.NOTATION_NODE(12)DOM 操作技术利用 JavaScript 代码、CSS 样式、表格修改 DOM 元素的结构、属性、内容的技术。动态脚本：&lt;script&gt;动态样式：&lt;link&gt;,&lt;style&gt;操作表格：&lt;table&gt;第十一章 DOM 扩展DOM扩展主要包含两方面：Selector API，HTML5选择符 APIquerySelector() ：接收一个 CSS 选择符，返回匹配的第一个元素；querySelectorAll() ：返回 NodeList 对象。// 取得ID为&quot;myDIV&quot;的元素 var myDIV = document.querySelector(&quot;#myDiv&quot;); // 取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName(&quot;em&quot;)) var ems = document.getElementById(&quot;myDiv&quot;).querySelectorAll(&quot;em&quot;); 元素遍历Element Traversal 规范为 DOM 元素新定义了5个属性：childElementCount：返回子元素的个数（不包括文本节点和注释）firstElementChild：指向第一个子元素，firstChild元素版lastElementChild：指向最后一个子元素，lastChild元素版previousElementSibling：指向前一个同辈元素，previousSibling元素版nextElementSibling：指向后一个同辈元素，nextSibling元素版HTML5与类相关的扩展：getElementsByClassName()：返回带有特定类的所有元素的 NodeList。classList属性：HTML5为所有元素添加 classList属性。焦点管理：HTML5也添加了辅助管理DOM焦点的功能。document.activeElement 属性，始终会引用 DOM 中当前获得焦点的元素。document.hasFocus()方法，确定文档是否获得了焦点。var button = document.getElementById(&quot;myButton&quot;); button.focus(); console.log(document.activeElement === button); // true console.log(document.hasFocus()); // true HTMLDocument 的变化：readyState 属性：document.readyState 指示文档是否加载完成。loading：正在加载文档；complete：已经加载完文档。head 属性：document.head 属性可以获得&lt;head&gt;元素。字符集属性：document.charset：表示文档中实际使用的字符集。document.defaultCharset：当前文档的默认字符集。自定义数据属性：HTML5规定可以为元素添加非标准的属性，以此为元素提供与渲染无关的信息。每个自定义数据属性，都要为其添加前缀data-。可通过 dataset 属性访问自定义属性的值。&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myName=&quot;nicholas&quot;&gt;&lt;/div&gt; // 访问上述div元素的自定义属性 var div = document.getElementById(&quot;myDiv&quot;); // 访问自定义属性值时，属性名前不必加data-前缀 var appId = div.dataset.appId; 插入标记：innerHTML 属性：在读模式下，innerHTML属性返回调用元素的所有子节点HTML标记。在写模式下，innerHTML属性会根据指定的值创建新的DOM树，然后用新DOM树替换调用元素原先的所有子节点。outerHTML 属性：在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。insertAdjacentHTML() 方法：语法：insertAdjacentHTML(插入位置，要插入的HTML文本)插入位置必须是下列四个值之一：“beforebegin”，在当前元素之前插入一个紧邻的同辈元素“afterend”，在当前元素之后插入一个紧邻的同辈元素“afterbegin”，给当前元素插入第一个子元素（不管当前元素是否有无子元素）“beforeend”，给当前元素插入最后一个子元素（不管当前元素是否有无子元素）scrollIntoView() 方法：所有元素均可调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。第十二章 DOM2 和 DOM3DOM1级主要定义的是HTML和XML文档的底层结构。DOM2 和DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML特性。第十三章 事件事件流事件流描述的是从页面中接收事件的顺序。事件冒泡（event bubbling）：事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。事件捕获（event capturing）:不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件。事件流包括三个阶段：事件捕获阶段：首先发生，为截获事件提供了机会。处于目标阶段：实际的目标接收到事件。事件冒泡阶段：在此阶段可以对事件做出响应。事件处理程序事件是用户或浏览器自身执行的某种动作（比如click、load、mouseover等）事件处理程序（事件侦听器）是响应某个事件的函数。事件处理程序的名字以“on”开头，如click事件的事件处理程序是onclick。HTML事件处理程序：为元素添加一个与事件处理程序同名的属性，该属性的值是能够执行的JS代码或JS函数。&lt;script type=&quot;text/javascript&quot;&gt; function showMessage() { console.log(&quot;Hello world&quot;); } &lt;/script&gt; &lt;input type=&quot;button&quot; value=&quot;Clicke Me&quot; onclick=&quot;showMessage()&quot; /&gt; DOM0级事件处理程序：将一个函数赋值给一个事件处理程序属性。var btn = document.getElementById(&quot;myBtn&quot;); // 为按钮指定onclick事件处理程序 btn.onclick = function(){ console.log(&quot;Clicked&quot;); } // 删除事件处理程序 btn.onclick = null; DOM2级事件处理程序：“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()、removeEventListener() 。var btn = document.getElementById(&quot;myBtn&quot;); //定义事件处理程序函数 var handler = function(){ console.log(this.id); } btn.addEventListener(&quot;click&quot;, handler, false); btn.removeEventListener(&quot;click&quot;, handler, false); true：在捕获阶段调用事件处理程序；false：在冒泡阶段调用事件处理程序。事件对象触发DOM上的某个事件时，会产生一个event事件对象，该对象包含着所有与事件有关的信息。兼容DOM（DOM0级和DOM2级）的浏览器将event对象传入到事件处理程序中。var btn = document.getElementById(&quot;myBtn&quot;); btn.onclick = function(event){ console.log(event.type); //&quot;click&quot; }; btn.addEventListener(&quot;click&quot;, function(event){ console.log(event.type); //&quot;click&quot; }, false); 属性/方法：currentTarget：正在处理事件的那个元素target：事件的目标type：事件类型cancelable：可以阻止特定事件的默认行为preventDefault()：阻止特定事件的默认行为stopPropagation()：停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡eventPhase：事件出于事件流的阶段 捕获阶段为1 处于目标对象为2 冒泡阶段为3事件类型UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件、合成事件、变动事件。第十四章 表单脚本在HTML中，表单是由 &lt;form&gt; 元素来表示的，而在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
        <tag>JavaScript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript高级程序设计》读书笔记（一）]]></title>
    <url>%2Fposts%2Fe8afa8c0.html</url>
    <content type="text"><![CDATA[《JavaScript高级程序设计》读书笔记从今天开始阅读 《JavaScript高级程序设计》（第三版）。按照图灵社区推荐的阅读规划：(一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。(1-7章) (二) 熟悉JavaScript运行的环境，深刻理解DOM，熟悉DOM提供给JavaScript的原生API。(8-14章) (三) 学习HTML新增的一些对象提供的API，包括canvas ，媒体事件等。(15-16章) (四) 学习在浏览器中进行实际开发时的错误调试技巧。(17章) (五) 学习JavaScript对各数据载体的操作方法（如JSON、XML），学会Ajax的使用方法。(18-21章) (六) 学习JavaScript的一些高级技巧及实践方案。(22-25章) (一) 熟悉JavaScript的语法，理解那些JavaScript中让人疑惑的概念。(1-7章)第一章 JavaScript 简介一个完整的 JavaScript 实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。ECMAScript：提供核心语言功能；DOM：提供访问和操作网页内容的方法和接口；BOM：提供与浏览器交互的方法和接口。第二章 在 HTML 中使用 JavaScriptHTML 4.01 为 &lt;script&gt; 元素定义了6个属性：async、charset、defer、language（废弃）、src、type 。在不存在 defer 和 async 属性时，浏览器都会按照不同&lt;script&gt;元素在页面中出现的先后顺序对它们依次进行解析。标签的位置：为了避免浏览器在呈现页面时出现明显的延迟，现代Web应用程序一般都把全部 JavaScript 引用放在&lt;body&gt;元素中页面内容的后面。延迟脚本：defer 属性表明脚本在执行时不会影响页面的构造，告诉浏览器立即下载文件，但脚本会被延迟到整个页面都解析完毕后再运行；只适用于外部脚本文件。&lt;script defer=&quot;defer&quot; src=&quot;example.js&quot;&gt;&lt;/script&gt; 异步脚本：async 属性表示当前脚本不必等待其他脚本，也不必阻塞文档呈现，告诉浏览器立即下载文件，且并不保证标记为 async 的脚本按照他们的先后顺序执行；只适用于外部脚本文件。&lt;script async src=&quot;example1.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;example2.js&quot;&gt;&lt;/script&gt; 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载；而 load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded)。第三章 基本概念本章内容：语法、数据类型、操作符、控制流语句、函数。其中内容和 Java 类似的部分，不再记笔记。语法区分大小写：ECMAScript 中的一切都区分大小写。ECMAScript 5 引入严格模式。在整个脚本中启用严格模式，在顶部添加 &quot;use strict&quot;;给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。数据类型ECMAScript 中有5种基本数据类型：Undefined、Null、Boolean、Number、String。还有1种复杂数据类型：Object，Object 本质是一组无序的键值对组成。typeof 操作符：用来检测变量的数据类型。“undefined”：未定义、”boolean”：布尔值、”string”：字符串、”number”：数值、”object”：对象或 null、 “function”：函数检测 null 值返回 “Object”、检测函数返回 “function” 。Undefined 类型：使用 var 声明变量但未对其初始化时，这个变量的值就是 undefined。对未声明的变量只能只能执行一项操作，即使用 tyoeof 检测其数据类型，返回 undefined 值。Null 类型：null 值表示一个空对象指针；只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。undefined 表示未初始化的变量；null 表示空对象指针；null == undefined 。Boolean 类型：其他类型转换为 Boolean 类型，使用函数 Boolean()。Number 类型：表示整数和浮点数值。NaN 即非数值（Not a Number）是一个特殊的数值，表示一个原本要返回数值的操作未返回数值的情况。任何涉及 NaN 的操作都会返回 NaN；NaN与任何值都不等，包括 NaN 本身。NaN 类型可以使用 isNaN() 函数检测。数值转换：有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()。Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。Number() 函数转换：null和空字符串返回 0；undefined和无法转换的字符串返回 NaN ；对象依次尝试调用 valueOf()、toString()方法，根据函数返回值进行转换。parseInt() 函数转换：忽略字符前的空格，找到第一个非空格字符；如果第一个字符不是数字字符或者负号，返回 NaN ；继续解析遇到非数字字符为止。可选第二个参数指定进制。parseFloat() 函数转换：和 parseInt() 函数类似，但是字符串中的第一个小数点是有效的。String 类型：符串是不可变的，要改变要先删除。其他类型转换为 String 类型，使用函数 toString() 或 String() 或加一个空字符串（&quot;&quot;）。数值、布尔值、对象、字符串值 都有 toString() 方法。null、undefined 值没有。String() ：null 返回 &quot;null&quot; ， undefined 返回 &quot;undefined&quot;。其他调用 toString() 方法。Object 类型：一组数据（属性）和功能（方法）的组合。创建对象的方法：var o = new Object(); 在 ECMAScript 中，Object 类型是其他所有实例的基础，Object 类型具有的属性和方法也同样存在于更具体的对象中。Object 的每个实例（对象）都具有下列属性和方法：constructor：保留着用于创建当前对象的函数即构造函数；hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在；isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型；propertyIsEnumerable()；toLocaleString()；toString()：返回对象的字符串表示；valueOf()：返回对象的字符串、数值或布尔值表示。操作符操作符包括：算数操作符、位操作符、关系操作符、相等操作符。用法和概念基本和 Java 一致，相同部分不再记笔记。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。&quot;23&quot;&lt;&quot;3&quot; //true 相等操作符基本规则：null == undefined，且不转换；对象除非指向同一个否则互相不等；操作值是数值，则另一个值转换为数值进行比较；操作值是布尔值，则将布尔值转换为数值再进行比较，false转换为0,true转换为1。true == 1 ; //true true == 2 ; //false NaN == NaN ; //false NaN != NaN ; //true 全等和不全等：两个操作数未经转换就相等为全等；转换之后相等为非全等。&quot;23&quot; == 23 ; //true &quot;23&quot; === 23 ; //false 语句for-in 语句可以用来枚举对象的属性。for (property in expression) { ... } break 和 continue 语句与 label 语句联合使用：多发生在循环嵌套的情况下。var num = 0; outermost: for (var i = 0; i &lt; 10; i++) { for (var j = 0; j &lt; 10; j++) { if (i == 5 &amp;&amp; j ==5) { break outermost; } num++; } } console.log(num); // 55 函数函数参数：参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。没有重载：ECMAScript 函数不能像传统意义上那样实现重载。如果在ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。第四章 变量、作用域和内存问题JavaScript 变量的特征：本质是松散类型，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。基本类型和引用类型的值基本类型指的是简单的数据段，而引用数据类型指那些可能由多个值构成的对象。Undefined、Null、Boolean、Number 和 String 这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。引用类型的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。动态的属性：对引用类型可添加属性和方法，也可改变和删除其属性和方法；对基本类型也能添加属性，但基本类型并不会保存，操作是无效的。复制变量值：从一个变量向另一个变量复制值，基本类型会创建新值并复制到新变量；而引用类型只会复制指向对象的指针，新旧变量会相互影响。传递参数：函数的参数是按值传递时的，即把函数外部的值复制给函数内部的参数（参数实际上是函数的局部变量），就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样，复制的是一个指向对象的指针。function setName(obj){ obj.name = &#39;Nicholas&#39;; obj = new Object(); obj.name = &#39;Greg&#39;; } var person = new Object(); setName(person); console.log(person.name); // =&gt; Nicholas 对于引用类型，当把参数名指向新的内存空间，再对其做添加属性等操作，不会影响到原来传递的那个对象，所以不是按引用传递参数。检测类型：instanceof 根据原型链，检测变量是什么引用类型的实例。检测基本数据类型 typeof 非常有用，但如果变量是对象或 null ，typeof 只能返回 “Object” 。执行环境和作用域执行环境：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。有全局执行环境和局部（函数）执行环境之分。作用域链：搜索变量和函数的作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端是当前执行的代码所在的变量环境，最后一个对象是全局执行环境的变量对象。延长作用域链：try-catch 语句的 catch 块和 with 语句。没有块级作用域：由花括号封闭的代码没有自己的作用域。如 if 、for 语句中只是在语句的执行环境中（全局或函数）。查询标识符：从作用域链的前端开始，向上逐级查询，找到后搜索结果停止，没有找到则一直追溯到全局环境的变量对象。垃圾收集JavaScript 具有自动垃圾回收机制，即执行环境会负责管理代码执行过程中使用的内存。最常用的方法有标记清除和引用计数。管理内存：最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。解除一个值的引用并不意味着自动回收该值所占用的内存——解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。第五章 引用类型引用类型的值（对象）是引用类型（类、对象定义）的一个实例。Object 类型创建对象：// 1、使用 Object 构造函数 var person = new Object(); person.name = &quot;Nicholas&quot;; person.age = 29; // 2、对象字面量表示法 var person = { name : &quot;Nicholas&quot;, age : 29 }; // 属性名可以使用字符串 var person = { &quot;name&quot; : &quot;Nicholas&quot;, &quot;age&quot; : 29, 5 : true //自动转换为字符串 }; // 与 new Object() 等价 var person = {}; person.name = &quot;Nicholas&quot;; person.age = 29; 访问对象属性：// 1、点表示法 person.name // 2、方括号表示法 person[&quot;name&quot;] // 通过变量访问 var n = &#39;name&#39;; console.log(person[n]); // 包含语法错误的字符 onsole.log(person[&#39;first name&#39;]; Array 类型ECMAScript 数组的每项可保存任何类型的数据，没项类型可不同；大小可自动调整。创建数组：var a1 = new Array(); var a2 = new Array(20); var a3 = new Array(&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;); var a4 = []; var a5 = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]; 检测数组：Array.isArray() 方法可检测对象是不是数组。转换方法：toLocaleString()、toString()和 valueOf()方法。toLocaleString()、toString() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。toLocaleString() 方法为了取得每一项的值，调用的是每一项的 toLocaleString() 方法。valueOf() 方法返回的还是数组。var person1 = { toLocaleString : function () { return &quot;Nikolaos&quot;; }, toString : function() { return &quot;Nicholas&quot;; } }; var person2 = { toLocaleString : function () { return &quot;Grigorios&quot;; }, toString : function() { return &quot;Greg&quot;; } }; var people = [person1, person2]; console.log(people); //Nicholas,Greg console.log(people.toString()); //Nicholas,Greg console.log(people.toLocaleString()); //Nikolaos,Grigorios join() 方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; console.log(colors.join(&quot;,&quot;)); //red,green,blue console.log(colors.join(&quot;||&quot;)); //red||green||blue 栈方法：push() 和 pop() 方法。push() 方法接收任意数量的参数，把他们逐个加到数组末尾，并返回修改后的数组长度。pop() 方法从数组末尾移除最后一项，减少数组长度，然后返回移除项。队列方法：shift() 和 unshift() 方法。shift() 从数据前端取项方法。类比 pop() 。unshift() 从数组前端添加项。类比 push() 。重排序方法：reverse() 和 sort() 方法。reverse() 反转数组项的顺序。sort() 默认升序排列数组项，调用每项的 toString() 转型方法，然后比较字符串。sort() 方法可以接受一个比较函数作为参数。比较函数接受两个参数，第一个参数在第二个之前返回负数。// 从小到大： function compare(value1, value2) { if (value1 &lt; value2) { return -1; } else if (value1 &gt; value2) { return 1; } else { return 0; } } var values = [0, 1, 5, 10, 15]; values.sort(compare); console.log(values); //0,1,5,10,15 // 或者 function compare(value1, value2) { return value1 &lt; value2; } var values = [0, 1, 5, 10, 15]; values.sort(compare); console.log(values); //0,1,5,10,15 操作方法 ：concat() slice() splice() 。concat() 添加项。创建新数组。var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]); console.log(colors); //red,green,blue console.log(colors2); //red,green,blue,yellow,black,brown slice() 截取。创建新数组。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]; var colors2 = colors.slice(1); var colors3 = colors.slice(1,4); console.log(colors2); //green,blue,yellow,purple console.log(colors3); //green,blue,yellow splice() 删除插入替换。改变原数组。三个参数：起始位置、要删除的项数、要插入的项。第三个不传是删除功能，第二个为 0 是插入功能，都有则替换。返回：删除的项。var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; var removed = colors.splice(0,1); //remove the first item console.log(colors); //green,blue console.log(removed); //red - one item array removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); //insert two items at position 1 console.log(colors); //green,yellow,orange,blue console.log(removed); //empty array removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //insert two values, remove one console.log(colors); //green,red,purple,orange,blue console.log(removed); //yellow - one item array 位置方法：indexOf() lastIndexOf() 接收两个参数：要查找的项和（可选）查找起点位置的索引；indexOf()从前往后查找，lastIndexOf()从后往前查找；返回要查找的项的位置，没找到则返回 -1。迭代方法：两个参数：在每项运行的函数和（可选的）作用域对象；其中函数接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。有返回false的项时就不会再对后面的项检测了，直接返回false。some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。有返回true的项时就不再对后面的项检测了，直接返回ture。filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。本质上与使用 for 循环迭代数组一样。var a = [1, 2, 3, 4, 5, 4, 3, 2, 1]; var everyResult = a.every(function (item, index, array) { return (item &gt; 2); }); console.log(everyResult); // false var someResult = a.some(function (item, index, array) { return (item &gt; 2); }); console.log(someResult); // true var filterResult = a.filter(function (item, index, array) { return (item &gt; 2); }); console.log(filterResult); // [3, 4, 5, 4, 3] var mapResult = a.map(function (item, index, array) { return (item * 2); }); console.log(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2] var forEachResult = a.forEach(function (item, index, array) { console.log(item); }); console.log(forEachResult); // undefined 缩小方法（递归方法）：reduce() 和 reduceRight() 迭代数组的所有项，然后构建一个最终返回的值；reduce()方法从前往后，reduceRight()从后往前。reduce() 和 reduceRight() 接收两个参数：一个在每项上调用的函数和（可选的）作为缩小基础的初始值。其中函数接收4个参数：前一个值、当前值、项的索引和数组对象。函数的返回值又会作为第一个参数自动传给下一项。var values = [1,2,3,4,5]; var sum = values.reduce(function(prev, cur, index, array){ return prev + cur; },1); console.log(sum); //16 Date 类型创建日期对象：var now = new Date(); var date = new Date(2005, 4, 5, 17, 55, 55); // 2005年5月5日下午5点55分55秒 获取调用时的日期和时间和毫秒数：var start = Date.now(); doSomething(); var stop = Date.now(); var result = stop - start; 日期的格式化方法：var date = new Date(2015, 2, 5, 17, 55, 55); date.toString(); // &quot;Thu Mar 05 2015 17:55:55 GMT+0800 (CST)&quot; date.toDateString(); // &quot;Thu Mar 05 2015&quot; date.toTimeString(); // &quot;17:55:55 GMT+0800 (CST)&quot; date.toLocaleString(); // &quot;2015/3/5 下午5:55:55&quot; date.toLocaleDateString(); // &quot;2015/3/5&quot; date.toLocaleTimeString(); // &quot;下午5:55:55&quot; RegExp 类型创建正则表达式：var exp1 = / pattern / flags ; var exp2 = new RegExp(&#39;pattern&#39;, &#39;flags&#39;); 模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。标志（flags）用以标明正则表达式的行为。正则表达式的匹配模式支持下列3 个标志：g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。RegExp 实例方法：exec()：返回第一个匹配项信息的数组，数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串；还包含两个额外的属性，index 和 input。test()：在模式与该参数匹配的情况下返回true，否则返回false。正则表达式：http://www.runoob.com/regexp/regexp-tutorial.htmlFunction 类型函数实际上是对象。函数名实际上是指向函数对象的指针。每个函数都是 Function 类型的实例，而且与其他引用类型一样具有属性和方法。// 函数声明 function sum (num1, num2){ return num1 + num2; } // 函数表达式 var sum = function(num1, num2){ return num1 + num2; }; // 使用构造函数，不推荐 var sum = new Function(&#39;num1&#39;, &#39;num2&#39;, &#39;return num1 + num2&#39;); 函数声明与函数表达式：解释器会率先读取函数声明，并使其在执行任何代码之前可用（函数声明提升）；函数表达式必须等到解释器执行到它所在行才会真正被解释执行。// 函数声明 console.log(sum(10,10)); function sum (num1, num2){ return num1 + num2; } // 函数表达式 console.log(sum(10,10));// Uncaught TypeError: sum is not a function var sum = function(num1, num2){ return num1 + num2; }; 作为值的函数：因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。函数的内部属性：arguments 、this 。arguments: 是一个类数组对象，包含着传入函数中的所有参数。function factorial(num){ if (num &lt;= 1) { return 1; } else { return num * factorial(num-1) } } function factorial(num){ if (num &lt;= 1) { return 1; } else { return num * arguments.callee(num-1) } } arguments 的属性 callee 指向拥有此 arguments 的函数。// 无论引用函数时使用的什么名字，都可以保证正常完成递归。 var trueFactorial = factorial; factorial = function(){ return 0; }; console.log(trueFactorial(5)); //120 console.log(factorial(5)); //0 this 引用的是函数据以执行的环境对象。在全局作用域中调用函数，this 引用的是全局对象 window；把函数赋给对象 o 并调用时，this 引用的就是对象 o 。caller : 调用当前函数的函数的引用，返回后者的源代码。函数的属性和方法：函数的两个属性：length 和 prototype 。length：表示函数希望接收的命名参数的个数。prototype: 对于ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。不可枚举。函数的两个非继承而来的方法：apply() 和 call() 。在特定的作用域中调用函数。apply()：接受两个参数，运行函数的作用于和参数数组。function sum(num1, num2){ return num1 + num2; } // 参数数组可以是 Array 的实例，也可以是 arguments 对象。 function callSum1(num1, num2){ return sum.apply(this, arguments); } function callSum2(num1, num2){ return sum.apply(this, [num1, num2]); } console.log(callSum1(10,10)); //20 console.log(callSum2(10,10)); //20 call()：必须明确地传入每个参数。function sum(num1, num2){ return num1 + num2; } function callSum(num1, num2){ return sum.call(this, num1, num2); } console.log(callSum(10,10)); //20 apply() 和 call() 真正强大的地方是能够扩充函数赖以运行的作用域。而使用它们来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。window.color = &quot;red&quot;; var o = { color: &quot;blue&quot; }; function sayColor(){ console.log(this.color); } sayColor(); //red sayColor.call(this); //red sayColor.call(window); //red sayColor.call(o); //blue bind() 方法会创建一个函数的实例，其 this 值会绑定到传给 bind() 函数的值。var objectSayColor = sayColor.bind(o); objectSayColor(); //blue 基本包装类型Boolean 类型、Number 类型、String 类型。单体内置对象Global 对象、Math 对象。第六章 面向对象的程序设计对象：无序属性的集合，其属性可以包含基本值、对象或者函数。理解对象属性在创建时都带了一些特征值（characteristic），JavaScript 通过这些特征值来定义他们的行为。ECMAScript 中有两种属性：数据属性和访问器属性。描述属性的各种特征，是为了实现JavaScript引擎用的，不能直接访问。数据属性：[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。[[Enumerable]]：表示能否通过 for-in 循环返回属性。[[Writeable]]：表示能否修改属性的值。[[Value]]：包含这个属性的数据值。访问器属性：[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为数据属性。[[Enumerable]]：表示能否通过 for-in 循环返回属性。[[Get]]：在读取属性时调用的函数。[[Set]]：在写入属性时调用的函数。定义及读取特性：Object.defineProperty() Object.defineProperties()；Object.getOwnPropertyDescriptor() 。创建对象虽然使用 Object 构造函数或者对象字面量可以创建单个对象，但使用同一接口创建很多对象，会产生大量的重复代码。工厂模式：使用函数来封装以特定接口来创建对象。function createPerson(name,age,job){ var o=new Object(); o.name=name; o.age=age; o.job=job; o.sayName=function(){ console.log(this.name); }; return o; } var person1=createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;); 构造函数模式：function Person(name,age,job){ this.name=name; this.age=age; this.job=job; this.sayName=function(){ console.log(this.name); }; } var person1=new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;); 要创建Person的实例，必须使用new操作符。用这种方式调用构造函数需要4个步骤：创建一个新对象；将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；执行构造函数中的代码（为这个新对象添加属性）；返回新对象。构造函数和其他函数唯一的区别，就是在于调用他们的方式不同。任何函数，只要通过 new 操作符来调用，那么它就可以作为构造函数。原型模式：创建的每一个函数都有一个 prototype（原型）属性，指向一个对象；这个对象（原型对象 ）的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype 就是通过调用构造函数而创建的实例的原型对象。好处是可以让所有的实例共享原型对象包含的属性和方法，不用在构造函数里面定义实例的信息，而是直接添加到原型对象中。function Person(){ } Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function(){ console.log(this.name); }; var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot; var person2 = new Person(); person2.sayName(); //&quot;Nicholas&quot; console.log(person1.sayName == person2.sayName); //true 1.理解原型对象：只要创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，指向原型对象；默认所有原型对象都会获得一个 constructor 属性，指向 prototype 属性所在函数（构造函数）；调用构造函数创建实例后，实例内部将包含一个指针 [[Prototype]] 或者 __proto__ 指向构造函数的原型对象。··· // 使用 isPrototype() 来检测构造函数的原型对象和实例对象之间是否有关系 console.log(Person.prototype.isPrototypeOf(person1)); //true console.log(Person.prototype.isPrototypeOf(person2)); //true // Object.getPrototypeOf() 返回实例对象的原型 if (Object.getPrototypeOf){ console.log(Object.getPrototypeOf(person1) == Person.prototype); //true console.log(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; } 当代码读取某个对象的属性时，先从对象实例本身开始，若没有找到才会在原型对象中查找。当为对象实例添加属性时，这个属性会屏蔽掉原型对象中的同名属性，即使将这个属性设置为 null ，也只会在实例中设置这个属性。不过使用 delete 操作符可以完全删除实例属性，使得可以重新访问原型中的属性。··· person1.name = &quot;Greg&quot;; console.log(person1.name); //&quot;Greg&quot; - 来自实例 console.log(person2.name); //&quot;Nicholas&quot; - 来自原型 delete person1.name; console.log(person1.name); //&quot;Nicholas&quot; - 来自原型 // 使用 hasOwnProperty() 来检测属性存在于实例中还是原型中 console.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型 person1.name = &quot;Greg&quot;; console.log(person1.hasOwnProperty(&quot;name&quot;)); // true - 来自实例 delete person1.name; console.log(person1.hasOwnProperty(&quot;name&quot;)); // false - 来自原型 实例与原型的关系：2.原型与 in 操作符：单独使用和在 for-in 循环中使用。··· // 单独使用时无论属性在原型还是在实例中都返回 true console.log(&quot;name&quot; in person1); // true person1.name = &quot;Greg&quot;; console.log(&quot;name&quot; in person1); //true // for-in 循环时，返回的是所有能通过对象访问的、可枚举的属性；同样也包括原型和实例中的。 for (var prop in person1) { console.log(prop); // name age job sayName } Object.keys() 方法可以取得对象上所有可枚举的实例属性。··· var keys = Object.keys(Person.prototype); console.log(keys); //&quot;name,age,job,sayName&quot; Object.getOwnPropertyNames() 方法可以得到所有实例属性，无论其是否可枚举。··· var keys = Object.getOwnPropertyNames(Person.prototype); console.log(keys); //&quot;constructor,name,age,job,sayName&quot; 3.更简单的原型语法：function Person(){ } // 本质是重写了默认的 prototype 对象 // constructor 属性指向 Object Person.prototype = { name : &quot;Nicholas&quot;, age : 29, job: &quot;Software Engineer&quot;, sayName : function () { console.log(this.name); } }; console.log(friend instanceof Object); //true console.log(friend instanceof Person); //true console.log(friend.constructor == Person); //false console.log(friend.constructor == Object); //true 为解决 constructor 无法确定对象类型的问题：function Person(){ } // 方法1： Person.prototype = { // 使 constructor 属性指向构造函数 constructor : Person, name : &quot;Nicholas&quot;, age : 29, job: &quot;Software Engineer&quot;, sayName : function () { console.log(this.name); } }; // 方法2： Person.prototype = { name : &quot;Nicholas&quot;, age : 29, job: &quot;Software Engineer&quot;, sayName : function () { console.log(this.name); } }; // 设置 constructor 属性不可枚举 Object.defineProperty(Person.prototype.&quot;constructor&quot;){ enumerable : false, value: Person } // 结果相同 var friend = new Person(); console.log(friend instanceof Object); //true console.log(friend instanceof Person); //true console.log(friend.constructor == Person); //true console.log(friend.constructor == Object); //false 4.原型的动态性：我们对原型的修改都能立刻反映到实例上。但是重写原型，实例对象还是指向原来的原型，不会指向新重写的原型对象。重写原型切断了新的原型和之前已经存在的对象实例间的联系。5.原型对象的问题：原型对象中讯在引用类型的属性，会使所有实例共享该引用。组合使用构造函数和原型模式：构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;Court&quot;]; } Person.prototype = { constructor: Person, sayName : function () { console.log(this.name); } }; var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); person1.friends.push(&quot;Van&quot;); console.log(person1.friends); //&quot;Shelby,Court,Van&quot; console.log(person2.friends); //&quot;Shelby,Court&quot; console.log(person1.friends === person2.friends); //false console.log(person1.sayName === person2.sayName); //true 实例属性都是在构造函数中定义的，每个实例都会有自己的一份实例属性的副本。动态原型模式：将原型信息封装在构造函数中。function Person(name, age, job){ //properties this.name = name; this.age = age; this.job = job; //methods if (typeof this.sayName != &quot;function&quot;){ Person.prototype.sayName = function(){ console.log(this.name); }; } } var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); friend.sayName(); 寄生构造函数模式、稳妥构造函数模式。继承ECMAScript 只支持实现继承，主要依靠原型链来实现。原型链：利用原型将一个引用类型继承另一个引用类型的属性和方法。function SuperType(){ this.property = true; } SuperType.prototype.getSuperValue = function(){ return this.property; }; function SubType(){ this.subproperty = false; } //继承 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function (){ return this.subproperty; }; var instance = new SubType(); console.log(instance.getSuperValue()); //true 实例以及构造函数和原型之间的关系：getSuperValue() 方法仍然在 SuperType.prototype 中，但 property 位于 SubType.prototype 中。因为我们重写了 SubType 的原型，新原型即 SuperType 的实例；property 是实例的属性，getSuperValue() 则是 SuperType 原型的方法。1.注意默认原型：函数的默认原型是 Object 实例，因此默认原型会包含指针指向 Object.prototype 。2.确定实例与原型的关系：console.log(instance instanceof Object); //true console.log(instance instanceof SuperType); //true console.log(instance instanceof SubType); //true console.log(Object.prototype.isPrototypeOf(instance)); //true console.log(SuperType.prototype.isPrototypeOf(instance)); //true console.log(SubType.prototype.isPrototypeOf(instance)); //true 3.谨慎地定义方法：给原型添加方法一定要在替换原型之后；也不能使用字面量创建原型方法。4.原型链问题：引用类型的原型属性会被所有实例共享；不能向超类传递参数。借用构造函数：通过 apply() 或 call() 方法在新创建的对象上执行超类的构造函数。function SuperType(){ this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } function SubType(){ //继承自 SuperType SuperType.call(this); } var instance1 = new SubType(); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); //&quot;red,blue,green,black&quot; var instance2 = new SubType(); console.log(instance2.colors); //&quot;red,blue,green&quot; 通过 apply() 或 call() 方法在 SubType 实例的环境下调用了 SuperType 构造函数。1.传递参数：function SuperType(name){ this.name = name; } function SubType(){ //继承自 SuperType，传递参数 SuperType.call(this, &quot;Nicholas&quot;); //实例属性 this.age = 29; } var instance = new SubType(); console.log(instance.name); //&quot;Nicholas&quot;; console.log(instance.age); //29 2.问题： 和构造函数模式类似，方法都在构造函数中定义，无法复用。组合继承：JavaScript中最常用的继承。融合了原型链和构造函数的优点。function SuperType(name){ this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } SuperType.prototype.sayName = function(){ console.log(this.name); }; function SubType(name, age){ SuperType.call(this, name); this.age = age; } SubType.prototype = new SuperType(); SubType.prototype.sayAge = function(){ console.log(this.age); }; var instance1 = new SubType(&quot;Nicholas&quot;, 29); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); //&quot;red,blue,green,black&quot; instance1.sayName(); //&quot;Nicholas&quot;; instance1.sayAge(); //29 var instance2 = new SubType(&quot;Greg&quot;, 27); console.log(instance2.colors); //&quot;red,blue,green&quot; instance2.sayName(); //&quot;Greg&quot;; instance2.sayAge(); //27 原型式继承、寄生式继承、寄生组合式继承。第七章 函数表达式定义函数的方法有两种：函数声明与函数表达式。递归递归函数是在一个函数通过名字调用自身函数构成。function factorial(num){ if (num &lt;= 1){ return 1; } else { return num * factorial(num-1); } } var anotherFactorial = factorial; factorial = null; console.log(anotherFactorial(4)); //error! - factorial 已经不是函数 解决办法是使用命名函数表达式：function factorial = (function f(num){ if (num &lt;= 1){ return 1; } else { return num * f(num-1); } }); 闭包闭包 是有权访问另一个函数作用域中的变量的函数。1.闭包和变量:闭包只能取得函数中任何变量的最后一个值。function createFunctions(){ var result = new Array(); for (var i=0; i &lt; 10; i++){ result[i] = function(){ return i; }; } return result; } 其中每个函数都引用着保存变量 i 的同一个变量对象,所以函数内部返回的值都是 10 。function createFunctions(){ var result = new Array(); for (var i=0; i &lt; 10; i++){ result[i] = function(num){ return function(){ return num; }; }(i); } return result; } 2.关于 this 对象:匿名函数通常具有全局性,因此其 this 对象通常指向 windows 。var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getNameFunc : function(){ return function(){ return this.name; }; } }; console.log(object.getNameFunc()()); //&quot;The Window&quot; 在非严格模式下 this 的值有时候会意外发生改变。var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;, getName: function(){ return this.name; } }; console.log(object.getName()); //&quot;My Object&quot; console.log((object.getName)()); //&quot;My Object&quot; console.log((object.getName = object.getName)()); //&quot;The Window&quot; 在严格模式下 } 第三个其实是重写了 getName 方法,this 值就指向全局了。模仿块级作用域JavaScript 没有块级作用域(私有作用域)的概念,可使用匿名函数方法模仿。(function () { ... })(); 私有变量JavaScript 没有私有成员的概念,所有对象属性都是公有的,但是有个私有变量的概念,也就是函数中定义的变量。function Person(name){ this.getName = function(){ return name; }; this.setName = function (value) { name = value; }; } var person = new Person(&quot;Nicholas&quot;); console.log(person.getName()); //&quot;Nicholas&quot; person.setName(&quot;Greg&quot;); console.log(person.getName()); //&quot;Greg&quot; 创建 Person 实例只能 通过 getName() 和 setName() 方法访问内部变量,但是针对每个实例都会创建一组新方法。1.静态私有变量(function(){ var name = &quot;&quot;; Person = function(value){ name = value; }; Person.prototype.getName = function(){ return name; }; Person.prototype.setName = function (value){ name = value; }; })(); var person1 = new Person(&quot;Nicholas&quot;); console.log(person1.getName()); //&quot;Nicholas&quot; person1.setName(&quot;Greg&quot;); console.log(person1.getName()); //&quot;Greg&quot; var person2 = new Person(&quot;Michael&quot;); console.log(person1.getName()); //&quot;Michael&quot; console.log(person2.getName()); //&quot;Michael&quot; 初始化未声明的变量,总会创建一个全局变量。严格模式下报错。示例代码中 name 变成了一个静态的,所有实例共享的属性。2.模块模式模块模式是为单例创建私有变量和特权方法。单例即只有一个实例的对象。function BaseComponent(){ } function OtherComponent(){ } var application = function(){ //私有变量和方法 var components = new Array(); //初始化 components.push(new BaseComponent()); //公共接口 return { getComponentCount : function(){ return components.length; }, registerComponent : function(component){ if (typeof component == &quot;object&quot;){ components.push(component); } } }; }(); application.registerComponent(new OtherComponent()); console.log(application.getComponentCount()); //2 3.增强的模块模式针对单例必须是某种类型的实例,同时还对其添加属性或方法的情况。function BaseComponent(){ } function OtherComponent(){ } var application = function(){ //私有变量和方法 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建 application 的一个局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function(){ return components.length; }; app.registerComponent = function(component){ if (typeof component == &quot;object&quot;){ components.push(component); } }; //返回副本 return app; }(); console.log(application instanceof BaseComponent); application.registerComponent(new OtherComponent()); console.log(application.getComponentCount()); //2]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
        <tag>JavaScript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript DOM 编程艺术》读书笔记]]></title>
    <url>%2Fposts%2F25be2399.html</url>
    <content type="text"><![CDATA[《JavaScript DOM 编程艺术》读书笔记本科的时候也有看前端的内容但是没有系统地学习，现在有 WebGIS 相关的项目，并且发现 Android 开发也发生了一些变化: 很多应用不再单单是一个简单的原生 Android 应用，用到了跨平台技术，比如说 React Native 、 Ionic 等等，这都需要 Javascript 基础。所以打算系统地学习下 Javascript 。其实有这个想法很久了，包括暑假来到也有意学习前端技术，最开始是在慕课网看 前端基础 相关视频，然后也简单地在 菜鸟教程 看了相关文字内容，最后在廖雪峰的网站看 JavaScript全栈教程，这部分对后来 Node.js 后端开发很有帮助。但是现在发现 Javascript 水品还不行，没有接近实战的水平，所以打算再系统学习下。按照知乎 如何循序渐进、有效地学习JavaScript？ 问题的回答，决定先学习 《JavaScript DOM 编程艺术》（第二版），后面再学习 《JavaScript高级程序设计》，最后再刷 《ECMAScript 6 入门》 学习 ES6 。第1章 JavaScript 简史本章主要介绍了 JavaScript 的起源、浏览器之间的战争、DOM 的演变史。DOM (Document Object Model,文档对象模型) 是一套对文档的内容进行抽象和概念化的方法。感觉和类的说法很类似。第2章 JavaScript 语法程序设计语言分为解释型和编译型两大类。Java或者C++等语言需要一个编译器，把用Java等高级语言编写出来的源代码翻译为计算机能直接执行的文件。解释型语言不需要编译器–它们仅需要解释器，对于JavaScript而言，Web浏览器负责完成有关解释和执行工作。浏览器的JavaScript解释器将直接读取源代码并执行，相关错误也只能在此时才能发现。语法JavaScript 语法基本上和 Java 或者 C++ 类似，下面主要介绍不同点。JavaScript 是一种弱类型语言，变量使用前不需要进行类型声明，但不建议这样做。数据类型JavaScript 中的数据类型主要包括 字符串、数值、布尔值 三种。字符串：单引号双引号都可以，最好根据字符内容选择。数值：不单单是整数，允许任意位小数。布尔值：true 或 false 。数组JavaScript 数组声明不必指出数组长度：var car = Array(5); var car = Array(); var car = []; 声明数组的同时也可以进行填充（向数组添加元素）：var cars = new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;); var cars = [&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;]; 数组元素类型不必相同，甚至可以是数组或者对象：var cars = new Array(&quot;Saab&quot;,2017,true); var beatles = []; beatles[0] = cars; // beatles[0][1] 的值为 2017 。 对象简介对象的声明使用 Object 关键字：var car = new Object(); var car = {}; var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566}; 对象属性取值赋值方法：var person = {firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566}; person.lastname = &quot;Wang&quot;; var name = person.lastname; var name = person[&quot;lastname&quot;]; 算数操作符、条件语句、循环语句和 Java、C++ 基本一致，不再赘述。比较操作符不太一样:== : 表示类型转换后值是否相等；=== ：严格相等，类型必须相同。函数函数声明及调用方法：function myFunction(a, b) { return a * b; } // 调用函数 myFunction(2,5); 变量的作用域全局变量：可以在脚本的任意位置引用，包括函数内部。局部变量：在函数内部声明，只在函数内部有效。对象对象是自包含的数据集合，包含在对象里的数据可通过 属性（property） 和 方法（method） 访问。属性是隶属于某个特定对象的变量方法是只有某个特定对象才能调用的函数对象分类：自定义对象：利用 JavaScript 创建的自己的对象；内建对象：JavaScript提供的一系列预先定义好的对象。数组也可以看做是 JavaScript 的内建对象的一种。常见的还有Data对象；宿主对象：由浏览器提供的预定义对象。常见的有 windows，document 等。第3章 DOMDOM 三个字母的具体含义:D 是基础，没有文档（Document）DOM 也就无从谈起；O 是对象（Object），JavaScript 本身就可以看做是由对象构成的语言，其重要性不言而喻；M 是模型（Model），其含义是某种事物的表现形式。具体的说 DOM 把文档表示成了一颗家谱树（DOM 使用 parent、child，sibling 等记号来表明家庭成员之间的关系。节点DOM 由许多不同的节点（node）组成，节点可分为三类：元素节点：DOM 的原子是元素节点，可以包含其他元素。文本节点：元素节点的内容。属性节点：元素节点的描述。&lt;p title=&quot;Paragraph&quot;&gt;This is a paragraph.&lt;/p&gt; /** * 元素节点：p * 文本节点：This is a paragraph. * 属性节点：title=&quot;Paragraph&quot; */ 获取元素有三种方法可以获取元素节点，分别通过 id、标签名、class 。// document 特有函数，返回一个元素 var x = document.getElementById(&quot;intro&quot;); // getElementsByTagName、getElementsByClassName 返回元素数组 var y = document.getElementsByTagName(&quot;p&quot;); var y = x.getElementsByTagName(&quot;p&quot;); // 允许使用通配符 var y = x.getElementsByTagName(&quot;*&quot;); var z = document.getElementsByClassName(&quot;intro&quot;); var z = x.getElementsByClassName(&quot;intro&quot;); // 允许查找带有多个类名的元素，并且类名顺序不重要 var z = x.getElementsByClassName(&quot;import intro&quot;); 获取和设置属性获取和设置属性的方法如下：getAttribute()：该方法只能通过元素节点对象调用；setAttribute():该方法允许我们对属性节点的值做出修改。var img = document.getElementById(&quot;image&quot;)； img.getAttribute(&quot;src&quot;); img.src; img.setAttribute(&quot;src&quot;,&quot;landscape.jpg&quot;); img.src = &quot;landscape.jpg&quot;; document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;; 通过浏览器查看源代码，其属性并不会改变，也就是说 setAttribute 做出的修改不会反映到文档本身的源码里。这种“表里不一”的的现象源自 DOM 的工作模式：先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。第4章 案例研究：JavaScript图片库事件处理函数事件处理函数的作用是，在特定事件发生时调用特定的代码。 &lt;a href=&quot;images/fireworks.jpg&quot; title=&quot;A fireworks display&quot; onclick=&quot;showPic(this); return false;&quot;&gt;Fireworks&lt;/a&gt; 事件处理函数的工作机制：在给某元素添加事件处理函数后，一旦事件发生相应的 JavaScript 代码就会执行。被调用的 JavaScript 代码可以返回一个值，这个值将被传递至事件处理函数。例如：我们给某链接添加一个 onclick 事件处理函数，并把这个事件处理函数所触发的 JavaScript 代码返回 true 或 false 。这样一来，当这个链接被点击时，JavaScript 代码返回值是 true ，onclick 事件处理函数就认为 这个链接被点击了；反之，认为没有被点击。所以在 onclick 事件处理函数所触发的 JavaScript 代码里增加一条 return false; 语句，屏蔽掉链接的默认行为。对函数进行拓展childNodes 属性childNodes 属性可以获取任一元素的所有子元素。var body_element = document.getElementById(&quot;body&quot;)[0]; // 得到 body 的所有子元素、数组 body_element.childNodes; nodeType 属性childNodes 属性返回的数组包括所有类型的节点，而不仅仅是元素节点。事实上，文档里的每样东西都是一个节点，设置连空格和换行符都被解释为节点。可通过节点的 nodeType 属性区分不同的节点。node.nodeType返回值是一个数字。nodeType 共有 12 种取值，其中仅 3 种具有实用价值。元素节点：1.属性节点：2.文本节点：2.nodeValue 属性若改变 文本节点 的值，可通过 DOM 提供的 nodeValue 属性。node.nodeValue注意：对于元素节点而言，element.nodValue 得到的值并不是元素的文本值。正确的做法的先得到元素节点的文本节点，再取 nodeValue 属性：element.childNodes[0].nodeValuefirstChild 和 lastChild 属性firstChild：元素的第一个子元素。lastChild：元素的最后一个元素。function showPic(whichPic) { var source = whichPic.getAttribute(&quot;href&quot;);//获取资源路径 var placeholder = document.getElementById(&quot;placeholder&quot;); placeholder.setAttribute(&quot;src&quot;,source); var text = whichPic.getAttribute(&quot;title&quot;);//获取内容 var description = document.getElementById(&quot;description&quot;); description.firstChild.nodeValue = text; } 第5章 最佳实践1、在使用任何一句JavaScript代码时，都应该想想，对这个网页是否有用；2、平稳退化（graceful degradation)：如果正确使用了 JavaScript 脚本，可以让访问者在他们的浏览器不支持 JavaScript 的情况下仍能顺利地浏览你网站。虽然某些功能无法使用，但是最基本的操作仍能顺利完成；3、渐进加强：用额外的信息层去包裹原始数据；使 CSS 代码负责提供关于“表示”的信息，JavaScript 代码负责提供关于“行为”的信息。4、分离 JavaScript：在 HTML 文档中使用诸如 onclick 之类的属性也是一种没有效率又容易引发问题的做法。如果利用像 CSS 中的 class 和 id 属性那样，把JavaScript 代码调用行为与 HTML 文档内容和结构分离，网页就会健壮不少。5、向后兼容：对象检测：检测浏览器对 JavaScript 的支持程度。用一个 if 语句的条件表达式看求值结果是 true 还是 false 来采取不同的行动。如在代码前加上 if(!getElementById) return false;6、性能考虑：尽量少访问DOM和尽量减少标记，不管什么时候只要是查询DOM中的某些元素，浏览器就会搜索整个DOM树，从中查找可能匹配的元素。在多个函数都会取得一组类似元素的情况下，可以考虑重新构建代码，把搜索结果保存在一个全局变量里，或者把一组元素以参数形式传递给函数。减少标记数量的目的在于，过多的不必要的元素只会增加DOM树的规模。7、合并和放置脚本：减少请求数量是在性能优化时首先要考虑的；把所以的&lt;script&gt;标签都放在文档的末尾，&lt;/body&gt;标记之前，就可以让页面变得更快。8、压缩脚本：指的是把脚本文件中的不必要的字节，比如空格和注释，统统删除，从而达到“压缩”文件的目的；多数情况下应该有两个版本，一个是工作副本，可以修改代码并添加注释，另一个是精简副本，用于放在站点上，通常在精简副本的文件名上加上 min 字样。第6章 案例研究：图片库改进版本章主要是第5章内容在 图片库 上的实践。共享onload事件：假如有两个函数 firstFunction 和 secondFunction 需要在页面加载时执行：window.onload = firstFunction; window.onload = secondFunction; 这样做的话实际上只有后一个可以执行。window.onload = function() { firstFunction(); secondFunction(); } 这样做创建了一个匿名函数，在需要绑定的函数不是很多的场合的确很实用.最佳解决方案,使用 addLoadEvent 函数。这个方案需要额外添加一些代码，但一旦有了这些代码，绑定函数到 onload 就很方便。function addLoadEvent(func){ //将现有的 window.onload 处理函数保存到 oldonload var oldonload = window.onload; //如果现有的 window.onload 上没有处理函数，将 func 添加给它 if(typeof oldonload != &#39;function&#39;) { window.onload = func; } else{ window.onload function() { oldload(); func(); } } } 第7章 动态创建标记JavaScript 可以通过创建新元素和修改现有元素改变网页的结构。传统方法document.writedocument 的 write() 方法可以方便快速地将字符串插入到文档内。&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;&lt;p&gt;This is inserted.&lt;/p&gt;&quot;); &lt;/script&gt; &lt;/body&gt; 缺点就是违背了”行为与表现分离的原则”,即使把这句语句挪到外部，还是需要在&lt;body&gt;里边添加&lt;script&gt;标签才可以调用。innerHTML 属性innerHTML 属性可以用来读写某给定元素里地 HTML 元素。&lt;body&gt; &lt;div id=&quot;testdiv&quot;&gt;&lt;/div&gt; &lt;/body&gt; window.onload = function(){ var testdiv = document.getElementById(&quot;testdiv&quot;); testdiv.innerHTML=&quot;&lt;p&gt;I inserted &lt;em&gt;this&lt;/em&gt; content.&lt;/p&gt;&quot;; } 利用此技术无法区分“插入一段内容”还是“替换一段内容”。DOM 方法createElement 方法var para = document.createElement(&quot;p&quot;); 创建元素节点，只创建会出现一个文档碎片（document fragment）。本身并不影响页面表现，它是游荡在JavaScript世界里的一个孤儿。但是它已经有 nodeType 和 nodeName 属性。appendChild 方法把新创建的节点插入文档的节点树最简单方法是：让其成为某个现有节点的一个子节点。var para = document.createElement(&quot;p&quot;); var testdiv = document.getElementById(&quot;testdiv&quot;); testdiv.appendChild(para); createTextNode 方法创建文本节点填充元素节点的内容。把文本节点插入为元素节点的子节点。var para = document.createElement(&quot;p&quot;); var testdiv = document.getElementById(&quot;testdiv&quot;); testdiv.appendChild(para); var txt = document.createTextNode(&quot;Hello World&quot;); para.appendChild(txt); 改变顺序，二者结果相同。var para = document.createElement(&quot;p&quot;); var txt = document.createTextNode(&quot;Hello World&quot;); para.appendChild(txt); var testdiv = document.getElementById(&quot;testdiv&quot;); testdiv.appendChild(para); 重回图片库在已有元素前插入元素DOM 提供了 insertBefore() 方法，把一个元素插入到现有元素之前。parentElement.insertBefore(newElement,targetElement);其中：parentElement：目标元素的父元素，newElement：想插入的元素，targetElement：想插入哪个元素之前。var gallery = document.getElementById(&quot;imagegallery&quot;); gallery.parentNode.insertBefore(placeholder,gallery); 在已有元素后插入元素DOM 并没有提供了 insertAfter() 方法，下面编写：function insertAfter (newElement,targetElement){ var parent = targetElement.parentNode; if(parent.lastChild == targetElement){ parent.appendChild(newElement); }else{ parent.insertBefore(newElement,targetElement.nextSibling); } } var gallery = document.getElementById(&quot;imagegallery&quot;); insertAfter(placeholder,gallery); AjaxAjax 可以做到只更新页面中的一小部分，其它内容不用重新加载。Ajax 的主要优势是对页面的请求以异步方式发送到服务器。XMLHttpRequest 对象Ajax 的核心是 XMLHttpRequest 对象，XMLHttpRequest 充当浏览器脚本与服务器之间的中间人的角色。JavaScript 可以通过这个对象自己发送请求，同时自己处理响应。function getnewContent (){ var request = new XMLHttpRequest(); if(request){ request.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true); request.onreadystatechange = function(){ if(request.readyState == 4){ var para = document.createElement(&quot;p&quot;); var txt = document.createTextNode(request.responseText); para.appendChild(txt); var testdiv = document.getElementById(&quot;testdiv&quot;); testdiv.appendChild(para); } }; request.send(null); } } 其中 readyState 属性的值，有5个可能值：0 表示未初始化1 表示正在加载2 表示加载完毕3 表示正在交互4 表示完成访问服务器返回的数据要通过两个属性完成。responseText：保存文本字符串形式的数据。responseXML：保存 Content-Type 头部指定为 “text/xml” 的数据。注意 异步请求，脚本在发送 XMLHttpRequest 请求之后仍然会继续执行，不会等待响应返回。HIjaxHIjax 意思是渐进增强地使用 Ajax 。第8章 充实文档内容JavaScript 脚本只应该用来充实文档内容，要避免使用 DOM 技术来创建核心内容。function displayAbbreviations() { if (!document.getElementsByTagName || !document.createElement || !document.createTextNode) return false; // 得到所有链接 var abbreviations = document.getElementsByTagName(&quot;abbr&quot;); if (abbreviations.length &lt; 1) return false; var defs = new Array(); // 遍历链接 for (var i=0; i&lt;abbreviations.length; i++) { var current_abbr = abbreviations[i]; if (current_abbr.childNodes.length &lt; 1) continue; var definition = current_abbr.getAttribute(&quot;title&quot;); var key = current_abbr.lastChild.nodeValue; defs[key] = definition; } // 创建列表 var dlist = document.createElement(&quot;dl&quot;); // 遍历访问键 for (key in defs) { var definition = defs[key]; var dtitle = document.createElement(&quot;dt&quot;); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); var ddesc = document.createElement(&quot;dd&quot;); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); // 添加列表项到列表中 dlist.appendChild(dtitle); dlist.appendChild(ddesc); } if (dlist.childNodes.length &lt; 1) return false; // 创建标题 var header = document.createElement(&quot;h2&quot;); var header_text = document.createTextNode(&quot;Abbreviations&quot;); header.appendChild(header_text); // 把标题添加到页面主体 document.body.appendChild(header); // 把列表添加到页面主体 document.body.appendChild(dlist); } addLoadEvent(displayAbbreviations); 我的理解就是把原本 HTML 的内容通过 JavaScript 操作提取出来摘要，再加到 HTML 中充实文档内容。第9章 CSS-DOM我们在浏览器看到的网页其实有三部分构成：结构层(structural layer) 由 XHTML 或者 HTML 等标记语言创建。表示层(presentation layer) 由 CSS 负责创建。行为层(behavior layer) 负责内容应该如何响应事件这一动作，这主要是由 javaScript 和 DOM 负责。style 属性在文档中每个人元素都是一个对象，每个元素都有一个 style 属性，他们也是一个对象。获取样式element.style.color; // 中间带连字符的 CSS 属性要使用驼峰写法 element.style.fontFamily; 获取样式属性的返回值与设置值采用同样的单位。如我们在 CSS font-size 属性时以 em 为单位，相应的 DOM fontSize 属性也以 em 为单位。注意 通过 style 获取属性的局限性，即只能返回 内联样式。&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;通过 link 元素引入的 CSS 文件样式不能用 DOM style 属性检索出来。&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;通过 &lt;head&gt; 部分引入的 &lt;style&gt; 标签里也不能用 DOM style 属性检索出来。&lt;head&gt; &lt;style&gt; hr {color:sienna;} p {margin-left:20px;} &lt;/style&gt; &lt;/head&gt; 设置样式style 对象的各个属性都是可读写的，可以通过元素的 style 属性获取样式，也可以通过它更新样式。element.style.property = value; // 例如： para.style.color = &quot;black&quot;; 何时该用 DOM 脚本设置样式在绝大多数场合还是应该使用 CSS 声明样式。在使用 CSS 不方便的场合，可以利用 DOM 对文档的样式做一些小的增强。通过 CSS 设置样式方式：// 1.通过标签元素 p { font-size: 1em; } // 2.通过class属性 .fineorint { font-size: 1em; } // 3.通过id属性 #fineorint { font-size: 1em; } 通过 DOM 脚本设置样式的情况：根据元素在节点数的位置来设置样式根据某种条件反复设置某种样式响应事件，即事件发生时设置有关元素的样式className 属性前面一直在使用 DOM 直接设置或者修改元素的样式，这种让行为层干表示层的活，并不是理想的工作方式。与其使用 DOM 直接改变某个元素的样式，倒不如通过 JavaScript 代码修改元素的 class 属性。通过修改 DOM 直接改变元素样式：function styleHeaderSiblings() { if (!document.getElementsByTagName) return false; var headers = document.getElementsByTagName(&quot;h1&quot;); for (var i=0; i&lt;headers.length; i++) { var elem = getNextElement(headers[i].nextSibling); elem.style.fontWeight = &quot;bold&quot;; elem.style.fontSize = &quot;1.2em&quot;; } } 通过修改 class 属性：function styleHeaderSiblings() { if (!document.getElementsByTagName) return false; var headers = document.getElementsByTagName(&quot;h1&quot;); for (var i=0; i&lt;headers.length; i++) { var elem = getNextElement(headers[i].nextSibling); elem.setAttribute(&quot;class&quot;,&quot;intro&quot;); } } 当然需要提前引入 CSS 样式：.intro { font-weight: bold; font-size: 1.2em; } 更简单的是通过 className 属性。className 属性是一个可读/可写的属性，凡是元素节点都有这个属性。获得元素的 class 属性：element.className修改元素的 class 属性：element.className = value通过 className 属性修改样式：function styleHeaderSiblings() { if (!document.getElementsByTagName) return false; var headers = document.getElementsByTagName(&quot;h1&quot;); for (var i=0; i&lt;headers.length; i++) { var elem = getNextElement(headers[i].nextSibling); elem.className = &quot;intro&quot;; } } 缺点：通过 className 属性设置元素的 class 属性将替换原有 class 设置。可以通过 字符串拼接 解决(注意 intro 前的空格)：elem.className += &quot; intro&quot;;第10章 用JavaScript实现动画效果JavaScript 能够按照预定的时间间隔重复调用一个函数，而这意味着我们可以随着时间的推移而不断地改变某个元素地样式。位置位置通常是由 CSS 负责设置的：element { position: absolute; top: 50px; left: 100px; } static: 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。relative: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed: 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。inherit: 规定应该从父元素继承 position 属性的值。时间JavaScript 函数 setTimeout 能让某个函数在经过一段预定的时间后才开始执行。variable = setTimeout(&quot;function&quot;,interval);第一个参数为函数名字，第二个参数为间隔时间。若想取消执行：clearTimeout(variable)本章主要是定义的一个位置随时间运动的函数：function moveElement(elementID,final_x,final_y,interval) { if (!document.getElementById) return false; if (!document.getElementById(elementID)) return false; var elem = document.getElementById(elementID); var xpos = parseInt(elem.style.left); var ypos = parseInt(elem.style.top); if (xpos == final_x &amp;&amp; ypos == final_y) { return true; } if (xpos &lt; final_x) { xpos++; } if (xpos &gt; final_x) { xpos--; } if (ypos &lt; final_y) { ypos++; } if (ypos &gt; final_y) { ypos--; } elem.style.left = xpos + &quot;px&quot;; elem.style.top = ypos + &quot;px&quot;; var repeat = &quot;moveElement(&#39;&quot;+elementID+&quot;&#39;,&quot;+final_x+&quot;,&quot;+final_y+&quot;,&quot;+interval+&quot;)&quot;; movement = setTimeout(repeat,interval); } 第11章 HTML5本章介绍了 HTML5 的新特性，包括 &lt;canvas&gt;、 &lt;audio&gt;、 &lt;video&gt; 元素及新的表单控件。第12章 综合示例结合前面的知识实现了一个综合示例，对前面的知识进行了很好的回顾。这本书看下来，感受最大的是 HTML 和 CSS 基础太差，JavaScript 部分还好。原来计划上个周末看完呢，中间又催文档啥的，这个周末（2017.10.29）才看完。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
        <tag>JavaScript编程艺术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉迷学术，不可自拔（三）]]></title>
    <url>%2Fposts%2F21b8791e.html</url>
    <content type="text"><![CDATA[或许这就是研究僧生活吧 。专硕也就两年，是时候为未来打算了。前阵老师找谈话，问将来的打算，去事业单位还是企业公司等等。“打算去互联网公司，做 Android 开发，最好能跟 GIS 有点关系，不想把整个 GIS 都丢掉。”回来就查了下阿里巴巴对 Android 工程师的要求：熟悉iOS/Android平台原理机制,具备客户端性能优化的经验有一定软件架构设计能力，熟悉常见的异步、同步、多线程、跨进程、组件、容器的设计方法具备扎实的数据结构和计算机系统基础，编码功底扎实具备C++跨平台开发经验，熟悉NDK开发优先具备创新业务技术攻关和落地能力者优先（不限于算法、生物识别、图形图像、3D建模、AR、多媒体等领域）也有查 Android 工程师的技术栈。总体来说包括以下几个方面：计算机基础，包括计算机网络、操作系统、数据库数据结构与算法Java 语言基础及设计模式Android 技术栈C++ 语言，使用 NDK 可加分React Native 、Ionic 等跨平台技术在国庆前基本上在拿着 《Java编程思想》 啃，学到了不少新的知识点，非常遗憾没有笔记。国庆假期在看 《计算机网络(第七版)》 谢希仁，基本上过了一遍，并写了阅读笔记 计算机网络阅读笔记 ，对付面试应该没问题吧。基本上国庆后就在抓紧时间做 Node.js 后端的项目，现在已经完成了所有的单元测试，除了逻辑性的错误，问题不大。然后就是 WebGIS 项目，现在在写文档阶段，打算这段时间学习下 Javascript ，尤其是 ES6 。论文外审没过，改投的 计算机应用与软件 ，今天交的审稿费，这次应该能过，感觉上面的论文跟我的差不多水。后面模型和视频叠加的技术尽快做完吧。打算简单地过一遍操作系统，然后看 Java 语言。]]></content>
      <categories>
        <category>沉迷学术</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
        <tag>沉迷学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-计算机网络（六）]]></title>
    <url>%2Fposts%2F698896b2.html</url>
    <content type="text"><![CDATA[计算机网络-应用层 部分读书笔记运输层为应用进程提供了端到端的通信服务，但不同的网络应用的应用进程之间，还需要有不同的通信规则，因此在运输层协议之上，还需要有 应用层协议。域名系统 DNS域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。域名存储：理论上：我们可以只使用一个域名服务器存储所有的域名和与之对应的IP地址。因为互联网的规模巨大，这个域名服务器一定会因为过负荷而无法正常工作。而且如果出现故障，整个互联网将进入瘫痪状态。实际上：DNS被设计成联机分布式数据库系统，并采用C/S方式。因此即使单个计算机出现故障也不会影响整个互联网的正常运行。域名结构如今互联网域名采用层次树状的命名方法。顶级域名：1.国家顶级域名 nTLDcn（中国) us(美国) uk(英国) ···2.通用顶级域名 gTLDcom(公司企业) net(网络服务机构) org(非营利性组织) int(国际组织)edu(美国专用的教育机构) gov(美国的政府部门) mil(美国的军事部门) name(个人)aero(航空运输企业) asia(亚太地区) biz(公司和企业) travel(旅游业)coop(合作团体) info(各种情况) jobs(人力资源管理者)museum(博物馆) pro(有证书的专业人员) tel(Telnic股份有限公司)mobi(移动产品与服务的用户和提供者)3.基础结构域名arpa(反向域名) 用于反向域名解析二级域名（我国）1.类别域名com(工、商、金融等企业) ac(科研机构) edu(中国教育机构 gov(中国政府机构)net(提供互联网络服务的机构) mil(中国国防机构) org(非营利性的组织)2.行政区域名bj(北京) js(江苏) sx(山西) ···域名服务器域名服务器结构理论上：在理论上来说，按照上面的域名的结构可以对照出域名服务器的结构，但是如果这样的话会有许多的域名服务器，这样导致了效率变低。实际上：实际上DNS采用了划分区的方法来解决效率低的问题。DNS服务器管辖的范围是 区 而不是 域 ，每一个区设置相应的权限域名服务器来保存该区中所有主机的域名到IP地址的映射。区可能等于或者小于域，但一定不能大于域。域名服务器的分类和作用1. 根域名服务器知道所有顶级域名服务器的域名和IP地址。只有13个域名，多台服务器使用同一个IP地址。本地域名服务器无法解析时，首先要求助根域名服务器。2. 顶级域名服务器管理所有在该顶级域名服务器中注册的二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。3. 权限域名服务器负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。4. 本地域名服务器不属于域名服务器层级结构当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者ISP，或者一个大学，甚至一个大学里的一个系，都可以拥有一个本地域名服务器。域名解析过程对于用户来说，域名解析过程只有一步，将域名向本地域名服务器查询，本地域名服务器返回查询结果。但是对于本地域名服务器来说就没这么简单了，查询方法有如下两种：1. 迭代查询1 用户向本地域名服务器查询。2 本地域名服务器向根域名服务器查询。3 根域名服务器告诉本地域名服务器下一次查询的顶级域名服务器的IP地址。4 本地域名服务器向顶级域名服务器查询。5 顶级域名服务器告诉本地域名服务器下一次查询的权限域名服务器的IP地址。6 本地域名服务器向权限域名服务器查询。7 权限域名服务器将最终的IP地址告诉本地域名服务器。8 本地域名服务器将最终的IP地址告诉用户。2. 递归查询1 用户向本地域名服务器查询。2 本地域名服务向根域名服务器查询。3 根域名服务器向顶级域名服务器查询。4 顶级域名服务器向权限域名服务器查询。5 权限域名服务器将IP地址告诉顶级域名服务器。6 顶级域名服务器将IP地址告诉根域名服务器。7 根域名服务器将IP地址告诉本地域名服务器。8 本地域名服务器将IP地址告诉用户。提高域名服务器可靠性DNS服务器把数据复制到几个域名服务器来保存，其中一个是主域名服务器 其他是辅助域名服务器 ，当主域名服务器出现故障，辅助域名服务器可以保证DNS查询工作的正常运行。主域名服务器会定期把数据复制到辅助域名服务器中。而修改数据只需要在主域名服务器操作即可保证数据的一致性。提高查询效率在域名服务器中使用高速缓存（高速缓存域名服务器） 用来存放最近查询过的域名以及从何处获取域名映射信息的记录。例如：如果不久前已经查询过 www.baidu.com 的IP地址，那么再次向本地域名服务器发出查询申请的时候，本地域名服务器并不需要向根域名服务器发出查询申请，而是直接把高速缓存中上次查询的结果告诉用户。文件传输协议文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。主进程的工作步骤如下:1.打开熟知端口（端口号为 21），使客户进程能够连接上。2.等待客户进程发出连接请求。3.启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。4.回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。在进行文件传输时，FTP 客户端和服务器之间会建立两个并行的 TCP 连接。控制进程和数据传输进程为从属进程。控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。实际用于传输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。FTP 若存取一个文件，就行必须先获取一个本地文件副本。如果要修改文件，只能对文件的副本进行修改，然后再对修改后的文件副本传回原节点。网络文件系统 NFS(Network File System)NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。对于上述例子，计算机 A 的 NFS 客户软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 的 NFS 服务器。NFS 服务器更新文件后返回应答信息。在网络上传送的只是少量的修改数据。简单文件传送协议 TFTP(Trivial File Transfer Protocol)1.TFTP 是一个很小且易于实现的文件传送协议。2.TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。3.TFTP 只支持文件传输而不支持交互。4.TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。TFTP 的 主要特点(1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。(2) 数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。(3) 支持 ASCII 码或二进制传送。(4) 可对文件进行读或写。(5) 使用很简单的首部。远程终端协议 TELNETTELNET 是一个简单的远程终端协议，也是因特网的正式标准。用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。TELNET 使用网络虚拟终端 NVT 格式客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。服务器软件把收到的数据和命令，从 NVT 格式转换成远地系统所需的格式。向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式。万维网 WWW万维网是一个大规模的、联机式的信息储藏所。客户程序向服务器发出请求，服务器程序返回客户所需的万维网文档。统一资源定位符 URL统一资源定位符 URL是用来表示从互联网上获取资源位置和访问这些资源的方法。超文本传送协议 HTTPHTTP使用TCP作为其运输层协议，面向事务的应用层协议；服务器在向客户机发送被请求的文件时，并不存储任何关于该客户机的状态信息，即HTTP是一个无状态协议；有时为了能够使Web站点识别用户，可以使用 Cookie。非持久连接和持久连接非持久连接：至多一个对象经过一个TCP连接发送。持久连接：多个对象能够经过客户机和服务器之间的单个TCP连接发送。HTTP既可以使用非持久连接，也可以使用持久连接，默认方式下HTTP使用持久连接。HTTP 报文HTTP 有两类报文：请求报文——从客户向服务器发送请求报文。响应报文——从服务器到客户的回答。由于HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。HTTP 请求报文GET /somedir/page.html HTTP/1.1 Host: www.someschool.edu Connection: close User-agent: Mozilla/4.0 Accept-language: fr HTTP 请求报文的第一行叫做请求行，其后继的行叫做首部行；请求行有3个字段：方法字段、URL字段和 HTTP 协议版本字段；方法字段可以取值GET、POST、HEAD、 PUT和DELETE。Host 首部行定义了目标所在的主机（Web代理缓存需要）；Connection 首部行值为close表示HTTP使用非持久连接 ；User-agent 首部行用来定义用户代理（即浏览器类型）；Accept-language 首部行表示用户想要得到该对象什么语言版本.HTTP 响应报文HTTP/1.1 200 OK Connection: Close Data: Thu, 03 Jul 2003 12:00:15 GMT Server: Apache/1.3.0 (Unix) Last-Modified: Sun, 6 May 2007 09:23:24 GMT Content-Length: 6821 Content-Type: text/html (data data data data data) 该响应报文同样分成3个部分：一个初始状态行，6个首部行，然后是实体主体；实体主体部分是报文的主体，包含了所请求的对象本身；状态行有3个字段：协议版本、状态码和相应状态信息。状态码：1xx 表示通知信息，如请求收到了或正在进行处理。2xx 表示成功，如接受或知道了。3xx 表示重定向，如要完成请求还必须采取进一步行动。4xx 表示客户的差错，如请求中有错误的语法或者不能完成。5xx 表示服务器的差错，如服务器失效无法完成请求。更多信息：计算机网络（三）http状态码大全Date 首部行表示服务器产生并发送该响应报文的日期和时间；Server 首部行表示该报文是由什么服务器产生的（类似请求报文里的User-agent）；Last-Modified 首部行表示对象创建或者最后修改的日期和时间；Content-Length 首部行表明了被发送对象的字节数；Content-Type 首部行表示实体主体中的对象类型.Web缓存（代理服务器）Web缓存器也叫代理服务器，是能够代表初始Web服务器来满足HTTP请求的网络实体；Web缓存器有自己的磁盘存储空间，并在该存储空间中保存最近请求过的对象的拷贝；Web缓存器可以大大减少对客户机请求的响应时间。在服务器上存放用户的信息1.万维网站点使用 Cookie 来跟踪用户。2.Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。3.使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。万维网文档超文本标记语言 HTMLHTML 并不是应用层协议，而是一种制作网页的语言。XML 可扩展标记语言，主要是传输数据。XHTML 可扩展超文本标记语言，更严格版本的HTML。动态万维网文档静态文档是指文档在创建完毕之后就存放在万维网服务器中，就不会改变了。静态文档的最大优点就是简单，可以由不懂程序设计的人员来创建。但是缺点是不够灵活。动态文档（dynamic document）是指文档的内容是在浏览器访问万维网服务器的时候才由应用程序动态创建。通用网关接口 CGICGI 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。万维网服务器与 CGI 的通信遵循 CGI 标准。“通用”：CGI 标准所定义的规则对其他任何语言都是通用的。“网关”：CGI 程序的作用像网关。“接口”：有一些已定义好的变量和调用等可供其他 CGI 程序使用。活动万维网文档活动文档(active document)技术把所有的工作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。电子邮件因特网电子邮件系统有3个主要组成部分：用户代理、邮件服务器和简单邮件传输协议；用户代理允许用户阅读、回复、转发和撰写报文；邮件服务器组成了电子邮件体系结构的核心；SMTP则是因特网电子邮件中的主要应用层协议（使用TCP传输）；一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器（使用SMTP协议），再传输到接收方的邮件服务器（使用SMTP协议），然后在这里被分发到接收方的邮箱里（POP3或IMAP）。简单邮件传送协议 SMTPSMTP 通信的三个阶段1.连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。2.邮件传送3.连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。邮件读取协议POP3 和 IMAPPOP 也使用客户服务器的工作方式。在接收邮件的用户 PC 机中必须运行 POP 客户程序，而在用户所连接的 ISP 的邮件服务器中则运行 POP 服务器程序。IMAP 协议IMAP (Internet Message Access Protocol）也是按客户服务器方式工作，现在较新的是版本 4，即 IMAP4。用户在自己的 PC 机上就可以操纵 ISP 的邮件服务器的邮箱，就像在本地操纵一样。因此 IMAP 是一个联机协议。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。IMAP 的特点:1.IMAP最大的好处就是用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。2.IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像附件（此文件可能很大）的邮件。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。3.IMAP 的缺点是如果用户没有将邮件复制到自己的 PC 机上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。动态主机配置协议 DHCP动态主机配置协议 DHCP 提供了即插即用连网(plug-and-play networking)的机制。这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。DHCP 使用客户服务器方式1.需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为 DHCP 客户。2.本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。3.DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池(address pool)中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文（DHCPOFFER）。DHCP 中继代理(relay agent)并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。租用期(lease period)DHCP 服务器分配给 DHCP 客户的 IP 地址的临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期。DHCP 协议的工作过程：1.DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。2.DHCP 客户从 UDP 端口 68发送 DHCP 发现报文。3.凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文。4.DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文。5.被选择的 DHCP 服务器发送确认报文DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。6.租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租用期。7.DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。8.DHCP 服务器若不同意，则发回否认报文DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2）。若DHCP服务器不响应步骤6的请求报文DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。9.DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。应用进程跨越网络的通信两个端系统进行通信，真正进行通信的其实是进程而不是程序。不同端系统上的进程通过跨越计算机网络交换报文而相互通信。客户机和服务器进程网络应用程序是由成对的进程组成的，对每对通信进程，通常将进程分为客户机和服务器，在Web中，浏览器是一个客户机进程，Web服务器是一个服务器进程；对于P2P文件共享，下载文件的对等方被视为客户机，上传文件的对等方被视为服务器；其具体定义为：在给定的一对进程之间的通信会话中，发起通信的进程被视为客户机，在会话开始时等待联系的进程是服务器进程与计算机网络之间的接口对于一对通信进程，进程通过被称为套接字的软件接口在网络上发送和接收报文；套接字是同一台主机内应用层与运输层之间的接口；由于该套接字是在网络上建立网络应用程序的可编程接口，因此也将该套接字称为应用程序和网络之间的应用程序编程接口（API）；应用程序开发者可以控制套接字在应用层端的所有东西，但是对该套接字的运输层端几乎没有控制；应用程序开发者对于运输层的控制仅限于：1.选择运输层协议；2.设置一些运输层参数（如最大缓存，最大报文长度）P2P 应用大多数流量密集型应用程序都是基于P2P体系的，例如文件分发、文件搜索/共享、因特网电话等等；P2P体系最突出的特性是其自扩展性；例如，在一个P2P文件共享应用中，尽管每个对等方都由请求文件产生负载，但每个对等方向其他对等方分发文件也为系统增加了服务能力；P2P通常不需要庞大的服务器基础设施和带宽]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-计算机网络（五）]]></title>
    <url>%2Fposts%2Fc86dd6b.html</url>
    <content type="text"><![CDATA[计算机网络-运输层 部分读书笔记运输层协议概述运输层提供应用进程间的逻辑通信。网络层为主机之间提供逻辑通信（网络核心部分），运输层为应用进程之间提供端到端的逻辑通信（网络边缘部分）。从运输层来看，通信是两主机应用进程之间相互通信。不同进程可以使用同一运输层协议传输数据。运输层要对收到的报文进行差错检测。在网络层，IP数据报首部的检验和字段，只检验首部而不检查数据部分。传输层的两个主要协议(1) 用户数据报协议 UDP （User Datagram Protocol）(2) 传输控制协议 TCP （Transmission Control Protocol）在 OSI 中，两个对等实体在通信时传达的数据单元叫做传输协议数据单元 TPDU 。在 TCP/IP 中，根据协议不同分别称之为TCP报文段、UDP数据段 。UDP 传输数据之前不需要先建立连接，不提供可靠交付。TCP 提供面向连接的服务，传输之前先建立连接，结束后要释放连接。不提供广播或者多播服务。运输层的端口为了使运行在不同操作系统的计算机应用程序能够相互通信，使用统一的方法（在运输层使用协议端口号）对 TCP/IP 体系的应用进程进行标志。在运输层使用协议端口使软端口，软件端口使应用层的各协议进程与传输实体进行层间交互的一种地址。硬件端口使不同硬件设备进行交互的接口。用户数据报协议 UDPUDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。UDP 的主要特点：UDP 是无连接的，即发送数据之前不需要建立连接。UDP 使用尽最大努力交付，即不保证可靠交付。UDP 是面向报文的，对应用层交下来的报文、IP层交上来的UDP数据报，不合并也不拆分。UDP 没有拥塞控制，很适合多媒体通信的要求。UDP 支持一对一、一对多、多对一和多对多的交互通信。UDP 的首部开销小，只有 8 个字节。UDP 的首部格式：源端口字段：源端口是一个大于1023的16位数字，由基于UDP应用程序的用户进程随机选择。目的端口字段：目的端口号，在终点交付报文使用。长度字段：指明了包括首部在内的UDP报文段长度。UDP长字段的值是UDP报文头的长度(8字节)与UDP所携带数据长度的总和。校验和字段：指整个UDP报文头和UDP所带的数据的校验和（也包括伪报文头）。伪首部不包括在真正的UDP报文头中，但是它可以保证UDP数据被正确的主机收到了。因在校验和中加入了伪头标，故ICMP除能防止单纯数据差错之外，对IP分组也具有保护作用。传输控制协议 TCPTCP 的主要特点：TCP 是面向连接的运输层协议。使用之前先建立建立连接，使用后释放。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。TCP 提供可靠交付的服务，使用 TCP 连接传达的数据，无差错、不丢失、不重复，并且按序到达。TCP 提供全双工通信。TCP 连接的两端都设有缓存，允许通信双方的应用进程在任何时候都能发送数据。面向字节流。TCP 把应用程序交下来的数据仅仅看成一串无结构的字节流。不保证接收方和发送方的数据块具有对应的大小关系，但是字节流完全一样，由接收方应用程序还原成有意义的应用层数据。TCP 连接是一条虚连接（逻辑连接）而不是一条真正的物理连接。TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。TCP 的连接TCP 把连接作为最基本的抽象。一条 TCP 连接有两个端点，又叫嵌套字（socket）或插口，由端口号拼接IP地址组成。嵌套字 socket = IP地址 ： 端口号每条 TCP 连接唯一地被通信两端的两个端点所确定。即：TCP 连接 = {socket1，socket2} = {（IP1：port1），（IP2：port2）}TCP 连接的端点是个很抽象的嵌套字。同一 IP 地址可以有多个 TCP 连接，同一端口号也可以出现在不同的 TCP 连接中。TCP 与 UDP 的区别：TCP 提供面向连接的服务。TCP 不提供广播或多播服务。TCP 协议数据单元的首部增大很多，还要占用许多的处理机资源。UDP 在传送数据之前不需要先建立连接。对方收到 UDP 报文后，不需要给出任何确认。在某些情况下 UDP 是一种最有效的工作方式。可靠传输的工作原理TCP 发送的报文段是交给 IP 层传递的，但是 IP 层只能提供尽最大努力服务。也就是说，TCP下面的网络所提供的是不可靠的传输。理想状态下的传输条件有两个特点：传输信道不产生差错。不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。停止等地协议 ARQARQ 协议（自动重传请求）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用 确认和超时 这两个机制，在不可靠服务的基础上实现可靠的信息传输。1、无差错情况“停止等待” 即每发送完一个分组就停止发送，等待对方确认。在收到确认后再发送下一个分组。2、出错情况B 接收分组使检测出差错就丢弃，其他什么也不做（不通知A收到有差错的分组），也可能发送过程中丢失了。A 超过一段时间没有收到确认就认为分组丢失了，因而重传前面发送过的分组。3、确认丢失和确认迟到B 发送的确认丢失，A 又重传分组，此时B放弃重复的分组并再次向 A 发送确认。A 收到重复的确认分组就放弃。为了提高传输效率，发送方可以连续发送多个分组，不必每发完一个分组就停下来等待确认，即流水线传输。流水线传输使用 连续ARQ协议和滑动窗口协议。连续 ARQ 协议接收方采用累计确认的方式。即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按需到达的最后一个分组确认，这就表示：到这分组为止的所有分组都已正确收到了。TCP 报文段TCP（Transmission Control Protocol）传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议源端口和目标端口：和 UDP 类似，源端口号和目的端口号实现分用功能；序号：本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而起数据共100字节，则下一个报文段的序号就是400。确认号：是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号。例如，B收到报文段序号字段是501，数据长度为200（字节的序号501-700），则表明B收到了A发送的到700为止的数据。因此B期望的数据序号是701，在确认报文段中确认号置为701。数据偏移：数据起始处离TCP报文段的起始处有多远。实际上是TCP报文段首部的长度，因为首部长度不固定，所以数据偏移字段是必要的。数据偏移的单位是4个字节，即首部最大长度为 4*15。保留字段： 供今后使用，目前置为0。控制位，用来说明本报文的性质：紧急URG（URGent）：当URG=1时，此报文应尽快传送，而不要按本来的列队次序来传送。与 “紧急指针” 字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长；确认ACK（ARKnowledge）：只有当ACK=1时，确认序号字段才有意义推送PSH（PuSH）：当PSH=1时，希望接收方T尽快将本报文段传送给其应用层，而不要比及全部缓存都填满了之后再向上交付。复位RST（ReSeT）：当RST=1时，表明TCP连接呈现严重错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接；同步比特SYN（SYNchronization）：在建立连接时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若接受建立连接，在响应的报文段中使SYN=1和ACK=1。所以，SYN=1默示这是一个连接请求或连接接受报文，而ACK的值用来区分是哪一种报文；终止FIN（FINis）：用来释放一个连接，当FIN=1时，表示发送方的字节串已经发完，并请求释放传输连接；其他：窗口：指出现在允许对方发送的数据量，窗口值从本报文段的确认号算起，总是动态变化着。检验和：检验和覆盖了整个的TCP报文段： TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。紧急指针：参考标志字段的URG位。选项：为了适合复杂网络环境和更好地服务于应用层设计的。TCP选项最长是40字节。数据：无任何数据的TCP段也是合法的，通常用于确认和控制信息。TCP 报文段的 选项 字段。最大报文段长度 MSS ：TCP报文段中的 数据字段 的最大长度。窗口扩大：就是为了建立TCP连接时协商扩大窗口。时间戳：包含时间戳值和时间戳回送回答字段。计算往返时间、防止序号重复使用时序号绕回。选择确认：见下节。TCP 可靠传输的实现TCP 可靠传输 的实现：确认和重传、数据校验、数据合理分片和排序、流量控制、拥塞控制。TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。发送过的数据未收到确认之前必须保留，以便超时重传时使用。发送窗口后沿变化有两种可能：发送窗口不动(没收到确认)和前移(收到新的确认)。前沿通常时不断向前移动，但也有可能不动（没有收到新的确认；收到确认但对方通知的窗口变小了）。发送缓存用来暂时存放： 发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。接收缓存用来暂时存放：按序到达的、但尚未被接收应用程序读取的数据； 不按序到达的数据。必须强调三点：A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。超时重传时间的选择TCP 采用一种自适应算法。TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。但是由于TCP的下层互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同，因此注定超时重传时间要动态变化。选择确认 SACK选择确认是针对没有出错但是未按序到达的报文段，如果中间只是缺少一些报文段，那么发送方就可以不重传已发送的所有数据，而只是重传缺少的数据。TCP 的流量控制流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制就可以实施流量控制。原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小。注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。TCP 的拥塞控制在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这种情况叫做拥塞。拥塞控制设计拥塞控制是很难设计的，因为它是一个动态的问题，许多情况下，甚至正式拥塞控制机制本身成为引起网络性能恶化甚至死锁的原因。从控制理论的角度来看拥塞控制这个问题，可以分为 开环控制和闭环控制 两种方法。开环控制 就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。闭环控制 是基于反馈环路的概念，包括如下措施：监测网路系统以便检测拥塞在何时何地发生；把拥塞发生的信息传送到可采取行动的地方；调整网络系统的行动以解决出现的问题。拥塞控制的方法TCP 拥塞控制的算法有四种，即慢开始（Slow-start)，拥塞避免（Congestion Avoidance)，快重传（Fast Restrangsmit)和快恢复（Fast Recovery）。我们假定：1）数据是单方向传送，而另外一个方向只传送确认。2）接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。1. 慢开始和拥塞避免发送方维持一个拥塞窗口(cwnd)的状态变量。其大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口小于或等于拥塞窗口。慢开始原理：当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞。比较好的方法是试探一下，即从小到达逐渐增大发送端的拥塞控制窗口数值。通常在刚刚开始发送报文段时可先将拥塞窗口cwnd(拥塞窗口)设置为一个最大报文段的MSS的数值。在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind（接收窗口）足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量– 慢开始门限 ssthresh。拥塞避免算法的思路是：让拥塞窗口cwnd线性缓慢增长。2. 快重传和快恢复快重传的算法思路是：要求接收方每收到一个时序的报文段后就立即发出重复确认，而不是等待发送数据时才进行捎带确认发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期快恢复的算法思路是：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始阀值ssthresh减半接着不执行慢开始，而是从新阀值ssthresh开始执行拥塞避免算法(加法增大)TCP拥塞控制和流量控制的差别拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。拥塞控制是一个全局过程，涉及所有主机、所有路由器，以及降低网络传输性能有关的所有因素。流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。TCP 的运输连接管理TCP是面向连接的协议，运输连接是用来传送TCP报文段的。运输连接有三个阶段：连接建立、数据传送、连接释放。在TCP连接建立过程中要解决三个问题：要使每一方知道对方的存在。要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。TCP连接的建立是采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），而被动等待连接建立的应用进程叫做服务器（sever）。TCP 的连接建立假定主机A运行的是TCP客户程序，而B运行的是TCP服务器程序。最初两端的TCP都是处于CLOSED状态。A主动打开连接，B被动打开连接。B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程A的请求。然后服务器出于LISTEN状态，等待客户A的连接请求。A的客户端进程首先创建TCB，然后向B发送连接请求报文段。这时首部中的同不好SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN（SYN = 1）报文段不能携带数据，但是要消耗一个序号。这时客户机A进入同步已发送状态（SYN-SENT）。B收到连接请求的报文段后，如果同意建立连接，则向A发送确认。在确认报文段中应当把SYN和ACK的值都置为1，确认号是ack = x + 1，同时也为自己初始化一个序号seq = y。注意该报文也不能携带数据，但是需要消耗掉一个序号。此时TCP服务器进程进入同步收到状态（SYN-RCVD）。TCP客户进程收到服务器端的确认后，还要想B发送确认。报文段的ACK置为1，确认号ack = y + 1，而自己的序号为seq = x + 1。TCP的标准规定，ACK报文段可以携带数据，如果不携带数据则不消耗序号，在这种情况下，下一个报文段的序号仍是seq = x + 1.这时TCP连接已经建立，此时A已经进入ESTABLISHED状态。当B收到确认后，也进入ESTABLISHED状态。至此，A与B已经建立连接，我们称作“三报文握手”或者“三次握手”。TCP 的连接释放当数据传输结束后，通信的上方都可以释放连接。现在A和B都处于ESTABLISHED状态。A的应用进程先向其TCP发出连接释放报文段，然后停止发送数据，主动关闭TCP连接。A的连接释放报文段把FIN置为1，其序号为seq = u，它等于前面已传送过的最后一个字节的序号加1。此时A进入FIN-WAIT-1状态，等待B的确认。TCP规定，FIN不携带数据，但是要消耗掉一个序号。B收到连接释放报文段后向A发出确认，确认号是ack = u + 1,这个报文段自己的序号是v，等于B前面已传送数据的最后一个字节的序号加1。然后B进入CLOSE-WAIT状态。TCP服务器进程这时通知高层应用进程，因而从A到B这个方向的连接就释放了，这时TCP的连接处于半关闭状态，即A已经没有数据向B发送了，但是若B仍要发送数据，A依旧要接受。也就是说从B到A这个方向的连接并未关闭。A收到来自B的报文段后进入FIN-WAIT-2状态，等待B的连续释放报文。如果B已经没有数据向A发送了，其应用进程就会通知TCP释放连接。这时B发送连续确认报文段必须使FIN = 1，现在B的序号为w（在半关闭状态，B可能又发送了一段数据）B还必须重复已经发送过的确认号ack = u + 1。这时B进入了LAST-ACK状态，等待A的确认。A在收到B的报文段后进行确认，其确认号为w + 1（TCP规定，FIN报文段需要消耗一个序号），其自己的序号为seq = u + 1。然后进入到TIME-WAIT状态。这时需要注意的是TCP连接还没有释放掉，必须经过时间等待计时器（TIME-WAIT timer）设置的2MSL（Maximum Segment Lifetime）,A才进入关闭状态。MSL叫做最大报文段寿命。上述的TCP的释放过程我们称为“四报文握手”或者“四次挥手”。TCP 的有限状态机可以非常清楚地看出 TCP 连接各种状态之间的关系。粗实线箭头表示客户机进程的正常变迁。粗虚线箭头表示服务器进程的正常变迁。细虚线表示异常变迁。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-计算机网络（四）]]></title>
    <url>%2Fposts%2F6318182c.html</url>
    <content type="text"><![CDATA[计算机网络-网络层 部分读书笔记网络层向上只提供简单灵活的、无连接、尽最大努力交付的数据报（IP数据报或分组）服务。网际协议 IP网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有三个协议：地址解析协议 ARP （Address Resolution Protocol）网际控制报文协议 ICMP （Internet Control Message Protcol）网际组管理协议 IGMP （Internet Group Management Protcol）逆地址转换协议 RARP（Reverse Address Resolution Protocol），已淘汰。虚拟互联网络虚拟互联网就是各种异构的网络逻辑上的互联网络。具体连接各异构网络的中间设备如下:物理层：网卡，网线，集线器，中继器，调制解调器链路层：网桥，交换机网络层：路由器运输层及其以上：网关IP地址的编址方法IP地址的编址方法经历了三个阶段：分类的 IP 地址、子网的划分、构成超网。分类的 IP 地址IP地址 = 网络号 + 主机号IP 地址分为五类：A 类 网络号总数：2^7 - 2 主机号总数：2^24 - 2B 类 网络号总数：2^14 - 1 主机号总数：2^16 - 2C 类 网络号总数：2^21 - 1 主机号总数：2^8 - 2注意：主机号全为 0 代表本主机所在的网络地址，全为 1 代表该网络的所有主机所有主机。A 类网络号全为 0 为保留地址，意思是本网络，网络号 127 (例如 127.0.0.1) 为本地软件环回测试地址。B类、C类网络号全为 0 (128.0.0.0、192.0.0.0) 不指派，主机号要减去全为 0 ，全为 1 的。子网的划分1. 从二级 IP 地址到三级 IP 地址IP地址 = 网络号 + 主机号 》》 IP地址 = 网络号 + 子网号 + 主机号划分子网的思路：可将物理网络划分为若干子网，对外仍然表现为一个网络划分方法是从主机号借用若干位作为子网号从其他网络发到路由器过程没有变化，但是路由器收到 IP 数据报后，再按照目的网络号和子网号，把 IP 数据报交付目的主机。2.子网掩码路由器根据子网掩码把 IP 数据报转发到子网。子网掩码和 IP 地址逐位“与”运算，得到子网的 IP 地址。默认子网掩码在不划分子网时，该网络的子网掩码就是默认网掩码。以 B 类地址为例，子网号没有 0、1、15、16 长度，划分子网要全为 0 和全为 1 的情况。构成超网无分类编址 CIDR （构造超网）1. 取消传统 A、B、C 类地址及划分子网的概念IP 地址 = 网络前缀 + 主机号2. CIRD 把网络前缀相同的连续 IP 地址组成一个 CIRD地址块 。CIRD 记法： 128.14.35.7/20/20 代表网络前缀位数20位。CIRD 使用32位的地址掩码（子网掩码），在CIRD记法中，/20 代表子网掩码 1 的个数。IP 数据报IP 数据报的完整格式IP 数据报 = 首部 （固定长度+可选字段）+ 数据更多信息查看百度百科: IP数据报IP 层转发分组流程转发分组研究的是分组怎样从一个路由器到另一个路由器的问题。IP数据报最终一定可以找到目的主机所在目的网络上的路由器(可能要通过多次的间接交付)。只有到达最后一个路由器时，才试图向目的主机进行直接交付。在互联网上转发分组时，是从一个路由器转发到下一个路由器。在路由表中，对每一条路由最主要的是以下两个信息：（目的网络地址，下一跳地址）。转发分组算法(1) 从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。(2) 若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付给目的主机（这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧）；否则就要执行(3)进行间接交付。(3) 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(4)。(4) 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(5)。(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(6)。(6) 报告转发分组出错。由此可见，在IP数据报的首部并没有指明下一跳路由器的IP地址，在IP数据报的首部只有源IP地址和目的IP地址。转发分组是基于目的主机所在的网络，路由表也没有具体指明到某个网络的完整路径。划分子网后的分组转发划分子网后，路由表中包含：目的网络地址、子网掩码、下一跳地址。(1) 从收到的分组的首部提取目的IP地址 D。(2) 先用各网络的子网掩码和D逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。(3) 若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4)。(4) 对路由表中的每一行的子网掩码和D逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)。(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。(6) 报告转发分组出错。地址解析协议 ARPIP 地址与 MAC 地址MAC 地址是链路层和物理层使用的地址。IP 地址是网络层积以上各层使用的地址。地址解析协议地址解析协议 ARP 根据 IP 地址寻找相应的硬件地址。ARP 的原理是 每台主机都有一个 ARP 高速缓存，存储本局域网的所有主机的IP地址和硬件地址的映射表。当主机A向局域网内的其他主机B发送 IP 数据报时，从ARP高速缓存中取出B的物理地址即可。如果缓存中不存在B的物理地址，则发送ARP请求分组（广播），B接收到分组发送ARP响应分组（单播），并在B的高速缓存中存储A的IP地址和物理地址。ARP 解决的是局域网上主机或者路由器 IP 与物理地址的映射问题。如果两主机在同一局域网，则通过路由器解决。RARP 逆地址解析协议，根据硬件地址查询 IP 地址。现在被包含在 DHCP 中。网际控制报文协议 ICMP为了更有效地转发 IP 数据报和提高交付成功的机会。ICMP 报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去。类型分为 ICMP 差错报告报文和 ICMP 询问报文。用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，令管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。它与传输协议最大的不同：它一般不用于在两点间传输数据，而常常用于返回的错误信息或是分析路由。ICMP控制的内容包括但不仅限于：echo响应（ping）、目标网络不可达、目标端口不可达、禁止访问的网络、拥塞控制、重定向、TTL超时…路由选择协议在Internet的概念中，将整个互联网划分为许多个小的自治系统（AS）。AS的最主要的特征：一个AS对其他AS表现出的是一个单一和一致的路由选择策略。路由选择协议分为两类：内部网关协议 IGP：在一个AS内部使用的路由选择协议，而这与互联网中其他AS选用什么路由协议无关。例如：RIP、OSPF协议。外部网关协议 EGP：若源主机和目的主机不再同一个AS中，就需要使用一种协议将路由选择信息传递到另一个AS中，这就是EGP。例如：BGP协议。内部网关协议 RIPRIP （路由信息协议）属于内部网关协议（IGP）的一种，是一种基于距离向量的路由选择协议。RIP 仅和相邻路由、按固定时间、交换本路由知道的所有信息。内部网关协议 OSPFOSPF 属于内部网关协议（IGP）的一种，基于 Dijkstra 提出的最短路径算法。OSPF提出了“区域（Area）”的概念，一个网络可以由单一区域或者多个区域组成。其中，一个特别的区域被称为骨干区域（Backbone Area），该区域是整个OSPF网络的核心区域，并且所有其他的区域都与之直接连接。所有的内部路由都通过骨干区域传递到其他非骨干区域。所有的区域都必须直接连接到骨干区域，如果不能创建直接连接，那么可以通过虚拟链路（Virtual-link）和骨干区域创建虚拟连接。外部网关协议 BGPBGP 属于外部网关协议（EGP）的一种。由于BGP是工作在AS之间的协议，并且各个AS的情况复杂，所以 BGP只是力求找到一个可以到达目的网络且比较好的路由，而并不是寻找一条最佳路由。每一个AS都应该有一个“BGP发言人”，一般来说，两个BGP发言人是通过一个共享网络连接在一起的，BGP发言人往往是BGP边界路由，但也可以不是。一个BGP发言人与其他AS的BGP发言人要交换路由信息，首先要建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话。当BGP发言人交换了路由信息后，就构造自治系统连通图，最后通过该图来进行路由选择。IPv6IPv6二进位制下为128位长度，以16位为一组，每组以冒号“:”隔开，可以分为8组，每组以4位十六进制方式表示。例如：2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的IPv6地址。IPv6 地址分为：单播：点对点通信多播：一对多通信，数据发送到一组计算机的每一个。任播：终点是一组计算机，但数据只发给其中的一个，通常是最近的一个。IPv4向IPv6过渡采用双协议栈、隧道技术等。地址转换协议 NATNAT 是一种在 IP数据报 通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。多协议标记交换 MPLSMPLS是利用标记（label）进行数据转发的。当分组进入网络时，要为其分配固定长度的短的标记，并将标记与分组封装在一起，在整个转发过程中，交换节点仅根据标记进行转发。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-计算机网络（三）]]></title>
    <url>%2Fposts%2Fd4350149.html</url>
    <content type="text"><![CDATA[计算机网络-数据链路层 部分读书笔记链路层的基本概念数据链路层属于计算机网络的低层。链路层使用的信道可分为点对点信道（PPP）和广播信道（CSMA/CD）两种。使用点对点信道的数据链路层链路 是两结点间的一段物理线路，中间没有其他交换结点。物理链路。数据链路 是链路 + 通信协议。逻辑链路。帧 – 点对点信道的数据链路层的协议数据单元。数据链路层把网络层交换来的数据构成帧发送到链路上，以及把接受的帧中的数据上交给网络层。点对点信道的数据链路层进行通信的主要步骤如下：结点A的数据链路层把网络层下发的IP数据报添加首部和尾部封装成帧；结点A把封装好的帧发给结点B的数据链路层；结点B收到的帧若无差错，则提取出IP数据报给网络层，否则丢弃这个帧。链路层基本问题封装成帧链路层将网络层传下来的IP数据报添加首部（SOH）和尾部（EOH）封装成帧，这样接收端在收到物理层上交的比特流后就能根据首尾标记知道帧的开始与结束。首位和尾部的主要作用就是进行帧定界（确定帧的界限），同时还包含一些控制信息。透明传输表示无论什么样比特组合的数据都能够通过这个数据链路层，而不会因为比特流中还有特定的帧结束或开始标志而发生传输差错。防止因传输的数据（EOT）中出现尾部控制字符而提前结束。解决办法是添加转义字符（ESC）。差错检测现实的通信链路不可避免会产生比特差错，即会有一定误码率（BER），这个和信道的信噪比有关系。为了保证数据传输可靠性，加入了一些差错检测措施，例如循环冗余检错技术（CRC）。在数据链路层进行差错校验就需要将数据划分为帧，每一帧都加上冗余码，一帧一帧地传送和校验。但是这样只能保证帧无差错传输（无比特差错），无法保证帧丢失、重复或失序等（无传输差错）情况发生。点对点协议 PPP用户通常要连接到某个ISP（Internet Service Provider）才能接入因特网。PPP协议则是用户与ISP通信时使用的数据链路层协议。PPP协议主要由三个部分组成：一个将IP数据报封装到串行链路的方法。一个用来建立、配置和测试数据链路连接的链路控制协议 LCP（Link Control Protocol）。一套网络控制协议 NCP（Network Control Protocol），其中每个协议支持不同的网络层协议。PPP协议的工作状态：使用广播信道的数据链路层广播信道可以进行一对多的通信。局域网的数据链路层局域网为一个单位所有，并且地理范围和站点数量有限。按照网络拓扑分类如下：局域网的总线网中以太网最为著名。适配器负责计算机与外界局域网通信，即“网卡”。CSMA/CD 协议载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection)。这个协议有几个要点：多点接入：总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是载波监听和碰撞检测。载波监听：发送前监听。即不管是在发送前，还是在发送中，每个站总是不停地检测总线上是否有其他站在发送数据，等信道空闲才发送。碰撞检测：适配器边发送边监听。以便判断自己发送数据时，是否也有其他站在发送数据。如果同时多个站发送数据，总线上的传输信号会电压会增大。发生碰撞时，适配器就会立即停止发送，等一段随机时间后再次发送。使用集线器的星型拓扑集线器的特点如下：使用集线器的以太网在逻辑上仍是个总线网，各站共享逻辑上的总线，各站使用的还是CSMA/CD协议。一个集线器有许多接口，像一个多接口的转发器。集线器工作在物理层，每个接口仅简单的转发比特，不进行碰检测。自适用串音回波抵消，即接口转发的较强信号对接收的较弱信号没有干扰。以太网的 MAC 层MAC 层的硬件地址硬件地址又叫物理地址、MAC地址，是主机中固化在适配器 ROM 中的地址。适配器有过滤功能。当适配器收到 MAC 帧的时会先检查帧中的目的地址，是发往本站的就接收，否则就丢弃。发往本站的帧有三种：单播（一对一）、广播（一对全部）、多播（一对多）。MAC 帧的格式首部没有帧长度、尾部是帧检验序列 FCS 。拓展的以太网在物理层拓展以太网优点是扩大了以太网覆盖的地理范围，缺点是当某个系的两站通信时所传送的数据会通过所有的集线器转发，其他系内部在这时都不能通信。在链路层拓展以太网通过以太网交换机实现，实质是多接口的网桥。具有并行性，相互通信的主机都是独占传输媒体，无碰撞得传输数据。通过自学习建立帧交换表，按照帧目的 MAC 转发，即插即用。虚拟局域网虚拟局域网 VLAN，是由一些网段构成的与物理位置无关的逻辑组。在 VLAN 中的帧都有明确的标识符，指明该帧属于哪个 VLAN。高速以太网100BASE-T 以太网（百兆以太网）吉比特以太网（千兆以太网）10吉比特以太网（万兆以太网）]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-计算机网络（二）]]></title>
    <url>%2Fposts%2Fe65336e0.html</url>
    <content type="text"><![CDATA[计算机网络-物理层 部分读书笔记物理层的基本概念物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是具体的传输媒体。物理层的作用就是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这种差异。物理层的主要任务是确定与传输媒体接口相关的一些特性，即：机械特性，指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。电气特性，指明在接口电缆的各条线上出现的电压的范围。功能特性，指明某条线上出现的某一电平的电压表示何意。过程特性，规程特性 指明对于不同功能的各种可能事件的出现顺序。数据通信的基础知识信道 是向某一方向发送信息的媒体。可分为三种基本方式：单向通信，单工，只能从一个方向到另一个方向。双向交替通信，半双工，双方都可以接收和发送，但不能同时发送。双向同时通信，全双工，可以同时发送信息，也可以同时接受信息。单项通信只需要一条信道，其余两种需要两条信道。物理层下的传输媒体传输媒体也称传输媒介或传输介质，数据传输系统中在发送器和接收器之间的物理通路。引导型传输媒体：双绞线、同轴电缆、光纤等非引导型传输媒体：无线电微波、卫星通信等信道复用技术信道复用技术就是使用复用器和分用器将原本需要多个信道传输的信息通过单个信道传输。频分复用（FDM）：不同的用户分配不同的频带。时分复用（TDM）及统计时分复用（STDM）：TDM 每个用户周期性占用信道。但是用户暂无数据时，信道利用率不高：STDM 用户没有数据就跳过，动态分配时序。波分复用（WDM）：针对光纤的频分复用。码分复用（CDM）：码分多址，不同的用户采用不同的码型。感觉前两种侧重于模拟信号，后两种侧重于数字信号。宽带接入技术ADSL 技术，非对称数字用户线。模拟电话用户线基础上。HFC 网，光纤同轴混合网。有线电视网基础上。FTTx 技术，包括光纤到路边（FTTC）、光纤到大楼（FTTB）及光纤到户（FTTH）等等。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-计算机网络（一）]]></title>
    <url>%2Fposts%2F4962ad82.html</url>
    <content type="text"><![CDATA[具备扎实的数据结构和计算机系统基础，编码功底扎实现在应该为找工作做准备了，先打好计算机基础吧。这也算是《计算机网络》的读书笔记吧。互联网相关概念网络分为电信网络、有线电视网络、计算机网络。互联网（Internet）是一个专有名词，指当今世界上最大的计算机网络。互连网（internet）是一个通用名词，泛指多个计算机网络互连而形成的计算机网路，即“网络的网络”。计算机网络由若干结点和链路组成。经历了三个发展阶段：第一分阶段是从单一网络 ARPANET 向互连网发展的过程；第二个阶段是建成了三级结构的互联网，分为主干网、地区网和校园网（或企业网）；第三个阶段是多层次 ISP （网络服务提供商） 结构的互联网。互联网的组成互联网从工作方式上来看，客户分为两部分：边缘部分，用户直接使用的；核心部分，为边缘部分提供服务的。互联网的边缘部分就是连接到互联网上的所有主机，又称为端系统。计算机之间的通信，即主机A的某个进程和主机B的另一个进程进行通信，进程就是指运行着的程序。在网络边缘的端系统之间的通讯方式分为两类，客户/服务器方式（C/S方式）和对等方式（P2P方式），认为浏览器/服务器方式（B/S）是C/S的一种特例。互联网的核心部分向网络边缘的主机提供连通性，使任何一台主机都能向其他主机通信。分组交换采用存储转发技术，把一个报文划分为几个分组后再进行传送。在发送整块数据之前，先把整块数据分为等长的数据段，在每段数据段前加上由一些必要信息组成的首部，就构成了一个分组。 报文（message）是发送的整块数据；分组（packet）又称为包，分组的首部也叫包头。计算机网络的类别从网的作用范围来看，可分为：广域网（Wide Area Network，WAN）城域网（Metropolitan Area Network，MAN）局域网（Local Area Network，LAN）个人区域网（Personal Area Network，PAN）计算机网络的性能1.速率，数据的传送速率，或称数据率、比特率,单位 bit/s。比特（binary digit，bit），二进制数字的 0 或 1 。字节（byte，B），通常 1B = 8bit 。2.带宽（bandwidth），即速率。3.吞吐量（throughup），单位时间通过某网络（或信道、接口）的实际数据量。吞吐量受网络的带宽和网络的额定速率的限制。4.时延 ，数据从网络的一端传送到另一端的时间，也称为延迟、迟延。由以下几部分组成：发送延时，主机或者路由器发送数据帧所需要的时间。传播时延，电磁波在信道中传播一段距离所需要的时间。处理时延，主机或路由器收到分组后的处理时间。排队时延，分组进入路由器后要在输入队列中排队等待处理。总时延 = 发送延时 + 传播延时 + 处理延时 + 排队延时。5.时延带宽积，传播时延和带宽的乘积，代表链路的容纳多少比特。6.往返时间 RTT ，数据双向交互一次所需的时间。计算机网络体系结构OSI/RM (Open System Interconnect 简称OSI) 开放系统互连参考模型 是国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。TCP/IP (Transmission Control Protocol/Internet Protocol，简称TCP/IP) 传输控制协议/因特网互联协议 是四层结构。它从低到高分别是：网络接口层、网际层、传输层和应用层。学习计算机网络采用折中的方法，具有五层协议的体系结构。(1)应用层 是应用进程间通信交互的规则。对于不同的网络应用采用不同的协议，如 DNS、HTTP、SMTP 等。(2)运输层 是两主机进程间通信的通用数据传输服务。“通用”指不针对某个特定网络应用，多种应用可以使用同一个运输层服务。运输层具有复用和分用的功能。传输层有两种协议：传输控制协议 TCP（Transmission Control Protocol）提供面向链接的、可靠的数据传输服务，传输单位是报文段（Segment）。用户数据报协议 UDP（User Datagram Protocol）提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），传输单位是用户数据报。(3)网络层 负责为分组交换网上的不同主机提供通信服务。在发送数据时将网络层的数据封装成分组或包进行传送。在 TCP/IP 协议中，网络层使用IP协议，因此分组也叫 IP 数据报，简称数据报。无论在哪层传送的数据单元，都可成为分组。(4)数据链路层 数据在链路上传送的协议。两节点传递数据时，链路层将网络层的 IP 数据报组装成帧（framing），在两个相邻节点间的链路上传递帧（frame）。(5)物理层 传递数据的单位是比特。例如考虑多大电压是 1 或 0 ，以及如何识别，电线插头的引脚数以及引脚如何连接等属于物理层的范围。传递信息的媒介，如双绞线、光纤等不在物理层，有人称之为 0 层。TCP/IP 的体系结构 并不是严格遵守 OSI 分层的概念。TCP/IP 可以为各式各样的应用提供服务，同时也允许协议在各式各样的网络构成的互联网上运行。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉迷学术，不可自拔（二）]]></title>
    <url>%2Fposts%2F52a7a0b6.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;这阵子应该是比较消极的一阵了，八月底放假了但是没回家，基本还是学习为主。基本刷了一遍 jQuery 的教程。&nbsp;&nbsp;&nbsp;&nbsp;Android 方面尝试了 Google VR SDK for Android 做全景应用，也开发了 Demo 。本来是希望能用在壁纸上，但是遇到问题了。后面打算用 GLWallpaperService 用 OpenGL ES 渲染，不过感觉可能性不大。&nbsp;&nbsp;&nbsp;&nbsp;开学事情挺多的，报道、开学典礼、选课挺折腾人的。论文没过又投了下，希望能过。&nbsp;&nbsp;&nbsp;&nbsp;现在干活基本没什么动力了，每天上课心力憔悴，基本都是摄影测量遥感相关的课程。宿舍距离学校又有段距离，每次上课都不想来，来了不想回宿舍。&nbsp;&nbsp;&nbsp;&nbsp;感觉还是本科好点，干的都是自己喜欢想做的事。现在这都跟打杂差不多，啥都干。]]></content>
      <categories>
        <category>沉迷学术</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
        <tag>沉迷学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NullPointerException]]></title>
    <url>%2Fposts%2F9f6df7dc.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;NullPointerException是 java.lang.NullPointerException 的简称，是 Java 语言中的一个异常类，位于 java.lang 包中，父类是 java.lang.RuntimeException ，该异常在源程序中可以不进行捕获和处理。&nbsp;&nbsp;&nbsp;&nbsp;当应用程序试图在需要对象的地方使用 null 时，抛出该异常。这种情况包括：调用 null 对象的实例方法。访问或修改 null 对象的字段。如果一个数组为 null，试图用属性 length 获得其长度时。如果一个数组为 null，试图访问或修改其中某个元素时。在需要抛出一个异常对象，而该对象为 null 时。应用程序将会抛出 NullPointerException 类的实例，表明其他对 null 对象的非法使用。]]></content>
      <tags>
        <tag>NullPointerException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沉迷学术，不可自拔（一）]]></title>
    <url>%2Fposts%2F1d34da54.html</url>
    <content type="text"><![CDATA[“城外的人想冲进去，城里的人想逃出来。”来武汉一个月了，相比较而言可能我还算比较幸运，至少没有到“帮老师办签证订机票”的地步。刚来到做的是前端的项目，其实真是没有一点经验，前面只是能看懂一点代码，并没怎么系统地学习。做Javastript也是可以的，后面做Rect Native等跨平台开发也是有帮助的。前端的东西太多了，现在还没学好，实际帮助也不多。后来又写了一点Node.js的东西，主要是利用Egg.js对Mongodb进行增删查改 CURD 操作，现在反正已经趟了一趟浑水了。最大的收获就是对网络的一些基础知识的理解，虽然考了计算机三级，然而并没有什么卵用。中间写了一篇论文投到测绘科技了，感觉中的可能性不大，太简单了。使用DataV做了一点可视化，但是感觉限制太多，字段太少了。现在还有一点时间，在学 Android ,希望能进阶下。武汉的空气不错，蓝蓝的天下白云飘。有时候在想，是读研好还是工作好呢。这个问题似乎也没有什么意义了。]]></content>
      <categories>
        <category>沉迷学术</category>
      </categories>
      <tags>
        <tag>胡思乱想</tag>
        <tag>沉迷学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业感想]]></title>
    <url>%2Fposts%2F3efac350.html</url>
    <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp; &nbsp; 正如毕业论文致谢中所说： “回想四年来的学习生活，既有成功时的喜悦，也有失败时的痛楚。”&nbsp; &nbsp; &nbsp; &nbsp; 先看下我们那时吹过的牛逼，年少轻狂啊。&nbsp; &nbsp; &nbsp; &nbsp; 其实当时志愿报的通信工程，电气工程及其自动化，机械工程及其自动化等，最后调剂到地理信息科学专业。记得当时我跟学姐说我调剂了，学姐说，没准我可能喜欢这个专业，庆幸事实也是如此。我至今依然认为 GIS 专业是个很好的专业。和地理信息科学专业相比，我更喜欢 GIS 这个称谓，因为大多数听到地理信息科学老是认为我们是学地理的，事实我感觉 GIS 专业偏计算机更多一点。&nbsp; &nbsp; &nbsp; &nbsp; 大一印象最深刻就是军训了，当时觉得也没啥，同样记得是学姐说，大学四年军训也是印象很深刻的一段回忆了。但是当时整个人都是懵逼的状态，谁也不知道谁，后来翻看照片。哦，原来这个是舍友啊。上学期还是比较浪的，去过河南省博物院、二七塔。我记得有一节课郭老师问，有谁去过河南省博物院，我们宿舍很骄傲啊。暑假的时候就去了陈老师的公司，也是很惬意，GIS 最基础的工作了。&nbsp; &nbsp; &nbsp; &nbsp; 大二就开始逃课了，也是当时对 GIS 有一点认识，算是启蒙吧。当时觉得 AR 很好，也了解一点。后来就跟着骆老师和赵老师参加ESRI的比赛，也是最开始接触 Android 开发。https://fir.im/zzumap. 至今非常感谢刘学长的指导。&nbsp; &nbsp; &nbsp; &nbsp; 我觉得大三是成长最快的一年，包括学习以及其他方面。知道自己该做什么，不该做什么，不至于一天到无所事。下学期也非常荣幸能跟着李老师做项目，也给了我很多机会。后来我发现，其实原来在大一暑假的时候参加比赛分组，李老师就联系过我，只不过我当时去陈老师的公司了。&nbsp; &nbsp; &nbsp; &nbsp; 大四也就是考研了，这也没有啥，有好基友在一块，只要能坚持下来就好了。毕业了，各奔东西。有人月薪2000，有人月薪8000+，年薪20万也有人在。开心就好。&nbsp; &nbsp; &nbsp; &nbsp; 有些事我知道，有些事我不知道。&nbsp; &nbsp; &nbsp; &nbsp; 现在大概走在通往全栈的不归路上，沉迷学术，不可自拔。一直觉得大学四年了得留一段文字记录下，防止以后忘了，今天终于如愿。2017年7月30日于武汉大学信息学部​​​​]]></content>
      <tags>
        <tag>胡思乱想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文查重删除部分文章]]></title>
    <url>%2Fposts%2F971444b9.html</url>
    <content type="text"><![CDATA[毕业论文查重会涉及到网络查重，先删除部分文章。。涉及到内容也不是很多，后面分享要注意啊，发过论文再写。]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-11、自定义扩展图层加载Google地图/高德地图并缓存]]></title>
    <url>%2Fposts%2Ff1483927.html</url>
    <content type="text"><![CDATA[本文主要介绍自定义扩展图层加载Google地图/高德地图并缓存概述上篇文章介绍了自定义扩展图层加载天地图并缓存，由于众所周知的原因，天地图并不一定能满足所有项目需要，并不一定符合实际国情，所以这篇文章介绍自定义扩展图层加载Google地图/高德地图，因为 Google地图（http://ditu.google.cn ）/ 高德地图（http://ditu.amap.com ）的坐标系比较符合“中国特色坐标系“。事实上加载Google地图/高德地图和加载天地图类似，甚至前者还要更简单。Google Map瓦片地址：http://mt2.google.cn/vt/lyrs=m&amp;hl=zh-CN&amp;gl=cn&amp;x=420&amp;y=193&amp;z=9核心代码如下：@Override protected byte[] getTile(int level, int col, int row) throws Exception { if (level &gt; layerInfo.getMaxZoomLevel() || level &lt; layerInfo.getMinZoomLevel()) { return new byte[0]; } byte[] bytes = null; if (cachePath != null) bytes = getOfflineCacheFile(cachePath, level, col, row); if (bytes == null) { String url = &quot;http://mt&quot; + (col % 4) + &quot;.google.cn/vt/lyrs=&quot; + layerInfo.getLayerName() + &quot;&amp;hl=zh-CN&amp;gl=cn&amp;&quot; + &quot;x=&quot; + col + &quot;&amp;&quot; + &quot;y=&quot; + row + &quot;&amp;&quot; + &quot;z=&quot; + level; Log.d(&quot;GoogleMapLayer&quot;, &quot;getTile: &quot; + url); Map&lt;String, String&gt; map = null; bytes = com.esri.core.internal.io.handler.a.a(url, map); if (cachePath != null) AddOfflineCacheFile(cachePath, level, col, row, bytes); } return bytes; } 其中String url = &quot;http://mt&quot; + (col % 4) + &quot;.google.cn/vt/lyrs=&quot; + layerInfo.getLayerName() + &quot;&amp;hl=zh-CN&amp;gl=cn&amp;&quot; + &quot;x=&quot; + col + &quot;&amp;&quot; + &quot;y=&quot; + row + &quot;&amp;&quot; + &quot;z=&quot; + level; 可以更改为String url = &quot;https://mt&quot; + (col % 4) + &quot;.google.com/vt/lyrs=&quot; + layerInfo.getLayerName() + &quot;&amp;hl=zh-CN&amp;gl=cn&amp;&quot; + &quot;x=&quot; + col + &quot;&amp;&quot; + &quot;y=&quot; + row + &quot;&amp;&quot; + &quot;z=&quot; + level; 但是这个URL不太符合目前的中国的国情。按照惯例下面是我封装好的Jar包。Jar包下载地址：ArcGMap.jar使用方法：GoogleMapLayer（TYPE，PATH）； TYPE：有一下三种类型可选PATH：缓存路径{选填}，为空则不缓存。package com.wshunli.map.arcgmap; /** * 项目：ArcGMap * 作者：WangShunli * 时间：2017/3/2 14:34 * 邮箱：admin@wshunli.com * 说明： */ public interface GoogleMapLayerTypes { /** * 谷歌矢量地图服务 */ final int VECTOR_GOOGLE_MAP = 1; /** * 谷歌影像地图服务 */ final int IMAGE_GOOGLE_MAP = 2; /** * 谷歌地形地图服务 */ final int TERRAIN_GOOGLE_MAP = 3; } 示例代码：GoogleMapLayer GOOGLE_VECTOR_Layer = new GoogleMapLayer(GoogleMapLayerTypes.VECTOR_GOOGLE_MAP, ZZMANHOLE_PATH + &quot;/GMapCacheDemo&quot;); 高德地图瓦片地址：http://webst01.is.autonavi.com/appmaptile?style=6&amp;x=13417&amp;y=6499&amp;z=14核心代码如下：@Override protected byte[] getTile(int level, int col, int row) throws Exception { if (level &gt; layerInfo.getMaxZoomLevel() || level &lt; layerInfo.getMinZoomLevel()) { return new byte[0]; } byte[] bytes = null; if (cachePath != null) bytes = getOfflineCacheFile(cachePath, level, col, row); if (bytes == null) { String url = &quot;http://webst0&quot; + ((col + row) % 4 + 1) + &quot;.is.autonavi.com/appmaptile?style=&quot; + layerInfo.getLayerName() + &quot;&amp;x=&quot; + col + &quot;&amp;y=&quot; + row + &quot;&amp;z=&quot; + level; Map&lt;String, String&gt; map = null; bytes = com.esri.core.internal.io.handler.a.a(url, map); if (cachePath != null) AddOfflineCacheFile(cachePath, level, col, row, bytes); } return bytes; } 高德地图还可以获取路况信息：http://history.traffic.amap.com/traffic?type=2&amp;day=7&amp;hh=11&amp;mm=0&amp;x=13417&amp;y=6499&amp;z=14 道理是一样的。按照惯例下面是我封装好的Jar包。Jar包下载地址：ArcAMap.jar使用方法：AMapLayer（TYPE，PATH）； TYPE：有一下三种类型可选PATH：缓存路径{选填}，为空则不缓存。package com.wshunli.map.arcamap; /** * 项目：ArcAMap * 作者：WangShunli * 时间：2017/3/3 10:19 * 邮箱：admin@wshunli.com * 说明： */ public interface AMapLayerTypes { /** * 高德矢量地图服务 */ final int VECTOR_AMAP = 1; /** * 高德影像地图服务 */ final int IMAGE_AMAP = 2; /** * 高德地形路网服务 */ final int ROAD_AMAP = 3; } 示例代码：AMapLayer AMAP_VECTOR_Layer = new AMapLayer(AMapLayerTypes.VECTOR_AMAP, ZZMANHOLE_PATH + &quot;/AMapCacheDemo&quot;); 参考资料1、ArcGIS For Android 使用谷歌地图服务 - 牧羊的专栏 - 博客频道 - CSDN.NEThttp://blog.csdn.net/u014014578/article/details/214763952、客户端地图拼图算法解析 - 九毫 - 博客园http://www.cnblogs.com/ninemilli/archive/2011/12/26/2289285.html3、OpenStreetMap/Google/百度/Bing瓦片地图服务(TMS) - 可可西 - 博客园http://www.cnblogs.com/kekec/p/3159970.html4、国内主要地图瓦片坐标系定义及计算原理 | CntChen Bloghttp://cntchen.github.io/2016/05/09/国内主要地图瓦片坐标系定义及计算原理/5、Arcgis for js加载百度地图 - LZUGIS - 博客频道 - CSDN.NEThttp://blog.csdn.net/gisshixisheng/article/details/448537096、jxsapp/ArcGis_moka: arcgis Android 加载 Google 地图 相关工具包https://github.com/jxsapp/ArcGis_moka7、ArcGIS Javascript API 加载高德在线地图扩展 - ThinkGIShttp://www.thinkgis.cn/topic/55bed4f76edd0d1a1d9f44cf]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-10、自定义扩展图层加载天地图并缓存]]></title>
    <url>%2Fposts%2Feeb67a5.html</url>
    <content type="text"><![CDATA[本文主要介绍自定义扩展图层加载天地图并缓存国家地理信息公共服务平台“ 天地图 ”（以下简称“天地图“）是国家测绘地理信息局主导建设的网络化地理信息共享与服务门户，集成了来自国家、省、市（县）各级测绘地理信息部门，以及相关政府部门、企事业单位 、社会团体、公众的地理信息公共服务资源，向各类用户提供权威、标准、统一的在线地理信息综合服务。“天地图”属于基础性、公益性服务平台，针对不同用途设计了多种数据版本和服务模式，用户可根据自身需求进行使用。基本情况如下：1、基于 OGC 的 WMTS 1.0.0版本；2、提供矢量地图、影像地图和地形图；3、提供两种坐标系：国家2000大地坐标系和 Web Mercator 投影坐标系；4、地图和标注数据分开，矢量地图和影像地图提供中英文标注，地形图仅提供中文标注。核心代码如下：protected byte[] getTile(int level, int col, int row) throws Exception { if (level &gt; layerInfo.getMaxZoomLevel() || level &lt; layerInfo.getMinZoomLevel()) return new byte[0]; byte[] bytes = null; if (cachePath != null) bytes = getOfflineCacheFile(cachePath, level, col, row); if (bytes == null) { String url = layerInfo.getUrl() + &quot;?service=wmts&amp;request=gettile&amp;version=1.0.0&amp;layer=&quot; + layerInfo.getLayerName() + &quot;&amp;format=tiles&amp;tilematrixset=&quot; + layerInfo.getTileMatrixSet() + &quot;&amp;tilecol=&quot; + col + &quot;&amp;tilerow=&quot; + row + &quot;&amp;tilematrix=&quot; + (level + 1); Map&lt;String, String&gt; map = null; bytes = com.esri.core.internal.io.handler.a.a(url, map); if (cachePath != null) AddOfflineCacheFile(cachePath, level, col, row, bytes); } return bytes; } 我把整个项目封装成Jar包以供调用。下载地址：tianditu.jar支持的天地图图层类型：package com.wshunli.map.tianditu; /** * 项目：TiDiTu * 作者：WangShunli * 时间：2016/4/9 11:33 * 邮箱：admin@wshunli.com * 说明： */ public interface TianDiTuLayerTypes { /** * 天地图矢量墨卡托投影地图服务 */ final int TIANDITU_VECTOR_MERCATOR = 0; /** * 天地图矢量墨卡托中文标注 */ final int TIANDITU_VECTOR_ANNOTATION_CHINESE_MERCATOR = 1; /** * 天地图矢量墨卡托英文标注 */ final int TIANDITU_VECTOR_ANNOTATION_ENGLISH_MERCATOR = 2; /** * 天地图影像墨卡托投影地图服务 */ final int TIANDITU_IMAGE_MERCATOR = 3; /** * 天地图影像墨卡托投影中文标注 */ final int TIANDITU_IMAGE_ANNOTATION_CHINESE_MERCATOR = 4; /** * 天地图影像墨卡托投影英文标注 */ final int TIANDITU_IMAGE_ANNOTATION_ENGLISH_MERCATOR = 5; /** * 天地图地形墨卡托投影地图服务 */ final int TIANDITU_TERRAIN_MERCATOR = 6; /** * 天地图地形墨卡托投影中文标注 */ final int TIANDITU_TERRAIN_ANNOTATION_CHINESE_MERCATOR = 7; /** * 天地图矢量国家2000坐标系地图服务 */ final int TIANDITU_VECTOR_2000 = 8; /** * 天地图矢量国家2000坐标系中文标注 */ final int TIANDITU_VECTOR_ANNOTATION_CHINESE_2000 = 9; /** * 天地图矢量国家2000坐标系英文标注 */ final int TIANDITU_VECTOR_ANNOTATION_ENGLISH_2000 = 10; /** * 天地图影像国家2000坐标系地图服务 */ final int TIANDITU_IMAGE_2000 = 11; /** * 天地图影像国家2000坐标系中文标注 */ final int TIANDITU_IMAGE_ANNOTATION_CHINESE_2000 = 12; /** * 天地图影像国家2000坐标系英文标注 */ final int TIANDITU_IMAGE_ANNOTATION_ENGLISH_2000 = 13; /** * 天地图地形国家2000坐标系地图服务 */ final int TIANDITU_TERRAIN_2000 = 14; /** * 天地图地形国家2000坐标系中文标注 */ final int TIANDITU_TERRAIN_ANNOTATION_CHINESE_2000 = 15; } 调用方法示例：package com.wshunli.map.tianditu.sample; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import com.esri.android.map.MapView; import com.esri.android.map.event.OnZoomListener; import com.wshunli.map.tianditu.TianDiTuLayer; import com.wshunli.map.tianditu.TianDiTuLayerTypes; /** * 项目：TiDiTuDemo * 作者：WangShunli * 时间：2017/3/2 12:38 * 邮箱：admin@wshunli.com * 说明： */ public class MainActivity extends AppCompatActivity { public static String TDT_PATH = android.os.Environment.getExternalStorageDirectory() + &quot;/TDTCacheDemo&quot;; MapView mMapView; //矢量地图 public TianDiTuLayer vec_c; //矢量标注 public TianDiTuLayer cva_c; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mMapView = (MapView) findViewById(R.id.map); vec_c = new TianDiTuLayer(TianDiTuLayerTypes.TIANDITU_VECTOR_2000, TDT_PATH); mMapView.addLayer(vec_c); cva_c = new TianDiTuLayer(TianDiTuLayerTypes.TIANDITU_VECTOR_ANNOTATION_CHINESE_2000, TDT_PATH); mMapView.addLayer(cva_c); /** * 解决天地图标注覆盖问题 */ mMapView.setOnZoomListener(new OnZoomListener() { @Override public void preAction(float v, float v1, double v2) { } @Override public void postAction(float v, float v1, double v2) { cva_c.clearTiles(); } }); } } 参考资料1、ArcGIS读取天地图2.0 - ArcGIS产品与技术专栏 - 博客频道 - CSDN.NEThttp://blog.csdn.net/arcgis_all/article/details/88481202、arcgis api for android 叠加天地图 - 阿华博台 - 博客频道 - CSDN.NEThttp://blog.csdn.net/yu624774720hua/article/details/87553983、入门Android开发–ArcGis读取天地图，并实现一些简单功能。 - 从入门到忘记 - 博客频道 - CSDN.NEThttp://blog.csdn.net/u013867301/article/details/510362004、arcgis for android 本地缓存 | 大光的博客http://daguang.me/2013/08/01/arcgis-for-android-本地缓存/5、Android开发，arcgis自定义layer-历史影像和地图缓存的实现 - 博客频道 - CSDN.NEThttp://blog.csdn.net/Stanny_Bing/article/details/53736659]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-9、ArcGIS for Android 常用数据加载方法]]></title>
    <url>%2Fposts%2Fef27f7d3.html</url>
    <content type="text"><![CDATA[ArcGIS for Android 支持的空间数据类型ArcGIS Runtime SDK for Android支持的空间数据源有多种，主要分为3大类：ArcGIS在线数据源、ArcGIS离线数据源（自10.2版本起），以及第三方数据源，详细的类别支持请见下表：数据源类型数据源名称ArcGIS在线数据源切片地图服务（ArcGISTiledMapServiceLayer）、动态地图服务（ArcGISDynamicMapServiceLayer）、影像服务（ArcGISImageServiceLayer）、要素服务（ArcGISFeatureLayer）ArcGIS离线数据源紧凑型切片（ArcGISLocalTiledLayer）、tpk切片包（ArcGISLocalTiledLayer）、.geodatabase数据文件（GeodatabaseFeature）、.shp文件（ShapefileFeatureTable）、地名地址库（Locator）、网络数据集（Network Dataset）第三方数据源Bing地图（BingMapsLayer）、Open Street map（OpenStreetMapLayer）、OGC图层（KMLLayer、WMSLayer）、第三方自定义扩展图层ArcGIS for Android 常用数据加载方法ArcGISTiledMapServiceLayerArcGISTiledMapServiceLayer图层对应ArcGIS for Server服务中的切片服务，由于切片都是事先做好的，ArcGISTiledMapServiceLayer不能对图层中的数据进行更改，除非更新服务缓存，在ArcGIS Runtime SDK for Android中，也不允许对此类型的数据进行查询，通常用做底图使用。同时，因为加载的是缓存切片，这个类型的图层是ArcGIS Runtime SDK for Android中相应请求最快的图层之一，它采用多个线程，通常是使用单独线程来处理请求和绘制图片，并且异步处理。用法如下：map = (MapView)findViewById(R.id.map); // Add tiled layer to MapView ArcGISTiledMapServiceLayer tileLayer = new ArcGISTiledMapServiceLayer(&quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer&quot;); map.addLayer(tileLayer); ArcGISDynamicMapServiceLayerArcGISDynamicMapServiceLayer图层对应ArcGIS for Server服务中的动态服务，动态地图服务的地图数据是按照移动设备范围读取的。 ArcGISDynamicMapServiceLayer图层通常包含多个图层，这些图层由server根据请求来渲染并以raster image形式返回，并且返回的raster并不包含feature的额外信息。它的功能特点是更新非常方便，并能及时呈现给用户，同时，图层的可视性和空间参考可以改变，可以给图层添加单独的layer definition，ArcGIS for Server为每个image动态投影，而地图的空间参考是由第一个加载的图层决定。它的性能特点是，它的渲染时间取决于请求数据的数量和复杂度，因此一般都比tiled map server要慢，因此，它适合数据经常发生改变、或者需要针对不同的用户呈现不同的数据，且要素信息（如attributes，geometry，symbol等）不需要的情况。它的用法与ArcGISTiledMapServiceLayer图层相同，示例代码如下：map = (MapView)findViewById(R.id.map); // Add DynamicMapServiceLayer to MapView ArcGISDynamicMapServiceLayer agsDynlyr = new ArcGISDynamicMapServiceLayer(&quot;http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Demographics/ESRI_Population_World/MapServer&quot;); map.addLayer(agsDynlyr); 在国内的话可以使用智图 提供的全国基础地图服务服务地址：http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServerArcGISImageServiceLayerArcGISImageServiceLayer图层对应ArcGIS for Server服务中的影像服务，它为移动端使用影像数据提供了一种途径，通过这种方式调用的影像数据通常可以用来作为底图。调用影像服务也非常简单，同调用上述服务一样，示例代码如下：map = (MapView)findViewById(R.id.map); map.addLayer(new ArcGISImageServiceLayer(&quot;http://myserver/arcgis/rest/services/MyImage/ImageServer&quot;,null)); ArcGISFeatureLayerArcGISFeatureLayer图层对应ArcGIS for Server服务中的Feature Service，该图层可以是空间图层，也可以是非空间的表，该图层包含了要素最丰富的信息，其中的每个要素都能被空间查询和SQL查询。从Feature Service中请求要素时以JSON格式返回，每个要素都单独渲染，因此与其它图层类型相比，要素图层具有最丰富的功能。只有Feature Service（要素服务）才可以具备在线数据编辑功能，因此，如果想要对某个数据进行在线编辑或同步，需要将其发布成Feature Service，并在移动端新建一个ArcGISFeatureLayer图层以加载该服务。该图层有一些设定，这些设定能影响图层的性能，包括请求时间，返回大小、处理和响应时间等（设置需要在图层initialized完成之后进行）。ArcGISFeatureLayer图层继承自GraphicsLayer，因此也具有该图层的所有操作。调用该图层的示例代码如下：String url = &quot;https://servicesbeta.esri.com/ArcGIS/rest/services/SanJuan/TrailConditions/FeatureServer/0&quot;; map = (MapView)findViewById(R.id.map); //按照快照方式加载该图层 map.addLayer(new ArcGISFeatureLayer(url,MODE.ONDEMAND)); setContentView (map); 加载tpk和紧凑型切片ArcGISLocalTiledLayer是ArcGIS Runtime SDK for Android中专门用来添加离线数据包（底图）的图层，该图层目前支持两种格式的离线数据：一个是紧凑型切片，另一个就是tpk。使用起来也很简单，实例化该类的一个对象，并在构造函数中输入数据的路径即可，代码示例如下：map = (MapView)findViewById(R.id.map); // Add Local tiled layer to MapView ArcGISLocalTiledLayer agsLocaltiledlyr = new ArcGISLocalTiledLayer(&quot;file:///mnt/sdcard/ArcGIS/sample/HelloWorld/Layers&quot;); map.addLayer(agsLocaltiledlyr); 加载影像数ArcGIS Runtime SDK for Android 从10.2.4开始支持直接读取本地影像数据，数据类型包含：ASRP/USRP、CIB1,5,10、DTED0, 1, 2、GeoPackage、GeoTIFF、HFA、HRE、IMG、JPEG、JPEG2000、NITF、PNG、RPF、SRTM1, FileRasterSource是加载本地影像数据文件类，地图视图中以RasterLayer作为图层对象展示出来。代码如下：String rasterPath = Environment.getExternalStorageDirectory().getPath() + &quot;/raster/test.tif&quot;; FileRasterSource rasterSource; try { rasterSource = new FileRasterSource(rasterPath); } catch (IllegalArgumentException ie) { Log.d(TAG, &quot;null or empty path&quot;); } catch (FileNotFoundException fe) { Log.d(TAG, &quot;raster file doesn&#39;t exist&quot;); } catch (RuntimeException re) { Log.d(TAG, &quot;raster file can&#39;t be opened&quot;); } RasterLayer rasterLayer = new RasterLayer(rasterSource); mMapView.addLayer(rasterLayer); 加载离线的 .geodatabase 本地文件.geodatabase 文件是ArcGIS 10.2中专为业务数据的离线而推出的一种数据格式，本质上，它仍然是SQLite数据库的封装，在SQLite数据模型的基础上，Esri计划逐步实现桌面端Geodatabase数据模型的存储，不仅包括Feature Class，还包括镶嵌数据集、网络数据集等。目前，主要实现了Feature Class的存储。即，在ArcGIS 10.2.2中，要使用完全的离线功能，可以使用ArcGIS for Desktop提供的GP工具来将需要编辑和离线的业务数据导出到.geodatabase中，也可以直接从ArcGIS for Server上的要素服务中下载数据，并在移动端存储为.geodatabase，从而实现完全离线的移动应用。ArcGIS Runtime SDK for Android中也提供了具体的Geodatabase类和FeatureLayer图层来加载.geodatabase文件，常用的类包括Geodatabase、GeodatabaseFeatureTable、GeodatabaseFeature、GeodatabaseFeatureServiceTable等，分别用来打开geodatabase数据文件、获取要素图层、获取图层中的具体要素，以及获取在线的要素服务。具体来讲，加载.geodatabase文件的步骤有如下几步：实例化一个Geodatabase对象，这个类有两个构造函数，都需要指定本地数据库的存储路径；创建一个GeodatabaseFeatureTable对象实例，用来获取需要的图层；创建一个FeatureLayer来存储获取的图层，并将获取的图层加载到地图中；调用dispose()方式释放资源。示例代码如下：//实例化geodatabase对象，并指定文件目录 gdb = new Geodatabase(&quot;{/path/to/geodatabase}&quot;); //实例化gdbfeaturetable对象，并获取第一个图层 gdbfeaturetable = gdb.getGeodatabaseFeatureTableByLayerId(0); //创建一个FeatureLayer来存储获取的图层，并将获取的图层加载到地图中 featurelayer = new FeatureLayer(gdbfeaturetable); mMapView.removeAll(); mMapView.addLayer(featurelayer); //调用dispose()方式释放资源 gdb.dispose(); 加载ShapeFile文件ShapeFile文件：ArcGIS平台中最常见的数据格式，包含属性信息、投影信息等。新版本的SDK（10.2.4开始）可以直接加载.shp文件进行数据的展示、查询。代码加载如下：ShapefileFeatureTable shpTable = new ShapefileFeatureTable(shpUrl); FeatureLayer fl = new FeatureLayer(shpTable); fl.setRenderer(new SimpleRenderer(new SimpleMarkerSymbol( Color.BLACK, 2, STYLE.CIRCLE))); mapView.addLayer(fl); 参考资料1、《ArcGIS Runtime SDK for Android开发笔记》——（10）、ArcGIS Runtime SDK支持的空间数据类型 - gis-luq - 博客园 http://www.cnblogs.com/gis-luq/p/4941737.html2、《ArcGIS Runtime SDK for Android开发笔记》——（11）、ArcGIS Runtime SDK常见空间数据加载 - gis-luq - 博客园 http://www.cnblogs.com/gis-luq/p/5062715.html]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-8、ArcGIS for Android 离线数据部署]]></title>
    <url>%2Fposts%2F9ac79c45.html</url>
    <content type="text"><![CDATA[本文主要介绍在代码工程中添加数据并部署到移动终端的操作步骤数据是GIS应用的基础，与所有GIS应用一样，用 ArcGIS for Android 开发的应用也离不开数据。而Android应用是在移动终端上运行的，数据和应用安装包都需要通过数据线连接进行拷贝，当终端较多时，尤其显得数据拷贝工作既繁琐又枯燥。为了更方便地部署应用数据，可以将数据文件放在工程资源中，在程序启动的同时，将数据一起部署到目标设备的指定目录。本文介绍在代码工程中添加数据并部署到移动终端的操作步骤：首先，数据文件拷贝到工程的assets目录；然后，程序启动时，获取assets的内容并将其存储至移动端的指定目录。通过assets的方式，可以将数据一起打包到apk安装包中，安装完成后，程序启动时即可将数据部署至移动端，不需要再单独拷贝。代码如下：/** * 将assets写入移动设备 * * @param dir assets下的文件夹 */ public void copyAssetsDirToSdcard(String dir) { String desFolder = ZZMANHOLE_PATH + dir; FileUtils.createOrExistsDir(desFolder); String[] mAssetsFileList = null; try { mAssetsFileList = getAssets().list(dir); } catch (IOException e) { e.printStackTrace(); } assert mAssetsFileList != null; for (String file : mAssetsFileList) { File desFile = new File(desFolder + &quot;/&quot; + file); if (!desFile.exists()) try { InputStream is = getAssets().open(dir + &quot;/&quot; + file); writeFileFromIS(desFile, is, false); } catch (IOException e) { e.printStackTrace(); } } } 说明：1、assets 目录位置 \app\src\main\assets；2、其中 ZZMANHOLE_PATH 为项目目录可通过以下代码获得：public static String PATH = android.os.Environment.getExternalStorageDirectory() + &quot;/pathname/&quot;; 3、将 assets 目录下的 path 复制到 SDcard 项目目录：copyAssetsDirToSdcard(“path”);即将\app\src\main\assets\path 复制到 PATH\path；4、writeFileFromIS 代码如下：/** * 将输入流写入文件 * * @param file 文件 * @param is 输入流 * @param append 是否追加在文件末 * @return {@code true}: 写入成功&lt;br&gt;{@code false}: 写入失败 */ public static boolean writeFileFromIS(File file, InputStream is, boolean append) { if (file == null || is == null) return false; if (!createOrExistsFile(file)) return false; OutputStream os = null; try { os = new BufferedOutputStream(new FileOutputStream(file, append)); byte data[] = new byte[1024]; int len; while ((len = is.read(data, 0, 1024)) != -1) { os.write(data, 0, len); } return true; } catch (IOException e) { e.printStackTrace(); return false; } finally { closeIO(is, os); } } 5、closeIO 代码如下：/** * 关闭IO * @param closeables closeable */ public static void closeIO(Closeable... closeables) { if (closeables == null) return; for (Closeable closeable : closeables) { if (closeable != null) { try { closeable.close(); } catch (IOException e) { e.printStackTrace(); } } } } 参考资料1、java - android 怎么复制assets文件夹到本地SD卡？ - SegmentFault https://segmentfault.com/q/10100000044788292、Android学习之遍历拷贝assets下的目录 - linzhiyong的专栏 - 博客频道 - CSDN.NET http://blog.csdn.net/u012527802/article/details/52025849]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《SuperMap iMobile for Android学习笔记》-2、SuperMap for Android开发环境搭建]]></title>
    <url>%2Fposts%2Fa5d0654b.html</url>
    <content type="text"><![CDATA[本文主要针对在Windwos环境下用Android Studio搭建SuperMap for Android开发环境.]]></content>
      <categories>
        <category>SuperMap iMobile for Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SuperMap iMobile for Android</tag>
        <tag>SuperMap for Android</tag>
        <tag>SuperMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《SuperMap iMobile for Android学习笔记》-1、SuperMap for Android介绍]]></title>
    <url>%2Fposts%2F3dcd8203.html</url>
    <content type="text"><![CDATA[产品简介SuperMap iMobile 8C是一款全新的移动GIS开发平台，具备专业、全面的移动GIS功能。支持基于Android和iOS操作系统的智能移动终端，可以快速开发在线和离线的移动GIS应用。发展历程功能概述专业的移动 GIS 开发平台，提供全面的移动GIS功能。在专业数据采集、行业GIS应用、大众化GIS应用等领域都有广泛的应用。全新的地图显示引擎，SuperMap iMobile 8C利用OpenGL在面片渲染、文本渲染及反走样等方面的优势提升地图显示效果，使得地图绘制效果更精美；同时利用OpenGL的整体渲染模式，大幅提升地图的显示性能。除支持广泛的在线地图服务外，还支持强大的离线数据。在多种特殊的应用场景都有广泛的应用，如：移动网络信号无覆盖、移动网络流量受限、数据保密、高性能移动GIS等。提供移动端、桌面端和服务器端通用数据格式，跨终端交换数据无需转换格式，即拷即用。消息总线功能，支持多端之间的协同操作，在一个终端执行的操作可以快速同步到其它相关终端，从而实现数据共享和即时通讯的功能。支持态势标绘功能，提供多种点符号和箭头符号的标绘。可应用于调度，指挥等多种应急行业中。高性能的二三维一体化，在移动端支持高精细的三维模型，支持水纹、火焰、喷泉、樱花等多种动画效果。支持在线和离线方式浏览倾斜摄影建模数据，支持选中单个模型对象高亮、以及单体模型的属性信息、空间信息查询等GIS功能。GIS和导航一体化，极大的提高了室外GIS作业的便利性和工作成效。SuperMap iMobile 8C 通过对三种国际标准AMQP、MQTT和STOMP的支持，实现了GIS数据的广播方式消息传播和点对点消息传播，进而实现多端协同和数据分发。主要特点全面的GIS功能作为专业的移动GIS开发平台，SuperMap iMobile 8C提供了涵盖地图操作、数据采集、绘制编辑、空间分析、路径导航等专业移动GIS应用功能。基于该平台构建的移动GIS应用将能够便捷的提供多源地图组合与专题数据浏览，实现空间信息的查询与分析，进行终端的数据采集、编辑与管理，并能够高效的进行动态变化数据的展示与监控。全新的地图显示引擎相比PC端地图，移动端地图更注重用户体验:地图显示效果及地图操作性能。为了提升地图的体验，SuperMap iMoble 8C 采用全新的OpenGL显示技术绘制地图，大大的提升了地图的显示效果及显示性能。在地图显示效果方面， 利用OpenGL面片渲染、文本渲染及反走样的优势，确保地图绘制效果更精美。在地图显示性能方面，OpenGL的整体渲染模式，不仅可以大幅提高地图的整体渲染性能，而且可以利用GPU加速，让地图加载更快，显示更流畅。新版显示引擎还可实现地图透明、地图旋转、地图俯仰角等多种地图显示特效。离线在线一体化SuperMap iMobile既支持多种在线地图服务，也支持完全离线应用。这在移动网络信号无覆盖、网络流量受限、数据保密以及高性能移动GIS应用等领域发挥了重要作用。导航GIS一体化导航可以直接使用GIS应用的地图和数据，实现导航与业务功能无缝衔接。可以根据业务需要定制路径分析和导航的参数条件，实现个性化按需导航。互联互通一体化SuperMap iMobile 8C通过对三种国际标准AMQP、MQTT和STOMP的支持，实现了GIS数据的广播方式消息传播和点对点消息传播，进而实现多端协同和数据分发。同时，iMobile 8C 对 GeoJson 传输格式的支持，使得移动端能够更好的实现和服务器端进行几何对象的交互应用。SuperMap iMobile 8C实现了可以让移动终端通过蓝牙与高精度数据定位采集终端的定位盒子通讯，获取亚米级的定位数据。这为移动终端在位置服务应用上带来数据采集的便捷性和准确性，位置数据的采集和服务应用面更加广泛。专业的空间分析SuperMap iMobile 8C提供全面的GIS分析功能，可以基于本地和服务数据进行缓冲区分析、叠加分析和路网、管线分析等，对数据进行即时的信息挖掘与处理。高效的网络分析SuperMap iMobile 8C 支持高效的网络拓扑分析，可以广泛应用于GIS数据路线规划、管网分析、管网巡查等业务。增强的数据采集功能GPS 数据采集：SuperMap iMobile 8C 提供5种 GPS 数据采集模式：普通模式、抓路模式、等距离间隔模式、等时间间隔模式、智能记录模式。多媒体数据采集：除位置信息之外，SuperMap iMobile 8C 提供照片、音频和视频信息的采集。动态变化对象实时显示SuperMap iMobile 8C 提供了在终端根据实时数据动态渲染专题地图的能力，可以根据终端应用需求和数据的即时变化来动态展示专题信息，进一步发挥移动应用的即时效应。对于位置和状态属性快速变化的动态对象，SuperMap iMobile 8C 提供了高性能的交互显示。终端应用可以实现在地图上实时监控目标对象的位置变化、状态变化，并能够以动画方式展示对象变化的过程。动态对象支持手势交互操作，为应用提供丰富直观的交互体验。通过动态对象显示，可以简单快捷的实现车辆监控，电子围栏等对运动目标的监控应用，以及对设备报警、运行状态等实时状态监控应用。针对海量数据显示，SuperMap iMobile 8C版本还提供了聚合显示的功能，全面提升了海量数据的显示性能和效果。应用于调度指挥的态势标绘SuperMap iMobile 8C 支持应用于指挥调用的态势标绘功能，提供多种点符号及箭头符号的标绘。通过这些标绘符号，可以快速的进行调度或指挥信息的表达，同时，结合iMobile的手绘几何对象功能、涂鸦功能，可以更丰富的表达信息。高性能移动三维三维场景是SuperMap iMobile 8C的核心应用功能，用户可以快速构建二三维一体化的移动GIS应用系统，在移动终端实现三维地图和场景的浏览与交互操作。提供地形、影像、模型、矢量等数据和粒子、水面等特效的移动端三维显示和查询。三维倾斜摄影倾斜摄影测量是测绘领域近些年发展起来的一项新技术，通过使用同一飞行器的多台传感设备，可以同时从垂直和四向采集影像，从而达到快速还原真实世界的效果。相对于人工建模，倾斜摄影具备以下特性：能够真实反映地物的情况、获取的数据精度高、能够自动化建模。这些特性可以显著降低三维数据的建模成本，大大提高数据采集效率。在SuperMap iMobile 8C产品中提供便捷高效的模型加载机制，支持在线和离线直接浏览OSGB倾斜摄影数据，无需进行数据转换。同时支持模型选中高亮、单体模型的属性信息查询等高级GIS功能。数据安全SuperMap iMobile 8C更加的注重数据的安全，在数据加密方面提供了工作空间加密、数据源加密以及缓存数据加密功能。工作空间加密：支持在工作空间中设置密码，打开工作空间时需要输入密码，此种加密方式只能粗略保证数据安全。数据源加密：根据密钥，把整个文件进行加密，高安全的一种做法，即使是数据流失，在其它工具中也无法打开此文件。缓存文件加密：根据密钥，把整个文件进行加密，高安全的一种做法，即使是数据流失，在其它工具中也无法打开此文件。]]></content>
      <categories>
        <category>SuperMap iMobile for Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SuperMap iMobile for Android</tag>
        <tag>SuperMap for Android</tag>
        <tag>SuperMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Awesome GIS]]></title>
    <url>%2Fposts%2Fc287a376.html</url>
    <content type="text"><![CDATA[Awesome GIS is for collecting the geographic information system (GIS) related sources, including cartographer tools, geoanalysis tools, developing tools, data, conference &amp; communities, news, MOOC’s course, some amazing map site, etc.征得原作者同意，全文引用。原文地址:https://github.com/sshuair/awesome-gisWelcome to contribute. Let’s make it better. Please follow the Contributing Guidelines.Inspired by Awesome Python.Table Of Contents:Desktop Application3D ApplicationWeb Map ServerFront-end FrameworkiOS &amp; AndroidGeospatial Library (non-web)Spatial DatabaseMap Render EngineSaasData FormatDataConference &amp; CommunitiesNews SiteAmazing Map SiteMOOCGeospatial Start-ups And CompaniesDesktop ApplicationArcGIS - A enterprise level desktop GIS software published by ErsiQGIS - A cross-platform free and open-source desktop GIS softwareGRASS GIS - Used for geospatial data management and analysis, as a founding member of OSGEOuDig - An open source desktop application framework built with EclipsegvSIG - A powerful, user-friendly, interoperable geomatics professionalsMarble - A virtual globe and world atlasSharpMap - An mapping library in web and desktop applications built in .NETJUMP GIS - An open source GIS written in JavaWhitebox GAT - Software package for geospatial analysis and data visualizationTileMill - Creating beautiful interactive maps with CartoCSS. Github LinkGlobal Mapper - A geographic information system (GIS) software package currently developed by Blue Marble Geographics that runs on Microsoft Windows3D ApplicationSkyline - A glimpse into Skyline’s cutting-edge 3D geospatial visualization products, and their potential to transform the way your organization makes decisions, shares information and manages its assetsCityEngine - Transform 2D GIS Data into Smart 3D City ModelsArcGIS Earth - Display data, sketch placemarks, measure distances and areas, and add annotations at any part of the worldWorld Wind - Providing features for displaying with geographic dataGoogle Earth - Bringing a earth view for global mappingWeb Map ServerArcGIS Server - A GIS server for enterprise applicationMapServer - Publishing spatial data and interactive mapping applications to the webGeoServer - An open source server for sharing geospatial datadeegree - An open source software for spatial data infrastructures and the geospatial webGeoDjango - A GIS server built with python web framework – djangoMapnik - An open source mapping toolkit written in C++ for desktop-based and server-based map renderinggeomajas - An open source platform to create Web GIS applicationsGeoMOOSE - A Web Client JavaScript Framework for displaying distributed cartographic datamapbender3 - Publishing spatial data infrastructure services on the Symfony 2 PHPMapFish - A framework for building rich web-mapping applications built with Pylons Python web frameworkMapGuide - A Web Client JavaScript Framework for displaying distributed cartographic dataMapBuilder - This project has been retired in 2008Nanocubes - An in-memory data structure for spatiotemporal data cubes. Github LinkFront-end FrameworkLeaflet - Open-source javaScript library for mobile-friendly interactive mapsMapbox GL JS - A JavaScript &amp; WebGL library that renders interactive maps from vector tiles and the Mapbox GL Style SpecificationOpenLayer3 - Open-source javascript map viewing librarythree.js - A javascript 3D library which makes WebGL simplercesiumjs - An open-source JavaScript library for world-class 3D globes and mapswebglearth2 - Open-source virtual planet web application running in any web browser with support for WebGL HTML5 standardArcGIS API for JavaScript - Creating high-performing apps and smarter visualizations supportted by ERSID3.js - A javascript library for manipulating documents based on dataEcharts - A user-friendly data visualisation library supported by Baidugeomajas-client javascript - Open source javascript mapping API for cool maps and appsGoogle Maps Javascript API - A javascript api for google mapd3-carto-map - A library for creating layer-based maps using D3turf.js - Advanced geospatial analysis for browsers and node supported by MapboxPolymaps - A JavaScript library for image- and vector-tiled maps using SVGjVectorMap - A vector-based, cross-browser and cross-platform component for interactive geography-related data visualization on the web. Github LinkTangram - A javaScript library for rendering 2D &amp; 3D maps live in a web browser with WebGLiOS &amp; AndroidiOSArcGIS Runtime SDK for iOS - Build mapping apps for iOS devicesAndroidArcGIS Runtime SDK for Android - Build native mapping apps for Android devicesCross-PlatformArcGIS Runtime SDK for Xamarin - Build native mapping apps for Android and iOS in C# (Technical Preview)Geospatial Library (non-web)GDAL - A translator library for raster and vector geospatial data formatsProj.4 - A library for cartographic projectionShapely - A library for manipulation and analysis of geometric objects in the Cartesian planeFiona - IO for GIS Data writted by PythonRtree - A wrapper of libspatialindex providing spatial indexing featuresGeoTools - An open source Java library that provides tools for geospatial dataOrfeo toolbox - An open-source C++ library for remote sensing images processingSpatial DatabasePostGIS based on PostgreSQL - Most advanced open source databaseOracle Spatial - Oracle-based advanced spatial data analysisSpatialite based on SQLite - Lightweight SQL library to support fully spatially capabilityMSSQL - A high-preformance database support by MicrosoftMBtiles - A specification for storing tiled map data in SQLite databasesmySQL - the world’s most popular open source databasemongoDB - An open-source, document database designed for ease of development and scalingMap Render Enginemapnik - Mapnik combines pixel-perfect image output with lightning-fast cartographic algorithms, and exposes interfaces in C++, Python, and Nodemapbox-gl-native - A library for embedding interactive, customizable vector maps into native applications on multiple platformstangram-es - A C++ library for rendering 2D and 3D maps from vector data using OpenGL ES, and mainly focused on mobile and embedded devices.SaasMapbox - Helping you design your own map and presenting your dataCartodb - The easiest way to map and analyze your location dataGIS Cloud - A next generation platform for apps that manage location informationstamen - Data visualization to tell compelling stories for some of the world’s most visible companiescitytracking - A two-year project, to change the way people view, talk about, utilize digital city servicesworldmap - Building your own mapping portal and publish it to the worldGeoHey - A geographic online one-stop solution (Chinese)GeoQ - A location intelligence platform (Chinese)地图慧 - A self-designed map server for customs (Chinese)地图无忧 - A enterprise-level map service (Chinese)##Data FormatGeoJson - Represent geospatial information by jsonTopoJson - Represent geospatial information by json in a smaller sideTileJSON - Represent vector tile provider by jsonWKT - A text markup language for representing vector geometry objects on a mapDataData List Sitea-comprehensive-list-of-all-open-data-portals-around-the-worldFree GIS DataGeoCommons - A community contributed collection of open data from around the worldData Site199itHarvard DataverseWorldPopNYC Open DataLos Angeles GeoHubGlobal LUCC data (30m)Global cities Shapefile dataNetworkRepository.com - The First Interactive Network Repository with Visual AnalyticsOpenFlights: Airport and airline dataGridded Population of the World (GPW), v3 | SEDACCiti Bike Trip HistoriesNYC Taxi &amp; Limousine Commission - Trip Record DataT-Drive trajectory data samplepm2.5-ChinaRemote sensing imgemetro extracts - City-sized portions of OpenStreetMapGeofabrikConference &amp; CommunitiesConferenceEsri International User ConferenceEsri Developer SummitFOSS4GCommunitiesOGCMaptimegeo communityGIS stackexchangeGIS-Lab - informal community of russian-speaking GIS/RS specialists, we get better ourselves and help get better othersGeoNet - The Esri CommunityNews SiteGIS Lounge - Maps and GISThe GIS News Tweets DailyGeoawesomenessGISuser - The GIS And Mapping Professional ResourceESRI newsDirections Magazine - GIS News and GeospatialGISCafeGIS timesgeospatial prgisgeographycanadiangisMAPCITEGeospatial WorldBlogsWiki.GIS.com - The GIS EncyclopediaGeo BlogsmastermapsAnita GraserCharleyMike BostockGretchen PetersonKARTO PICSAmazing Map SiteMaps of the YearCartography and Geovisualization Group at Oregon State Universitysnazzymaps - A google map style galleryOdyssey.jsAmazing MapsBeijing City LabChinese Bus SystemflowingdatafinemappingthematicmappingdougmccuneOpenWebGIS is free online GISNC STATE UNIVERSITY Center for Geospatial AnalyticsCHATTY MAPS - the sounds map of city.MOOCdiscoverspatial - Easy to follow spatial courses &amp; tutorials from the world’s leading instructorsCoursera’s GIS Specialization - Including Fundamentals of GIS, GIS Data Formats, Design and Quality, Geospatial and Environmental Analysis, Imagery, Automation, and Applications and Capstone: Geospatial Analysis.Geospatial Intelligence &amp; the Geospatial RevolutionMaps and the Geospatial RevolutionMongoDB地理数据模块与MongoGIS - Mandarin.Geospatial Start-ups And CompaniesNameCategoryCityCountryFounded3D RoboticsDronesSan Diego, CAUS2009ADCiMapsAppleton, WIUS1988AdmooveLBMarketingParyżFrance2010AirsageLocation Big DataAtlanta, GAUS2000AltergeoMapsMoscowRussia2008AppleMapsCupertino, CAUS1976AutodeskGISSan Rafael, CAUS1982BeacifyLBMarketingChicago, ILUS2013Bentley SystemsGISExton, PAUS1984BlackSky GlobalRemote SensingSeattle, WAUS2013Blue Sense NetworksLBMarketingReadingUK2013BoniLBMarketingChicago, ILUS2011Boundless SpatialGISNew York, NYUS2002ByteLightIndoorBoston, MaUS2011CartoDBMapsNew York, NYUS2012CE-TrafficTrafficPragueCzech Republic2008CitymapperTransitLondonUK2011CitymapsMapsNew YorkUS2010deCartaMapsSan Jose, CAUS1996Digital GlobeRemote SensingLongmont, COUS1992DJIDronesShenzhenChina2006DroneDeployDronesSan Francisco, CAUS2013EsriGISRedlands, CAUS1969EstimoteLBMarketingKrakówPoland2012FactualLocation Big DataLos Angeles, CAUS2008FatmapMapsLondonUK2014FoursquareLocal discoveryNew York, NYUS2009GarminNavigationOlathe, KSUS1989GeofeediaLBMarketingChicago, ILUS2011GeoloqiMapsPortland, ORUS2010GIS CloudGISLondonUK2008GoogleMapsMountain View, CAUS1998HereMapsBerlinGermany2012HivemapperDronesBurlingame, CAUS2014HudwayNavigationMarina Del Rey, CAUS2013ifinityLBMarketingWarsawPoland2013Indoo.rsIndoorBrunn Am GebirgeAustria2010IndoorAtlasIndoorPalo Alto, CAUS2012InrixTrafficKirkland, WAUS2004IntergraphGISMadison, ALUS1969Kontakt.ioLBMarketingKrakówPoland2013Life360LBSSan Francisco, CAUS2008LocaidLocation Big DataCarlsbad, CAUS2005Location LabsLocation Big DataEmeryville, CAUS2002LocationaryLocation Big DataToronto, ONCanada2009LocomizerLocation Big DataLondonUK2013MagellanNavigationSan Francisco, CAUS2001MapboxMapsWashington, DCUS2010MapillaryMapsMalmoSweden2013MapitaLocation Big DataHelsinkiFindland2012MapjamMapsSan Francisco, CAUS2012MaponicsMapsWhite River Junction, VTUS2001MapquestMapsDenver, COUS1996Maps.meMapsZurichSwitzerland2011Maps4newsMapsEindhovenNetherlands2008MapsenseMapsSan Francisco, CAUS2013MaptiaMapsSeattle, WAUS2012MaptiksMapsBritish ColumbiaCanada2014MapzenMapsNew YorkUS2013Media mobileTrafficParisFrance2005MicelloIndoorSanta Clara, CAUS2007MoovitTransitNess ZionaIsrael2011NavigineIndoorWilmingtonUS2011NavmiiNavigationSan Francisco, CAUS2010NextomeIndoorValenzanoItaly2013Nofity NearbyLBMarketingNew York, NYUS2015Pitney BowesGISStamford, CTUS1920PlaceableLocation Big DataDenver, COUS1996PlaceIQLocation Big DataNew York, NYUS2010Planet LabsRemote SensingSan Francisco, CAUS2010PlazesLocal discoveryBerlinGermany2006Point InsideLBMarketingBellevue, WAUS2009PozzeyIndoorAdelaideAustralia2014PrecisionHawkDronesRaleigh, NCUS2011RedbirdRemote SensingParisFrance2013RoximityLBMarketingDenver, COUS2012SatellogicRemote SensingPalo Alto, CAUS2010SenseFlyDronesCheseaux-LausanneSwitzerland2009SenseWhereIndoorEdinburghUK2009ShopkickLBMarketingRedwood City, CAUS2009Skybox ImagingRemote SensingMountain View, CAUS2009Skyhook WirelessLocation Big DataBoston, MAUS2003SparkGeoMapsPrince George, BCUS2010Street Light DataLocation Big DataSan Francisco, CAUS2010SygicNavigationBratislavaSlovakia2004TelenavNavigationSunnyvale, CAUS1999Tesla MotorsMapsPalo Alto, CAUS2003ThinknearLocation Big DataLos Angeles, CAUS2011TomTomMapsAmsterdamNetherlands1991TopconSurveyingLivermore, CAUS1994TrimbleSurveyingSunnyvale, CAUS1978TripadvisorLocal discoveryNeedham, MAUS2000UberTransitSan Francisco, CAUS2009UbisenseIndoorCambridgeUK2006UrtheCastRemote SensingVancouver, BCCanada2010ValarmLBSThousand Oaks, CAUS2012VenuelabsLBMarketingBellevue, WAUS2009WaytagMapsCape TownSouth Africa2009WazeNavigationPalo Alto, CAUS2007what3wordsMapsLondonUK2013WiFi SlamLocation Big DataPalo Alto, CAUS2011YelpLocal discoverySan Francisco, CAUS2004Reference:List of geographic information systems softwareosgeoAmrEldib’s Awesome GISbrandonxiang’s Awesome GISlist top 100 geospatial start ups companies world还有一个不错的Awesome GIS:https://amreldib.com/awesome-gis/转载文章以下声明无效]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全站启用HTTPS]]></title>
    <url>%2Fposts%2F700667be.html</url>
    <content type="text"><![CDATA[使用CloudFlare做DNS解析和CDN加速。全站启用HTTPS。以后有时间详细介绍、要专心考研了。因为免费的七牛云储存不支持HTTPS访问，易出现12306证书错误，而且据百度云观测出现部分地区无法访问。多说评论头像有问题，可以改用Disqus解决。取消CloudFlare的使用，改回原来的CloudXNS。在本机测试CloudFlare的CDN还是有一定作用的，ping值由原来的200ms降到50ms左右。]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-7、地图图层Layer]]></title>
    <url>%2Fposts%2Fee026d20.html</url>
    <content type="text"><![CDATA[在GIS中图层是很重要的概念，图层是空间数据的载体，通过它可将各种类型的地图数据进行加载显示，但图层只有添加到MapView对象中才能使用。在ArcGIS Runtime for Android中有许多种图层，不同图层有不同的作用，下图是图层的继承关系图：DynamicLayerDynamicLayer 是动态图层的基类.ArcGISDynamicMapServiceLayerArcGISDynamicMapServiceLayer 图层对应 ArcGIS for Server 服务中的动态服务，动态地图服务的地图数据是按照移动设备范围读取的，用法与ArcGISTiledMapServiceLayer 图层相同。ArcGISDynamicMapServiceLayer 图层通常包含多个图层，这些图层由server根据请求来渲染并以raster image形式返回，并且返回的raster并不包含feature的额外信息。它的功能特点是更新非常方便，并能及时呈现给用户，同时，图层的可视性和空间参考可以改变，可以给图层添加单独的layer definition，ArcGIS Server为每个image动态投影。而地图的空间参考是由第一个加载的图层决定。它的性能特点：它的渲染时间取决于请求数据的数量和复杂度，因此一般都比tiled map server要慢，因此，它适合数据经常发生改变、或者需要针对不同的用户呈现不同的数据，且要素信息（如attributes，geometry，symbol等）不需要的情况。 //ArcGISDynamicMapServiceLayer class is used to define the Layer that is added to the //MapView object. MapView mv = new MapView(this); mv.addLayer(new ArcGISDynamicMapServiceLayer( &quot;http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Demographics/ESRI_Population_World/MapServer&quot;)); setContentView(mv); ArcGISImageServiceLayerArcGISImageServiceLayer图层对应ArcGIS for Server服务中的影像服务，调用影像服务也非常简单，同调用上述服务一样，示例代码如下： //ArcGISImageServiceLayer class is used to define the Layer that is added to the //MapView object. MapView mv = new MapView(this); mv.addLayer(new ArcGISImageServiceLayer( &quot;http://myserver/arcgis/rest/services/MyImage/ImageServer&quot;,null)); setContentView(mv); WMSLayer加载符合开放地理空间联盟（OGC）标准的WMS服务器数据。服务地址类似：http://[SERVER:PORT]/[INSTANCE]/services/[SERVICE]/MapServer/WMSServer 添加示例代码如下：String wmsURL = &quot;http://[SERVER:PORT]/[INSTANCE]/services/[SERVICE]/MapServer/WMSServer&quot;; WMSLayer wmsLayer = new WMSLayer(wmsURL); mMapView.addLayer(wmsLayer); 定义空间参考：// use a spatial reference defined by sr WMSLayer wmsLayer = new WMSLayer(wmsURL, sr); mMapView.addLayer(wmsLayer); 利用图层名称组成的数列设置图层可见性：String[] visibleLayers = {&quot;ushigh&quot;, &quot;counties&quot;}; wmsLayer.setVisibleLayer(visibleLayers); 获得所有图层信息：WMSLayerInfo[] wmsLayerInfo = wmsLayer.getLayers(); GraphicsLayerGraphicsLayer是ArcGIS Runtime for Android中比较重要的图层类型，也是使用最为频繁的一个。GraphicsLayer可以包含一个或多个Graphic对象，查询的返回结果和动态标绘的Graphic数据都要通过它呈现。建议在MapView中添加图层时不要第一个添加该类型的图层，因为MapView加载图层时先要初始化一些地图参数，而该图层不具备这些参数，其具体用法如下： //GraphicsLayer class is used to define the Layer that is added to the //MapView object. MapView mv = new MapView(this); mv.addLayer(new GraphicsLayer()); setContentView(mv); 除了可以呈现Graphic对象外，它还具备了一些其他有用的功能，如要素更新与要素获取等等，由类GraphicsLayer处理，GraphicsLayer是由应用程序来定义的图层，专门用来绘制有空间参考的要素，并不适合绘制non-geographical要素，如指北针或copyright text。可以用屏幕坐标来查询图层中的要素并且使用getGraphics（）方法返回要素，并且支持设置图层比例尺。不推荐在graphics layer中存放太多的要素，但是，它有着不错的性能，并且是feature layer class的基类，如果必须要处理大量的要素，建议使用feature collection来存储在feature layer中。TiledLayerTiledLayer为加载切片的图层。包含两个直接子类。ArcGISLocalTiledLayer, TiledServiceLayerArcGISLocalTiledLayerArcGISLocalTiledLayer是用来添加离线数据包的图层，该图层目前支持两种格式的离线数据：一个是紧凑型的缓存切片，另一个是打包的tpk格式的数据，对于这两种数据的制作方法可以参照我的文章，图层用法如下：MapView mv = new MapView(this); ArcGISLocalTiledLayer local = new ArcGISLocalTiledLayer(&quot;file:///mnt/sdcard/&lt;CacheName&gt;/Layers&quot;);//离线图层，将缓存的地址作为参数传入 mv.addLayer(local); setContentView(mv); TiledServiceLayerArcGISTiledMapServiceLayer, BingMapsLayer, OpenStreetMapLayer, WMTSLayer1、ArcGISTiledMapServiceLayer在ArcGIS for Server中可以发布多种地图服务，移动端需要有不同的图层来对应这些服务。ArcGISTiledMapServiceLayer图层对应ArcGIS for Server服务中的切片服务，于切片都是事先做好的，ArcGISTiledMapServiceLayer不能对图层中的数据进行更改，除非更新服务缓存，在arcgis for android中，也不允许对此类型的数据查询，通常用做底图使用。同时，因为加载的是缓存切片，这个类型的图层是arcgis for android中相应请求最快的图层之一，它采用多个线程，通常是每个图片使用一个线程来处理请求和绘制图片，并且异步处理。用法如下：MapView mv = new MapView(this); mv.addLayer(new ArcGISTiledMapServiceLayer( &quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer&quot;)); setContentView(mv); 2、BingMapsLayerBingMapsLayer用来加载必应地图。用法如下：MapView mv = new MapView(this); mv.addLayer(new BingMapsLayer( &quot;[your Bing Maps key]&quot;, MapStyle.Aerial)); setContentView(mv); 3、OpenStreetMapLayerOpenStreetMapLayer用来加载OpenStreetMapLayer。实际用得比较少。4、WMTSLayerWMTSLayer加载WMTS服务，比如加载天地图什么的。FeatureLayerFeatureLayer是一种类型的层的特征组成; 在功能FeatureLayer包括几何图形和一组一致的属性。在一个特征FeatureLayer可以在地图，查询，编辑上显示，和选定（视觉突出显示）。每个要素都有一个唯一的ID。一个FeatureLayer对应一个FeatureTable，这是在向传递FeatureLayer构造。在正确显示顺序，getSpatialReference（）值必须以该地图的空间参考匹配FeatureLayer 添加。如果功能层的 FeatureTable是GeodatabaseFeatureServiceTable，通过调用设置空间参考 setSpatialReference(SpatialReference) 方法。当FeatureTable是GeodatabaseFeatureTable从获得的地理数据库，生成使用地理数据库时所设置的空间参考GeodatabaseSyncTask通过调用 setOutSpatialRef（的SpatialReference）方法。KmlLayerKmlLayer是用来加载KML（Keyhole Markup Language）文件（.KML、.kmz）的图层。KML 是一种文件格式，用于在地球浏览器（例如 Google 地球、Google 地图和谷歌手机地图）中显示地理数据。KML 是由开放地理空间联盟（Open Geospatial Consortium, Inc.，简称 OGC）维护的国际标准。RasterLayerRasterLayer是用来加载影像的图层。ArcGIS Runtime SDK for Android 从10.2.4开始支持直接读取本地影像数据，数据类型包含：ASRP/USRP、CIB1,5,10、DTED0, 1, 2、GeoPackage、GeoTIFF、HFA、HRE、IMG、JPEG、JPEG2000、NITF、PNG、RPF、SRTM1, FileRasterSource是加载本地影像数据文件类，地图视图中以RasterLayer作为图层对象展示出来。代码如下：String rasterPath = Environment.getExternalStorageDirectory().getPath() + &quot;/raster/test.tif&quot;; FileRasterSource rasterSource; try { rasterSource = new FileRasterSource(rasterPath); } catch (IllegalArgumentException ie) { Log.d(TAG, &quot;null or empty path&quot;); } catch (FileNotFoundException fe) { Log.d(TAG, &quot;raster file doesn&#39;t exist&quot;); } catch (RuntimeException re) { Log.d(TAG, &quot;raster file can&#39;t be opened&quot;); } RasterLayer rasterLayer = new RasterLayer(rasterSource); mMapView.addLayer(rasterLayer); 参考资料1、Layer | ArcGIS Android 10.2.7 APIhttps://developers.arcgis.com/android/api-reference/reference/com/esri/android/map/Layer.html]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-6、地图容器MapView]]></title>
    <url>%2Fposts%2F7622cba.html</url>
    <content type="text"><![CDATA[MapView 概述MapView是ArcGIS Runtime SDK for Android的核心组件，通过MapView可以呈现地图服务的数据，并且在MapView中定义了丰富的属性、方法和事件，用户通过MapView可以操作设备的触摸屏，默认MapView可以响应用户的各类手势的操作，GIS的开发中，什么时候都少不了地图操作。MapView是Android中ViewGroup的子类，也是ArcGIS Runtime SDK for Android中的地图容器，与很多ArcGIS API中的Map、MapControl类作用是一样的。MapView 功能介绍MapView 的强大不仅仅是因为它是呈现地图数据的容器，MapView 为提供丰富的功能，下面来分析 MapView 为提供哪些功能。首先，MapView 具有呈现地图能力，MapView 可以添加一个或多个图层，图层又分很多种，如：切片图层、动态图层、本地图层等等；图层只有添加到 MapView 容器中才能进行显示。其次，通过 MapView 可以设置地图的显示范围、是否允许被旋转、地图背景、地图的最大/最小分辨率及其指定当前显示的分辨率/比例尺。最后，MapView 提供了丰富的手势监听接口，通过这些监听器，可以监听各种手势动作，如点击、双击、移动或长按等操作。MapView 的使用MapView 的添加方式有两种方式可以将 MapView 添加到应用当中：一个是 XML 方式，另一个是硬编码方式；一般多采用 XML 方式，方便调整布局及其属性相关设置。1、XML方式 &lt;com.esri.android.map.MapView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; url=&quot;http://www.arcgis.com/home/webmap/viewer.html?webmap=e229d715f7ca4fa980308549fb288165&quot;/&gt; 2、JAVA方式 //ArcGISTiledMapServiceLayer class is used to define the Layer that is added to the //MapView object. MapView mMapView = new MapView(this); mMapView.addLayer(new ArcGISTiledMapServiceLayer( &quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer&quot;)); setContentView(mMapView); MapView的配置XML方式以上内容使用XML实现 &lt;!-- MapView with MapOptions settings for Topo basemap, zoom level, and centered in Costa Mesa, CA. --&gt; &lt;com.esri.android.map.MapView android:id=&quot;@+id/map&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; mapoptions.MapType=&quot;topo&quot; mapoptions.ZoomLevel=&quot;13&quot; mapoptions.center=&quot;33.666354, -117.903557&quot;/&gt; 在JAVA中以下代码即可使用// Retrieve the MapView, Basemap, ZoomLevel, and Center from XML layout MapView mMapView = (MapView) findViewById(R.id.map); JAVA方式1、采用的MapOptions类实例化一个MapView，定义底图，缩放级别，以及中心。 MapOptions topo = new MapOptions(MapType.TOPO, 23, -110, 9); MapView mapView = new MapView(this, topo); 2、使用 MapOptions 切换底图。 MapOptions topo = new MapOptions(MapType.TOPO, 23, -110, 9); MapView mapView = new MapView(this, topo); MapView 的常见操作地图常见的操作有缩放、旋转、平移、获取范围、比例尺、分辨率等信息，以及常用的手势操作，其中，经常使用到的功能和常见问题有以下几个：获取/设置比例尺、分辨率、中心点、范围ArcGIS forAndroid中，MapView具有很多与地图操作有关的方法，其中，与地图的比例尺、分辨率、中心点、范围有关的方法如下：1、获取/设置比例尺返回类型方法说明doublegetScale()获得当前地图的比例尺.doublegetMaxScale()获得当前地图的最大比例尺.doublegetMinScale()获得当前地图的最小比例尺.voidsetScale(double scale)设置当前地图的比例尺.voidsetMaxScale(double maxScale)设置当前地图的最大比例尺.voidsetMinScale(double minScale)设置当前地图的最小比例尺.2、获取/设置分辨率返回类型方法说明doublegetResolution()获得当前地图的分辨率.doublegetMaxResolution()此方法在 10.2.2 以后弃用，使用 getMinScale() 替代.doublegetMinResolution()此方法在 10.2.2 以后弃用，使用 getMaxScale() 替代.voidsetResolution(double res)设置当前地图的分辨率.voidsetMaxResolution(double maxResolution)此方法在 10.2.2 以后弃用，使用 setMinScale(double) 替代.voidsetMinResolution(double minResolution)此方法在 10.2.2 以后弃用，使用 setMaxScale(double) 替代.3、获取/设置中心点返回类型方法说明PointgetCenter()获取地图中心点.voidcenterAt(Point centerPt, boolean animated)设置地图中心点.voidcenterAt(double lat, double lon, boolean animated)设置地图中心点.4、获取/设置范围返回类型方法说明PolygongetExtent()返回当前可视区域范围.EnvelopegetMaxExtent()获取MapView的最大范围.voidsetExtent(Geometry geometry)设置当前地图显示的空间范围.地图缩放、平移和旋转1、地图缩放返回类型方法说明voidzoomin()放大地图.voidzoomout()缩小地图.voidzoomTo(Point centerPt, float factor)缩放到给定点.voidzoomToResolution(Point centerPt, double res)设定中心点，缩放到给定分辨率水平.voidzoomToScale(Point centerPt, double scale)设定中心点，缩放到指定比例尺.2、地图平移MapView的方法中，没有专门针对平移操作，主要原因在于，MapView中已经默认支持平移操作，即使用鼠标或手势拖动地图时就会平移地图，所以无需设置；3、地图旋转返回类型方法说明doublegetRotationAngle()返回当前地图旋转角度（单位degree）.voidsetRotationAngle(double degree, Point centerPt, boolean animated)将地图旋转到指定的角度（单位degree），度数为正数则按逆时针方向旋转.中心点、动画可选.voidsetRotationAngle(double degree, float pivotX, float pivotY)以某个点为中心旋转地图.voidsetAllowRotationByPinch(boolean allowRotationByPinch)允许/取消pinch旋转.booleanisAllowRotationByPinch()返回是否允许pinch时旋转.地图坐标转换地图坐标转换主要使用下列几个方法，其中，主要使用toMapPoint()方法实现获取地图上的点坐标信息：返回类型方法说明SpatialReferencegetSpatialReference()返回地图的坐标系统.PointtoMapPoint(float screenx, float screeny)将屏幕坐标转换成地图坐标系下的ArcGIS geometry Point坐标.PointtoMapPoint(Point src)将屏幕坐标转换成地图坐标系下的ArcGIS geometry Point坐标.PointtoScreenPoint(Point src)将地图坐标系下的ArcGIS geometry Point坐标转换成屏幕坐标.地图手势操作默认情况下的MapView将下面的手势作出回应：单指双击和双指手势出来会放大到地图。双指双击和捏合手势将缩小地图。单指拖动和单击快速滑动手势会平移地图。双击后拖动手势将允许进/出地图的缩放持续。返回类型方法说明OnLongPressListenergetOnLongPressListener()获取地图长按事件监听.OnPanListenergetOnPanListener()获取地图平移事件监听.OnPinchListenergetOnPinchListener()获取地图捏夹事件监听.OnSingleTapListenergetOnSingleTapListener()获取地图单击事件监听.OnZoomListenergetOnZoomListener()获取缩放监听.voidsetOnLongPressListener(OnLongPressListener onLongPressListener)设置地图长按事件监听.voidsetOnPanListener(OnPanListener onPanListener)设置地图平移事件监听.voidsetOnPinchListener(OnPinchListener onPinchListener)设置地图捏夹事件监听.voidsetOnSingleTapListener(OnSingleTapListener onSingleTapListener)设置地图单击事件监听.voidsetOnZoomListener(OnZoomListener onZoomListener)设置缩放监听.MapView 的方法MapView的所有公有方法及描述。返回类型方法说明intaddLayer(Layer layer, int index)Adds the child Layer at the given index.intaddLayer(Layer layer)Adds the child Layer.voidaddLayers(Layer[] layerArray)Adds the Layer array.voidcenterAndZoom(double lat, double lon, float levelOrFactor)If the MapView is initialized, centers the map at the given latitude and longitude and zoom the map based on the given factor.voidcenterAt(double lat, double lon, boolean animated)If the MapView is initialized, centers the map at the given latitude and longitude; optionally, the change is animated.voidcenterAt(Point centerPt, boolean animated)If the MapView is initialized, centers the map at the given point; optionally, the change is animated.BitmapcreateSymbolImage(Symbol symbol, Geometry geometry, int width, int height, int color)This method was deprecated in API level . at 10.2.2 use getLegendImage(Symbol, Geometry, int, int, int) instead.Bitmap[]createSymbolImages(Symbol[] symbol, Geometry[] geometry, int width, int height, int color)This method was deprecated in API level . at 10.2.2 use getLegendImages(Symbol[], Geometry[], int, int, int) instead.voidenableWrapAround(boolean enable)Enable or disable the map wrap around feature.ViewGroup.LayoutParamsgenerateLayoutParams(AttributeSet attrs)CalloutgetCallout()Returns a callout window.PointgetCenter()Returns the center of the MapView as an ArcGIS geometry Point.BitmapgetDrawingMapCache(float x, float y, int w, int h)Creates a drawing cache of the map in the given screen coordinates.PolygongetExtent()Returns a polygon comprising of four corners of map in map coordinates.GridgetGrid()Returns the Grid instance of the map which allows for the type and visibility of the grid to be controlled.LayergetLayer(int index)Gets a layer at the given index.LayergetLayerByID(long layerID)Gets a layer by its ID.LayergetLayerByURL(String url)Gets a layer by its service URL.Layer[]getLayers()Returns all child Layers that are added to the MapView.LocationDisplayManagergetLocationDisplayManager()Returns the LocationDisplayManager.EnvelopegetMapBoundaryExtent()This method was deprecated in API level . in 10.2.2, use getMaxExtent() insteadEnvelopegetMaxExtent()Returns the max extent of the map.doublegetMaxResolution()This method was deprecated in API level . at 10.2.2 please use getMinScale()doublegetMaxScale()Returns maximum scale.doublegetMinResolution()This method was deprecated in API level . 10.2.2 please use getMaxScale()doublegetMinScale()Returns the minimum scale.OnLongPressListenergetOnLongPressListener()Gets the OnLongPressListener of the MapView.OnPanListenergetOnPanListener()Gets the OnPanListener of the MapView.OnPinchListenergetOnPinchListener()Gets the OnPinchListener of the MapView.OnSingleTapListenergetOnSingleTapListener()Gets the onSingleTapListener of the MapView.OnStatusChangedListenergetOnStatusChangedListener()Gets the OnStatusChangedListener of the MapView.OnZoomListenergetOnZoomListener()Gets the OnZoomListener of the MapView.doublegetResolution()Returns the resolution of the MapView.doublegetRotationAngle()Returns the current rotation angle of the map in degrees counter-clockwise.doublegetScale()A convenience method for obtaining the current map scale .SpatialReferencegetSpatialReference()Returns the spatial coordinate system being used by the MapView.booleanisAllowOneFingerZoom()Returns true if one-finger zooming is allowed.booleanisAllowRotationByPinch()Returns true if the rotation by pinch is allowed.booleanisLoaded()Returns true if the MapView is initialized.booleanisRecycled()Returns true if the MapView has been recycled.booleanisShowMagnifierOnLongPress()This method checks whether the map will show the magnifier when the user performs a tap and hold gesture on the map.voidonChildViewAdded(View parent, View child)voidonChildViewRemoved(View parent, View child)voidpause()Pauses the map.voidrecycle()Releases the resources referenced by the MapView so that they can be recycled.voidremoveAll()Removes all child layers from the map.voidremoveLayer(int index)Removes a child layer at the given index.voidremoveLayer(Layer layer)Removes the child Layer from the parent MapView.voidrestoreState(String state)Restores the center and resolution, and the LocationDisplayManager state (whether it was active and whether or not to autopan) from the given state String into the MapView.StringretainState()Saves the coordinates of the center of the map, the current map resolution, and the LocationDisplayManager state (whether it was active and whether or not to autopan) as a String.voidsetAllowMagnifierToPanMap(boolean allow)Flag to indicate if the map should pan when the magnifier gets near the edge of the map’s bounds.voidsetAllowOneFingerZoom(boolean allowOneFingerZoom)Allows/disallows one-finger zooming.voidsetAllowRotationByPinch(boolean allowRotationByPinch)Allows/disallow pinch to rotate.voidsetEsriLogoVisible(boolean visible)Turns on or off the ESRI logo.voidsetExtent(Geometry geometry, int padding)Zooms the map to the given geometry, so that geometry fits within the bounds of the map with the specified padding between the geometry and edge of the map.voidsetExtent(Geometry geometry)Zooms the map to the given geometry so that geometry fits within the bounds of the map.voidsetExtent(Geometry geometry, int padding, boolean animated)Zooms the map to the given geometry, so that geometry fits within the bounds of the map with the specified padding between the geometry and edge of the map; optionally, the change is animated.voidsetMapBackground(int bkColor, int gridColor, float gridSize, float gridLineSize)Sets the map background with color and grid.booleansetMapOptions(MapOptions options)Switches basemap by the given options.voidsetMaxExtent(Envelope env)Sets the boundary extent of the map.voidsetMaxResolution(double maxResolution)This method was deprecated in API level . at 10.2.2 please use setMinScale(double)voidsetMaxScale(double maxScale)Sets the maximum scale to which the map can be zoomed in.voidsetMinResolution(double minResolution)This method was deprecated in API level . at 10.2.2, please use setMaxScale(double)voidsetMinScale(double minScale)Set the minimum scale to which the map can be zoomed out.voidsetOnLongPressListener(OnLongPressListener onLongPressListener)Sets the OnLongPressListener of the MapView.voidsetOnPanListener(OnPanListener onPanListener)Sets the OnPanListener of the MapView.voidsetOnPinchListener(OnPinchListener onPinchListener)Sets the onPinchListener of the MapView.voidsetOnSingleTapListener(OnSingleTapListener onSingleTapListener)Sets the onSingleTapListener of the MapView.voidsetOnStatusChangedListener(OnStatusChangedListener onStatusChangedListener)Sets the OnStatusChangedListener of the MapView.voidsetOnZoomListener(OnZoomListener onZoomListener)Sets the OnZoomListener of the MapView.voidsetResolution(double res)Sets the resolution of the MapView.voidsetRotationAngle(double degree, Point centerPt, boolean animated)Rotates the map to the given angle in degrees and re-centers the map at the specified map coordinates; optionally, the change is animated.voidsetRotationAngle(double degree, boolean animated)Rotates the map to the given angle in degrees; optionally, the change is animated.voidsetRotationAngle(double degree)Rotates the map to the given angle in degrees; if the specified angle is positive, rotation is counter-clockwise, if negative then rotation is clockwise.voidsetRotationAngle(double degree, float pivotX, float pivotY)Rotates the map to the given angle in degrees, pivoting the rotation around a given point on the screen.voidsetScale(double scale, boolean animated)Sets the map scale; optionally, the change is animated.voidsetScale(double scale)Sets the map scale.voidsetShowMagnifierOnLongPress(boolean showMagnifier)Sets a flag that defines whether or not the map should show the magnifier when the user performs a long press gesture on the map.FutureswitchBaseMap(BaseMap basemap, Portal portal, OnBaseMapSwitchListener listener)Replaces the basemap layers of this MapView if it was created from a WebMap, otherwise just adds the new basemap layers at the bottom or top of the existing MapView layers, depending on whether they are base or reference layers.PointtoMapPoint(float screenx, float screeny)A convenience method that will convert a device’s screen coordinates to an ArcGIS geometry Point that has the same spatial coordinate system as the MapView’s.PointtoMapPoint(Point src)A convenience method that will convert a device’s screen coordinates into an ArcGIS geometry Point that has the same spatial coordinate system as the MapView’s.PointtoScreenPoint(Point src)A convenience method that will convert an ArcGIS geometry Point from the MapView’s spatial coordinate system into the device’s screen coordinates.voidunpause()Unpauses the map.voidzoomTo(Point centerPt, float factor)If the MapView is initialized, zooms the map by a factor to the given center point.voidzoomToResolution(Point centerPt, double res)Centers the map on the given point and zoom into the given resolution level.voidzoomToScale(Point centerPt, double scale)Centers the map on the given point and zoom into the given scale level.voidzoomin()Zooms in one level from current map resolution; the map animates to the new resolution.voidzoomin(boolean animated)Zooms in one level from current map resolution; optionally, the change is animated.voidzoomout()Zooms out one level from current map resolution; the map animates to the new resolution.voidzoomout(boolean animated)Zooms out one level from current map resolution; optionally, the change is animated.参考资料1、MapView | ArcGIS Android 10.2.7 APIhttps://developers.arcgis.com/android/api-reference/reference/com/esri/android/map/MapView.html2、ArcGIS for Android地图控件的5大常见操作http://blog.csdn.net/arcgis_mobile/article/details/78014673、《ArcGIS Runtime SDK for Android开发笔记》——（9）、空间数据的容器-地图MapView - gis-luq - 博客园http://www.cnblogs.com/gis-luq/p/4941715.html4、arcgis for android 学习 - (4) 了解mapView的一些方法和事件 - 张云飞VIR - 博客园http://www.cnblogs.com/vir56k/archive/2012/06/04/2534418.html]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-5、Hello World]]></title>
    <url>%2Fposts%2F87f9c009.html</url>
    <content type="text"><![CDATA[开发环境搭建完成后，按照国际惯例先写一个 Hello World。ArcGIS for Android 项目代码编写在布局中添加 MapView打开 res&gt;&gt;layout&gt;&gt;activity_main.xml 文件，添加 MapView&lt;com.esri.android.map.MapView android:id=&quot;@+id/map&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 新建 MapView 并设置 UI 和代码的绑定private MapView mMapView = null; private ArcGISTiledMapServiceLayer mArcGISTiledMapServiceLayer = null; //设置UI和代码绑定mMapView = (MapView)this.findViewById(R.id.map); 新建地图图层并添加到 MapView 中String strMapUrl=&quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer&quot;; mArcGISTiledMapServiceLayer = new ArcGISTiledMapServiceLayer(strMapUrl); mMapView.addLayer(mArcGISTiledMapServiceLayer); ArcGIS for Android 项目运行和普通 Android 项目类似，ArcGIS for Android 项目可以在模拟器中运行，也可以在真机中运行在真机运行项目1、手机需要开启 开发者调试模式注：在 Android 4.2 以后版本的系统中, 开发者模式是默认隐藏的。到 设置 &gt; 关于手机 连续点击版本号7次即可显示。2、点击Android Studio工具栏上的Run按钮，运行Android项目。3、选择连接手机设备、点击OK即可4、运行效果在模拟器中运行项目1、点击AVD Manager按钮打开 AVD Manager 界面2、点击左下角的Create Virtual Device，创建模拟器3、可以根据自己的需要配置，这里我默认4、根据自己的需要选择系统镜像、我选择默认5、模拟器配置，注意Graphices选项，选择Hardware具体可参考:教你5步学会ArcGIS Android模拟器调试6、稍等片刻创建完成。7、选择刚刚创建的模拟器，点击Launch emulator第一次启动可能有点慢，运行效果如下模拟也要开启开发者模式、方法和真机完全相同以下步骤和真机运行类似8、点击Android Studio工具栏上的Run按钮，运行Android项目。9、选择连接模拟设备、点击OK即可可能会报错 INSTALL_FAILED_NO_MATCHING_ABIS是由于使用了 native libraries 。该 native libraries 不支持当前的 CPU 的体系结构。就是在libs文件夹下删除过多出问题了。我们的模拟器是X86的，可以保留 X86 其他的删除。10、再次运行，效果如下参考资料1、Running Your Apphttps://developer.android.com/training/basics/firstapp/running-app.html2、教你5步学会ArcGIS Android模拟器调试http://blog.csdn.net/arcgis_mobile/article/details/7758650]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-4、ArcGIS for Android开发环境搭建（离线部署）]]></title>
    <url>%2Fposts%2Fc96fa2b2.html</url>
    <content type="text"><![CDATA[本文主要介绍以复制SDK的形式搭建ArcGIS for Android开发环境ArcGIS for Android SDK的下载1、打开 ArcGIS for Developers 网站、点击右上角登录2、登陆成功后进入到 Applications 页面，点击右上角的下载按钮打开 下载页面。3、可以看到ArcGIS Runtime SDK for Android 最新版10.2.7的下载地址，点击 download 按钮下载。ArcGIS for Android SDK的解压与复制1、解压 ArcGIS for Android SDK 包，目录结构如下。其中里面比较重要的有以下几项：1、doc —— 该版本SDK对应的API文档，官网一直都是最新的，需要查看旧版API或者指定版本API说明的的一般需要到这里查找 2、lib-project —— aar格式的函数库，例如：arcgis-android-v10.2.6-2.aar 3、libs —— jar和so格式的函数库，一般在项目中拷贝到项目文件夹下，引用即可，可实现离线部署 4、samples——示例代码。官方所有示例代码都在这里，新版基于Android studio 开发环境 其他说明：SDK包下载及说明也可以参考博文http://www.cnblogs.com/gis-luq/p/4735815.html2、将SDK libs文件夹下的文件复制到项目的libs文件夹下。其实所有文件复制过去、安装包是比较大的（30M+），可以考虑开发时把其中两个先删除了，减少编译时间，生成安装包时再加上。至于 armeabi、armeabi-v7a 和 x86 之间的区别可参考文章：http://blog.csdn.net/loveyaozu/article/details/51205820ArcGIS for Android SDK的配置在此说明我的Android Studio版本是 Android Studio 2.1 Beta3 其他版本可能略有不同。App Module配置在App Module添加如下代码配置SDKsourceSets { main { jniLibs.srcDir &#39;libs&#39; } } 点击同步 Gradle 按钮，可以看到SDK已经添加进来了。以下关于SDK使用的内容和在线部署完全相同2、Packaging 配置在生成APK时我们可能不希望将一些文件打包到 APK 中，这时我们可通过下面的配置将所需文件排除 APK 文件中：packagingOptions{ exclude &#39;META-INF/LGPL2.1&#39; exclude &#39;META-INF/LICENSE&#39; exclude &#39;META-INF/NOTICE&#39; } Permissions 和 Features 配置对于绝大多数的 ArcGIS Android 应用几乎都需要网络的支持；也有一些应用可能会需要访问设备的 SDcard ，需要对该卡有读写的权限；除此对于 GIS 来说最常用的功能就是定位了，应用应该具备定位权限。ArcGIS Android 的 MapView 使用了 OpenGL ES 2.x，所以在配置文件中还需添加 OpenGL ES 的支持，因此应用的配置文件至少包含下面的配置信息：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt; 至此ArcGIS for Android开发环境搭建完成参考资料1、Android开发中libs包下面的mips、armeabi、armeabi-v7a和x86http://blog.csdn.net/loveyaozu/article/details/512058202、基于Android Studio构建ArcGIS Android开发环境（离线部署）http://www.cnblogs.com/gis-luq/p/4760377.html3、Arcgis Android 手动搭建开发环境http://www.cnblogs.com/wangcan/p/4773530.html4、使用Android Studio进行ArcGIS for Android开发的环境部署http://blog.sina.com.cn/s/blog_7cdaf8b60102w0bk.html]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-3、ArcGIS for Android开发环境搭建]]></title>
    <url>%2Fposts%2F29ec97b7.html</url>
    <content type="text"><![CDATA[本文主要针对在Windwos环境下用Android Studio搭建ArcGIS for Android开发环境新建 Android 项目1、打开Android Studio 选择 Start a new Android Studio project 新建一个Android项目2、配置项目，确定各个名称和存放项目存放路径Application name：项目名称 Company Domain：公司域名 Package name：APP 打包名称 project location：存放路径 3、接下来设定兼容的安卓的最小版本，这依情况而定，我这里设定为安卓4.0.3版本。如果不确定各个版本的区别，可以点击 Help me choose，在打开的窗口中介绍了各个安卓版本的比例。4、确定后最小兼容版本后，选择项目的活动类型，这里有很多现成的模板可以使用，对于初学者选择默认的Blank Activity即可。5、接下来设定活动名称，界面布局的名称，以及界面标题，最后点击Finish完成项目的创建。更多内容可访问以下网址：Android studio教程：[1]创建app项目http://jingyan.baidu.com/article/4853e1e51ba60e1909f726ad.html配置 ArcGIS for Android 支持Gradle是近来比较流行的一个系统构建工具，你可以通过编译自己的构建文件（build.gradle）来自定义构建流程。一个Gradle项目的构建文件是在项目的根目录下，您可以在项目的根目录下找到构建文件（build.grade）。在开发ArcGIS for Android的Gradle项目时需要配置两部分的依赖管理内容：配置 Project 的ArcGIS Repository（Esri ArcGIS maven）仓库位置配置 App Module 的ArcGIS Runtime SDK for Android依赖。ArcGIS Repository 配置打开根目录下的构建配置文件 build.gradle 文件，添加仓库配置，如下：repositories { jcenter() // Add the following ArcGIS repository maven { url &#39;https://esri.bintray.com/arcgis&#39; } } App Module 配置App Module中的 build.gradle 文件适合用来放特殊的指令和任务。一个 ArcGIS Android APP 需要 ArcGIS Android API library 工程 AAR bundle 。一旦在 Project 级别的 build.gradle 文件中配置好了ArcGIS 的仓库，则可以再这个文件中声明 ArcGIS Android 的依赖。1、ArcGIS 依赖配置dependencies { // Add the ArcGIS Android 10.2.7 API compile &#39;com.esri.arcgis.android:arcgis-android:10.2.7&#39; } 2、Packaging 配置在生成APK时我们可能不希望将一些文件打包到 APK 中，这时我们可通过下面的配置将所需文件排除 APK 文件中：packagingOptions{ exclude &#39;META-INF/LGPL2.1&#39; exclude &#39;META-INF/LICENSE&#39; exclude &#39;META-INF/NOTICE&#39; } Permissions 和 Features 配置对于绝大多数的 ArcGIS Android 应用几乎都需要网络的支持；也有一些应用可能会需要访问设备的 SDcard ，需要对该卡有读写的权限；除此对于 GIS 来说最常用的功能就是定位了，应用应该具备定位权限。ArcGIS Android 的 MapView 使用了 OpenGL ES 2.x，所以在配置文件中还需添加 OpenGL ES 的支持，因此应用的配置文件至少包含下面的配置信息：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; &lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt; 至此ArcGIS for Android开发环境搭建完成参考资料1、Install and set up ArcGIS Runtime SDK for Androidhttps://developers.arcgis.com/android/guide/install-and-set-up.htm2、Creating an Android Projecthttps://developer.android.com/training/basics/firstapp/creating-project.html3、ArcGIS Runtime SDK for Android 10.2.5新开发平台安装配置指南http://blog.csdn.net/arcgis_all/article/details/44060885]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-2、ArcGIS for Android介绍]]></title>
    <url>%2Fposts%2F61d96b3d.html</url>
    <content type="text"><![CDATA[ArcGIS for Android介绍Android是Google公司推出的开源移动操作系统，自2007年推出后，飞速发展，目前已经成为市场占有率最高的移动操作系统。Android SDK支持使用Java语言开发应用程序，Esri为Android平台提供了专门的开发包ArcGIS Runtime SDK for Android，便于开发者打造炫酷的地图应用，开发好的应用能够部署在Android智能手机、平板电脑和其他智能终端上，支持华为、小米、联想、HTC、Google、三星等国内外众多品牌。产品简介ArcGIS Runtime SDK for Android包括一个用于Android Studio的lib-project，用于eclipse等环境的jar函数库，提供了丰富的工具、文档和示例，使用户能够使用Java构建移动应用程序（这些应用程序将运用ArcGIS for Server提供的强大的制图、地理编码、地理处理和自定义功能）并将它们部署到Android系统的智能手机和平板上。ArcGIS Runtime SDK for Android可以通过ArcGIS for Server REST服务获取数据和服务资源。Esri发布了 GeoServices REST Specification ,这一标准规定了ArcGIS REST Service各种接口的访问参数及返回数据的结构，ArcGIS Runtime SDK for Android正是基于这一标准封装的。其实，ArcGIS基于REST接口的API，包括ArcGIS Runtime SDK for Android/iOS/Windows Phone，ArcGIS API for Flex/ Silverlight/ JavaScript，以及ArcGIS Runtime SDK for Java/.NET，都是基于这一标准进行封装的。尽管不同平台、不同语言的开发包有其自己的特性，但其对应服务端的编程模型是一致的。下图能很好的说明这一点。除了ArcGIS for Server，ArcGIS Runtime SDK for Android还可以通过Portal API轻松访问ArcGIS Online和Portal for ArcGIS上的资源，即与云建立密切的联系。另外，在10.2的版本中，ArcGIS Android SDK也能使用本地离线的数据，作为应用的重要数据源，这也是10.2的重大更新，被多数用户和开发者所关注，后面教程中也会详细介绍。截止目前写稿为止，ArcGIS Runtime SDK for Android最新版本是10.2.6-u2。有关ArcGIS Runtime SDK for Android 10.2.6-u2的所有资料，包括安装包下载、系统支持、安装环境说明、API接口说明、Sample、在线帮助等，都能从最新的ArcGIS for Developer站点 https://developers.arcgis.com/android/ 查找到。发展历程ArcGIS for Android从产品上来讲分为两个部分，一是给开发者准备的ArcGIS Runtime SDK for Android开发包，专用来开发Android设备上的移动GIS应用；另一个是名为“ArcGIS”的app，它使用ArcGIS Runtime SDK for Android开发包开发，具备常用的和典型的GIS功能，拿来即用，并可在Google Play等商店免费下载。ArcGIS Runtime SDK for Android开发包的发展历程如下：约在2011年6月份，发布ArcGIS Runtime SDK for Android beta版，就是开发者常说的0.9版本。它是一个测试版本，支持2.1，2.2的android系统。因为是第一个支持android智能操作系统的版本，虽然是测试版，也备受开发者关注。这个版本中，可以使用ArcGIS for Server中的地图服务、要素服务来进行移动端的地图浏览和简单查询操作，使用设备的GPS坐标，等等；2011年12月14日，发布了ArcGIS Runtime SDK for Android v1.0.1，这是第一个正式版的Android SDK。该正式版包含了beta全部功能，对其中一些bug进行了修复，并新增了许多功能，重要的功能如支持本地缓存的松散型切片，迈出了离线应用的第一步；总体上的功能已经比较完善，包括与Online和Portal的集成，使用设备的GPS，进行简单的外业数据采集和编辑，使用Server和Online上的分析功能，能进行identify操作，可以显示popup up，进行高级的几何计算等。为以后的版本功能提升提供了较好的原型；与0.9版本比较，1.0及以后的版本，SDK架构发生了很大的变化，主要变化在于核心功能改由C/C++编写，SDK层（Java）通过JNI的方式调用，以此提高效率。因此，需要支持OpenGL ES2.0的GPU。2012年4月7日，发布ArcGIS Runtime SDK for Android v1.1。这个版本的改进主要是增加了高级符号，支持一个应用中多个MapView，以及Group Layer中支持对所有子图层的操作，另外，与Online和Portal的结合更加深入，可以搜索组织的内容、用户、组等信息；2012年5月10日，发布ArcGIS Runtime SDK for Android v1.1.1版本。这个版本仅对v1.1版本进行了一个修复——让Eclipse能够更好的、更正确的识别Android依赖库；2012年6月22日，发布ArcGIS Runtime SDK for Android v2.0版本。这个版本最大的变化是对云的支持全面加强，支持ArcGIS 10.1的桌面、服务器和云产品，并正式推出Portal API来操作云中的资源。可以说这是在云计算的兴起之下，Esri的“云端”应用模式的全面体现。同时，发布了同步的ArcGIS app for Android v2.0版本，也是全面的加强与云的集成；2013年1月16日，发布ArcGIS Runtime SDK for Android v10.1.1版本。这个版本中新增了对网络分析、PKI认证的加密服务的支持，新增对KML、WMS、OpenStreetMap等第三方地图服务的支持；更为重要的是，Runtime SDK的版本号从这个版本开始发生了巨大的变化，从2.0直接升级到了10.1.1，同时，其它Runtime SDK（包括Java SE, WPF, Windows Phone等）版本号全部都更新至10.1.1；2013年7月1日，发布ArcGIS Runtime SDK for Android v10.1.1 update 1。这个版本的升级变化也很小，主要是支持了Android Support Library 13，并支持ArcGIS Online上的OAuth2类型的资源的访问；同时，这个版本提供了Javadoc；2013年10月29日，发布ArcGIS Runtime SDK for Android v10.2版本。10.2版本与之前的版本相比变化较大，一是新增了很多类和框架来辅助开发人员开发，如MapOptions和Application Framework for ArcGIS Android框架；同时，GraphicsLayer新增动态模式，性能极大提升；GeometryEngine中也新增了很多诸如测地线、偏移量、椭圆等方法来完成几何计算；另一方面，更大的变化是推出了Beta版的离线功能，提供相应的类和接口，来实现业务数据的离线存储、编辑，以及离线的地理编码和路径分析功能，这是国内用户需求最大、备受关注的功能之一，因此一经推出便引起广泛关注。只可惜这些离线的功能只是Beta版，并且需要10.2.1的Desktop和Server产品配合使用，因此离线功能并不能真正用于实践；2014年3月8日，发布ArcGIS Runtime SDK for Android v10.2.2版本。这个版本有两个最大的变化，一是正式推出了离线功能，10.2版本中Beta版的离线功能全部正式对用户提供，包括离线的要素编辑和同步，离线的地理编码，离线的路径分析功能，以及按需动态缓存地图切片到移动端等；另一大变化是授权的变化。ArcGIS Runtime SDK统一变更了授权方式，未经过授权的用户只可使用其中基础的功能，并且应用程序在分发时还会打上水印。2014年4月21日，发布ArcGIS Runtime SDK for Android v10.2.3版本。这个版本的主要变化在于它提供了一个全新的GeodatabaseFeatureServiceTable类来使用ArcGIS Feature Services，达到同时使用离线和在线数据的目的。2014年10月6日，发布ArcGIS Runtime SDK for Android v10.2.4版本。在这个版本中,更新了最低支持Android平台版本的android 4.0.1(API级别14)。直接支持本地矢量格式和栅格格式，包括shapefiles、KML、geopackages，可以直接影像数据，包括：ASRP/USRP、CIB1,5,10、DTED0, 1, 2、GeoPackage、GeoTIFF、HFA、HRE、IMG、JPEG、JPEG2000、NITF、PNG、RPF、SRTM1, 2。支持离线的空间分析功能，视线和视域分析（beta）（暂不支持x86设备），优化GeodatabaseFeatureServiceTable，使得在线离线都可以使用功能单一的API。网络地图服务得到了增强，支持了WMTS服务、Imager服务。离线API的质量得到了改进，包括地图的行为和性能改、callout显示增强。2015年1月15日，发布ArcGIS Runtime SDK for Android v10.2.5版本。支持android studio开发环境，示例代码默认开发环境基于Android Studio。Eclipse插件被弃用。从版本10.2.5,Esri公司不再提供的Eclipse IDE工具插件的形式,但是,它是可以继续使用jar包引用方式通过Eclipse完成开发工作。2015年6月19日，发布ArcGIS Runtime SDK for Android v10.2.6版本。该版本中大量的小bug得到了改进和更新。截稿至今2015年9月10日目前最新的版本为v10.2.6-u2。未来版本：“Quartz”，它是ArcGIS Runtime SDK下一个大版本的代号。这一版本包括了一系列显著的功能增强，正式版本预期于2016年第一季度发行，之前会有几个beta版本发行，第一个测试版定于2015年8月发行。(2015 UC)- - ArcGIS Runtime Quartz版本的新功能，包括：1) 地图性能改进2) 支持更多数据格式，矢量数据包括移动地理数据库（Runtime geodatabase），shapefile文件，KML；栅格图像主要包括JPEG， JPEG2000， NITF， GeoTIFF， MrSID， CADRG， ECRG， DTED， SRTM， HRE以及激光雷达。此外，还支持OGC的GeoPackage，以及自定义的矢量和栅格数据源3) 本地分析在内的更多GIS分析功能4) 支持智能制图，矢量切片和读写在线地图的功能5) 支持3D场景，浏览、分析3D数据6) 支持Xamarin，允许.NET开发人员构建跨平台运行的应用程序。功能概述使用ArcGIS Runtime SDK for Android，用户能够开发出功能强大的移动端GIS应用程序并将它们部署到Android系统的智能手机和平板上，主要功能可覆盖：地图浏览：实现常见的地图缩放、平移、旋转操作，并且支持手势响应；能加载和显示图例、指南针、罗盘等多种地图辅助元素；地图测量：能实现长度、面积、周长及测地线等的测量；数据查询：提供多种类和接口，用来进行基于图层的搜索、关键词搜索、模糊查询、周边搜索等，还能实现空间查询和非空间查询的结合；几何计算：包括简单的叠加分析、缓冲区分析，以及并、交、差等空间关系的运算；分析：包括最小/最短路径分析、地理编码、通视分析等；数据编辑：可编辑要素的空间信息或属性信息，空间信息包括更改要素的符号，改变要素的形状，移动要素的位置等，属性信息可更改其名称、照片等；还可新增、删除要素，并对编辑的数据进行保存；离线功能：可将数据下载到本地，或者直接使用本地数据源，在移动端实现数据的编辑、保存等功能，从而实现离线的外业作业流程；数据可视化：可使用多种要素符号、弹出框、图标、表格、柱状图等多种方式对数据进行展示和直观表达；访问云中的资源：可轻松访问ArcGIS Online和Portal for ArcGIS中的资源和服务，实时同步，随时随地的使用云中资源；GPS定位：使用设备的GPS模块，进行准确的定位和导航，精度能满足大众和专业用户的需求。本文出处： http://www.cnblogs.com/gis-luq/p/4765993.html转载文章以下声明无效]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ArcGIS Runtime SDK for Android学习笔记》-1、Android开发环境搭建]]></title>
    <url>%2Fposts%2Ff6977dbb.html</url>
    <content type="text"><![CDATA[本文主要针对在Windwos环境下用Android Studio搭建Android开发环境前言Android Studio 是一个Android开发环境，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试。在IDEA的基础上，Android Studio 提供：基于Gradle的构建支持Android 专属的重构和快速修复提示工具以捕获性能、可用性、版本兼容性等问题支持ProGuard 和应用签名基于模板的向导来生成常用的 Android 应用设计和组件功能强大的布局编辑器，可以让你拖拉 UI 控件并进行效果预览系统要求与软件准备系统要求Windows系统Microsoft® Windows® 8/7/Vista/2003（32 位或 64 位） 最低：2GB RAM，推荐：4GB RAM 400MB 硬盘空间 Android SDK、模拟器系统映像及缓存至少需要 1GB 空间 最低屏幕分辨率：1280 x 800 Java 开发工具包 (JDK) 7 用于加速模拟器的选件：支持 Intel® VT-x、Intel® EM64T (Intel® 64) 和禁止执行 (XD) 位功能的 Intel® 处理器 Mac OS X系统Mac® OS X® 10.8.5 或更高版本，直至 10.9 (Mavericks) 最低：2GB RAM，推荐：4GB RAM 400MB 硬盘空间 Android SDK、模拟器系统映像及缓存至少需要 1GB 空间 最低屏幕分辨率：1280 x 800 Java 运行组件环境 (JRE) 6 Java 开发工具包 (JDK) 7 用于加速模拟器的选件：支持 Intel® VT-x、Intel® EM64T (Intel® 64) 和禁止执行 (XD) 位功能的 Intel® 处理器 在 Mac OS 上运行附带 Java 运行组件环境 (JRE) 6 的 Android Studio 可优化字体渲染。您随后可将您的项目配置为使用 Java 开发工具包 (JDK) 6 或 JDK 7。 Linux系统GNU 网络对象模型环境或 KDE 桌面 GNU C Library (glibc) 2.15 或更高版本 最低：2GB RAM，推荐：4GB RAM 400MB 硬盘空间 Android SDK、模拟器系统映像及缓存至少需要 1GB 空间 最低屏幕分辨率：1280 x 800 Oracle® Java 开发工具包 (JDK) 7 已在 Ubuntu® 14.04 (Trusty Tahr)（能够运行 32 位应用的 64 位分发）上进行了测试。 更新的详细信息可访问官网：https://developer.android.com/intl/zh-cn/sdk/index.html#Requirements软件准备Google官方对于Android的开发建议使用Android Studio工具，该工具有哪些优势在这里就不在进行阐述了，感兴趣的可以去百度或Google搜索一下，除了Android Studio我们当然还可以使用Intellij IDEA这个开发工具，不过Intellij IDEA是收费的工具，下面列出这两个工具的下载地址：Android Studio下载地址：http://developer.android.com/sdk/index.html由于某些 众所周知 的原因以上网站可能无法访问：建议在Android Studio 中文社区下载Android Studiohttp://www.android-studio.org/Android SDK镜像站可在AndroidDevTools查找http://www.androiddevtools.cn/郑州大学开源镜像站： 郑州大学开源镜像站如果用校园网请填写 10.66.0.111 如果用联通/电信等外网请填写 123.15.57.34 JDK (Java SE Development Kit)下载地址：http://www.oracle.com/technetwork/cn/java/javase/downloads/index.html其他：Intellij IDE下载地址：http://www.jetbrains.com/idea/download/安装与配置过程JDK安装比较简单下一步、下一步，我就不在此赘述了。JAVA环境配置比如JDK安装在C:\Program Files\Java\jdk1.7.0变量设置新建变量 JAVA_HOMEC:\Program Files\Java\jdk1.7.0 新建变量 CLASSPATH.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; //记得前面有个&quot;.&quot; 在 PATH 中加入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 环境检查cmd打开命令提示符输入java -version，存在输出。详细可看以下文章：Java 开发环境配置：http://www.runoob.com/java/java-environment-setup.htmlAndroid环境配置以前一直以为Android不需要配置环境。后来出现问题了才发现。比如SDK安装在 D:\AndroidStudio\sdk变量设置新建变量 ANDROID_HOMED:\AndroidStudio\sdk 在 PATH 中加入%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools; 环境检查cmd打开命令提示符输入adb，存在输出。Android Studio安装对于Android Studio的安装部署分为两种情况：1、绿色版，解压后直接运行/bin/studio.exe或者/bin/studio64.exe即可，具体取决于所安装的JDK位数（32位或64位）。2、安装版，安装过程依旧是一路下一步，这里不做赘述。不清楚的可以参考百度经验教程。android studio安装使用教程（详细图文教程）http://jingyan.baidu.com/article/ad310e80a9328a1849f49e30.htmlAndroid Studio配置1、完成安装后选择Android Studio配置文件所在路径，对于第一次安装的情况，选择第二项不导入配置信息，点击OK。2、在弹出的欢迎页面选下一步。3、在安装选项处有两项内容：Standard和Custome。Standard为标准安装，Custome为用户自定义安装，这里我们选择第二种，自定义安装。4、设置Android Studio IDE 主题样式信息5、选择Android SDK路径信息，这里分为两种情况：选择位置已经包含离线下载好Android SDK：这种情况下只会检查缺少的项目并下载，如果SDK内容完整则不联网下载任何内容。选择位置不包含Android SDK：联网在指定位置下载Android SDK。6、这里我们选择第二种方式，离线部署Android SDK，由于内容不完整，所以需要联网下载缺少部分内容。如果启动时出现 fetching Android sdk compoment information 时间过长可以参考以下方法解决：1）进入刚安装的Android Studio目录下的bin目录。找到idea.properties文件，用文本编辑器打开。2）在idea.properties文件末尾添加一行： disable.android.first.run=true ，然后保存文件。3）关闭Android Studio后重新启动，便可进入界面。7、安装完成后，点击Finish即可。参考资料：android studio安装使用教程（详细图文教程）http://jingyan.baidu.com/article/ad310e80a9328a1849f49e30.html]]></content>
      <categories>
        <category>ArcGIS Runtime SDK for Android</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
        <tag>ArcGIS Runtime SDK for Android</tag>
        <tag>ArcGIS for Android</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat安装配置]]></title>
    <url>%2Fposts%2Fc8d48a24.html</url>
    <content type="text"><![CDATA[Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。Tomcat官网Apache Tomcat - Welcome!http://tomcat.apache.orgTomcat下载安装Tomcat下载9.0.0.M4下载地址：http://tomcat.apache.org/download-90.cgi注意:下载可以下载zip格式或exe格式的，其中zip格式的只要解压缩再配置下环境变量就可以使用了，就像绿色版的。我这里使用的是后者exe格式的，这个对于新手比较方便。点击32-bit/64-bit Windows Service Installer下载Tomcat安装安装很简单下一步下一步注意安装之前要有Java环境点击Finish可以看到Tomcat服务启动了打开浏览器，敲入http://localhost:8080,如果出现页面，那么配置成功。Tomcat配置Tomcat环境配置并非必须下面默认已经配置好Java环境。新建变量在桌面此电脑右键、左上角高级系统设置、高级选项卡、环境变量、系统变量下新建以下变量：比如Tomcat安装在C:\Tomcat，其他目录替换C:\Tomcat即可。变量名：CATALINA_BASE 变量值：C:\Tomcat; 变量名：CATALINA_HOME 变量值：C:\Tomcat; 添加变量在PATH中加入%CATALINA_HOME%\bin;在CLASSPATH中加入（如果没此变量，按照上步新建即可）%CATALINA_HOME%\common\lib\servlet-api.jar;(注意加的时候在原变量值后加英文状态下的“;”)其他问题安装tomcat出现failed to install tomcat8 service错误及解决方法在安装tomcat时，报 failed to install tomcat6 service ,check your setting and permissio 错误。往往是因为装过tomcat，而删除它时，只是简单的删除了它的文件夹，并没有删除服务里的tomcat服务，因此才出现上面的安装错误。两种解决办法：1、Windows+R (开始-&gt;运行) services.msc查看 Apache Tomcat 8.0 Tomcat8 对应的服务名，比如我的是 Tomcat8然后 cmd 中执行：sc delete Tomcat82、在运行框输入 regedit，打开注册表。进入HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet*\Services，然后删除 Tomcat8 系列即可 。最后重新安装Tomcat8就可以了。其他由我原来在博客园的文章整理而来1、http://www.cnblogs.com/wangshunli/p/4230382.html2、http://www.cnblogs.com/wangshunli/p/4487353.html]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coding Pages服务绑定域名问题]]></title>
    <url>%2Fposts%2Fa19762cf.html</url>
    <content type="text"><![CDATA[今天发现Hexo在本地部署没有问题、部署到Coding.net就有问题，在网页上文章没有更新我查看了一下在Coding上推送没有问题我就尝试在DNSPod中把域名指向wshunli.github.io发现没有问题我到Coding官网查看了一下、发现Coding Pages服务由之前的要求CNAME 记录指向 wshuni.coding.meCNAME 记录指向 pages.coding.me更改之后问题解决了。不知道为什么Coding不发个通知。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware 12安装Mac OS X 10.10]]></title>
    <url>%2Fposts%2F65583447.html</url>
    <content type="text"><![CDATA[准备软件1.VMware Workstation 12下载VMware Workstation下载__百度软件中心http://rj.baidu.com/soft/detail/13808.html?ald2.unlocker 208（for OS X 插件补丁）Unlockerhttp://www.insanelymac.com/forum/files/file/339-unlocker/或者：http://pan.baidu.com/s/1gexHZB93.Mac OS X 10.10镜像需要.cdr后缀的镜像OS X 10.11.1(15B42).cdr链接: http://pan.baidu.com/s/1skk3Skd 密码: txwg原版系统镜像下载Apple - OS X Yosemite - Mac App Storehttp://www.apple.com/osx/apps/app-store/苹果系统 Mac OS X Yosemite 正式版安装程序镜像下载 (10.10 新功能特性总结)下载 | 异次元软件http://www.iplaysoft.com/osx-yosemite.html安装步骤VMware Workstation 12安装下载Vmare Workstation，以管理员身份运行，安装，一直下一步即可。VM安装好后，注册码百度一大堆。具体可查看百度经验：怎样安装虚拟机wmware12http://jingyan.baidu.com/article/870c6fc30ad5f0b03ee4be5b.htmlUnlocker安装打开任务管理器，找到服务项，选择按名称排序，将框中四项全部停止运行。然后打开下载的插件，解压unlock208.zip文件，找到 unlock208\win-install.cmd，右键以管理员身份运行，等待运行完即可。（完成这一步vmware才能识别OS X）。python的安装及环境配置：Python开发_python的安装 - Hongten - 博客园http://www.cnblogs.com/hongten/p/hongten_python_install.html安装的小技巧：如果选择红框中的选项就不用配置环境变量了。以上内容为Windows平台下的安装方法，其他平台及详细说明可参考一下说明Unlocker208中的readme：Mac OS X Unlocker for VMware V2.0 ================================= 1. Introduction --------------- Unlocker 2 is designed for Workstation 11, Player 7, ESXi 6 and Fusion 7. If you are using an earlier product please continue using Unlocker 1 Version 2 has been tested against: * Workstation 11/12 on Windows and Linux * Player 7 &amp; Workstation Player 12 on Windows and Linux * Fusion 7/8 on Mavericks and Yosemite * ESXi 6.0 The patch code carries out the following modifications dependent on the product being patched: * Fix vmware-vmx and derivatives to allow Mac OS X to boot * Fix vmwarebase .dll or .so to allow Apple to be selected during VM creation * Fix libvmkctl.so on ESXi 6 to allow use with vCenter * Download a copy of the latest VMware Tools for OS X Note that not all products recognise the darwin.iso via install tools menu item. You will have to manually mount the darwin.iso for example on Workstation 11 and Player 7. The vmwarebase code does not need to be patched on OS X or ESXi so you will see a message on those systems telling you that it will not be patched. In all cases make sure VMware is not running, and any background guests have been shutdown. The code is now Python as it makes the Unlocker easier to run and maintain on ESXi. There are some challenges to write the code as ESXi has a subset of Python 2.7 which constrains some modules that can be used. 2. Prerequisites ---------------- The code requires Python 2.7 to work. Most Linux distros, ESXi and OS X ship with a compatible Python interpreter and should work without requiring any additional software. Windows has a packaged version of the Python script using PyInstaller, and so does not require Python to be installed. 3. Limitations -------------- If you are using VMware Player or Workstation on Windows you may get a core dump. Latest Linux and ESXi products are OK and do not show this problem. +-----------------------------------------------------------------------------+ | IMPORTANT: | | ========== | | | | If you create a new VM using version 11 or 12 hardware VMware may stop and | | create a core dump. There are two options to work around this issue: | | | | 1. Change the VM to be HW 10 - this does not affect performance. | | 2. Edit the VMX file and add: | | smc.version = &quot;0&quot; | | | +-----------------------------------------------------------------------------+ 4. Windows ---------- On Windows you will need to either run cmd.exe as Administrator or using Explorer right click on the command file and select &quot;Run as administrator&quot;. win-install.cmd - patches VMware win-uninstall.cmd - restores VMware win-update-tools.cmd - retrieves latest OS X guest tools 5. Linux --------- On Linux you will need to be either root or use sudo to run the scripts. You may need to ensure the Linux scripts have execute permissions by running chmod +x against the 2 files. lnx-install.sh - patches VMware lnx-uninstall.sh - restores VMware lnx-update-tools.cmd - retrieves latest OS X guest tools 6. Mac OS X ----------- On Mac OS X you will need to be either root or use sudo to run the scripts. This is really only needed if you want to use client versions of Mac OS X. You may need to ensure the OS X scripts have execute permissions by running chmod +x against the 2 files. osx-install.sh - patches VMware osx-uninstall.sh - restores VMware 7. ESXi ------- You will need to transfer the zip file to the ESXi host either using vSphere client or SCP. Once uploaded you will need to either use the ESXi support console or use SSH to run the commands. Use the unzip command to extract the files. &lt;&lt;&lt; WARNING: use a datastore volume to run the scripts &gt;&gt;&gt; Please note that you will need to reboot the host for the patches to become active. The patcher is embbedded in a shell script local.sh which is run at boot from /etc/rc.local.d. You may need to ensure the ESXi scripts have execute permissions by running chmod +x against the 2 files. esxi-install.sh - patches VMware esxi-uninstall.sh - restores VMware Note: 1. Any changes you have made to local.sh will be lost. If you have made changes to that file, you will need to merge them into the supplied local.sh file. 2. The unlocker runs at boot time to patch the relevant files and it now survives an upgrade or patch to ESXi as local.sh is part of the persisted local state. 8. Thanks --------- Thanks to Zenith432 for originally building the C++ unlocker and Mac Son of Knife (MSoK) for all the testing and support. Thanks also to Sam B for finding the solution for ESXi 6 and helping me with debugging expertise. Sam also wrote the code for patching ESXi ELF files. History ------- 12/12/14 2.0.0 - First release 13/13/14 2.0.1 - Removed need for Python for Windows 13/13/14 2.0.2 - darwin.iso was missing from zip file 02/01/15 2.0.3 - Added EFI firmware files to remove Server check - Refactored Python code 07/01/15 2.0.4 - Added View USB Service to Windows batch files - Fixed broken GOS Table patching on Linux 18/06/15 2.0.5 - ESXi 6 working - Latest tools from Fusion 7.1.2 20/06/15 2.0.6 - ESXi 6 patch for smcPresent vCenter compatibility 16/09/15 2.0.7 - Workstation 12 on Linux fixes 14/11/15 2.0.8 - Player 12 on Linux fixes - Get latest VMware tools command - Removed firmware files - Moved to PyInstaller 3.0 (c) 2011-2015 Dave Parsons Mac OS X 10.10的创建Mac OS X 10.10的创建和其他系统的创建几乎没有区别，下一步下一步Mac OS X 10.10的开启如下图所示点击开启虚拟机可能会出现如下错误：VMware Workstation不可恢复错误：(vcpu-0) vcpu-0:VEREIFY vmcore/vmm/main/physMem_monitor.c.1123 日志文件位于“E:OS X\vmware.log”中。 你可以请求支持。 要收集数据提供过给VMware技术支持，请选择“帮助”菜单中的“收集支持数据”。 也可以直接在VMwarestation文件夹中运行“vm-support”脚本。 只要找到安装目录并打开目录下的 OS X 10.10.vmx(OS X 10.10为虚拟机的名字) 文件，使用记事本打开后，在 floppy0.present = “FALSE” 后添加smc.version = &quot;0&quot;(建议您复制)后保存，问题即可解决。vmware11装OSX的问题呀_虚拟机吧http://tieba.baidu.com/p/3524285937开始安装MAC OS创建磁盘稍等片刻就会安装完成自动重启第一次启动基本完成、可见Mac主界面如下相关配置VMwareTool的安装及共享文件夹的设置安装VMwareTool设置共享文件夹共享文件夹的说明：由于虚拟机无法访问本机的硬盘，所以需要设置共享文件夹来方便虚拟机读取电脑的物理内存。点击虚拟机，选择设置如下图选择总是启用：大功告成：性能优化这样装完Mac还是很卡的、下面做优化【让更多人知道！】两个插件，虚拟机用OS X一！点！都！不！卡！http://bbs.feng.com/read-htm-tid-9559384.html安装Darwin7.1.0darwin 7.1.0.iso下载http://pan.baidu.com/s/1o6xCEhG点击Finder选择偏好设置点击右下角光盘图标，选择连接即可：安装fix_yosemite下载fix_yosemite_vm_graphic_performance.ziphttp://pan.baidu.com/s/1kTRfNq3安装fix_yosemite_vm_graphic_performance.zip里的pkg文件，重启。重启完后提示你beamoff停止运行，不要点重新启动！关掉对话框Done！感受极为流畅的虚拟机吧！跟Mac和黑苹果完全没差！其他由我原来在博客园的一篇文章整理而来http://www.cnblogs.com/wangshunli/p/4296649.html]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JRebel for Android入手使用]]></title>
    <url>%2Fposts%2F66bc4cd7.html</url>
    <content type="text"><![CDATA[JRebel for Android一款Android studio插件——允许你修改正在运行中的应用程序，而且不必重新部署或重启。支持所有运行Android 4.0及以上版本的手机和平板。由ZeroTurnaround开发。这是一款收费插件，每年49美元，免费试用21天。通常在开发过程中，我们每次修改代码后想要在模拟器或者真机上看到修改后的效果，都需要将Android应用重新编译、打包和安装到Android设备上并重启，这个过程是非常耽误时间的。JRebel for Android完美解决了这个问题。具体JRebel for Android为什么能够实现，这些技术细节这里不多说，详细请见官网：http://zeroturnaround.com/software/jrebel-for-android/如何安装在Android Studio插件里面搜索JRebel for Android即可。JRebel for Android是收费的可尝试如下文件rebel android studio 1.1.0 破解版 注册 - 下载频道 - CSDN.NEThttp://download.csdn.net/detail/bjgfs/94569061. 解压jrebel-for-android_1.1.0_act.zip中`jrebel-android.lic`和`jrebel-for-android_1.1.0_mark.zip` 2. Android Studio -&gt; Plugins -&gt; Install plugin from disk安装`jrebel-for-android_1.1.0_mark.zip` 3. Android Studio -&gt; Tools &gt; JRebel for Android &gt; Activate -&gt; I have a license -&gt; Browse，选择解压的`jrebel-android.lic`，然后点击`Activate JRebel for Android` 4. 激活成功，查看有效期至2116年2月11日 5. 软件的快捷是`CTRL+F10` 6. 已经在Android Studio2.0 Beta6/intellij idea 15测试成功 应该是我的Android Studio版本太新了(AndroidStudioPreview2.1)，提示错误JRebel for Android terminated: License file error: License verification failed.Process finished with exit code 1使用这个版本的还是先试用吧，也可以安装Android Studio1.5的稳定版本我为此重新安装了Android Studiojrebel-for-android_ 1.0.8_crack在AndroidStudio1.5下不更新可用下载地址： http://download.csdn.net/download/hjaitzw/9385764使用方法导入成功后studio会提示需要重启，此时重启studio，重启之后studio顶部工具栏会出现三个新按钮第一个按钮是运行项目、第二个是debug、第三个是更新运行你的项目。可能会提示：按照提示做就行了。当你修改了代码并重新查看运行效果时，点击即可，你会发现真机或者模拟器上的当前应用并没有重启并且很快展示了修改代码后的效果。目前使用过程中发现的问题，如果只是单纯的修改代码包括xml等布局文件没有问题，但如果是新增了Activity（其他组件还测试）应用还是会重新启动一次。其他详细使用可参考：http://zeroturnaround.com/software/jrebel-for-android/quick-start/]]></content>
      <categories>
        <category>JRebel for Android</category>
      </categories>
      <tags>
        <tag>JRebel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停车助手]]></title>
    <url>%2Fposts%2F9e85974b.html</url>
    <content type="text"><![CDATA[停车助手-停车只爱停车助手停车助手https://beta.bugly.qq.com/parkhelphttp://park.wshunli.com详细介绍1、基于百度地图开放平台的SDK地图，定位SDK开发。实现了对地图的基本操作（缩放旋转、切换图层、打开关闭实时交通状况等），对附近2000米范围内停车场的查询。2、UI设计遵循Google的Material Design规范。对百度地图默认的指南针、缩放、定位等图标进行定制。3、集成Bugly平台，内测分发、异常上报等Bugly 内测分发平台为移动开发者提供安装包托管、内测应用分发、反馈收集等服务，解决产品内测阶段的各类问题。https://bugly.qq.com4、集成阿里百川、用户反馈向移动开发者提供App内的用户反馈组件和强大的管理后台，方便用户报告Bug和反馈建议，同时减少用户在 AppStore上的差评。http://baichuan.taobao.com/5、集成信鸽推送推送文本内容直接展示在用户的通知栏中http://xg.qq.com/xg6、集成umeng统计国内专业的移动应用统计分析平台。我们帮助移动应用开发商统计和分析流量来源、内容使用、用户属性和行为数据，以便开发商利用数据进行产品、运营、推广策略的决策。http://mobile.umeng.com/analytics?spm=0.0.0.0.2CPESM7、腾讯优测、应用测试http://utest.qq.com/对应用进行加固、测试，随机50款通过率100%http://auto.utest.qq.com/share?key=3IJbAj8、360加固加固保为移动应用提供专业安全的保护，可防止应用被逆向分析、反编译、二次打包，防止嵌入各类病毒、广告等恶意代码，从源头保护数据安全和开发者利益。http://jiagu.360.cn/创作初衷做这款App的目的主要是学习百度LBS的开发和体会Google的Material Design。可能现在还不够实用，我会在以后不断地完善。LBS在应用中使用了百度地图、百度定位等SDK。实现了百度LBS的基本地图、图层展示、附近的POI搜索等UI高度个人定制了UI。地图操作部分包括地图缩放、指南针旋转、实时路况、图层切换等实现UI和功能自定义。MD学习使用了Google的Material Design。体会Material Design的设计并加以使用，APP整体外观优雅大方停车助手精彩截图地图操作功能实现对地图的旋转、缩放、图层切换等功能定位功能实现利用百度定位SDK对用户当前位置定位停车场查询实现对附近2000m附近停车场进行查询显示其他功能实现应用自动更新、统计、意见反馈等意见反馈欢迎发邮件至 ： park@wshunli.com]]></content>
      <categories>
        <category>停车助手</category>
      </categories>
      <tags>
        <tag>停车助手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitCafe项目迁移至Coding.net]]></title>
    <url>%2Fposts%2F5bba4c5d.html</url>
    <content type="text"><![CDATA[GitCafe 将于 2016年5月31日 停止所有服务，届时您在 GitCafe 的账户资料及所有项目都将被永久删除，请尽快将您的资料和项目迁移至 Coding。迁移问题1、GitCafe 什么时候停止服务？GitCafe 将于 2016年 5月 31日 后停止所有服务，届时您在 GitCafe 的账户资料及所有项目都将被永久删除。即日起，您可将您的账户绑定至 Coding 进行相关迁移工作。目前所有迁移工作将分两个阶段进行：即日起，GitCafe 将不能再注册新用户、创建新项目，但已有账户和已有项目均可进行正常操作。在此期间，GitCafe 的所有付费服务将停止收费，用户可以继续使用 GitCafe 或马上进行相关迁移工作。2016年 3月 2日 起至 GitCafe 停止服务前，GitCafe 全站将处于只读状态，用户只能进行相关迁移工作。2、用户需要手工迁移数据吗？不需要。我们提供自动迁移到 Coding 的工具，用户绑定 Coding 账号后，按照操作提示进行迁移。3、用户在 GitCafe 充值了极特币，迁移至 Coding 后，原来的极特币还可以用吗？绑定 Coding 账户后，用户在 GitCafe 的所有极特币将以 1500:1 的比例兑换成 Coding 交易币“码币”。由于码币的最小金额是0.01，当剩余极特币不足 15 个时，算作 0.01 码币。4、用户可以迁移哪些项目？用户只能迁移自己拥有的项目，且用户可以只迁移部分项目至 Coding，没迁移过的项目下次可以继续迁移。5、我在 GitCafe 中项目的哪些内容会被迁入 Coding？Coding 本身有 GitCafe 的几乎所有功能，Coding 也将尽可能保存您在 GitCafe 项目中的所有资源。迁移项目后，会为您在 Coding 创建一个同名项目，项目类型保持公开或私有不变。用户在 GitCafe 项目的项目基本信息、Deploy Keys 、Git 代码、工单、Wiki、Pages等内容将会一并迁移至 Coding。其中，工单全部以讨论的形式保存在 Coding，包括工单标签、讨论评论等。项目基本信息包括项目名、项目描述、项目图标、项目状态（公开项目还是私有项目）；由于 Coding 不存在项目中文名和项目主页，该信息不能被保存。由于项目协作人员无法和 Coding 用户一一对应，请项目拥有者自行通知相关协作人员注册 Coding，并将其邀请至对应的 Coding 项目。6、Coding 没有 Wiki，我在 GitCafe 中的 Wiki 会完整迁移到 Coding 吗？会。为完整保存 GitCafe 项目的 Wiki，GitCafe 的每一个项目迁移至 Coding 后，将创建两个对应项目。比如：GitCafe 中的项目 Test 迁移至 Coding 后将创建项目 Test 和项目 Test_Wiki。7、项目被迁移后，我在 GitCafe 还能正常进行操作吗？不能。迁移后，该项目在 GitCafe 马上变成只读状态。只读状态是指用户可以查看该项目的所有内容，包括代码、工单、Wiki等，但该项目的所有成员包括拥有者都不能对该项目进行任何操作，包括 Push 代码、新建工单、评论工单等。8、GitCafe 的私有项目是收费的，迁移至 Coding 后将如何收费。Coding 私有项目的基础版是不收费的，您的项目迁移至 Coding 后不会产生任何费用。Coding 其他收费策略参见 https://coding.net/upgrade9、Coding 和 GitCafe 在功能上有何区别？Coding 除了有 GitCafe 的代码托管相关功能外，Coding 还有 WebIDE、演示平台、质量管理等高级功能。除此之外，Coding 的注册用户还可以通过其旗下产品“码市”进行众包交易。10、没用过 Coding，不知道怎么用该怎么办？请查看 Coding 帮助文档： https://coding.net/help迁移过程进入个人首页进入个人首页可以看到如下公告进入公告https://gitcafe.com/migration注意勾选我已注意事项点击抹马上迁移稍等片刻即可迁移所有项目到Coding.net修改_config.yml删除如下字段gitcafe: git@gitcafe.com:wshunli/wshunli.git,gitcafe-pages Coding Pages服务将项目的默认分支修改为gitcafe-pages并填写二级域名修改DNS记录将国内流量指向Coding.me修改其他二级域名的 CNAME 记录指向 wshunli.coding.me更新：3/17/2016 5:59:46 PM修改其他二级域名的 CNAME 记录指向 pages.coding.me]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitcafe创建多个Page服务并绑定子域名]]></title>
    <url>%2Fposts%2F6ce17308.html</url>
    <content type="text"><![CDATA[想创建多个Page服务绑定二级域名作项目的展示页面，最终效果如下：在线访问：http://map.wshunli.com创建一个任意名字项目在本地创建一个Git目录创建目录D:\GitCafe\Map可用命令d: mkdir GitCafe cd GitCafe mkdir Map cd Map 添加一个试验性的html文档将index.html复制到目录D:\GitCafe\Map提交第一个版本将我们的项目初始化为一个 Git 版本库；$ git init Initialized empty Git repository in D:/GitCafe/Map/.git/ 现在，我们拥有了一个空的 Git 仓库，用 git add 命令将之前创建的 index.html 纳入到 Git 版本库中；$ git add index.html 接下来我们通过 git commit 命令来做一次本地的保存，并在 -m 字符后面添加这一次提交的提交说明。git commit -m &#39;Map init&#39; 添加 GitCafe 远程仓库$ git remote add origin &#39;git@gitcafe.com:wshunli/Map.git&#39; 创建一个 gitcafe-pages 的分支，并切换到该分支$ git checkout -b gitcafe-pages 提交该分支至 GitCafe$ git push -u origin gitcafe-pages 自定义二级域名在GitCafe中添加自定义域名map.wshunli.com在DNSPod中添加CNAME记录解析map.wshunli.com至gitcfe.io最终效果如下：参考资料1、Gitcafe 创建多个 Page 服务 | Zippera’s bloghttp://zipperary.com/2015/01/16/gitcafe-subdomain/2、GitCafe 快速上手 - GitCafe Helphttps://help.gitcafe.com/manuals/help/getting-started3、Wiki Pages 相关帮助 · GitCafe/Help - GitCafehttps://gitcafe.com/GitCafe/Help/wiki/Pages-相关帮助#wiki]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客部同时署到Github、GitCafe、Coding]]></title>
    <url>%2Fposts%2F6a8e93c5.html</url>
    <content type="text"><![CDATA[由于Github在国内的访问速度较慢，考虑将Hexo博客部署到国内的GitCafe和Coding，并采用DNSPod作分流。默认采用Github（稳定），国内采用GitCafe（速度），因为在学校教育网访问GitCafe有点问题（需要改下DNS），所以将教育网分流至Coding。域名记录如下：]Hexo的配置文件_config.yml设置如下：deploy: type: git repository: github: git@github.com:wshunli/wshunli.github.io.git,master gitcafe: git@gitcafe.com:wshunli/wshunli.git,gitcafe-pages coding: git@git.coding.net:wshunli/wshunli.git,coding-pages Github配置前面不再赘述详情可参考我的另一篇博客从绑定域名开始在D:\Hexo\source新建CNAME文件里面写上欲绑定的域名即可在DNSPod中添加CNAME记录解析至wshunli.github.ioGitCafe配置和Github配置类似。绑定域名不再用CNAME文件。注意：需要gitcafe-pages分支详情可看：Wiki Pages 相关帮助 · GitCafe/Help - GitCafehttps://gitcafe.com/GitCafe/Help/wiki/Pages-相关帮助#wiki在DNSPod中添加CNAME记录解析至wshunli.gitcafe.iocoding配置Coding Pages 服务设置如下：在DNSPod中添加CNAME记录解析至wshunli.coding.me参考资料1、将Hexo部署到GitCafe | 盛夏 http://www.sumrday.com/2014/09-18-Hello-Hexo.html2、在 Coding 上搭建 Hexo 个人博客！ - 各种各样的学习笔记 - SegmentFault https://segmentfault.com/a/1190000002900848?utm_source=tuicool]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(十二)]]></title>
    <url>%2Fposts%2F7a41d646.html</url>
    <content type="text"><![CDATA[练习十二、 ArcMap制图－地图版面设计设置地图符号－各种渲染方式的使用使用ArcMap Layout（布局）界面制作专题地图将各种地图元素添加到地图版面中提示：在以下练习过程中，请时常注意保存地图文档渲染图层要素－唯一值符号在ArcMap中新建地图文档，加载 [空间分析] 扩展模块及[空间分析工具栏]加载图层：[省会城市、地级市驻地、主要公路、国界线、省级行政区、Hillshade_10k]，将地图文档保存到Ex12下，名称为：ChinaMap在[图层列表面板]（TOC）中右键点击图层：[省级行政区]，执行[属性]命令，在出现的[图层属性]对话框中，点击[符号系统]选项页，如下图所示，渲染参数设置为：[类别－&gt;唯一值，字段值设置为：DZM] 。点击[添加全部值]按钮，将&lt;所有其它值&gt;前检查框的勾去掉。点击其他所有值前面的颜色方框，右键点击选择[所有符号的属性]命令。在[符号选择器]中，将[轮廓线颜色] 设置为 [无颜色]：点击[显示-Display]选项页，将图层透明度设置为：[50%]:现在图层：省级行政区根据字段[DZM]进行唯一值渲染，且有伪三维效果（关闭[省级行政区]和[Hillshade_10k]之外的其它所有图层）关闭并移除图层：[Hillshade_10k]显示图层：[国界线]，在[TOC]中右键点击图层：[国界线]，执行[属性]命令，在出现的[图层属性]对话框中将渲染方式设置为[单一符号]，点击[符号设置]按钮（如下图1）在[ 符号选择器]对话框中选择一种线状符号（如下图所示）显示图层:[地级城市驻地],并参考以上操作及下图所示,设置图层渲染方式::标注图层要素在TOC中，右键点击图层：[省级行政区]，执行[属性]命令，在出现的[图层属性]对话框中，点击[标注]选项页，确认标注字段为：[Name],点击[符号]按钮在[符号选择器]对话框中，将标注字体大小设置为: [12],点击[编辑符号]按钮(如下图所示):在[编辑器]对话框中, 点击[掩模]选项页, 并将大小设置为: [2]:连续三次[确定]后退出以上对话框,返回ArcMap 视图界面.显示图层: [地级城市驻地],并参考以上方法及下图效果进行标注:渲染图层要素—分类渲染在TOC中,右键点击图层[省级行政区],执行[属性]命令,然后在[图层属性]对话框中点击[符号系统]选项页,将渲染方式设置为:[分级色彩, 字段: Area,分类:5, 自然间隔分类法]在上图中,点击[分类]按钮可选择不同的分类方法:参照以上操作过程,对图层[省级行政区]基于字段[Area]运用不同的分类方法(等间隔、分位数、自然间隔、标准差)，比较不同的分类法进行分类的意义。自然间隔分类:相等间隔分类渲染：分位数分类渲染：标准差分类渲染：渲染图层要素—点密度渲染参照前面的步骤，对图层：[省级行政区]进行点密度渲染，如下图所示：根据人口字段：POPU计算点密度渲染图层要素—图表渲染参照前面的步骤，对图层：[省级行政区]进行点密度渲染，如下图所示：根据1998GDP、1999GDP、2000GDP属性生成柱状图渲染方式创建地图版面在上一步的基础上进行，将图层[省级行政区]的渲染方式恢复为[唯一值渲染，基于NAME字段]，如下图所示：在ArcMap中，点击按钮切换到布局视图界面。执行菜单命令：[文件]&gt;&gt;[页面和打印设置]，在对话框中设置纸张大小和方向，这里请将纸张方向设置为横向（汉化版的ArcMap翻译有误）设置完成后，可以看到在布局视图界面下，地图版面已变成为横向，且当前数据框已经添加到地图版面中。通过当前数据框中的[大小和位置]选项页可以精确设置[数据框]在地图版面中的位置或大小。（在版面视图界面下，右键点击[数据框]，然后执行[属性]命令，打开如下的窗口）通过[框架]选项页可以在当前数据框周围添加图框，及设置图框的式样：通过标准工具栏上的[放大、缩小、平移]按钮，可以调整地图版面中数据框的显示比例、范围，如下图所示：适当调整使数据只显示西南部分。添加各种元素到地图版面中制图元素–图表：在地图版面中可以插入统计图表，可以根据属性数据生成统计图表（类似Excel电子表格软件的操作）然后插入到地图版面中。视图&gt;&gt;图表&gt;&gt;创建图表制图元素－文字执行菜单命令：[插入]&gt;&gt;[标题]，修改地图标题的属性，设置合适的字号、字体制图元素–图片或照片执行菜单命令[插入]&gt;&gt;[图像]，浏览到Ex12文件夹，将logo.gif插入到当前地图版面中来，调整大小及位置制图元素—比例尺执行菜单命令[插入]&gt;&gt;[比例尺]，可以选择比例尺样式，及设定比例尺参数，如下图所示：（在地图版面中双击已添加的“比例尺”，修改其属性）制图元素――图例通过执行菜单命令：[插入]&gt;&gt;[图例]，向地图版面中加入图例，使用[图例向导]设置图例各种参数点击下一步。制图元素――指北针通过执行菜单命令：[插入]&gt;&gt;[指北针]，向地图版面中加入指北针制图元素――数据表数据表如果要添加到地图版面中，可以先将数据表打开，然后在数据表浏览窗口中点选项，在出现的右键菜单中执行[把表加到布局中]命令，如下图所示：点击，表选项&gt;&gt;将表添加到布局可以通过[图层属性]或[属性表属性]对话框设置可见字段或别名：如下打印输出地图制作好的地图可以导出为多种文件格式：比如JPG，PDF等。执行菜单命令：[文件]&gt;&gt;[导出地图]如果要进行出版印刷可以通过ArcGIS内置的ArcPress 实现分色打印]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(十一)]]></title>
    <url>%2Fposts%2Fd5704d24.html</url>
    <content type="text"><![CDATA[练习十一、3D 可视分析1、对地理数据进行透视观察、三维浏览；2、制作飞行动画GIS数据三维显示(1) 运行程序:[开始菜单]&gt;&gt;[所有程序]&gt;&gt;[ArcGIS]&gt;&gt;[ArcScene],打开 ArcScene(2) 在ArcScene中执行命令: [自定义]&gt;&gt;[扩展模块], 选中 [3D Analyst]扩展模块, 在ArcScene中点击[添加数据]按钮(如下图红色前头所指),将图层(Roads , bldg, ortho.lan, dtm_tim)添加到当前场景中.(1) 关闭 图层 [dtm_tin] 显示(2) 在图层列表面板(TOC)中右键点击图层[ortho.lan],打开图层属性对话框,在[基本高度]选项页中,将表面获取的高程设置为:[在自定义表面上浮动],并选择当前场景中的TIN数据图层:[dtm_tin](如下图所示),在[用于将图层高程值转换为场景单位系数为[2], 高程将被夸大2倍。点[确定]退出(1) 以相同方法设置图层 [Roads]、[bldg]的属性，夸张系数统一设置为[2](2) 对图层 [bldg],还需要进一步设置 [拉伸]选项和[符号系统]选项通过设置拉伸表达式为 [HEIGHT*2], 建筑的高度将根据属性字段[HEIGHT]的数据确定通过设置 [符号系统]选项，为每不同的建筑赋不同的颜色(1) 完成后的效果如下图所示：可以点击 [工具栏]上的查询按钮，查询每个建筑物的属性通过操作，熟悉 [工具] 中各按钮的功能其中[飞行]按钮 有两种状态，表示停止飞行，表示正在飞行状态，通过点击鼠标左键可以加快飞行速度，通过占击鼠标右键可以减慢飞行速度，直至停止，通过移动鼠标可以调整飞行方位、高度。(1) ArcScene中的三维场景可以导出为二维图片或三维VRML文件[.wrl]，VRML文件可以用 GLView进行浏览或查看，普通的互联网浏览器也可以通过安装插件的方式进行浏览，因此导出为VRML的三维场景可以发布到因特网上三维飞行动画制作(1) 录制飞行过程生成动画：在ArcScene打开三维场景文档[Animation.sxd]，在工具栏显示区点右键，打开[3D分析]、[动画]、[标准工具]这三个工具栏点击[动画]工具栏中的 [动画控制]按钮（下图）,打开[动画控制]工具栏，点击[动画控制]中的 [录制] 按钮（下图）;在[工具]中选择 [飞行]工具然后在地图显示区中沿任意路线进行飞行，(时间建议不要超过30s) ，然后点击鼠标右键直至停止飞行;点击[动画控制]工具中的停止按钮 [ ]，停止录相, 点击播放按钮，播放所录的动画补充说明：记录的动画可以转存为视频文件（比如AVI文件），并可进一步用于制作视频光盘借助于ArcScene和ArcGlobe可以实现比较复杂的3维分析及数据可视化应用，如需进行一步了解ArcGIS的三维分析可参考ESRI电子文档《Using3D Analyst》]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(十)]]></title>
    <url>%2Fposts%2Fd5f6956b.html</url>
    <content type="text"><![CDATA[练习十、网络分析(1) 加深对网络分析基本原理、方法的认识；(2) 熟练掌握ARCGIS下进行道路网络分析的技术方法；(3) 结合实际、掌握利用网络分析方法解决地学空间分析问题的能力。实验目的网络分析是GIS空间分析的重要功能分。有两类网络，一为道路（交通）网络，一为实体网络（比如，河流、排水管道、电力网络）。此实验主要涉及道路网络分析，主要内容包括：最佳路径分析，如：找出两地通达的最佳路径。最近服务设施分析，如：引导最近的救护车到事故地点。服务区域分析，如：确定公共设施（医院）的服务区域。通过对本实习的学习，应达到以下几个目的：(1) 加深对网络分析基本原理、方法的认识；(2) 熟练掌握ARCGIS下进行道路网络分析的技术方法。(3) 结合实际、掌握利用网络分析方法解决地学空间分析问题的能力。实验准备软件准备：ArcMap, 要求有网络分析扩展模块的许可授权数据准备：Shape文件创建网络数据集（高速公路：Highways, 主要街道：Major Streets,公园：Parks，湖泊：Lakes，街道：Streets）Geodatabase网络数据集：NetworkAnalysis.mdb：包含：街道图层：Streets仓库图层：Warehouses 商店图层：Stores在ArcMap中加载启用NetWork Anylyst网络分析模块：执行菜单命令［工具Tools］&gt;&gt;[Extensions],在［Extensions］对话框中点击 [Network Analyst]启用网络分析模块，即装入Network Analyst空间分析扩展模块。道路网络分析步骤1. 创建分析图层2. 添加网络位置3. 设置分析选项4. 执行分析过程显示分析结果实验内容及步骤(一) 最佳路径分析根据给定的停靠点，查找最佳路径（最省时的线路）1.1 数据准备（1）双击ArcMap工程，或从ArcMap中打开工程EX10_1.mxd.（2）如果网络分析扩展模块（Network AnalystExtension）已经启用（参考实验准备中的步骤）（3）如果网络分析工具栏没有出现，则在工具栏显区点右键打开或执行菜单命令[自定义]&gt;&gt;[工具条],并点击［NetworkAnalyst］以显示网络分析工具栏。（4）如果网络分析窗口没有推开，则在网络分析工具栏中点击网络分析窗口按钮（上图红色区域），以打开网络分析窗口：注意：这是一个悬停窗口，它可以嵌入并固定在ArcMap的窗体中，或是作为一个单独的窗口悬浮在操作区上。在练习中，为了方便可以将其固定在TOC面板之下。1.2 创建路径分析图层在网络分析工具栏[ Network Analyst]上点击下拉菜单[Network Analyst],然后点击［New Route］菜单项.此时在网络分析窗口[ Network Analyst]中包含一个空的列表，显示停靠点(Stops),路径（Routes），路障（Barriers）的相关信息。同时，在TOC(内容列表)面板上添加了新建的一个路径分析图层［Route］组合。1.3 添加停靠点通过以下步骤添加停靠点，最佳路径分析将找到最佳的经停顺序以计算并得到最佳路径(1) 在网络分析窗口[Network Analyst ]中点选Stops(0).(2). 在网络分析工具栏[Network Analyst]上点击“创建网络位置”[Create Network Location]工具。(3) 在地图的街道网络图层的任意位置上点击以定义一个新的停靠点。程序将在街道网络上自动的计算并得到一个距离给定位置最近的停靠点，已定义的停靠点会以特别的符号进行显示。停靠点会保持被选中的状态，除非它被明确地反选（Unselected）或者又新增了一个另外的停靠点。停靠点的所在的位置会同时显示一个数字“1”，数字表示经停的顺序。（4） 再添加4 个停靠点。新增加的停靠点的编号为2,3,4,5。经停的顺序可以在网络分析窗口[NetworkAnalyst]中更改。第一个停靠点被认定为出发点，最后一个停靠点被认定为是目的地。如果一个停靠点无法定位于道路网络上，则会显示一个“未定位”的符号。“未定位”的停靠点可以通过移动操作将其定位到道路网络上，在网络分析［NetworkAnalyst］工具栏上点选［选择/移动网络位置］ [Select/Move NetworkLocation]按钮，使用此工具将“未定位”的停靠点拖放到附近的道路网络上。1.4 设置分析选项以下操作基于规则（单向行驶规划必须遵守，任意路口可以调头）计算最省时间的线路(1). 如图所示，在网络分析窗口[Network Analyst]中点击分析图层属性按钮[Analysis Layer Properties]打开图层Route的属性设置对话框：(2) 在分析图层－Route属性对话框中，点击分析设置[AnalysisSettings]选项页，并确认－阻抗[impedance]设置为分钟Minutes (Minutes).(3).不使用时间限制 (保持Use Time Windows前的检查框为非选中状态)。当必须在规定时间在某个停靠点停留时才使用这个选项，选择这个选项后可以通过设置停靠点属性来设置某个停靠点到达的时间，离开的时间（在ArcMap联机帮助中查询关键词networkanalysis, routing with time windows 可以了解详细内容）(4).不使用“经停点重排序功能”（保持[Reorder stops to Find OptimalRoute]检查框为未选中状态）。这保证了经停顺序为你事先指定的顺序。(5) 在“交叉点U型转弯，下拉列表中选择 允许(6).在“输出图形类型”[Output Shape Type]下拉列表中选择 实际形状[TrueShape](7).选中“忽略无效位置”［Ignore InvalidLocations］检查框。这样分析时将会忽略那些不在道路网络上的停靠点。(8).在“限制”[Restrictions]列表框中选择单行线[Oneway]。(9) 点击方向[Directions]选项页，确定距离单位[DistanceUnits]设置为米[Meters], 显示时间[DisplayTime]检查框被选中，时间属性[TimeAttribute]被设置为分钟[Minutes]。点击［确定］按钮退出“图层属性”对话框。1.5 运行最佳路径分析得到分析结果(1) 在网络分析工具栏［Network Analyst］上点击“求解”[Solve]按钮。分析结果－最佳路径线状要素图层将在地图中显示，在“网络分析窗口”[Network Analyst Window]中“路径”[Route]目录下也会同时显示：(2) 在网络分析窗口[Network Analyst]中点击Route树状结点左边的加号(+)显示最佳路径(3) 右键击最佳路径“图形选择1-图形选择5”或在网络分析工具栏中点击方向[Direction]按钮打开“方向（路径）”窗口。(4) 在方向（路径）[Directions]窗口中点击“地图”[Map]可以显示转向提示地图(5) 关闭“方向”[Directions]窗口1.6 设置路障(barrier)通过在行驶路径步增加障碍，表示真实情况下，道路上无法通行的路障。在进行最佳路径分析将会绕开这些路径查找替代路线(1) 在ArcMap的中执行菜单命令[Window]&gt;&gt;[Magniﬁer]显示放大镜窗口[Magniﬁer](2) 通过按住放大镜窗口[Magniﬁer]的标题栏在地图上移动，在地图中找到已经计算得到的最佳路径，松开鼠标。这时最佳路径的一部分应该显示在放大镜窗口[Magniﬁer]的中心位置，我们将这这个区域的某个路段上放置一个路障。.(3) 在网络分析窗口[Network Analyst ]中单击“路障”[Barrier (0)].(4) 在网络分析工具栏[Network Analyst]上点击“创建网络位置”[CreateNetworkLocation]工具按钮。(5) 在放大镜窗口[Magniﬁer]中最佳路径上的某个位置放置一个路障。(6) 在网络分析工具栏[Network Analyst]上点击“求解”[Solve]按钮，得到新的最佳路径，从而避开路障(8) 关闭“放大镜”[Magniﬁer] 窗口1.7 保存分析结果――最佳路径(1) 在网络分析窗口[Network Analyst ]中右键点击“路径”[Routes (1)],在出现的右键菜单中点击“导出数据”［Export Data］菜单命令。(2) 在“导出数据”[ExportData]对话框中指定导出的文件命，比如“E:/输出/Export_routet_2.shp”(3) 点击[确定]按钮，最佳路径就会保存为指定的Shape文件。.(4) 当ArcMap询问“是否要将导出数据作为一个图层添加到地图中”时，点击否[NO](5) 关闭ArcMap最近服务设施分析（查找最近的消防队）在这个实验中，当某个位置发生火灾时将找到距事故最近的四个消防队，并且可以进一步找到能够最快到达事故地点的路线.2.1 数据准备（1）.双击ArcMap工程EX10_2.mxd，或从ArcMap中打开工程EX10_2.mxd.（2）.如果网络分析扩展模块（Network AnalystExtension）已经启用（参考实验准备中的步骤）（3）如果网络分析工具栏没有出现，则在工具栏显区点右键打开或执行菜单命令[自定义]&gt;&gt;[工具条],并点击［NetworkAnalyst］以显示网络分析工具栏。（4）如果网络分析窗口没有推开，则在网络分析工具栏中点击网络分析窗口按钮（上图红色区域），以打开网络分析窗口。2.2 创建“最近服务设施分析图层”在网络分析工具栏[ Network Analyst]上点击下拉菜单[Network Analyst],然后点击“新建最近设施点”[NewClosest Facility]菜单命令此时在网络分析窗口[ Network Analyst]中包含一个空的列表，显示“设施”[Facilities], 事故[Incidents],路径[Routes],路障[Barriers]树状目录。同时，在TOC(图层列表)面板上添加了新建的一个“最近设施点图层［Route］组合”2.3 添加“服务设施”图层通过添加已存在的一个点状图层作为服务设施图层，以定义服务设施的位置。.(1).在“网络分析窗口”中右键点击树状结点：Facilities (0)，在出现的右键菜单中点击命令“加载位置”[Load Locations].(2) 在“加载位置”[Load Locations]对话框中从“由图层加载”[LoadFrom]下拉列表中选择［File_Staion］ 。点击确定。在网络分析窗口[Network Analysis window]中显示有40个消防队。加载的服务设施――消防队在地图上显示为服务设施符号［绿色实心圆］。2.4 设定火灾事故发生地点通过以下步骤在道路网络上定位一个火灾事故发生地址。以进一步做救援调度分析。(1) 在网络分析窗口[Network Analyst ]中点选树状结点[Incidents(0)]，将在此图层上添加一个一个网络位置（事故地点）(2)将地图适当放大并平移到如下的区域，在如下图所示的位置添加一个火灾事故点：2.5 设置分析选项(1) 如图所示，在网络分析窗口[Network Analyst]中点击［最近呢设施点ClosestFacility］下拉列表右边的“分析图层属性”按钮[Analysis Layer Properties]打开图层［Closest Facility］的属性设置对话框：(1) 在图层属性对话框中点击“分析设置”[Analysis Settings]选项页，在“阻抗”［Impedance］下拉列表中选择“分钟”［Minutes(Minutes)］。(2) 使用时间前打对勾，默认中断值为3，可以设置要查找的设施点。(4) 将“行驶自”[Travel From]设定为“从设施点到事故点”[Facility toIncident] (由消防队到火灾事故点)。(5) 在“允交汇点的U形转弯”［Allow U-turns］下拉列表中选择任何路口[EveryWhere](6) 在“输出图形类型”[Output Shape Type]下拉列表中选择 实际形状[TrueShape](7) 选中“忽略无效位置”［Ignore InvalidLocations］检查框。这样分析时将会忽略那些不在道路网络上的停靠点(事故点)。(8)在“约束规则”[Restrictions]列表框中选择单行线[Oneway]。(9) 点击“确定”［OK］按钮。2.6 运行分析过程查找最近的服务设施（1） 在网络分析工具栏［NetworkAnalyst］上点击“求解”[Solve]按钮。分析结果－救援路径线状要素图层将在地图中显示，在“网络分析窗口”[NetworkAnalyst ]中“路径”[Route]目录下也会同时显示：注意：只找到距事故地点最近四个消防队。(2) 选中四条路线，在网络分析工具栏[NetworkAnalyst]上点击“方向”［Directions］工具按钮可以显示每条救援线路的导航信息。(3) 退出 ArcMap。服务区分析（计算服务区并生成起始－目的地OD成本矩阵）通过以下操作，创建一系列的多边形，表示在指定时间内可以从某个设施到达的距离。这些多边形被称为服务区多边形。在正面的练习中，基于6个仓库创建其3分钟、5分钟、10分钟服务区。同时也可以发现某个服务区中有多少个商店。然后确定应该如何重新布局一个仓库以更好地为商店提供服务。此外，将生成一个起始－目的地(OD)成本矩阵，表示在10分钟内从仓库到其它商店的商品配送的成本。这个成本矩阵可用于后勤、物流配送、路线选择分析。3.1 数据准备（1）.双击ArcMap工程EX10_3.mxd，或从ArcMap中打开工程EX10_3.mxd.（2）.如果网络分析扩展模块（Network AnalystExtension）已经启用（参考实验准备中的步骤）（3）如果网络分析工具栏没有出现，则在工具栏显区点右键打开或执行菜单命令[自定义]&gt;&gt;[工具条],并点击［NetworkAnalyst］以显示网络分析工具栏。（4）如果网络分析窗口没有推开，则在网络分析工具栏中点击网络分析窗口按钮（上图红色区域），以打开网络分析窗口。3.2 创建“服务区分析图层”(1). 在网络分析工具栏[ Network Analyst]上点击下拉菜单[NetworkAnalyst],然后点击“新建服务区”[New Sercice Area]菜单命令网络分析窗口[Network AnalystWindow]包含一个空列表，其中有四个类别：设施点[Facilities],面、线、点障碍、线障碍、面障碍此外，在图层列表[TOC]面板中新层了一个新的服务区分析图层组3.3 加载服务设施图层通过以下操作，将图层“仓库”[warehouses]设置服务设施，用于分析它们的服务区。在网络分析窗口[Network Analyst ]中右键点选Facilities(0)树状结点，然后在右键菜单中点击“加载位置”[LoadLocations]命令。在出现的Load Location对话框中，.将下拉菜单“加载自”设置为“Warehouse”，然后点击确定[OK]在网络分析窗口[Network AnalystWindow]中点击树状结点Facilities(6)左边的加号(+)，可以显示设施列表，这些服务设施同时在地图上显示。3.4 设置分析选项通过以下操作指定基于驾车时间进行服务区分析的选项。计算每个服务设施的3个服务区多边形，一个是3分钟服务区，一个是5分钟服务区，一个是10分钟服务区。(1). 在网络分析窗口[Network Analyst]中点击分析图层服务区属性按钮，打开分析图层属性对话框：(2) 点击分析设置选项页［Analysis Settings］(3) 点击阻抗[Impedance]下拉列表，并选择 “驾车需时”[Drivetime(Minutes)](4) 在“默认分隔”[Default breaks]输入框中输入“3 5 10”(输入 3 5 10,三个数字以窗格分隔，引号不需要输入)(5) 在“方向”选项中选择“离开设施点”［Away from facility］(6) 在“交叉点的U型转弯”下拉列表中选择“不允许”[Nowhere](7) 在“限制”[Restrictions]列表框中选择单行线[Oneway]。(8) 选中“忽略无效位置”［Ignore Invalid Locations］检查框。(9). 点击“面生成”[Polygon Generation]选项页(10) 确认“生成面”[Generate Polygons]选项被选中 .(11) 多边形类型[PolygonType]选择为：“概化”[Generalized].(“概化”面生成的比较快，“详细的”面[Detailed]更精确但需要多一些时间)(12). 将“多个设施点选项”[Multiple FacilitiesOptions]单选项设置为“重叠”，这个选项生成的服务区可能会有相互重叠的部分。.(13) 将“叠置类型”[OverlapType]单选项设置为“环”[Rings],这样5分钟服务区中将会去除3分钟服务区的部分，10分钟服务区将只表示5-10分钟的服务区(14). 点击“应用”[Apply]按钮保存所做设置(15) 点击确定[OK]按钮，保存所做设置.3.5 运行分析过程创建服务区在“网络分析”工具栏[ Network Analyst]中点击“求解”[Solve]工具按钮生成的服务区多边形。在地图及网络分析窗口[NetworkAnalyst]中同时显示,结果是几个透明多边形图层，可以同时显示其下的道路网络，很明显地显示了每个服务设施基于现有道路网络状况的3分钟、5分钟、10分钟服务区。3.6 确定没有处在服务区内的商店(1). 在TOC图层列表面板中将图层“Stores”移到最前面，以更好地显示此图层。(2) 执行菜单命令[选择-Selection]&gt;&gt;[根据位置选择- Select byLocation](3) 如下图所示，在“根据位置选择”对话框中，(4)点击“应用”[Apply]按钮，将会选择所有位于服务区内的商店。点击“关闭”[Close]按钮。(5)在TOC图层列表面板中右键点击图层“Stores”，点击“选择”，再点击“切换选择”(6)现在，选择集中显示了没有被任何服务区包含的所有商店的分布情况，可以基于此选择集重新布局现有仓库。.(7)在TOC图层列表面板中右键点击图层“Stores”，在右键菜单中执行命令［选择集-Selctions］&gt;&gt;[清除已选择的要素－ClearSelected Features]3.7 将分布不合理的设施（仓库）重新布局(1).查看2号仓库－Warehouse#2的服务区多边形，可以发现它的3分钟、5分钟、10分钟服务区内都没有商店，因此可以重新选择新的位置，以使2号仓库能够更好地为其它商店提供服务(2) 在网络分析窗口[Network Analyst ]中树状结点Facilities(6)下选择2号仓库[Warehouse #2](3) 使用网络分析工具栏上的“选择/移动网络位置”工具移动2号仓库Warehouse#2到地图中心位置。如下图所示：3.8 运行分析过程重新计算服务区在“网络分析”工具栏[ Network Analyst]中点击“求解”[Solve]工具按钮生成的服务区多边形：3.9 确认所有每商店归属于哪个服务区多边形(1) 在TOC图层列表面板中右键点击图层“Stores”，在右键菜单中执行命令：[连接和关联]&gt;&gt;[连接](2) 按如下图所示进行设置：.(3) 点击确定[OK]执行“连接”[join]操作(4) 在TOC面板中右键点击新生成的图层StoreswithPoly，在右键菜单中执行命令“打开属性表”[Open Attribute Table].每一行显示了商店的名称，以及这个商店位于哪个服务区内。可以基于这个数据表生成其它的信息，比如：仓库的3分钟服务区内商店的数目。(5) 关闭属性表可以将现有的服务设施（包含已经移动的2号仓库）数据导出为新的要素类（图层），方法如下：(6) 在网络分析窗口[Network Analyst ]中右键点击树状结点Facilities(6)，在右键菜单中执行命令“导出数据”［ExportData］，然后选择“所有要素”［All features］，并指定输出的文件名和位置。当ArcMap提示“是否要将新建的要素类加载到地图中”时，选择“否”.创建起始－目的地成本矩阵(Origin-Destination cost matrix)3.10 创建OD 成本矩阵分析图层(1) 在TOC面板中关闭图层.“Service Area”和“StoresWithinPoly”以更好的显示(2) 在网络分析工具栏.［Network Analyst］上执行菜单命令[创建OD成本矩阵]在网络分析窗口[ Network Analyst]中包含一个列表，显示“起始位置”[Origins],“目的地点”[Destinations],“线”[ Lines]和“点、线。面障碍障”［Barriers］分类列表。同时TOC面板中也加入了新生成的OD成本矩阵分析图层。3.11添加起始位置(O)rigin(1). 在网络分析窗口［Network Analyst ］中右键点击树状结点起始点Origins(0)，然后在出现的右键菜单中点击“加载位置”［Load Locations］命令.(2) 在“加载自”[Load From]下拉列表中选择［ServiceArea\Facilities］(如果没有完成服务区分析可以使用图层“Warehouses”.这样的话结果就会有差异)(3). 设置“只针对已选择的要素”[Selected FeaturesOnly]检查框为未选中状态.(4) 在“位置定位”[Location Position]设置项，选择“使用网络位置字段”［UseNetwork Location Fields］单选 按钮 ,这样将允许ArcGIS使用服务区设施中已定位的位置作为起始位置，这样会快一点(如果你加载的是图层Warehouses, 则需要使用[use Geometry]选项,并设置容差值为50米.)(5) 点击“确定”[OK]按钮.在网络分析窗口[Network Analyst ]及地图中将显示6个起始位置，把2号移动到2号仓库所在的服务区3.12 添加目的地(D)estinations将商店作为目的地(1) 在网络分析窗口［Network Analyst］中右键点击树状结点Destinations(0)，然后在右键菜单中执行命令“加载位置”［LoadLocations］(2) 从“加载自”［Load From］下拉列表中选择图层Stores.(3) 在“位置分析属性”［Location Analysis Properties］列表中,点击属性[property]Name 对应的列,［Feld］，从下拉列表中选择字段－“NOM”。(4) 点击“确定”[OK]按钮.现在，在网络分析窗口[Network Analyst]中已经有21个目的地的名称列表，同时在地图中也显示了这21个目的地3.13 设置分析选项以下操作将指定基于时间（驱车需时）计算OD成本矩阵的参数。(1). 点击网络分析窗口[Network Analyst ]中［OD成本矩阵］图层名称右边的图层属性按钮(2) 在图层属性对话框中点击“分析设置”[Analysis Settings]选项页(3) 点击“阻抗”［Impedance］下拉列表，选择 Drivetime(Minutes).(4) 在“默认中断值”［Default CutoffValue］输入框中输入10。这样将生成从每个仓库到其10分钟内可以到达的商店“起始－目的地”成本矩阵。(5) 在“要查找的目的地”[Destinations to Find]列表框中选择“全部”&lt;All&gt; （点向下的按钮）.(6) 在“交汇点的U形转弯”［Allow U-turns ］选择“允许”[Everywhere](7) 在输出Shape类型［Output Shape Type］列表框中选择“直线”［StraightLine］.(8) 在“限制”［Restrictions］列表中选择“单行线”[Oneway]规则.(9) 选中“忽略无效的位置”[Ignore Invalid Locations](10) 点击“确定”[OK]按钮保存这些参数3.14运行分析过程生成OD 成本矩阵在网络分析［NetworkAnalyst］工具栏中点击“求解”［Solve］工具按钮.起始－目的地（OD）路线显示在地图中。这里显示的数据为27条线路。（由于你在3.7中移动2号仓库Werehouse#2的位置可能与我的有偏移，这个数字不一定是27，但都属于正常的）3.15 为商店合理分配仓库基于 OD 成本矩阵，可以判断哪些商店由哪个仓库提供服务会更理想。(1) 在网络分析窗口［Network Analyst ］中右键点击树状结点Lines(27)，然后在出现的对话框执行命令“打开属性表”［Open Attribute Table］，打开OD成本矩阵.(2)属性表表示能在10分钟内从每个仓库到达的商店的“起始－目的地”成本矩阵。字段[OriginID]表示每个仓库的标识。字段［DestinationID］表示每个商店的标识。字段［DestinationRank］表示级别，即每个仓库能够为各个商店基于时间开销进行划分的服务等级。比如，在下表中：对2号仓库Warehouse#2,DestinationID 为32的商店的等级为1 ，而DestinationID为 31的商店的等级为2，这是因为从2号仓库Warehouse#2,到商店DestinationID 32所需要的时间要少(你的结果不一定与此完全相同.)OD成本矩阵显示每个仓库所服务的那些商店在每条线路上的时间开销。某些商店在10分钟服务限定条件下可以由多个仓库提供配送服务。OD成本矩阵可以用于后勤路线分析模型，以便进行优化选择。使用OD矩阵可改进商店配送及提供更好更快的物流服务。.选做内容――创建用于进行道路网络分析的网络数据集请参考 ESRI PDF 文档《Network_Analyst_Tutorial.pdf》的练习1～3(1) Exercise 1: Creating a Shapeﬁle based Network Dataset基于 Shape文件创建网络数据集(1) Exercise 2: Creating a geodatabase network dataset基于地理数据库――Geodatabase创建网络数据集(1) Exercise 3: Creating a multimodal network dataset实验数据：安装ArcGIS Tutorial 光盘内容后可在 ArcTutor\Network_Analyst目录下找到。实验报告要求实验报告包括以下内容：网络分析中对道路网络数据有何要求，如何得到符合网络分析要求的街道网络数据？网络分析应用举例：网络分析模块支持哪几种功能，分别解释其含意，就每一种功能举几个实际应用中的例子。]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(九)]]></title>
    <url>%2Fposts%2Fa85fe21f.html</url>
    <content type="text"><![CDATA[练习九、水文分析水文分析：根据DEM提取河流网络，计算流水累积量、流向、根据指定的流域面积大小自动划分流域水文分分析工具(1)通过Arctoolbox：水文分析工具位于[Spatial Analyst Tools]&gt;&gt;[Hydrology]之下数据基础：无洼地的DEM在ArcMap中加载 DEM数据，执行工具条 [水文分析]中的菜单命令 [ 水文分析]&gt;&gt;[ 填洼]，在出现的对话框中将 输入表面栅格数据，参数指定为“DEM”确定后得到无洼地的DEM数据：[ Fill_dem1 ]关键步骤：流向分析在上一步的基础上进行，执行工具条 [水文分析]中的菜单命令 [水文分析]&gt;&gt;[流向 ]，在出现的对话框中将 输入表面栅格数据，参数指定为Fill_dem1确定后得到流向栅格 [ FlowDir_Fill11]，了解流向栅格单元的数值表示的含义是什么计算流水累积量在上一步的基础上进行，执行工具条 [水文分析]中的菜单命令 [ 水文分析]&gt;&gt;[流量]，在出现的对话框中将 [输入流向栅格数据]参数指定为“Flow DirFill”确定后得到流水累积量栅格[Flow Acc_Flow1]提取河流网络(1) 提取河流网络栅格：在上一步的基础上进行，打开Arctoolbox，运行工具[Spatial Analyst工具]&gt;&gt;[地图代数&gt;&gt;[栅格计算器]在 [栅格计算器]中输入公式：con (Flow AccFlow1&gt;800,1)[输出栅格]指定为：StreamNet说明：通过此操作将流水累积量栅格[FlowAccFlow1]中栅格单元值（流水累积量）大于800的栅格赋值为1，从而得到河流网络栅格[StreamNet]得到的的河流网络栅格：StreamNet关闭除[Streamnet]之外的其它图层(1) 提取河流网络矢量数据在上一步的基础上进行，执行工具条 [水文分析]中的菜单命令 [ 水文分析]&gt;&gt;[ 栅格河网矢量化 ]，在出现的对话框中将[输入河流栅格数据]参数指定为“StreamNet，[在输入流向栅格数据]参数指定为 “FlowDir_Fill1，确定后得到河流网络矢量数据(1) 平滑处理河流网络打开[编辑器]工具栏，执行工具栏中的命令[编辑器]&gt;&gt;[开始编辑]，确保目标图层为河流网络图层[Shape],通过打开[Shape1属性表，并选择属性表的所有行选择图层[Shape]中的所有要素,执行[编辑器]工具栏中的命令[编辑器]&gt;&gt;[更多的编辑工具]&gt;&gt;[高级编辑]打开工具条：[高级编辑]，点击其上的[平滑]按钮（下图中所指）：在[平滑]处理对话框中输入参数[允许最大偏移]：3得到平滑后的河流网络矢量图层，执行命令:[编辑器]&gt;&gt;[停止编辑]，保存所做修改。比较平滑处理后的数据与没有进行处理过的数据流域分析在上一步的基础上进行，执行工具条 [Spatial Analyst工具]中的菜单命令 [水文分析 ]&gt;&gt;[ 盆域分析]，在出现的对话框中将[输入流向栅格数据]参数指定为 “Flow Dir_Fill1 ”,确定后得到流域栅格 [Basin_FlowDi1]打开[空间分析]工具栏，执行命令:[空间分析]&gt;&gt;[转换工具]&gt;&gt;[由栅格转出]—栅格转面，将流域栅格转换成为矢量图层，按下图所示指定参数：设置刚生成图层属性[符号系统]后得到类似上图的效果]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(八)]]></title>
    <url>%2Fposts%2Fb48e08fb.html</url>
    <content type="text"><![CDATA[练习八、地理建模地理建模：Model Builder 土壤侵蚀危险性建模分析认识ModelBuilder操作界面1: 添加硬盘上的数据或工具到模型中，数据也可以从ArcMap或ArcCatalog从直接拖到模型中，工具可以直接从Arctoolbox直接拖到模型中2: 显示全部模型要素，并充满ModelBuilder窗口3: 自由缩放，点击此按钮，按住鼠标不放，向上或向下移动鼠标可以缩放ModelBuilder中的流程图4: 选择，用以选择模型中的数据图框，工具图框5: 添加连接，将数据和工具连接起来6: 运行选中的处理过程或整个模型确定目标，加载数据目标：获取 [土壤侵蚀危险性分布图]因子确定：坡度、土壤类型、植被覆盖数据：矢量数据：研究区界线(StudyArea)、植被(Vegetation)，栅格数据：土壤类型栅格(Soilsgrid)(1) 在ArcMap中新建一个地图文档(2) 添加矢量数据：StudyArea、Vegetation、栅格数据Soilsgrid（同时选中：在点击的同时按住Shift）(3) 打开Arctoolbox，激活Spatial Analyst空间分析扩和3D分析扩展模块（执行菜单命令[工具]&gt;&gt;[扩展]，在出现的对话框中选中“空间分析模块”和“3D分析”）(4) 根据Vegetaion中的属性[VegTYPE]设置植被图层的符号为[唯一值渲染]，根据SoilsGrid 图层中属性[Value]设置土壤类型栅格的符号为[唯一值渲染]，设置图层StudyArea的边界和填充，并调整各图层的顺序得到如下下效果：(5) 保存地图文档为[Ex8.mxd]创建模型在上一步操作的基础上进行(1) 在ArcMap中，打开Arctoolbox，执行菜单命令: [工具]&gt;&gt;[选项],在[选项]设置对话框中，设置[空间处理]选项页中[我的工具箱位置]，将其指定为某个路径，比如[d:\arcgis],因为以下建立的模型将会被保存到后缀为[.tbx] 的文件中，而这个文件是保存在以上设定的路径下的.(2) 在Arctoolbox中，右键点击根目标[Arctoolbox],在右键菜单中执行[新的工具箱]命令，将会在[d:\arcgis]创建一个工具箱，将新建工具箱改名，比如[geosptial](3) 右键点击新建的工具箱[geosptial],在右键菜单中，执行命令：[新建]&gt;&gt;[模型]，将打开[ModelBuilder] 应用程序窗口：注意：对已存在的模型，右键点击模型后，选择[编辑]也可以打开[ModelBuilder]窗口，对已存在的模型进行编辑。编辑模型在上一步基础上进行(1) 在[ModelBuilder]窗口中，执行菜单命令：[模型]&gt;&gt;[模型属性]在[常规]选项页中，设置模型的名称及标签在[环境变量]选项页中设置分析范围为研究区范围通过在[环境设置]中，设定[常规设置]的[输出范围]为 [Same As Layer “StudyArea”](2) 在[ModelBuilder]窗口中，执行菜单命令 ：[模型]&gt;&gt;[图属性](3) 从ArcMap中，将图层[Vegetaion]、[Soilsgrid]拖放到[ModelBuilder]窗口中;从[Arctoolbox]中将工具{转为栅格] 拖放到[ModelBuilder]窗口中(此工具在[转换工具&gt;&gt;[DEM转栅格下)(4) 在[ModelBuilder]窗口中，双击工具图框[DEM转栅格]，在出现的工具设置对话框中指定输入USGSDEM文件为：[elevation.dem]－通过输入框右边的[浏览打开]按钮在硬盘上找到该文件。(5) 从[Arctoolbox]中将工具[坡度]拖放到[ModelBuilder]窗口中(此工具在[3D Analyst 工具]&gt;&gt;[栅格表面]下)，在 [ModelBuilder]窗口中，点击[添加连接]按钮（如下图红色箭头所指）将派生数据图框[DEMToRa_elev1]与工具图框[坡度]连接在一起。完成后效果如下图所示：右键点击图框[输出栅格]将其改名为: [坡度图](6) 从[Arctoolbox]中将工具[重分类]拖放到[ModelBuilder]窗口中(此工具在[Spatial Analyst工具]&gt;&gt;[ 重分类]下)，在 [ModelBuilder]窗口中，点击[添加连接]按钮将派生数据图框[坡度图]与工具图框[重分类]连接在一起。完成后效果如下图所示：(7) 在[ModelBuilder]窗口中，双击工具图框[重分类]，在[重分类]工具属性对话框中将坡度重分类：在这里我们通过INFO数据表[slopereclass]实现重分类，在上图中，点击[加载]按钮，找到数据表[slopereclass],将根据此数据表中的设定值将坡度分为10类。[Slopereclas]中有特殊的字段[FROM]、[TO]、[OUT]、[MAPPING]，可以用于重分类：在[ModelBuilder]窗口中，右键点击工具图框[重分类]后面的[输出栅格]将其改名为: [重分类坡度图](8) 从[Arctoolbox]中将工具[要素转栅格] 拖放到[ModelBuilder]窗口中(此工具在[转换工具]&gt;&gt;[转为栅格]–下)，在 [ModelBuilder]窗口中，点击[添加连接]按钮将数据图框[vegetaion]与工具图框[要素到栅格]连接在一起。完成后效果如下图所示：将工具图框[要素到栅格]后的[输出栅格]改名为 [植被栅格]。双击与[Vegetaion]相连的工具图框[要素到栅格]，在出现的对话框中，设置字段为[VEGTYPE],确定。在[ModelBuilder]中右键选中图框[要素转栅格]，执行[运行]命令。[注：此步骤比较重要](9) 从[Arctoolbox]中将工具[加权叠加]拖放到[ModelBuilder]窗口中(此工具在[Spatial Analyst工具&gt;&gt;[叠加分析]下)，右键点击工具图框[加权叠加]后的结果数据图框改名为[土壤侵蚀栅格]，完成后效果如下图所示：(10) 在[ModelBuilder]窗口中，双击工具图框[加权叠加]，在出现的[加权叠加]工具设置对话框中点击[Add Raster Row]按钮 (下图红色箭头所指)在[添加加权叠加图层]对话框中，按下图所示指定各参数，将因子[SOILSGRID]加入加权叠加分析过程：在[加权叠加]对话框再次点击[Add RasterRow]按钮，将下图所示设置参数，将因子[植被栅格]加入到加权叠加分析过程：在[加权叠加]对话框再次点击[Add RasterRow]按钮，将下图所示设置参数，将因子[重分类坡度图]加入到加权叠加分析过程：三个因子添加完成后，回到[加权叠加]工具设置对话框，分别将因子[Soilsgrid]、[植被栅格]、[重分类坡度图]的权重设置为:[25%]、[25%]、[50％](11) 设置因子[Soilsgrid]：根据不同土壤类型对土壤侵蚀危险性的影响力，不同的土壤类型给定不同的的数值，数值1表示改天土壤侵蚀危险度较低，(12) 设置因子[植被栅格]：根据不同植被类型对土壤侵蚀危险性的影响力，不同的植被类型给定不同的的数值，数值1表示改天土壤侵蚀危险度较低，(13) 设置因子[重分类坡度图]：根据不同坡度低的区域发生土壤侵蚀的危险系统较小，坡度较大的区域发生土壤侵蚀的危险系数较大，不同坡度对应不同数值，数值1表示改天土壤侵蚀危险度较低，最终完成的模型图如下：执行模型，查看结果(1) 在[ModelBuilder]窗口中执行菜单命令：[模型]&gt;&gt;[运行整个模型]。请耐心等待计算结果：需要（3-5s）(2) 在[ModelBuilder]窗口中，右键点击图框[土壤侵蚀栅格]在出现的右键菜单中选中[添加到显示窗口]。于是土壤侵蚀危险性分级栅格数据[Hazrad]表示研究区内土壤侵蚀的危险级别，1表示发生土壤侵蚀的可能性较小，6表示发生土壤侵蚀的可能性极大。]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(七)]]></title>
    <url>%2Fposts%2F7ddcb7f7.html</url>
    <content type="text"><![CDATA[练习七、地形分析地形分析：TIN及DEM的生成及应用加深对TIN建立过程的原理、方法的认识；熟练掌握ArcGIS中建立DEM、TIN的技术方法；结合实际，掌握应用DEM解决地学空间分析问题的能力。1. TIN 及DEM 生成矢量数据：高程点Elevpt_Clip.shp高程Elev_Clip.shp边界Boundary.shp洱海Erhai.shp本章的大部分练习都会用到三维分析扩展模块，要使用“三维分析模块”首先在ArcMap中执行菜单命令【自定义】&gt;【扩展模块】，在扩展模块管理窗口中，勾选【3DAnalyst】。然后在ArcMap工具栏的空白区域点右键，在出现的右键菜单中找到【3DAnalyst】项，点击该项，在ArcMap中显示三维分析工具栏。1.1由高程点、等高线矢量数据生成TIN转为DEM(1) 在ArcMap中新建一个地图文档，添加矢量数据：Elevpt_Clip、Elev_Clip、Boundary、Erhai；(2) 在ArcToolbox中双击【3D Analyst工具】&gt;【TIN管理】&gt;【创建TIN】，打开【创建TIN】对话框；(3) 在对话框中添加上述4个图层，参数设置如下图（注意：在构建Erhai图层时，SF_type参数需要设置为“硬替换”）：【创建TIN】对话框中的参数说明：height_field：高程字段，用于提供要素的高程值。当图层中无高度属性时，可选“&lt;None&gt;”，但至少要保证有一个图层属性表中有高程值。SF_type：表面要素类型字段，用于定义如何将要素几何添加到三角形中。tag_field：标签字段，用于指定在TIN中用做标签值的要素类型属性字段。“SF_type”字段取值类型说明：离散多点：是TIN网中的结点，主要决定表面的形状，在表面变化程度较大的区域包括较多的离散点，表面变化程度较小的区域包括较少的离散点。断裂线：主要用来表示自然要素（如山脊线、河流）或人工要素（如道路），分为硬断线和软断线。硬断线：用来表示坡度的不连续性，如河流和道路可以作为硬断裂线包括在TIN中；软断线：用于向TIN添加边，以捕获不会改变表面局部坡度的线状要素，研究区域边界可作为软断裂线包括在TIN中。(1) 在图层控制中，仅打开[ErHai]和[Tin]两个图层，同时关闭图层[Tin]的“边类型”，可得到如下的效果：(1) 在ArcToolbox中双击【3D Analyst工具】&gt;【由TIN转出】&gt;【TIN转栅格】，打开【TIN转栅格】对话框，在对话框中设置相关参数（如下图所示）：需要保存在个人数据库中(1) 确定后得到一个栅格数据图层[tinGrid]，其中每个栅格单元表示50m*50m的区域，如下图所示。1.2 TIN的显示(1) 在图层控制中，仅打开[Tin]图层，编辑图层的属性，在属性对话框中，点击【符号系统】选项页，将【边类型】和【高程】前面的勾去掉，点击【添加】按钮，如下图所示：(1) 在【添加渲染器】对话框中，将【具有相同符号的边】和【具有相同符号的节点】添加到TIN的显示列表中，如下图所示：(1) 点击确定，将[Tin]图层局部放大，认真理解TIN的存储模式及显示方式，如下图所示：1.3将TIN转换为坡度多边形(1) 新建地图文档，加载图层[Tin]，参考上一步操作，将【具有分级色带的表面坡度】项添加到TIN的显示列表中；{width=”3.248031496062992in”height=”2.688976377952756in”}(1) 在上面的对话框中，选中【坡度(度)】，将【分类】中的【类】指定为“5”，点击【分类】按钮，在下面的对框中，将【分类】中的【方法】指定为“手动”，在【中断值】列表中依次输入坡度中断值：8、15、25、35、90，如下图所示：点击【确定】后关闭图层属性对话框，图层[Tin]将根据指定的渲染方式进行渲染，效果如下图所示：(1) 在ArcToolbox中双击【3D Analyst工具】&gt;【表面三角化】&gt;【表面坡度】，打开【表面坡度】对话框，按下图所示指定各参数（注意：需要在【类明细表】中选取数据库SlopeCode.mdb）：得到多边形图层[tinSlope]，它表示研究区内各类坡度的分布状况，结果是矢量格式，打开其属性表可以看到属性字段[SlopeCode]的取值为1、2、3、4、5。查看矢量图层：tinSlopef中要素属性表，其中属性字段[SlopeCode]1、2、3、4、5分别表示坡度范围（0-8）、(8-15)、（15-25）、（25-35）、(35-90)。1.4合并破碎多边形(1) 新建地图文档，加载上一步生成的坡度多边形图层[tinSlope]，打开属性表，添加一个字段Area（类型为Double）；(1) 通过【计算几何】操作，计算各个多边形的面积：(1) 执行菜单命令【选择】&gt;【按属性选择】，打开【按属性选择】对话框，将面积小于等于10000平方米的多边形选择出来，被选中的多边形以高亮方式显示：(1) 双击ArcToolBox中的【数据管理工具】&gt;【制图综合】&gt;【消除】，打开【消除】对话框，将面积小于等于10000平方米的多边形合并到周围面积最大的多边形中。原始多边形合并后的多边形将地图适当放大，比较原始图层[tinSlope]与合并后的图层[tinSlope_Eliminate]。Eliminate（合并破碎多边形）操作原理1.5 TIN转换为坡向多边形参照1.3节中的操作步骤，可得到坡向多边形图层[tinAspect]：得到的坡向多边形中属性AspectCode的数值（-1,1,2,3,4,5,6,7,8,9）分别表示当前图斑的坡向（平坦、北、东北、东、东南、南、西南、西、西北、北），其中1,9是相同的可以合并为1。2. DEM的应用2.1坡度Slope(1) 新建地图文档，加载1.1节第6步中得到的栅格数据[tinGrid]；(2) 双击ArcToolBox中的【Spatial Analyst工具】&gt;【表面分析】&gt;【坡度】,打开【坡度】对话框，参照下图指定各参数：(3) 得到坡度栅格Slope_TinGrid，栅格单元的值在[ 0 -90 ] 度间变化：(1) 右键点击图层[Slope_TinGrid]，执行[属性命令]，设置图层[符号]，重新调整坡度分级（参考1.3节中第2步进行分类）：2.2坡向Aspect(1) 新建地图文档，加载1.1节第6步中得到的栅格数据[tinGrid]；(2) 双击ArcToolBox中的【Spatial Analyst工具】&gt;【表面分析】&gt;【坡向】, 打开【坡向】对话框，参照下图指定各参数：(1) 得到坡向栅格[AspectTinGrid]：2.3提取等高线(1) 新建地图文档，加载栅格数据[tinGrid]；(2) 双击ArcToolBox中的【3D Analyst工具】&gt;【栅格表面】&gt;【等值线】,打开【等值线】对话框，参照下图指定各参数：(1) 生成等高线矢量图层[Contour_TinGrid]：2.4计算地形表面的阴影图(1) 新建地图文档，加载栅格数据[tinGrid]；(2) 双击ArcToolBox中的【3D Analyst工具】&gt;【栅格表面】&gt;【山体阴影】,打开【山体阴影】对话框，参照下图指定各参数：(1) 生成地表阴影栅格：[ShadowTinGrid]：(1) 关闭除[TinGrid]和[ShadowTinGrid]以外的所有图层，并将[TinGrid]置于[ShadowTinGrid]之上，右键点击[TinGrid]，在出现的右键菜单中执行【属性】，在【图层属性】对话框中，参照下图所示设置【符号系统】选项页中颜色：(1) 打开工具栏【效果】，如下图所示，设置栅格图层[TinGrid]的透明度为40%左右，以便部分透出下层的山体阴影效果。2.5通视分析(1) 新建地图文档，加载栅格数据[tinGrid]；(2) 打开【3DAnalyst】工具栏，从工具栏选择【创建通视线】工具：(1) 在出现的【通视线】对话框中输入【观察点偏移】和【目标偏移】,即距地面的距离，如图：在地图显示区中从某点A沿不同方向绘制多条直线，可以得到观察点A到不同目标点的通视性：绿色线段表示可视的部分，红色线段表示不可见部分2.6视域分析(1) 新建地图文档，加载栅格数据[tinGrid]和矢量数据[移动基站.shp]；(2) 双击ArcToolBox中的【3D Analyst工具】&gt;【可见性】&gt;【视域】,打开【视域】对话框，参照下图指定各参数：(1) 生成可视区栅格[View_TinGrid]，其中绿色表示现有发射基站信息已覆盖的区域，淡红色表示无法接收到手机信号的区域。2.7地形剖面(1) 新建地图文档，加载栅格数据[tinGrid]；(2) 打开【3DAnalyst】工具栏，从工具栏选择【线插值】工具，跟踪一条线段，这条线段可以从[tinGrid]中得到高程值：(1) 从【3DAnalyst】工具栏中选择【创建剖面图】工具，得到该线段所在区域的剖面图：]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(六)]]></title>
    <url>%2Fposts%2Fe2d4af7d.html</url>
    <content type="text"><![CDATA[练习六、空间分析的应用1.加深对缓冲区分析基本原理、方法的认识；2.熟练掌握距离制图创建缓冲区技术方法。3.掌握利用缓冲区分析方法解决地学空间分析问题的能力。1. 距离制图－创建缓冲区数据准备：图层文件point.shp，lline.shp，polygon.shp1.1 点要素图层的缓冲区分析1) 在ArcMap中新建地图文档，加载图层：StudyArea，point2) 打开Arctoolbox，执行命令&lt;Spatial Analyst工具&gt;－&lt;距离分析&gt;-&lt;欧氏距离&gt;，按下图所示设置各参数注：在ArcView GIS 3.x中Find Distance功能与ArcGIS中&lt;&lt;欧氏距离&gt;制图功能相同。点击“环境”按钮设置“处理范围”中的 “范围”，使其与 StudyArea 相同1) 显示并激活由point.shp产生的新栅格主题，EucDist_（如上图）。在进行分析时，若选中了point图层中的某一个或几个要素，则缓冲区分析只对该要素进行；否则，对整个图层的所有要素进行。1.2 线要素图层的缓冲区分析在ArcMap中，新建地图文档，加载line图层，点击常用工具栏中的将地图适当缩小。分别选中图层line中的两条线，进行缓冲区分析，注意比较线的缓冲区分析与点的缓冲区分析有何不同。方法：打开Arctoolbox，执行命令&lt;Spatial Analyst公具&gt;－&lt;距离分析&gt;-&lt;欧氏距离&gt;；设置“环境设置”中“处理范围”中的“范围”为“与显示相同”对整个line层面进行缓冲区分析，观察与分析结果的区别（如下图）。1.3 多边形图层的缓冲区分析在ArcMap中新建地图文档，添加图层：polygon，进行缓冲区分析，观察面的缓冲区分析与点、线的缓冲区分析有何区别。与创建线的缓冲区相同，先将地图适当缩小，将“环境”中“处理范围”中的“范围”为“与显示相同”2．综合应用实验2.1 水源污染防治Point图层面表示了水源（如：水井）的位置分布，要求利用缓冲区分析找出水源污染防治的重点区域。步骤：在ArcMap中，新建地图文档，添加表示水源分布的点图层数据point.shp。打开ArcToolbox，执行&lt;Spatial Analyst &gt; 工具&gt;－&lt;距离&gt;-&lt;欧氏距离&gt;命令。显示并激活由point.shp产生的新栅格图层eucdist（如下图）。右键点击栅格图层eucdist，在右键菜单中执行“属性”命令，设置图层显示符号，可调整分类和设置图例显示方式。新的栅格图层显示了区域内每个栅格距最近的水井的距离，其中红色的栅格距各个井的距离最近，对水源的影响最大；蓝色的栅格距各个井的距离最远，影响最小。在本例中认为距各个水井0.1以内的区域对水质的影响和污染最大，因此，打开“空间分析”工具栏（首先要确保“空间分析”扩展模块已经加载），执行菜单命令&lt;Spatial&gt; Analyst&gt; 工具&gt;-&lt;地图代数&gt;-&lt;栅格计算器&gt;，将距离≤0.1以内的区域提取出作为缓冲区进行专项的污染防治。（如下图）。2.2 受污染地区的分等定级假定：point图层表示的是几个点状污染源，距污染源的远近不同，受污染的状况也不同，距污染源越近，受污染越严重，据此对污染源附近地区进行分等定级。(1) 在ArcMap中，新建地图文档，添加图层：point.、StudyArea。打开ArcToolbox，执行&lt;Spatial &gt; Analyst &gt; 工具&gt;－&lt;距离分析&gt;-&lt;欧氏距离&gt;命令，得到新的栅格图层EucDist_shp3；注意：指定范围为 “与图层StudyArea相同”(1) 打开“空间分析”工具栏，执行命令：&lt;空间分析&gt;－&lt;栅格计算器&gt;，基于栅格图层EucDist_shp3t进行栅格计算，分别提取（[EucDist_shp3]≤0.1）的区域、及（EucDist_shp3] &gt;=&gt; 0.1&amp;（EucDist_shp3] &lt;=&gt; 0.15）的区域，分别得到栅格图层：“restercal3”和“restercal2”；(1) 对栅格图层：“restercal2”进行重分类运算（执行命令&lt;空间分析&gt;－&lt;重分类&gt;命令），使得原来的True（1）值为0，False（0）值为1，得到新的栅格图层：Reclass_rast3。(1) 将图层“restercal3”与“Reclass&lt;重分类&gt;对栅格图层“Rastercalc4”按分等定级的要求进行分类得到结果栅格图层“Reclass &gt; of_rast2”。(&lt;=0.1的区域污染级别定为1，)=0.1且&lt;=0.15的区域级别定为2,&gt;0.15的区域级别定为3)说明：本例中，第（2）－（4）操作实际可以直接对栅格图层dist_of_point进行重分类得到。2.3 城市化的影响范围假定：urban图层表示的是城市化进程中的一些工业小城镇，还包括一个自然生态保护区。这些小城镇的城市化会对周边地区产生一些扩张影响，但自然生态保护区周围0.05的范围内不能有污染性的工业，因此其城市化的范围就受到限制。(1) 在ArcMap中，新建地图文档，添加图层：urban.shp、UrbanArea，&lt;Spatial &gt; Analyst &gt; 工具&gt;－&lt;距离分析&gt;-&lt;欧氏距离&gt;命令,分别对对urban图层中的进行分析，分别对保护区和城镇进行欧氏距离分析，保护区和城镇需要分开做欧氏距离分析，以城镇为例：点击选择-按属性选择注意：“环境”设置中，处理范围－&gt;的范围请选择为：与图层UrbanArea相同城镇的缓冲区保护区的缓冲区(1) 对图层Dist_Nature执行栅格计算（使用空间分析工具中的栅格计算器），提取&lt;=0.05的区域，并进行重分类，使得原来的True（1）值为0，False（0）值为1，得到“Reclass&gt; of 计算”。(1) 对图层Dist_Res进行栅格计算提取&lt;=0.06的区域，得到“计算2”；(1) 将图层“Reclass of &gt; 计算”与“计算2”相乘的栅格计算（使用空间分析工具栏中的栅格计算器），得到城市化范围“计算3”图层。(1) 仔细思考以上操作过程，对得到的结果进行解释不影响保护区的城市扩张区域]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(五)]]></title>
    <url>%2Fposts%2F7bdbe70f.html</url>
    <content type="text"><![CDATA[练习五、空间分析的基本操作空间分析的基本操作空间分析模块空间分析是基于地理对象的位置和形态的空间数据的分析技术，其目的在于提取和传输空间信息。空间分析是地理信息系统的主要特征。空间分析能力（特别是对空间隐含信息的提取和传输能力）是地理信息系统区别与一般信息系统的主要方面，也是评价一个地理信息系统成功与否的一个主要指标。本章的大部分练习都会用到空间分析扩展模块，要使用“空间分析模块”首先在ArcMap中执行菜单命令【自定义】&gt;【扩展模块】，在扩展模块管理窗口中，勾选【SpatialAnalyst】。然后，在ArcMap工具栏的空白区域点右键，在出现的右键菜单中找到【SpatialAnalyst】项，点击该项，在ArcMap中显示空间分析工具栏。执行“地理处理”工具栏中的菜单命令&lt;环境&gt;－&lt;工作空间&gt;，设定与空间分析操作有关的一些参数。这里请在“当前工作空间”和“临时工作空间”设定一个工作目录。因为在空间分析的过程种会产生一些中间结果，当设置了工作目录后，这些中间结果就会保存在指定的路径下。了解栅格数据在ArcMap中，新建一个地图文档，加载栅格数据：Slope1，右键点击图层Slope1，查看属性。在图层属性对话框中，点击“源”选项，可以查看此栅格图层的相关属性及统计信息。打开【SpatialAnalyst工具】工具栏，点击图标，查看栅格数据的统计直方图：新建ArcMap地图文档：加载离散栅格数据：Landuse，右键点击Landuse图层的【打开属性表】。查看字段“Count”可以看到每种地类所占栅格单元的数目用任意多边形剪切栅格数据（Extract by Mask）练习内容：提取出任意多边形内的栅格数据。在ArcMap中，加载栅格数据Landuse和矢量数据ClipPoly.shp。在ArcToolbox中双击【SpatialAnalyst工具】&gt;【提取分析】&gt;【按掩膜提取】。注意观察提取后的结果：栅格计算是栅格数据空间分析中进行数据处理和分析最为常用的方法，应用非常广泛，能够解决各类问题。在ArcToolbox中双击【SpatialAnalyst工具】&gt;【地图代数】&gt;【栅格计算器】。构造表达式：[landuse]*[extract_land1]，执行栅格图层Landuse和用以剪切的栅格 extract_land1之间的相乘运算。得到的结果即是以任意多边形剪切的的Landuse数据。栅格重分类（Raster Reclassify）练习内容：将连续栅格数据转换为离散栅格数据。在ArcMap中，新建地图文档，加载栅格数据Slope1，在ArcToolbox中双击【SpatialAnalyst工具】&gt;【重分类】&gt;【重分类】，打开【重分类】对话框。将坡度栅格重新分为5类：0 – 8 、8 – 15 、15 – 25 、25 – 35、 35 度以上。栅格计算－查询符合条件的栅格（Raster Calculator）练习内容：找出坡度在25度以下的区域。在ArcToolbox中双击【SpatialAnalyst工具】&gt;【地图代数】&gt;【栅格计算器】，打开【栅格计算器】对话框。构造表达式 [Slope1]&lt;=25满足条件的栅格赋值为1，其余的栅格赋值为 0面积制表（Tabulate Area）练习内容：计算两个数据集之间交叉制表的区域并输出表。加载Landuse92栅格图层，在ArcToolbox中双击【SpatialAnalyst工具】&gt;【区域分析】&gt;【面积制表】，打开【面积制表】对话框。按上图所示，指定分区数据和输入栅格数据。打开得到的交叉面积数据表，观查其中的记录，理解本操作的意义是什么？分区统计（Zonal Statistic）练习内容：汇总另一个数据集区域内的栅格数据值，并将结果输出为统计图表。在ArcMap中新建地图文档，加载栅格图层r5yield（粮食产区分类图） 、栅格Organic（土壤有机质含量分布图）。在r5yield 中，根据产量不同分为5个粮食产区：在ArcToolbox中双击【SpatialAnalyst工具】&gt;【区域分析】&gt;【以表格显示分区统计】，打开【以表格显示分区统计】对话框。按上图所示指定参数，确认后得到如下一个数据表：仔细研究上面的数据表，理解本操作的意义是什么？点击上面数据表中的下拉菜单，执行【创建图】命令。根据向导提示，设定参数，生成不同粮食产区土壤有机质含量（平均值）的统计图表。从统计图中可以看出，产量最低区有较低的有机质含量，中产区有机质含量较高。这表明较高的有机质含量会带来较高的产量。最高产量区有机质含量较低可能是其他因素的影响。缓冲区分析（Buffer）缓冲区分析（Buffer Analysis），是为了识别某一地理实体对周围地物的影响而在其周围建立的一定宽度的多边形区域。缓冲区分析是用来确定不同地理要素的空间邻近性或接近程度的一种分析方法。作为GIS的空间分析功能之一，缓冲区分析的应用非常广泛，常用于分析矢量实体的某种属性对周围的影响。例如，城市中工厂排放的废水废气所影响的空间范围，交通噪音污染的空间范围，湖泊对周围耕地的影响，等等。练习内容：选择目标要素，并构建其线状缓冲区。步骤1：添加缓冲区向导到菜单中在ArcMap窗口中，执行菜单命令：【自定义】&gt;【自定义模式】，打开【自定义】对话框，切换到【命令】选项卡。在【命令】选项卡中，选择【类别】列表框中的【工具】，然后在【命令】列表框中选择【缓冲向导】，按住鼠标左键不放，将其拖动到已经存在的工具栏中。步骤2：加载街道数据，并设置地图单位新建地图文档，加载街道图层AIOStreets和城市地籍图层AIOZonecov（地图单位为：米），并将数据框属性中的单位设置为“米”。步骤3：选择目标街道执行菜单命令：【选择】&gt;【按属性选择】。在对话框中构造表达式：”STR_NAME”= ‘CYPRESS’，以便从图层AIOStrees中选出名称为CYPRESS的街道。步骤4：创建目标街道的线状缓冲区单击缓冲图标，打开【缓冲向导】对话框：如下图所示，通过缓冲区向导，建立了所选择街道“CYPRESS”的50米缓冲区（一个新的多边形图层）。空间关系查询（Select by Location）练习内容：在上一步的基础上进行，找出与街道“CYPRESS”的50米缓冲区相交的地块。执行菜单命令：【选择】&gt;【按位置选择】，打开【按位置选择】对话框。从而得到与街道“CYPRESS”的50米缓冲区相交的所有地块，如下图所示。采样数据的空间内插（Interpolate）空间插值常用于将离散点的测量数据转换为连续的数据曲面，以便与其它空间现象的分布模式进行比较，它包括了空间内插和外推两种算法。空间内插算法是通过已知点的数据，推求同一区域其它未知点的数据；空间外推算法则是通过已知区域的数据，推求其它区域的数据。练习内容：通过空间内插的方法，将点上的数据扩展到连续的空间上，得到气温空间分布图。实验数据：气温.shp 中有两个字段Y01和Y02，分别记录的是16个气象观测站在2001年和2002年的年平均气温。YNBoundary.shp是云南省边界图。新建地图文档，加载图层气温.shp和YNBoundary.shp。在ArcToolbox中双击【SpatialAnalyst工具】&gt;【插值】&gt;【样条函数法】，打开【样条函数法】对话框，按下图所示指定参数。确定后，得到如下的气温空间分布图（通过修改图例得到相同的效果）。类似地，可生成2002年的平均气温空间分布图。2001年2002年空间内插后的年平均气温图（样条函数法）在ArcToolbox中双击【SpatialAnalyst工具】&gt;【插值】&gt;【反距离权重法】，打开【反距离权重法】对话框，通过设置相关选项和参数，重新进行空间插值，可生成反距离权重法插值后的年平均气温空间分布图：2001年2002年空间内插后的年平均气温图（反距离权重法）栅格单元统计（Cell Statistics）练习内容：在上一步的基础上，根据2001年和2002年的年平均气温得到多年平均气温空间分布图。在ArcToolbox中双击【SpatialAnalyst工具】&gt;【局部】&gt;【像元统计数据】，打开【像元统计数据】对话框，按下图所示指定参数。空间内插后的2001、2002年平均气温图邻域统计（Neighborhood）邻域分析也称为窗口分析，主要应用于栅格数据模型。地理要素在空间上存在着一定的关联性，对于栅格数据所描述的某项地学要素，其中的（i,j）栅格往往会影响其周围栅格的属性特征。准确而有效地反映这种事物空间上联系的特点，是计算机地学分析的重要任务。窗口分析是指对于栅格数据系统中的一个、多个栅格点或全部数据，开辟一个有固定分析半径的分析窗口，并在该窗口内进行诸如极值、均值等一系列统计计算，从而实现栅格数据有效的水平方向扩展分析。支持的几种分析窗口类型：ArcMap中，邻域统计功能所支持的各类算子包括：多数（Majority）最大值（Maximum ）均值（Mean ）中值（Median ）最小值（Minimum ）少数（Mirity ）范围（Range ）标准差（Standard Deviation ）总数（Sum ）变异度（Variety ）高通量（High Pass ）低通量（Low Pass ）焦点流（Focal Flow）原始栅格 （总数Sum） 邻域统计栅格练习内容：在ArcMap中新建地图文档，加载栅格数据：emidalat,打开“空间分析”工具栏，执行“邻域统计”命令，按如下所示指定参数，在ArcToolbox中双击【SpatialAnalyst工具】&gt;【邻域分析】&gt;【块统计】，打开【块统计】对话框，按下图所示指定参数。将得到一个经过邻域运算操作后的栅格BlockSt_emid1，这是以3×3的格网，对emidalat栅格中的单元运用“均值”（Mean）算子进行邻域运算后得到的结果。通过设置图例，使图层BlockSt_emid1和emidalat有如下的效果，将地图适当放大，并在图层控制面板中通过交替打开和关闭图层BlockSt_emid1的操作，观察BlockSt_emid1和原始栅格间的差别。原始栅格邻域统计后的栅格]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(四)]]></title>
    <url>%2Fposts%2F7d70b072.html</url>
    <content type="text"><![CDATA[练习四、空间数据处理1.空间数据处理（融合、合并、剪切、交叉、合并）2.设置地图投影及投影变换空间数据处理数据：云南县界.shp; Clip.shp西双版纳森林覆盖.shp 西双版纳县界.shp步骤：将所需要的数据下载后，解压到到 e:\gisdata,设定工作区:在ArcMap中执行菜单命令：&lt;地理处理&gt;－&gt;&lt;环境&gt;，设定“临时工作空间”为e:\gisdata第1步 裁剪要素在ArcMap中，添数据GISDATA\云南县界.shp，添加数据GISDATA\Clip.shp （Clip 中有四个要素）激活Clip图层。点击编辑器中的开始编辑，选中clip图层，选中Clip图层中的一个要素，注意确保不要选中“云南县界”中的要素！点击地理处理，打开ArcToolbox，分析工具→提取分析→裁剪指定输入类：云南县界，指定剪切要素：Clip（必须是多边形要素）指定输出要素类路径及名称，这里请命名为“云南县界_Clip1”依次选中Clip主题中其它三个要素，重复以上的操作步骤， 完成操作后将得到共四个图层（“云南县界_Clip1” , “云南县界_Clip2”，“云南县界_Clip3”，“云南县界_Clip4”）。第2步 拼接图层在ArcMap中新建地图文档，加载你在剪切要素操作中得到的 四个图层点击地理处理，打开ArcToolbox→数据管理工具→常规→追加打开“追加”面板，输入数据集素：依次添加其它三个图层目标数据集：设定为 云南县界_Clip1右键点击图层“云南县界_Clip1”，在出现的右键菜单中执行“数据”-&gt;”导出数据”指定导入数据的路径和名称:YNOK.shp通过以上操作我们就完成了将4个图层拼接为一个图层的处理。新建一地图文档，加载数据YNOK.shp，查看图层及打开其属性表看看与“云南县界”中的属性表有何区别。第3步 要素融合在拼接图层的基础上继续点击地理处理→ArcToolbo→数据管理工具→制图综合→融合输入要素：指定为YNOK融合字段：选择为“所属州”，将根据这个字段的值对要素进行融合，YNOK图层中“所属州”相同的要素将合并成一个要素以上操作，根据指定字段的值，对现有图层中的要素进行融合，产生新的图层――YNOK_Dissovle,打开并查看其属性表类似地，重复以上过程，并将融合字段指定为：CHINESE ，看看结果有何不同第4步 图层合并在ArcMap中新建一个地图文档，加载数据 GISDATA\西双版纳森林覆盖.shp 和 GISDATA\西双版纳县界.shp调整图层顺序，将西双版纳县界置于下方打开ArcToolbox，在ArcToolbox→分析工具→叠加分析→联合，执行“联合”命令在联合对话框中输入要素：依次添加 “西双版纳森林覆盖”“西双版纳县界”两个图层输出要素类：设置为 Union.shp查看输出要素类：Union的的属性表，并检查属性 “Type”，其中为“Y”的表示有植被覆盖的区域，右键点击图层Union,修改属性－&gt;符号系统 ，类别设置为唯一值，值字段设置为TYPE，点击添加值，把Y添加，点击确定。第5步 图层相交在图层合并练习的基础继续在ArcToolbox中，分析工具→叠加分析→相交，执行“相交”命令在“相交对话框”中输入要素：依次添加 “西双版纳森林覆盖”“西双版纳县界”两个图层输出要素类：设置为 Intersect.shp查看 输出要素类InterSect，并与“西双版纳森林覆盖”及“图层合并”操作所得结果――“Union”进行比较，并进一步思考这类操作适合求解哪一些现实问题。定义地图投影第6步 定义投影在ArcMap中新建地图文档，添加第4步成生成的图层:Union.shp在TOC中，右键点击图层“Union”，查看属性,在属性对话框中，点击“源”选项页，查看这图层是什么坐标系打开ArcToolbox→数据管理工具→投影和变换→定义投影，执行命令“定义投影”命令在定义投影对话框中，选择要素类：Union，点击坐标系输入框右边的按钮，在出现的“定义投影”对话框中，选择一个地理坐标系，GCS_BEJING_1954（注意：前提是我们已知道图层Union是使用北京1954地理坐标系）点击“按钮”，进入空间参考属性，从坐标系中选择（坐标系统\地理坐标系\Asia\Beijing1954.prj）在TOC中，右键点击图层“Union”，查看属性,在属性对话框中，点击“源”选项页，查看这个图层的坐标系是否已经被指定为“北京1954地理坐标系”第7步 投影变换地理坐标系－&gt;北京1954坐标系转换－&gt;西安80坐标系在第6步的基础上进行打开ArcToolbox→数据管理工具→投影和变换→要素→投影，执行命令“投影”命令在“投影”对话框中，输入数据集或要素类选union,把坐标系改为――“BEJING_1954_GK_ZONE_17N”（坐标系统\投影坐标系\GaussKruger\Beijing 1954\Beijing 1954 GK Zone 17N.prj）确定后，完成由地理坐标系GCS_BEJING_1954 到 投影坐标系BEJING_1954_GK_ZONE_17N 的变换。]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(三)]]></title>
    <url>%2Fposts%2F87335f7d.html</url>
    <content type="text"><![CDATA[练习三、地图配准操作1.对无坐标信息的地形图（图片格式）进行地图配准操作2.编辑器的使用（点要素、线要素、多边形要素的数字化）本例主要介绍如何给无坐标信息的地形图（图片格式）添加坐标信息。带有坐标信息的图片文件格式有tiff和grid 格式(此种情况可跳过1、2、3步，从第4步开始)，其余如jpg、bmp、png等都不带有坐标信息。第1步 确定目标坐标信息打开地形图图片，查看该地形图的坐标基准信息、比例尺以及坐标范围。【坐标基准信息】为该地形图的地理坐标系，在图片左下方；【比例尺】在图下侧中央，其确定了该地形图的投影方法，我国的大比例尺地形图均采用Gauss-Kruger（高斯-克吕格）投影；【坐标范围】确定了高斯-克吕格投影的带号（3度或6度）和中央经线。注：1:1万采用 3 度带投影，1:2.5 万-50万采用6度带投影。读图可知：第2步 设定数据框的属性打开ArcMap，加载地形图文件“70011-1.tif”，右键图层【Layers】-坐标系【CoordinateSystems】-投影坐标系【Projected Coordinate Systems】-【GaussKruger】-【Xian 1980】-【Xian 1980 3 Degree GK CM102E】，选择常规【General】选项卡，设置地图单位【Units】。第3步 定义投影。可以查看到该图层的坐标范围已校正到高斯坐标系下，但该数据只是隐式的具有坐标信息，需要进行定义投影后才具有显示坐标信息。打开【数据管理工具】|【投影和变换】|【定义投影】工具，输入数据集或要素类设置为“70011-1.tif”，点击右侧坐标系按钮，打开【空间参考属性对话框】；点击【选择】，选择投影坐标系【ProjectedCoordinate Systems】-【Gauss Kruger】-【Xian 1980】-【Xian 1980 3 DegreeGK CM 102E】；由于本例中地形图的中央经线为 102.65625°，因此需要修改默认以 102E为中央经线的坐标信息；点击【修改】按钮，设置本例投影名称为“newproject”，中央经线值改为102.65625°。确定，执行定义投影工具，得到定义投影的地形图。第4步 设置配准连接打开ArcMap，加载地形图图片数据。右击菜单栏空白处，添加地理配准工具条。首先，将地理配准工具条下的【自动校正】的勾取消；使用【添加控制点】工具，对四角点进行配准；点击某一角点后，右击任意位置，选择【输入经纬度】， 将步骤1中的经纬度坐标输入，依次设置好四角点的连接关系。注：若内图廓四边不水平或垂直，必须先将该图片整平后方能进行配准。本例已整平处理。第5步 查看连接表。点击工具条中【查看连接表】按钮打开【连接表】，表中列出了从像素坐标系（原始）到高斯坐标系（目标）的控制点对应关系，残差列表为空。在连接表对话框中，变换选择【校正】或【一阶多项式（仿射）】，即可计算出四角点校正前后产生的残差值。由于【校正】是强制性变换方法，容易造成图片校正前后发生严重扭曲、错位等错误，建议不使用该方法；而一阶多项式或二阶多项式等变换方法是在牺牲校正精度的情况下，保持图像的整体完整性（无错位）。本例中，由于控制点为四角点，全部包含了图内容，可以考虑使用【校正】方法。第6步 执行图像校正。选择工具条【地理配准】下的【纠正】菜单，保存校正后的地形图为“纠正.tif”，格式为“tiff”，像元大小默认（以一阶多项式变换方法进行纠正）。第7步 分层矢量化－在ArcCatlog中创建一个线要素图层(1) 打开ArcCatalog.在指定目录下，鼠标右击，在“新建”中，选择“个人Geodatabase”。并修改该Geodatabase数据库的名称（例如test3.mdb）。(2) 下面将为该Geodatbase创建新的要素类，首先创建一个“等高线”要素类来存储等高线要素。在ArcCatalog中，鼠标右击test3这个个人 Geodatabase,在“新建”中选择“要素类”.(1) 输入创建的要素类的名称“等高线”，点击下一步。(2) 点击下一步。下面将是我们创建新的要素类的关键，为我们的数据定义坐标系统，空间范围，存储要素类型。以及可以在这增加属性字段。(1) 点击Shape字段。在对话框中将显示详细的选项，我们首先点击“几何类型”，并将要素类型选择为我们需要的类型（我们现在要创建等高线这个要素类，所以应该选择线）.(1) 点击“空间参考”选项后面的按钮，在“空间参考属性”对话框中的“坐标系”选项页下，将选择合适的坐标系统，点击“选择”按钮。在(ProjectedCoordinate Systems目录下，选择Gauss uger—Xian 1980–Xian_1980_Degree_GK_CM_102E.prj)。点击增加，现在这些坐标系统信息应该如下图所示：(1) 下面我们将为该数据创建新的属性字段。“高程”，类型设置为“Float”用来存储等高线的高程值。(1) 点击完成这样，我们就创建了一个线状的要素类。第8步 已配准的地图上提取等高线并保存到上面创建的要素类中(1) 切换到ArcMap中，将新建的线要素图层，加载到包含已配准地形图的数据框中，保存地图文档为Ex3.mxd(2) 打开“编辑器”工具栏，在“编辑器”下拉菜单中执行“开始编辑命令”，并选择前面创建的“等高线”要素类。确认编辑器中：任务为――新建要素，目标为――等高线，设置图层――等高线的显示符号为红色，并设置为合适的宽度。(1) 将地图放大到合适的比例下，从中跟踪一条等高线并根据高程点判读其高程，输入该条等高线的高程。(2) 进行一步练习线要素的其它操作，比如线段的合并、分割、编辑顶点等操作可参照以上步骤，从地图中提出多边形要素（比如居民地），并进一步熟悉多边形要素编辑的相关操作。]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(二)]]></title>
    <url>%2Fposts%2Ff9c07f56.html</url>
    <content type="text"><![CDATA[练习二、管理地理空间数据库1.利用ArcCatalog 管理地理空间数据库2.在ArcMap中编辑属性数据第1步 启动 ArcCatalog 打开一个地理数据库当 ArcCatalog打开后，点击, 按钮（连接到文件夹）.建立到包含练习数据的连接（比如“E:\ARCGIS\2练习二\Exec2”）,在ArcCatalog窗口左边的目录树中, 点击上面创建的文件夹的连接图标旁的(+)号，双击个人空间数据库－ National.mdb。打开它。.在National.mdb中包含有2个要素数据集、1个关系类和1个属性表第2步 预览地理数据库中的要素类：在ArcCatalog窗口右边的数据显示区内，点击“预览”选项页切换到“预览”视图界面。在目录树中，双击数据集要素集－“WorldContainer”，点击要素类－“Countries94”激活它。在此窗口的下方，“预览”下拉列表中，选择“表格”。现在，你可以看到Countries94的属性表。查看它的属性字段 信息。花几分钟，以同样的方法查看一下National.mdb 地理数据库中的其它数据。第3步 创建缩图，并查看元数据在目录树中，选择地理数据库National中的要素类－Countries94，切换到“预览视图”，点击工具栏上的放大按钮，将图层放大到一定区域，然后再点，生成并更新缩略图。这时，切换到“内容”视图界面下，并在目录树中选择要素集－“WorldContainer”，数据查看方式更改为“缩略图方式”。.注意，此时，要素类“Countries94”的缩图图是不是发生了改变第4步 创建个人地理数据库(Personal Geodatabase)导入数据; 在数据库中创建属性表然后录入数据。在创建的地理数据库之间要完成数据库的概念设计，每一个图层对应一个数据表，在ArcCatalog中“要素类”（FeatureClass）的概念与之对应。可以将多个要素类组织成为一个“要素集”（FeatureDataSet），在同一个要素集中的要素类都具有相同的地理参考（坐标系相同）。在ArcCatalog的目录树中，定位到E盘，右键点击这E:盘，在出现的菜单中，选择&lt;新建&gt;-&lt;文件夹&gt;，文件夹名称改为myGeoDB。右键选中这个文件夹，在出现的菜单中，点击&lt;新建&gt;-&lt;个人地理数据库&gt;，这时会创建一个名称为“新建个人地理数据库.mdb”的数据库文件，将之改名为：“Yunnan”。右键点击数据库文件“Yunan.mdb”,在出现的菜单中，选择&lt;导入&gt;-&lt;要素类(多个)&gt;,在出现的对话框中，打开要导入要素：云南县界prj.shp/云南县城prj.shp/云南道路prj.shp (这些文件在Exece2文件夹下，按住Shift键并点击鼠标可同时选择多个Shape文件)确定后可以看到这三个图层已经被导入到数据库Yunan.mdb中右键点击数据库文件“Yunan.mdb”,在出现的菜单中，选择&lt;新建&gt;-&lt;要素集&gt;在出现的对话框中输入要素集的名称、点击按钮“下一步”为其指定一个坐标系在这里，我们设定坐标系为：GCS_WGS_1984（即Geographic CoordinateSystem-&gt;World-&gt;WGS1984.prj），这是一种被GPS采用的地理坐标系,最后点击完成.右键点击新建的要素集-Kunming，在出现的菜单中选择&lt;新建&gt;-&lt;要素类&gt;，在出现的对话框中输入要素类的名称”公交站点”，点击&lt;下一步&gt;,再次点击&lt;下一步&gt;按钮。在出现的对框中选择“Shape”字段，修改字段的几何类型为“点”（表示此要素类中将要存储的要素类型是点要素，我们准备用来存储公交站点）右击公交站点要素类,点击”属性”在出当前的对话框中，我们新加两个字段“站点名称”、“公交站点编号”，数据类型都设置为“Text”.点击“完成”按钮。在出当前的对话框中.点击“确定”按钮。这样我们就完成了要素类的定义。可以将这个要素类（图层）加入的ArcMap中，进行数字化的工作，从背景地图中提取公交站点的位置。新建数据表：右键点击地理数据库－Yunnan.mdb，在出现的菜单中，选择&lt;新建&gt;-&lt;表&gt;，输入表名称：公交线路。点&lt;下一步&gt;,在对话框中，输入公交站点编号和公交线路两个字段，也可以点击”导入”按钮,可查询字段属性,.点击“完成”，结束属性表的定义。第5步 拖放数据到ArcMap中启动ArcMap，新建一个空的地图文档，通过拖放的方式添加上面所创建的数据到ArcMap中：在 ArcCatalog中，点击“内容”选项页，在目录树中，点击地理数据库－Yunnan.mdb，将要素类－“公交站点”及属性数据表“公交线路”拖放到ArcMap中。关闭ArcCatalog，激活ArcMap窗口。第6步 编辑属性数据及进行1：M的空间查询为了让大家了解属性编辑的过程，我们需要在要素类公交站点中添加3个公交站点。（这只作演示使用，实际的数字化过程还需要加载经过配准后的扫描地图作为背景）。首先，在工具栏显示区的空白处点击右键，在出现的菜单在选中“编辑器”，从而打开编辑器工具栏在编辑器工具栏中，点击“编辑器”下拉菜单，选择“开始编辑”命令。按下按钮，在地图显区内随意地添加3个公交站点。在图层列表控制面板（TOC）中，右键选择图层－“公交站点”，在出现的菜单中，选择“打开属性表”命令，将显示公交站点的属性编辑窗口，在其中输入站点名称和公交站点编号。字段OBJECTID是关键字段，是自动生成的不需要输入。在图层列表控件面板（TOC）中，点击“数据源”选项页，切换到数据源视图下，右键选择属性表－“公交线路”，在出现的菜单中，选择“打开”命令，将会显示“公交线路”的属性编辑窗口。按下图所示输入几条公交线路（公交站点编号、公交线路）点击“编辑器”工具栏中的“编辑器”下拉菜单，选择“停止编辑”命令，将以上所作的编辑结果保存。右击公交站点，选择连接和关联，点击关联，打开关联对话框，点击确定按钮。点击识别按钮查询地图显示区中任意公交着站点的属性，可以看到经过公交站－“云南大学”的公交线路有3条，可进一步查询每条公交线路的详细数据。第7步 导入GPS数据，生成图层各类手持GPS接收机采集到的数据可以通过相关软件（比如MapSource等）导入到ArcMap中。GPS 数据文件启动ArcMap，切换到数据源视图。点击按钮添加GPS数据，选择对应的GPS数据文件(可以是.txt格式、dBase 等格式)，这里GPS数据文件为：澜沧江GPS.txt选中要添加的GPS数据文件，点击添加。根据GPS 数据生成图层：执行菜单命令：右击图层，选择显示XY数据，指定X坐标字段（东经）和Y坐标字段（北纬），按“编辑”按钮，选择坐标系统。一般GPS系统采用的坐标系统为WGS_1984。确定后，在地图显示区域中，就会根据GPS数据文件中采集的坐标信息创建点状的事件图层，右击数据–导出数据在图层控制面板（TOC）中，右键选中根据GPS数据文件生成的事件图层。在出现的菜单中，执行“数据”-&gt;“导出数据”命令：在导出数据对话框中，指定要导出的文件名称及存储位置。这样就完成了由GPS数据文件生成图层的过程。]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS基础软件及操作(一)]]></title>
    <url>%2Fposts%2F56f1e434.html</url>
    <content type="text"><![CDATA[练习一、浏览地理数据使用 ArcGIS浏览地理数据第1步 启动 ArcMap启动ArcMap。执行菜单命令：开始&gt;&gt;所有程序&gt;&gt; ArcGIS&gt;&gt;ArcMap当出现 ArcMap 对话框时, 点击 “一个新的空地图” 单选按钮，然后点击关闭。你现在将可以看到ArcMap 的操作界面如果你的ArcMap界面与上面的图看起来不一样，也不用在意，这不会对练习的结果产生影响。当你在ArcMap中进行各种操作时，你的操作对象是一个地图文档。一个地图文档可以包含多个数据框架，根据数据集依次形成数据框架。一个地图文档是存储在扩展名为.mxd文件中.第2步 检查要素图层执行菜单命令 File&gt;&gt;Open.浏览到包含有你下载的练习数据的文件夹 (比如是：C:\1练习一\exec1\Exec1) 然后点击 Redlands.mxd.点击 Open 按钮。打开地图文档 Redlands 后,你会看到加州Redlands市的地图。地图显示以图层表示的几种地理要素。每个图层表示某种专题信息。在ArcMap窗口的左边区域称为图层列表（TOC），它显示的是图层列表。窗口的右边区域显示的是图层控制面板中各图层的图形内容。例如, 所有油炸圈饼店是点要素(以房屋符号表示) 且被组合成名为DonutShops图层。名为Landuse的图层表示Redlands市土地利用现状，在这个图层中，根据多边形的地类将其组合成不同类型的土地利用多边形。第3步 显示其它图层在地图中显示其它图层，铁路、街道、及ESRI的位置。选中Railroads图层旁边的检查框. Redlands市的铁路就会显示在图中。.现在，选中Streets 旁边的检查框就可以显示Redlands 市的街道。注意：图层ESRI没有被显示。稍后，你将学习如何显示它。第4步 查询地理要素在ArcMap中，通过在地图显示区点击某个要素你就可以查询其属性，了解它是什么。首先，你应放大地图，这样你更清楚地查看单个的要素。你必须使用一个先前创建的书签，这个书签存储着包含ESRI和附近街道的地理区域。执行菜单命令 “视图”(View)&gt;&gt;“书签”( Bookmarks)&gt;&gt;“ESRI”当前显示区就被调整到书签ESRI所定义的区域。注意到，现在所有街道根据其名称显示了标注信息，你可以很容易找到ESRI所处的位置。地图文档的创建已决定了街道及ESRI的标注信息只在某个特定的比例尺范围才显示出来，在这个比例尺下它们可以很容易地找到。在“工具”(Tools)工具栏上，点击识别按钮如果看不到“工具”(Tools)工具栏，在菜单“帮助”(Help)的右边的菜单栏上点击右键，然后点击“工具”（Tools）选项。在表示街道的线要素上点击(就在街道名左边的红色线段)。查询结果窗口打开并显示数据库中名为FIRESERVICE的街道的所有属性。你可能需要将查询结果窗口放大，才能看到所有的属性。你可以 “闪现” 被查询的要素以观察它在地图中所处的区域。为方便查看，将查询结果窗口移到一个合适的位置，这可以同时看到这个要素在地图上的位置。查询结果窗口的左边，点击 FIRE SERVICE (街道的名称)，这时，可以观察到这个要素在地图中“闪现”。从“图层”下拉列表框中选择“所有图层”，然后在在图上再次点击代表“NewYork”的那条街道。查询结果窗口现在包含了“Landuse”图层中与选中的街道相交的地块 。通过在显示区内点击，可以继续查询其它的要素。.查询数据根据位置查询要素属性或通过属性来查询要素的功能是每个桌面GIS软件必须提供的功能。查询，通常是通过语句或表达式来定义的，用以在从地图上及数据库中选择要素。.最普通的GIS查询就是确定在指定的位置有什么。在这类查询中，用户知道他感兴趣的要素的位置，但是想进一步了解与之相关的特征。在GIS中，这是很容易实现的，因为地图显示区中的地理要素与它们的属性是(描述性的特征)相互关联的，属性信息是存储在数据库中的。这时候只需要点击识别按钮在图层上，就可识别。在GIS中，你可以在地图上点击一个要素来查看数据库中与之相关联的属性。另一类型的GIS 查询是确定符合给定条件的要素它的位置在哪里。在这种情况下，用户知道要素的重要特征，他想要找出具有这些特征的那些要素的具体位置。.第5步 检查其它属性信息在你浏览显示在图层列表（TOC）中某些图层的属性信息之前，你要重置ArcMap地图文档的显示区域为原来的显示区域。地图显示区域可以通过地图书签来定义。地图书签是为了防止地图显示变得混乱，可以通过书签恢复到原来的显示区域和显示风格。执行菜单命令“书签”-&gt;“Original”。地图显示区将显示这些图层：Donut Shops, Railroads, Streets, 及 Land Use.在图层列表（TOC）中，选中Railroads然后点击右键执行“打开属性表”命令。这时会显示与“Railroads”图层相关的属性表窗口。这个表中的每一行是一个记录，每个记录表示“Railroads”图层中的一个要素。.请注意：图层中要素的数目也就是数据表中记录的个数被显示在属性表窗口的底部，在这个例子中，有11个记录，其中有一个记录被选中。稍后，你将了解如何选中记录。向右拖动滚动条查看其它的属性。完成后，请关闭属性表窗口。同样的方法，查看图层－ Donut Shops的属性表关闭属性表.最后，打开图层－Land Use 的属性表。注意到每个要素 (记录)有一个属性(字段)－LU_ABV ，它是记录的是地类代码(土地类型的缩写)。在地图中，就是根据这个属性字段的值来确定每个地块的渲染方式的。完成后关闭属性表。第6步 设置并显示地图提示信息地图提示以文本方式显示某个要素的某一属性，当你保持将鼠标放在某个要素之上时，将会显示地图提示。使用地图提示是获取指定要素属性信息比较简单的一种方式。把鼠标放在Donut Shop 的标志上，就会看到有名字显示在图层上。你可以在“图层属性”对话框中，“显示”对话框中设置，地图提示信息来自于数据表中的哪一个字段。在图层列表中(TOC), 右键点击图层－ Donut Shops的名字，然后点击“属性“命令。在出现在属性对话框中，点击“显示”选项页。可以选择可见的字段。点击“确定” 按钮关闭图层属性对话框。将鼠标保持在图层－ Donut Shops中的任一个要素之上。这个要素的“Adreess”就为作为地图提示信息显示出来。第7步 根据要素属性设置图层渲染样式现在，图层－Streets是以单一符号进行浸染，每个要素都是同一种符号。你可以根据要素的属性来设置不同的渲染方式。首先，在图层列表(TOC)中反选Land use边上的检查框（将√去掉），从而关闭图层Land Use 的显示。然后右键点击图层－Streets，点“属性”菜单命令。在出现的图层属性对话框中，点击“符号系统”选项页。在对话框的左边区域，有地图渲染方式列表。点击“类别”，依次点击“唯一值”。在“值字段”下的下拉列表中，选择字段“CLASS”。点击按钮“添加所有值”。点击按钮“应用”(Apply)，先不要点“确定”，移动图层属性对话框到合适的位置，这样你就可以看到地图的显示发生了变化。现在，图层－streets就以会根据属性字段－ CLASS的取值不同而采用不同的符号表示。在图层属性对话框中的渲染方式列表中，点“要素”，然后点“确定”按钮，恢复原先的渲染方式和显示风格。第8步 根据属性选择要素有时，你可能需要显示满足特定条件的哪些要素。在这一步中，你将要选择及定位第10州际公路。在图层列表(TOC)中，反选图层――Railroads边上的检查框，关闭这个图层。因为下面的操作不需要显示这个图层。执行菜单命令&lt;选择&gt;－&gt; &lt;通过属性选择&gt;。在属性选择对话框中，你可以构造一个查询条件。通过构造表达式：Select *From Street WHERE “STR_NAME”=”I 10” ,可以从数据库中找出第10号州际公路。选中的要素将会在属性表及地图中高亮显示。.具体操作如下：在图层下拉列表中，选择Streets。在方法下拉列表中，确定“创建一个新的选择集”被选中。在字段列表中，调整滚动条，双击“STR_NAME”。然后，点击“＝”按钮。再点击“得到唯一值”按钮，在唯一值列表框中，找到“I 10”后双击。.点击“应用”按钮。将“属性选择”对话框移到，这样，你将可以方便地看到地图显示效果。注意到，在地图显示区中属性为“I 10”的第10号州际公路被高亮显示。选中的这些线段是第10号州际公路的组成部分。关闭，属性选择对话框。第9步 使用空间关系选择地理要素现在你将选择处于距 10号州际公路1000米范围内的所有油炸圈饼店，这样如果你开车从帕姆斯普林到洛杉矶，饥肠辘辘时就可以很快找到歇脚的地方，可以美餐一顿。执行菜单命令“选择”-&gt;“通过位置选择”。在“位置选择”对话框中，对过选择操作，形成如下的一个表达式，“我想要从图层――DonutShops 中选择要素，这些要素位于距图层――Street中被选中的要素1000米的区域内”。选中检查框“应用搜索距离”，设为1000 米。.点“应用”按钮，点“关闭”按钮。这时，在地图显示区中，处于沿10号州际公路1000米缓冲区范围内的油炸圈饼点就会被高亮显示。在图层列表(TOC)中，右键点击图层―― Donut Shops，然后点“打开属性表”命令。图层――donutshops中被显中的哪些要素就被高亮显示出来。关闭属性表。.上面的操作是通过空间分析实现的。在以后的课程中，你将会学会更多的更高级的空间分析功能的使用。第10步 退出 ArcMap执行菜单命令File &gt;&gt;Exit 关闭 ArcMap。点击 No，如果系统提示，保存修改(save changes)。]]></content>
      <categories>
        <category>GIS基础软件及操作</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费GIS数据下载网站推荐]]></title>
    <url>%2Fposts%2F8e4e1024.html</url>
    <content type="text"><![CDATA[数据是 GIS 的核心，然而你是不是还在为找不到数据而苦恼呢？本期我们为你挑选了国外十个免费的数据下载网站，赶快去看看吧！文章来源：Esri北京研发中心1、Natural Earth Data网址：http://www.naturalearthdata.comNatural Earth Data提供了全球范围内的矢量和影像数据。Natural Earth Data的最大优势就是数据是开放性的，用户有传播和修改数据的权限。2、USGS Earth Explorer网址：http://earthexplorer.usgs.gov美国地质勘探局（United States Geological Survey，简称USGS），是美国内政部所属的科学研究机构。其官网上提供最新、最全面的全球卫星影像，包括Landsat、Modis等。3、OpenStreetMap网址：http://wiki.openstreetmap.org/wiki/Downloading_dataOpenStreetMap（简称OSM）是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图。用户在OSM上可以免费获取不同级别和精度的GIS数据。4、NASA’s Socioeconomic Data and Applications Center (SEDAC)网址：http://sedac.ciesin.columbia.eduSEDAC提供全球范围内的GIS数据以帮助人们了解人与环境间的相互影响。数据涉及农业、气候、健康、基础设施、土地利用、海洋和沿海、人口、贫困、可持续性、城市和水等15种类型。5、Open Topography网址：http://www.opentopography.orgOpen Topography是一个提供高空间分辨率的地形数据和操作工具的门户网站。通过Open Topography，用户可以下载LiDAR数据（主要包括：美国、加拿大、澳大利亚、巴西、海地、墨西哥和波多黎各）。6、Diva GIS网址：http://www.diva-gis.org/DataDiva GIS包含全球各个国家的基础地理数据——边界、铁路、道路、气候、生物多样性以及农作物等。7、UNEP Environmental Data Explorer网址：http://geodata.grid.unep.chUNEP包含全球范围内500多种不同类型的空间和非空间数据，如淡水、人口、森林、污染排放、气候、灾害、卫生和国内生产总值等。8、FAO GeoNetwork网址：http://www.fao.org/geonetwork/srv/en/main.homeFAO是一个全球地理信息系统数据集，通过它你可以下载到农业、渔业、土地资源相关的GIS数据，同时它提供相关卫星图像数据。9、NASA Earth Observations (NEO)网址：http://neo.sci.gsfc.nasa.govNEO专注于提供全球范围内的卫星影像（大气、能源、土地、生活、海洋等50多种不同数据专题）。通过NEO可以查看地球气候和环境状况的每日快照。10、ISCGM Global Map网址：http://www.iscgm.orgISCGM提供的数据种类包括全球土地和森林覆盖数据集。同时一些文化和自然矢量数（边界、排水、交通、人口中心、海拔、土地覆盖、土地利用和植被）也能在这里获取。原文地址http://http://mp.weixin.qq.com/s?__biz=MjM5MDI2NjI0NQ==&amp;mid=401531535&amp;idx=1&amp;sn=f89760c9ff320602f6dcd9394d945fa1&amp;scene=0#wechat_redirect]]></content>
      <categories>
        <category>GIS数据</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细细品味ArcGIS--目录]]></title>
    <url>%2Fposts%2F1c018cc9.html</url>
    <content type="text"><![CDATA[记录和总结学习ArcGIS的过程]]></content>
      <categories>
        <category>细细品味ArcGIS</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建静态博客]]></title>
    <url>%2Fposts%2F9642fffa.html</url>
    <content type="text"><![CDATA[前言第一篇文章献给Hexo。Hexo简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。超快速度 Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。支持 Markdown Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。一键部署 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。丰富的插件 Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。环境配置安装node.jsNode.js https://nodejs.orgNode.js安装图解教程_百度经验http://jingyan.baidu.com/article/fd8044faf2e8af5030137a64.html安装GitGit http://git-scm.com推荐下载2.5.0版本、最新版本（2.6.4）总是出现问题。Git for windows 2.5.0 具体下载地址：https://github.com/git-for-windows/git/releases/tag/v2.5.0.windows.1如何在windows下安装GIT_百度经验http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html配置Github在Windows下，打开Git Bash。检查SSH keys的设置首先我们需要检查你电脑上现有的ssh key：$ cd ~/.ssh 如果显示“No such file or directory”，跳到第三步，否则继续。备份和移除原来的ssh key设置：因为已经存在key文件，所以需要备份旧的数据并删除：$ ls config id_rsa id_rsa.pub known_hosts $ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 生成新的SSH Key：输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 然后系统会要你输入加密串（Passphrase）： Enter passphrase (empty for no passphrase):&lt;输入加密串&gt; Enter same passphrase again:&lt;再次输入加密串&gt; 最后看到这样的界面，就成功设置ssh key了：添加SSH Key到GitHub：在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。在GitHub的主页上点击头像再点击设置按钮：settings：选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可：测试一下可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：$ ssh -T git@github.com 如果是下面的反应：The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)?` 不要紧张，输入yes就好，然后会看到：Hi &lt;em&gt;username&lt;/em&gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 设置你的账号信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。$ git config --global user.name &quot;你的名字&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 好了，你已经可以成功连接GitHub了。使用GitHub Pages建立博客应用github pages创建自己的个人博客_百度经验http://jingyan.baidu.com/article/ed2a5d1f3732cb09f7be1745.html安装Hexo关于Hexo的安装配置过程，请以官方给出的步骤为准。文档 | Hexo https://hexo.io/zh-cn/docs/Installation打开Git命令行，执行如下命令$ npm install -g hexo Setup your blog在电脑中建立一个名字叫Hexo的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令$ hexo init [info] Copying data [info] You are almost done! Don&#39;t forget to run `npm install` before you start b logging with Hexo! Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 npm install（在 D:\Hexo下）npm install 会在D:\Hexo目录中安装 node_modules。Start the server运行下面的命令（在D:\Hexo下）$ hexo server [info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 表明Hexo Server已经启动了，在浏览器中打开 http://localhost:4000/，这时可以看到Hexo已为你生成了一篇blog。你可以按Ctrl+C 停止Server。Create a new post新打开一个git bash命令行窗口，cd到D:\Hexo下，执行下面的命令$ hexo new &quot;My New Post&quot; [info] File created at d:\Hexo\source\_posts\My-New-Post.md 刷新http://localhost:4000/，可以发现已生成了一篇新文章 “My New Post”。Generate static files执行下面的命令，将markdown文件生成静态网页。$ hexo generate 该命令执行完后，会在 D:\Hexo\public\ 目录下生成一系列html，css等文件。编辑文章$ hexo new &quot;My New Post&quot; 会在D:\Hexo\source\_posts目录下生成一个markdown文件：My-New-Post.md可以使用一个支持markdown语法的编辑器（比如 Sublime Text 2）来编辑该文件。部署到Github部署到Github前需要配置_config.yml文件，首先找到下面的内容# Deployment ##Docs: http://hexo.io/docs/deployment.html deploy: type: 然后将它们修改为# Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:wshunli/wshunli.github.io.git branch: master 测试当部署完成后，在浏览器中打开http://wshunli.github.io ，正常显示网页，表明部署成功。总结：部署步骤每次部署的步骤，可按以下三步来进行。hexo clean hexo generate hexo deploy 总结：本地调试在执行下面的命令后，$ hexo g #生成 $ hexo s #启动本地服务，进行文章预览调试 浏览器输入http://localhost:4000，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。配置HexoHexo的配置文件是位于blog文件夹下的_config.yml文件。修改配置文件请使用Notepad++或者Sublime Text 2之类的程序，不要使用Windows自带的记事本。以下为Hexo 3.0.0初始配置。常规需要修改的地方已加中文注释，未加注释的参数不建议新手修改。# Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Hexo ##站点标题 subtitle: ##站点副标题 description: ##站点描述 author: John Doe ##作者 language: ##语言包，需要主题自带才可设置。如Jcaman自带简繁英，设置简体中文填入 zh-CN timezone: # URL ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: http://yoursite.com ##站点域名 root: / permalink: :year/:month/:day/:title/ ##文章永久链接格式，可添加.html后缀，如 :title.html permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: landscape ##当前主题名称 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: 安装主题Hexo提供了很多主题，具体可参见Hexo Themes。这里我选择使用NexT主题。安装1.将Git Shell 切到D:/Hexo目录下，然后执行下面的命令，将NexT下载到 /themes/pacman 目录下。$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2.修改你的博客根目录D:/Hexo下的config.yml配置文件中的theme属性，将其设置为NexT。3.更新NexT主题cd themes/next git pull NOTE：先备份_config.yml 文件后再升级配置如果next的默认设置不能满足需要的话，你可以修改 /themes/next/下的配置文件_config.yml来定制。NexT - an elegant theme for Hexo.http://theme-next.iissnan.com安装插件Plugins | Hexo https://hexo.io/plugins/多说评论系统多说 - 社会化评论系统http://duoshuo.com/1.登录后在首页选择 “我要安装”。2.创建站点，填写站点相关信息。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图：3.创建站点完成后在站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值。例如：duoshuo_shortname: iissnan-notes 百度统计1.登录 百度统计，定位到站点的代码获取页面2.复制 hm.js? 后面那串统计脚本 id，如：3.编辑 站点配置文件，新增字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。Swiftype 搜索使用 Swiftype 之前需要前往 Swiftype 配置一个搜索引擎。然后，编辑 站点配置文件，新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。优化Hexo404页面在\themes\next\source添加404.html即可使用七牛做图床推荐使用QRSBoxQRSBox 同步工具 | 七牛云存储 http://developer.qiniu.com/docs/v6/tools/qrsbox.html官网有详细介绍、我就不再赘述。https://portal.qiniu.com/signup?code=3lmfxlfwo25w2参考资料1、Hexo搭建Github静态博客 - 金石开 - 博客园 http://www.cnblogs.com/zhcncn/p/4097881.html2、使用Github Pages建独立博客 | BeiYuu.com http://beiyuu.com/github-pages3、Hexo | Setsuna’s Blog http://www.isetsuna.com/categories/Hexo/4、hexo | Zippera’s blog http://zipperary.com/categories/hexo/5、博客搬家记：从 Wordpress 到 Hexo+Github | 00’s Adventure http://www.uegeek.com/2016/01/10/from-wordpress-to-hexo/在此一并致谢！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
